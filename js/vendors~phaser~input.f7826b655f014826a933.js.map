{"version":3,"sources":["webpack:///./node_modules/phaser/src/input/index.js","webpack:///./node_modules/phaser/src/input/gamepad/index.js","webpack:///./node_modules/phaser/src/input/gamepad/events/BUTTON_DOWN_EVENT.js","webpack:///./node_modules/phaser/src/input/gamepad/events/BUTTON_UP_EVENT.js","webpack:///./node_modules/phaser/src/input/gamepad/events/CONNECTED_EVENT.js","webpack:///./node_modules/phaser/src/input/gamepad/events/DISCONNECTED_EVENT.js","webpack:///./node_modules/phaser/src/input/gamepad/events/GAMEPAD_BUTTON_DOWN_EVENT.js","webpack:///./node_modules/phaser/src/input/gamepad/events/GAMEPAD_BUTTON_UP_EVENT.js","webpack:///./node_modules/phaser/src/input/gamepad/GamepadPlugin.js","webpack:///./node_modules/phaser/src/input/gamepad/configs/index.js","webpack:///./node_modules/phaser/src/input/gamepad/configs/Sony_PlayStation_DualShock_4.js","webpack:///./node_modules/phaser/src/input/gamepad/configs/SNES_USB_Controller.js","webpack:///./node_modules/phaser/src/input/gamepad/configs/XBox360_Controller.js","webpack:///./node_modules/phaser/src/input/InputPlugin.js","webpack:///./node_modules/phaser/src/input/keyboard/index.js","webpack:///./node_modules/phaser/src/input/keyboard/events/ANY_KEY_DOWN_EVENT.js","webpack:///./node_modules/phaser/src/input/keyboard/events/ANY_KEY_UP_EVENT.js","webpack:///./node_modules/phaser/src/input/keyboard/events/COMBO_MATCH_EVENT.js","webpack:///./node_modules/phaser/src/input/keyboard/events/DOWN_EVENT.js","webpack:///./node_modules/phaser/src/input/keyboard/events/KEY_DOWN_EVENT.js","webpack:///./node_modules/phaser/src/input/keyboard/events/KEY_UP_EVENT.js","webpack:///./node_modules/phaser/src/input/keyboard/events/UP_EVENT.js","webpack:///./node_modules/phaser/src/input/keyboard/KeyboardPlugin.js","webpack:///./node_modules/phaser/src/input/keyboard/keys/KeyMap.js","webpack:///./node_modules/phaser/src/input/keyboard/keys/JustDown.js","webpack:///./node_modules/phaser/src/input/keyboard/keys/JustUp.js","webpack:///./node_modules/phaser/src/input/keyboard/keys/DownDuration.js","webpack:///./node_modules/phaser/src/input/keyboard/keys/UpDuration.js","webpack:///./node_modules/phaser/src/input/mouse/index.js","webpack:///./node_modules/phaser/src/input/touch/index.js","webpack:///./node_modules/phaser/src/input/InputPluginCache.js","webpack:///./node_modules/phaser/src/input/keyboard/events/index.js","webpack:///./node_modules/phaser/src/input/gamepad/events/index.js","webpack:///./node_modules/phaser/src/input/CreatePixelPerfectHandler.js","webpack:///./node_modules/phaser/src/input/CreateInteractiveObject.js","webpack:///./node_modules/phaser/src/input/gamepad/Axis.js","webpack:///./node_modules/phaser/src/input/gamepad/Button.js","webpack:///./node_modules/phaser/src/input/gamepad/Gamepad.js","webpack:///./node_modules/phaser/src/input/keyboard/keys/Key.js","webpack:///./node_modules/phaser/src/input/keyboard/combo/KeyCombo.js","webpack:///./node_modules/phaser/src/input/keyboard/combo/ProcessKeyCombo.js","webpack:///./node_modules/phaser/src/input/keyboard/combo/AdvanceKeyCombo.js","webpack:///./node_modules/phaser/src/input/keyboard/combo/ResetKeyCombo.js"],"names":["CONST","Extend","Input","CreatePixelPerfectHandler","CreateInteractiveObject","Events","Gamepad","InputManager","InputPlugin","InputPluginCache","Keyboard","Mouse","Pointer","Touch","module","exports","Axis","Button","GamepadPlugin","Configs","Class","EventEmitter","GetValue","InputEvents","Extends","initialize","sceneInputPlugin","call","this","scene","settings","sys","enabled","target","gamepads","queue","onGamepadHandler","_pad1","_pad2","_pad3","_pad4","pluginEvents","once","BOOT","boot","on","START","start","game","input","config","inputGamepad","device","inputGamepadEventTarget","DESTROY","destroy","startListeners","refreshPads","SHUTDOWN","shutdown","isActive","_this","handler","event","defaultPrevented","push","addEventListener","UPDATE","update","stopListeners","removeEventListener","off","i","length","removeAllListeners","disconnectAll","pad","connected","connectedPads","navigator","getGamepads","currentPads","livePad","id","index","currentPad","newPad","getAll","out","pads","getPad","len","splice","gamepad","type","emit","CONNECTED","DISCONNECTED","total","get","pad1","pad2","pad3","pad4","register","DUALSHOCK_4","SNES_USB","XBOX_360","UP","DOWN","LEFT","RIGHT","SHARE","OPTIONS","PS","TOUCHBAR","X","CIRCLE","SQUARE","TRIANGLE","L1","R1","L2","R2","L3","R3","LEFT_STICK_H","LEFT_STICK_V","RIGHT_STICK_H","RIGHT_STICK_V","SELECT","B","A","Y","LEFT_SHOULDER","RIGHT_SHOULDER","MENU","LB","RB","LT","RT","BACK","LS","RS","Circle","CircleContains","DistanceBetween","Ellipse","EllipseContains","GetFastValue","GEOM_CONST","IsPlainObject","PluginCache","Rectangle","RectangleContains","SceneEvents","Triangle","TriangleContains","systems","manager","displayList","cameras","install","mouse","topOnly","pollRate","_pollTimer","_eventData","cancelled","_eventContainer","stopPropagation","dragDistanceThreshold","dragTimeThreshold","_temp","_tempZones","_list","_pendingInsertion","_pendingRemoval","_draggable","_drag","_dragState","_over","_validTypes","_updatedThisFrame","events","eventEmitter","TRANSITION_START","transitionIn","TRANSITION_OUT","transitionOut","TRANSITION_COMPLETE","transitionComplete","PRE_UPDATE","preUpdate","GAME_OUT","onGameOut","GAME_OVER","onGameOver","timeStamp","removeList","insertList","toRemove","toInsert","current","gameObject","indexOf","clear","concat","updatePoll","time","delta","pointers","pointersTotal","updateMotion","rate","captured","pointer","hitTestPointer","sortGameObjects","sortDropZones","processOverOutEvents","getDragState","processDragThresholdEvent","MOUSE_DOWN","processDragDownEvent","processDownEvents","MOUSE_UP","processDragUpEvent","processUpEvents","TOUCH_START","processOverEvents","TOUCH_END","TOUCH_CANCEL","processOutEvents","MOUSE_MOVE","TOUCH_MOVE","processDragMoveEvent","processMoveEvents","MOUSE_WHEEL","processWheelEvent","skipQueue","undefined","queueForRemoval","hitArea","hitAreaCallback","callbackContext","resetCursor","disable","enable","dropZone","setHitArea","getCamerasBelowPointer","c","camera","over","hitTest","obj","currentlyOver","aborted","GAMEOBJECT_POINTER_DOWN","localX","localY","GAMEOBJECT_DOWN","downElement","canvas","POINTER_DOWN","POINTER_DOWN_OUTSIDE","setDragState","state","passed","timeThreshold","distanceThreshold","x","y","downX","downY","downTime","processDragStartList","list","dragState","dragStartX","dragStartY","dragStartXGlobal","worldX","dragStartYGlobal","worldY","dragX","dragY","GAMEOBJECT_DRAG_START","DRAG_START","primaryDown","draglist","draggable","loop","now","dropZones","GAMEOBJECT_DRAG_OVER","DRAG_OVER","GAMEOBJECT_DRAG_LEAVE","DRAG_LEAVE","GAMEOBJECT_DRAG_ENTER","DRAG_ENTER","parentContainer","dx","dy","rotation","getParentRotation","dxRotated","Math","cos","sin","dyRotated","scaleX","scaleY","GAMEOBJECT_DRAG","DRAG","displayOriginX","displayOriginY","dropped","GAMEOBJECT_DROP","DROP","GAMEOBJECT_DRAG_END","DRAG_END","GAMEOBJECT_POINTER_MOVE","GAMEOBJECT_MOVE","POINTER_MOVE","deltaX","deltaY","dz","deltaZ","GAMEOBJECT_POINTER_WHEEL","GAMEOBJECT_WHEEL","POINTER_WHEEL","totalInteracted","justOver","setCursor","GAMEOBJECT_POINTER_OVER","GAMEOBJECT_OVER","POINTER_OVER","previouslyOver","GAMEOBJECT_POINTER_OUT","GAMEOBJECT_OUT","POINTER_OUT","justOut","stillOver","currentlyDragging","GAMEOBJECT_POINTER_UP","GAMEOBJECT_UP","upElement","POINTER_UP","POINTER_UP_OUTSIDE","queueForInsertion","child","setDraggable","gameObjects","value","Array","isArray","makePixelPerfect","alphaTolerance","textureManager","textures","setHitAreaFromTexture","cursor","useHandCursor","pixelPerfect","customHitArea","console","warn","io","setHitAreaCircle","radius","callback","shape","setHitAreaEllipse","width","height","frame","realWidth","realHeight","setHitAreaRectangle","setHitAreaTriangle","x1","y1","x2","y2","x3","y3","enableDebug","color","shapeType","debug","hitAreaDebug","factory","add","updateList","remove","offsetx","offsety","arc","ELLIPSE","ellipse","LINE","line","POLYGON","polygon","points","RECTANGLE","rectangle","triangle","isFilled","setStrokeStyle","scale","setDisplayOrigin","matrix","getWorldTransformMatrix","tx","ty","setRotation","setScale","setPosition","setScrollFactor","scrollFactorX","scrollFactorY","setDepth","depth","removeDebug","setPollAlways","setPollRate","setPollOnMove","setGlobalTopOnly","globalTopOnly","setTopOnly","renderList","sort","childA","childB","depthSort","sortDropZoneHandler","bind","getIndex","listA","getIndexList","listB","min","indexA","indexB","_tempSkip","addPointer","quantity","setDefaultCursor","transitionAllowInput","style","defaultCursor","activePointer","isOver","mousePointer","pointer1","pointer2","pointer3","pointer4","pointer5","pointer6","pointer7","pointer8","pointer9","pointer10","KeyboardManager","KeyboardPlugin","Key","KeyCodes","KeyCombo","AdvanceKeyCombo","ProcessKeyCombo","ResetKeyCombo","JustDown","JustUp","DownDuration","UpDuration","GameEvents","KeyMap","SnapFloor","keyboard","keys","combos","prevCode","prevTime","prevType","captures","addCaptures","MANAGER_PROCESS","BLUR","resetKeys","PAUSE","SLEEP","addCapture","keycode","removeCapture","getCaptures","enableGlobalCapture","preventDefault","disableGlobalCapture","clearCaptures","createCursorKeys","addKeys","up","down","left","right","space","SPACE","shift","SHIFT","enableCapture","emitOnRepeat","output","split","currentKey","trim","addKey","key","idx","keyCode","setEmitOnRepeat","toUpperCase","removeKey","ref","plugin","removeAllKeys","createCombo","checkDown","duration","isDown","t","timeDown","_tick","code","repeat","stopImmediatePropagation","onDown","KEY_DOWN","ANY_KEY_DOWN","onUp","KEY_UP","ANY_KEY_UP","reset","_justDown","_justUp","timeUp","isUp","MouseManager","TouchManager","inputPlugins","mapping","settingsKey","configKey","source","hasOwnProperty","COMBO_MATCH","BUTTON_DOWN","BUTTON_UP","GAMEPAD_BUTTON_DOWN","GAMEPAD_BUTTON_UP","alpha","getPixelAlpha","texture","name","alwaysEnabled","threshold","getValue","abs","pressed","Vector2","buttons","axes","vibration","vibrationActuator","_noButton","_LCLeft","_LCRight","_LCTop","_LCBottom","_RCLeft","_RCRight","_RCTop","_RCBottom","_FBLeftTop","_FBLeftBottom","_FBRightTop","_FBRightBottom","_noAxis","_HAxisLeft","_VAxisLeft","_HAxisRight","_VAxisRight","leftStick","rightStick","_created","performance","getAxisTotal","getAxisValue","setAxisThreshold","getButtonTotal","getButtonValue","isButtonDown","timestamp","localButtons","gamepadButtons","localAxes","gamepadAxes","set","originalEvent","altKey","ctrlKey","shiftKey","metaKey","location","repeats","getDuration","keyboardPlugin","keyCodes","char","charCodeAt","size","timeLastMatched","matched","timeMatched","resetOnWrongKey","maxKeyDelay","resetOnMatch","deleteOnMatch","onKeyDown","progress","combo","comboMatched","keyMatched","timeLimit"],"mappings":";8EAMA,IAAIA,EAAQ,EAAQ,KAChBC,EAAS,EAAQ,IAMjBC,EAAQ,CAERC,0BAA2B,EAAQ,KACnCC,wBAAyB,EAAQ,KACjCC,OAAQ,EAAQ,IAChBC,QAAS,EAAQ,MACjBC,aAAc,EAAQ,KACtBC,YAAa,EAAQ,MACrBC,iBAAkB,EAAQ,KAC1BC,SAAU,EAAQ,MAClBC,MAAO,EAAQ,MACfC,QAAS,EAAQ,KACjBC,MAAO,EAAQ,OAKnBX,EAAQD,GAAO,EAAOC,EAAOF,GAE7Bc,EAAOC,QAAUb,G,qBCtBjBY,EAAOC,QAAU,CAEbC,KAAM,EAAQ,KACdC,OAAQ,EAAQ,KAChBZ,OAAQ,EAAQ,KAChBC,QAAS,EAAQ,KACjBY,cAAe,EAAQ,MAEvBC,QAAS,EAAQ,Q,mBCIrBL,EAAOC,QAAU,Q,mBCAjBD,EAAOC,QAAU,M,mBCEjBD,EAAOC,QAAU,a,mBCLjBD,EAAOC,QAAU,gB,mBCMjBD,EAAOC,QAAU,Q,mBCAjBD,EAAOC,QAAU,M,qBCnBjB,IAAIK,EAAQ,EAAQ,GAChBC,EAAe,EAAQ,IACvBhB,EAAS,EAAQ,KACjBC,EAAU,EAAQ,KAClBgB,EAAW,EAAQ,GACnBb,EAAmB,EAAQ,KAC3Bc,EAAc,EAAQ,IAgDtBL,EAAgB,IAAIE,EAAM,CAE1BI,QAASH,EAETI,WAEA,SAAwBC,GAEpBL,EAAaM,KAAKC,MASlBA,KAAKC,MAAQH,EAAiBG,MAS9BD,KAAKE,SAAWF,KAAKC,MAAME,IAAID,SAS/BF,KAAKF,iBAAmBA,EAWxBE,KAAKI,SAAU,EAUfJ,KAAKK,OAULL,KAAKM,SAAW,GAUhBN,KAAKO,MAAQ,GAUbP,KAAKQ,iBAULR,KAAKS,MAULT,KAAKU,MAULV,KAAKW,MAULX,KAAKY,MAELd,EAAiBe,aAAaC,KAAKnB,EAAYoB,KAAMf,KAAKgB,KAAMhB,MAChEF,EAAiBe,aAAaI,GAAGtB,EAAYuB,MAAOlB,KAAKmB,MAAOnB,OAWpEgB,KAAM,WAEF,IAAII,EAAOpB,KAAKC,MAAME,IAAIiB,KACtBlB,EAAWF,KAAKE,SAASmB,MACzBC,EAASF,EAAKE,OAElBtB,KAAKI,QAAUV,EAASQ,EAAU,UAAWoB,EAAOC,eAAiBH,EAAKI,OAAOH,MAAMf,SACvFN,KAAKK,OAASX,EAASQ,EAAU,iBAAkBoB,EAAOG,yBAE1DzB,KAAKF,iBAAiBe,aAAaC,KAAKnB,EAAY+B,QAAS1B,KAAK2B,QAAS3B,OAY/EmB,MAAO,WAECnB,KAAKI,UAELJ,KAAK4B,iBAEL5B,KAAK6B,eAGT7B,KAAKF,iBAAiBe,aAAaC,KAAKnB,EAAYmC,SAAU9B,KAAK+B,SAAU/B,OAWjFgC,SAAU,WAEN,OAAQhC,KAAKI,SAAWJ,KAAKC,MAAME,IAAI6B,YAW3CJ,eAAgB,WAEZ,IAAIK,EAAQjC,KACRK,EAASL,KAAKK,OAEd6B,EAAU,SAAUC,IAEhBA,EAAMC,kBAAqBH,EAAMD,aAMrCC,EAAMJ,cAENI,EAAM1B,MAAM8B,KAAKF,KAGrBnC,KAAKQ,iBAAmB0B,EAExB7B,EAAOiC,iBAAiB,mBAAoBJ,GAAS,GACrD7B,EAAOiC,iBAAiB,sBAAuBJ,GAAS,GAOxDlC,KAAKF,iBAAiBe,aAAaI,GAAGtB,EAAY4C,OAAQvC,KAAKwC,OAAQxC,OAW3EyC,cAAe,WAEXzC,KAAKK,OAAOqC,oBAAoB,mBAAoB1C,KAAKQ,kBACzDR,KAAKK,OAAOqC,oBAAoB,sBAAuB1C,KAAKQ,kBAE5DR,KAAKF,iBAAiBe,aAAa8B,IAAIhD,EAAY4C,OAAQvC,KAAKwC,QAEhE,IAAK,IAAII,EAAI,EAAGA,EAAI5C,KAAKM,SAASuC,OAAQD,IAEtC5C,KAAKM,SAASsC,GAAGE,sBAUzBC,cAAe,WAEX,IAAK,IAAIH,EAAI,EAAGA,EAAI5C,KAAKM,SAASuC,OAAQD,IAEtC5C,KAAKM,SAASsC,GAAGI,IAAIC,WAAY,GAczCpB,YAAa,WAET,IAAIqB,EAAgBC,UAAUC,cAE9B,GAAKF,EAQD,IAFA,IAAIG,EAAcrD,KAAKM,SAEdsC,EAAI,EAAGA,EAAIM,EAAcL,OAAQD,IAC1C,CACI,IAAIU,EAAUJ,EAAcN,GAG5B,GAAKU,EAAL,CAKA,IAAIC,EAAKD,EAAQC,GACbC,EAAQF,EAAQE,MAChBC,EAAaJ,EAAYG,GAE7B,GAAKC,EAwBIA,EAAWF,KAAOA,GAGvBE,EAAW9B,UAEX0B,EAAYG,GAAS,IAAI9E,EAAQsB,KAAMsD,IAKvCG,EAAWjB,OAAOc,OAjCtB,CAEI,IAAII,EAAS,IAAIhF,EAAQsB,KAAMsD,GAE/BD,EAAYG,GAASE,EAEhB1D,KAAKS,MAIAT,KAAKU,MAILV,KAAKW,MAILX,KAAKY,QAEXZ,KAAKY,MAAQ8C,GAJb1D,KAAKW,MAAQ+C,EAJb1D,KAAKU,MAAQgD,EAJb1D,KAAKS,MAAQiD,SA7BzB1D,KAAK+C,iBAoEbY,OAAQ,WAKJ,IAHA,IAAIC,EAAM,GACNC,EAAO7D,KAAKM,SAEPsC,EAAI,EAAGA,EAAIiB,EAAKhB,OAAQD,IAEzBiB,EAAKjB,IAELgB,EAAIvB,KAAKwB,EAAKjB,IAItB,OAAOgB,GAaXE,OAAQ,SAAUN,GAId,IAFA,IAAIK,EAAO7D,KAAKM,SAEPsC,EAAI,EAAGA,EAAIiB,EAAKhB,OAAQD,IAE7B,GAAIiB,EAAKjB,IAAMiB,EAAKjB,GAAGY,QAAUA,EAE7B,OAAOK,EAAKjB,IAgBxBJ,OAAQ,WAEJ,GAAKxC,KAAKI,QAAV,CAKAJ,KAAK6B,cAEL,IAAIkC,EAAM/D,KAAKO,MAAMsC,OAErB,GAAY,IAARkB,EAQJ,IAHA,IAAIxD,EAAQP,KAAKO,MAAMyD,OAAO,EAAGD,GAGxBnB,EAAI,EAAGA,EAAImB,EAAKnB,IACzB,CACI,IAAIT,EAAQ5B,EAAMqC,GACdI,EAAMhD,KAAK8D,OAAO3B,EAAM8B,QAAQT,OAEjB,qBAAfrB,EAAM+B,KAENlE,KAAKmE,KAAK1F,EAAO2F,UAAWpB,EAAKb,GAEb,wBAAfA,EAAM+B,MAEXlE,KAAKmE,KAAK1F,EAAO4F,aAAcrB,EAAKb,MAahDJ,SAAU,WAEN/B,KAAKyC,gBAELzC,KAAK8C,sBAUTnB,QAAS,WAEL3B,KAAK+B,WAEL,IAAK,IAAIa,EAAI,EAAGA,EAAI5C,KAAKM,SAASuC,OAAQD,IAElC5C,KAAKM,SAASsC,IAEd5C,KAAKM,SAASsC,GAAGjB,UAIzB3B,KAAKM,SAAW,GAEhBN,KAAKC,MAAQ,KACbD,KAAKE,SAAW,KAChBF,KAAKF,iBAAmB,KACxBE,KAAKK,OAAS,MAUlBiE,MAAO,CAEHC,IAAK,WAED,OAAOvE,KAAKM,SAASuC,SAgB7B2B,KAAM,CAEFD,IAAK,WAED,OAAOvE,KAAKS,QAgBpBgE,KAAM,CAEFF,IAAK,WAED,OAAOvE,KAAKU,QAgBpBgE,KAAM,CAEFH,IAAK,WAED,OAAOvE,KAAKW,QAgBpBgE,KAAM,CAEFJ,IAAK,WAED,OAAOvE,KAAKY,UAexB/B,EAAiB+F,SAAS,gBAAiBtF,EAAe,UAAW,UAAW,gBAEhFJ,EAAOC,QAAUG,G,qBCrnBjBJ,EAAOC,QAAU,CAEb0F,YAAa,EAAQ,MACrBC,SAAU,EAAQ,MAClBC,SAAU,EAAQ,Q,mBCAtB7F,EAAOC,QAAU,CAEb6F,GAAI,GACJC,KAAM,GACNC,KAAM,GACNC,MAAO,GAEPC,MAAO,EACPC,QAAS,EACTC,GAAI,GACJC,SAAU,GAEVC,EAAG,EACHC,OAAQ,EACRC,OAAQ,EACRC,SAAU,EAEVC,GAAI,EACJC,GAAI,EACJC,GAAI,EACJC,GAAI,EACJC,GAAI,GACJC,GAAI,GAEJC,aAAc,EACdC,aAAc,EACdC,cAAe,EACfC,cAAe,I,mBC3BnBnH,EAAOC,QAAU,CAEb6F,GAAI,GACJC,KAAM,GACNC,KAAM,GACNC,MAAO,GAEPmB,OAAQ,EACRpF,MAAO,EAEPqF,EAAG,EACHC,EAAG,EACHC,EAAG,EACHjB,EAAG,EAEHkB,cAAe,EACfC,eAAgB,I,mBCjBpBzH,EAAOC,QAAU,CAEb6F,GAAI,GACJC,KAAM,GACNC,KAAM,GACNC,MAAO,GAEPyB,KAAM,GAENJ,EAAG,EACHD,EAAG,EACHf,EAAG,EACHiB,EAAG,EAEHI,GAAI,EACJC,GAAI,EAEJC,GAAI,EACJC,GAAI,EAEJC,KAAM,EACN/F,MAAO,EAEPgG,GAAI,GACJC,GAAI,GAEJjB,aAAc,EACdC,aAAc,EACdC,cAAe,EACfC,cAAe,I,qBCpCnB,IAAIe,EAAS,EAAQ,IACjBC,EAAiB,EAAQ,IACzB7H,EAAQ,EAAQ,GAChBpB,EAAQ,EAAQ,KAChBI,EAA0B,EAAQ,KAClCD,EAA4B,EAAQ,KACpC+I,EAAkB,EAAQ,IAC1BC,EAAU,EAAQ,KAClBC,EAAkB,EAAQ,KAC1B/I,EAAS,EAAQ,IACjBgB,EAAe,EAAQ,IACvBgI,EAAe,EAAQ,GACvBC,EAAa,EAAQ,IACrB7I,EAAmB,EAAQ,KAC3B8I,EAAgB,EAAQ,IACxBC,EAAc,EAAQ,IACtBC,EAAY,EAAQ,IACpBC,EAAoB,EAAQ,IAC5BC,EAAc,EAAQ,IACtBC,EAAW,EAAQ,IACnBC,EAAmB,EAAQ,KA+C3BrJ,EAAc,IAAIY,EAAM,CAExBI,QAASH,EAETI,WAEA,SAAsBI,GAElBR,EAAaM,KAAKC,MASlBA,KAAKC,MAAQA,EASbD,KAAKkI,QAAUjI,EAAME,IASrBH,KAAKE,SAAWD,EAAME,IAAID,SAS1BF,KAAKmI,QAAUlI,EAAME,IAAIiB,KAAKC,MAU9BrB,KAAKa,aAAe,IAAIpB,EAUxBO,KAAKI,SAAU,EASfJ,KAAKoI,YASLpI,KAAKqI,QAGLxJ,EAAiByJ,QAAQtI,MAazBA,KAAKuI,MAAQvI,KAAKmI,QAAQI,MAa1BvI,KAAKwI,SAAU,EAsBfxI,KAAKyI,UAAY,EAWjBzI,KAAK0I,WAAa,EAElB,IAAIC,EAAa,CAAEC,WAAW,GAU9B5I,KAAK6I,gBAAkB,CACnBC,gBAAiB,WAEbH,EAAWC,WAAY,IAY/B5I,KAAK2I,WAAaA,EAUlB3I,KAAK+I,sBAAwB,EAgB7B/I,KAAKgJ,kBAAoB,EAWzBhJ,KAAKiJ,MAAQ,GAWbjJ,KAAKkJ,WAAa,GAWlBlJ,KAAKmJ,MAAQ,GAWbnJ,KAAKoJ,kBAAoB,GAWzBpJ,KAAKqJ,gBAAkB,GAWvBrJ,KAAKsJ,WAAa,GAUlBtJ,KAAKuJ,MAAQ,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,IAUzFvJ,KAAKwJ,WAAa,GAUlBxJ,KAAKyJ,MAAQ,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,IAUzFzJ,KAAK0J,YAAc,CAAE,SAAU,OAAQ,SAAU,QAAS,SAAU,cAAe,SAAU,YAAa,cAAe,cAAe,aAAc,UAUtJ1J,KAAK2J,mBAAoB,EAEzB1J,EAAME,IAAIyJ,OAAO9I,KAAKiH,EAAYhH,KAAMf,KAAKgB,KAAMhB,MACnDC,EAAME,IAAIyJ,OAAO3I,GAAG8G,EAAY7G,MAAOlB,KAAKmB,MAAOnB,OAYvDgB,KAAM,WAEFhB,KAAKqI,QAAUrI,KAAKkI,QAAQG,QAE5BrI,KAAKoI,YAAcpI,KAAKkI,QAAQE,YAEhCpI,KAAKkI,QAAQ0B,OAAO9I,KAAKiH,EAAYrG,QAAS1B,KAAK2B,QAAS3B,MAG5DA,KAAKa,aAAasD,KAAK1F,EAAOsC,OAalCI,MAAO,WAEH,IAAI0I,EAAe7J,KAAKkI,QAAQ0B,OAEhCC,EAAa5I,GAAG8G,EAAY+B,iBAAkB9J,KAAK+J,aAAc/J,MACjE6J,EAAa5I,GAAG8G,EAAYiC,eAAgBhK,KAAKiK,cAAejK,MAChE6J,EAAa5I,GAAG8G,EAAYmC,oBAAqBlK,KAAKmK,mBAAoBnK,MAC1E6J,EAAa5I,GAAG8G,EAAYqC,WAAYpK,KAAKqK,UAAWrK,MACxD6J,EAAa/I,KAAKiH,EAAYjG,SAAU9B,KAAK+B,SAAU/B,MAEvDA,KAAKmI,QAAQyB,OAAO3I,GAAGxC,EAAO6L,SAAUtK,KAAKuK,UAAWvK,MACxDA,KAAKmI,QAAQyB,OAAO3I,GAAGxC,EAAO+L,UAAWxK,KAAKyK,WAAYzK,MAE1DA,KAAKI,SAAU,EAGfJ,KAAKwJ,WAAa,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAG/CxJ,KAAKa,aAAasD,KAAK1F,EAAOyC,QAWlCuJ,WAAY,SAAUtI,GAEdnC,KAAKgC,YAELhC,KAAKmE,KAAK1F,EAAO+L,UAAWrI,EAAMuI,UAAWvI,IAYrDoI,UAAW,SAAUpI,GAEbnC,KAAKgC,YAELhC,KAAKmE,KAAK1F,EAAO6L,SAAUnI,EAAMuI,UAAWvI,IAapDkI,UAAW,WAGPrK,KAAKa,aAAasD,KAAK1F,EAAO2L,YAE9B,IAAIO,EAAa3K,KAAKqJ,gBAClBuB,EAAa5K,KAAKoJ,kBAElByB,EAAWF,EAAW9H,OACtBiI,EAAWF,EAAW/H,OAE1B,GAAiB,IAAbgI,GAA+B,IAAbC,EAAtB,CASA,IAHA,IAAIC,EAAU/K,KAAKmJ,MAGVvG,EAAI,EAAGA,EAAIiI,EAAUjI,IAC9B,CACI,IAAIoI,EAAaL,EAAW/H,GAExBY,EAAQuH,EAAQE,QAAQD,GAExBxH,GAAS,IAETuH,EAAQ/G,OAAOR,EAAO,GAEtBxD,KAAKkL,MAAMF,GAAY,IAK/BL,EAAW9H,OAAS,EACpB7C,KAAKqJ,gBAAgBxG,OAAS,EAG9B7C,KAAKmJ,MAAQ4B,EAAQI,OAAOP,EAAW5G,OAAO,MAWlDhC,SAAU,WAEN,OAAQhC,KAAKI,SAAWJ,KAAKC,MAAME,IAAI6B,YAe3CoJ,WAAY,SAAUC,EAAMC,GAExB,IAAKtL,KAAKgC,WAEN,OAAO,EAQX,GAHAhC,KAAKa,aAAasD,KAAK1F,EAAO8D,OAAQ8I,EAAMC,GAGxCtL,KAAK2J,kBAIL,OAFA3J,KAAK2J,mBAAoB,GAElB,EAGX,IAAI/G,EACAuF,EAAUnI,KAAKmI,QAEfoD,EAAWpD,EAAQoD,SACnBC,EAAgBrD,EAAQqD,cAE5B,IAAK5I,EAAI,EAAGA,EAAI4I,EAAe5I,IAE3B2I,EAAS3I,GAAG6I,eAIhB,GAA0B,IAAtBzL,KAAKmJ,MAAMtG,OAEX,OAAO,EAGX,IAAI6I,EAAO1L,KAAKyI,SAEhB,IAAc,IAAViD,EAEA,OAAO,EAEN,GAAIA,EAAO,EAChB,CAGI,GAFA1L,KAAK0I,YAAc4C,IAEftL,KAAK0I,WAAa,GAQlB,OAAO,EALP1I,KAAK0I,WAAa1I,KAAKyI,SAU/B,IAAIkD,GAAW,EAEf,IAAK/I,EAAI,EAAGA,EAAI4I,EAAe5I,IAC/B,CACI,IAAI0B,EAAQ,EAERsH,EAAUL,EAAS3I,GAGvB5C,KAAKkJ,WAAa,GAGlBlJ,KAAKiJ,MAAQjJ,KAAK6L,eAAeD,GAEjC5L,KAAK8L,gBAAgB9L,KAAKiJ,MAAO2C,GACjC5L,KAAK+L,cAAc/L,KAAKkJ,YAEpBlJ,KAAKwI,UAGDxI,KAAKiJ,MAAMpG,QAEX7C,KAAKiJ,MAAMjF,OAAO,GAGlBhE,KAAKkJ,WAAWrG,QAEhB7C,KAAKkJ,WAAWlF,OAAO,IAI/BM,GAAStE,KAAKgM,qBAAqBJ,GAEA,IAA/B5L,KAAKiM,aAAaL,IAElB5L,KAAKkM,0BAA0BN,EAASP,GAGxC/G,EAAQ,IAGRqH,GAAW,GAInB,OAAOA,GAiBXnJ,OAAQ,SAAU0B,EAAMqH,GAEpB,IAAKvL,KAAKgC,WAEN,OAAO,EAMX,IAHA,IAAIwJ,EAAgBD,EAAS1I,OACzB8I,GAAW,EAEN/I,EAAI,EAAGA,EAAI4I,EAAe5I,IACnC,CACI,IAAI0B,EAAQ,EACRsH,EAAUL,EAAS3I,GAyBvB,OAtBA5C,KAAKkJ,WAAa,GAGlBlJ,KAAKiJ,MAAQjJ,KAAK6L,eAAeD,GAEjC5L,KAAK8L,gBAAgB9L,KAAKiJ,MAAO2C,GACjC5L,KAAK+L,cAAc/L,KAAKkJ,YAEpBlJ,KAAKwI,UAGDxI,KAAKiJ,MAAMpG,QAEX7C,KAAKiJ,MAAMjF,OAAO,GAGlBhE,KAAKkJ,WAAWrG,QAEhB7C,KAAKkJ,WAAWlF,OAAO,IAIvBE,GAEJ,KAAK9F,EAAM+N,WACP7H,GAAStE,KAAKoM,qBAAqBR,GACnCtH,GAAStE,KAAKqM,kBAAkBT,GAChCtH,GAAStE,KAAKgM,qBAAqBJ,GACnC,MAEJ,KAAKxN,EAAMkO,SACPhI,GAAStE,KAAKuM,mBAAmBX,GACjCtH,GAAStE,KAAKwM,gBAAgBZ,GAC9BtH,GAAStE,KAAKgM,qBAAqBJ,GACnC,MAEJ,KAAKxN,EAAMqO,YACPnI,GAAStE,KAAKoM,qBAAqBR,GACnCtH,GAAStE,KAAKqM,kBAAkBT,GAChCtH,GAAStE,KAAK0M,kBAAkBd,GAChC,MAEJ,KAAKxN,EAAMuO,UACX,KAAKvO,EAAMwO,aACPtI,GAAStE,KAAKuM,mBAAmBX,GACjCtH,GAAStE,KAAKwM,gBAAgBZ,GAC9BtH,GAAStE,KAAK6M,iBAAiBjB,GAC/B,MAEJ,KAAKxN,EAAM0O,WACX,KAAK1O,EAAM2O,WACPzI,GAAStE,KAAKgN,qBAAqBpB,GACnCtH,GAAStE,KAAKiN,kBAAkBrB,GAChCtH,GAAStE,KAAKgM,qBAAqBJ,GACnC,MAEJ,KAAKxN,EAAM8O,YACP5I,GAAStE,KAAKmN,kBAAkBvB,GAIpCtH,EAAQ,IAGRqH,GAAW,GAMnB,OAFA3L,KAAK2J,mBAAoB,EAElBgC,GAeXT,MAAO,SAAUF,EAAYoC,QAEPC,IAAdD,IAA2BA,GAAY,GAE3C,IAAI/L,EAAQ2J,EAAW3J,MAGvB,GAAKA,EAAL,CAKK+L,GAEDpN,KAAKsN,gBAAgBtC,GAGzB3J,EAAM2J,gBAAaqC,EACnBhM,EAAMhB,YAASgN,EACfhM,EAAMkM,aAAUF,EAChBhM,EAAMmM,qBAAkBH,EACxBhM,EAAMoM,qBAAkBJ,EAExBrC,EAAW3J,MAAQ,KAGnB,IAAImC,EAAQxD,KAAKsJ,WAAW2B,QAAQD,GAuBpC,OArBIxH,GAAS,GAETxD,KAAKsJ,WAAWtF,OAAOR,EAAO,IAGlCA,EAAQxD,KAAKuJ,MAAM,GAAG0B,QAAQD,KAEjB,GAEThL,KAAKuJ,MAAM,GAAGvF,OAAOR,EAAO,IAGhCA,EAAQxD,KAAKyJ,MAAM,GAAGwB,QAAQD,KAEjB,IAEThL,KAAKyJ,MAAM,GAAGzF,OAAOR,EAAO,GAE5BxD,KAAKmI,QAAQuF,YAAYrM,IAGtB2J,IAcX2C,QAAS,SAAU3C,GAEfA,EAAW3J,MAAMjB,SAAU,GA8B/BwN,OAAQ,SAAU5C,EAAYuC,EAASC,EAAiBK,GAoBpD,YAlBiBR,IAAbQ,IAA0BA,GAAW,GAErC7C,EAAW3J,MAGX2J,EAAW3J,MAAMjB,SAAU,EAK3BJ,KAAK8N,WAAW9C,EAAYuC,EAASC,GAGrCxC,EAAW3J,OAASwM,IAAa7C,EAAW3J,MAAMwM,WAElD7C,EAAW3J,MAAMwM,SAAWA,GAGzB7N,MAiBX6L,eAAgB,SAAUD,GAItB,IAFA,IAAIvD,EAAUrI,KAAKqI,QAAQ0F,uBAAuBnC,GAEzCoC,EAAI,EAAGA,EAAI3F,EAAQxF,OAAQmL,IACpC,CAQI,IAPA,IAAIC,EAAS5F,EAAQ2F,GAIjBE,EAAOlO,KAAKmI,QAAQgG,QAAQvC,EAAS5L,KAAKmJ,MAAO8E,GAG5CrL,EAAI,EAAGA,EAAIsL,EAAKrL,OAAQD,IACjC,CACI,IAAIwL,EAAMF,EAAKtL,GAEXwL,EAAI/M,MAAMwM,UAEV7N,KAAKkJ,WAAW7G,KAAK+L,GAI7B,GAAIF,EAAKrL,OAAS,EAId,OAFA+I,EAAQqC,OAASA,EAEVC,EASf,OAFAtC,EAAQqC,OAAS5F,EAAQ,GAElB,IAkBXgE,kBAAmB,SAAUT,GAEzB,IAAItH,EAAQ,EACR+J,EAAgBrO,KAAKiJ,MAErBN,EAAa3I,KAAK2I,WAClBE,EAAkB7I,KAAK6I,gBAE3BF,EAAWC,WAAY,EAKvB,IAHA,IAAI0F,GAAU,EAGL1L,EAAI,EAAGA,EAAIyL,EAAcxL,OAAQD,IAC1C,CACI,IAAIoI,EAAaqD,EAAczL,GAE/B,GAAKoI,EAAW3J,MAAhB,CASA,GAJAiD,IAEA0G,EAAW7G,KAAK1F,EAAO8P,wBAAyB3C,EAASZ,EAAW3J,MAAMmN,OAAQxD,EAAW3J,MAAMoN,OAAQ5F,GAEvGF,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,MAKJ,GAFAtO,KAAKmE,KAAK1F,EAAOiQ,gBAAiB9C,EAASZ,EAAYnC,GAEnDF,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,QAiBR,OAZKA,GAAWtO,KAAKmI,UAEbyD,EAAQ+C,cAAgB3O,KAAKmI,QAAQ/G,KAAKwN,OAE1C5O,KAAKmE,KAAK1F,EAAOoQ,aAAcjD,EAASyC,GAIxCrO,KAAKmE,KAAK1F,EAAOqQ,qBAAsBlD,IAIxCtH,GAsBX2H,aAAc,SAAUL,GAEpB,OAAO5L,KAAKwJ,WAAWoC,EAAQrI,KAqBnCwL,aAAc,SAAUnD,EAASoD,GAE7BhP,KAAKwJ,WAAWoC,EAAQrI,IAAMyL,GAclC9C,0BAA2B,SAAUN,EAASP,GAE1C,IAAI4D,GAAS,EACTC,EAAgBlP,KAAKgJ,kBACrBmG,EAAoBnP,KAAK+I,sBAa7B,IAXIoG,EAAoB,GAAK7H,EAAgBsE,EAAQwD,EAAGxD,EAAQyD,EAAGzD,EAAQ0D,MAAO1D,EAAQ2D,QAAUJ,GAK3FD,EAAgB,GAAM7D,GAAQO,EAAQ4D,SAAWN,KAFtDD,GAAS,GAQTA,EAIA,OAFAjP,KAAK+O,aAAanD,EAAS,GAEpB5L,KAAKyP,qBAAqB7D,IAiBzC6D,qBAAsB,SAAU7D,GAG5B,GAAmC,IAA/B5L,KAAKiM,aAAaL,GAElB,OAAO,EAKX,IAFA,IAAI8D,EAAO1P,KAAKuJ,MAAMqC,EAAQrI,IAErBX,EAAI,EAAGA,EAAI8M,EAAK7M,OAAQD,IACjC,CACI,IAAIoI,EAAa0E,EAAK9M,GAElBvB,EAAQ2J,EAAW3J,MAEvBA,EAAMsO,UAAY,EAElBtO,EAAMuO,WAAa5E,EAAWoE,EAC9B/N,EAAMwO,WAAa7E,EAAWqE,EAE9BhO,EAAMyO,iBAAmBlE,EAAQmE,OACjC1O,EAAM2O,iBAAmBpE,EAAQqE,OAEjC5O,EAAM6O,MAAQ7O,EAAMyO,iBAAmBzO,EAAMuO,WAC7CvO,EAAM8O,MAAQ9O,EAAM2O,iBAAmB3O,EAAMwO,WAE7C7E,EAAW7G,KAAK1F,EAAO2R,sBAAuBxE,EAASvK,EAAM6O,MAAO7O,EAAM8O,OAE1EnQ,KAAKmE,KAAK1F,EAAO4R,WAAYzE,EAASZ,GAK1C,OAFAhL,KAAK+O,aAAanD,EAAS,GAEpB8D,EAAK7M,QAehBuJ,qBAAsB,SAAUR,GAE5B,IAAIyC,EAAgBrO,KAAKiJ,MAEzB,GAA+B,IAA3BjJ,KAAKsJ,WAAWzG,QAAyC,IAAzBwL,EAAcxL,SAAiB+I,EAAQ0E,aAA8C,IAA/BtQ,KAAKiM,aAAaL,GAGxG,OAAO,EAIX5L,KAAK+O,aAAanD,EAAS,GAK3B,IAFA,IAAI2E,EAAW,GAEN3N,EAAI,EAAGA,EAAIyL,EAAcxL,OAAQD,IAC1C,CACI,IAAIoI,EAAaqD,EAAczL,GAE3BoI,EAAW3J,MAAMmP,WAA6C,IAA/BxF,EAAW3J,MAAMsO,WAEhDY,EAASlO,KAAK2I,GAItB,OAAwB,IAApBuF,EAAS1N,QAET7C,KAAK+O,aAAanD,EAAS,GAEpB,IAEF2E,EAAS1N,OAAS,IAEvB7C,KAAK8L,gBAAgByE,EAAU3E,GAE3B5L,KAAKwI,SAEL+H,EAASvM,OAAO,IAKxBhE,KAAKuJ,MAAMqC,EAAQrI,IAAMgN,EAEU,IAA/BvQ,KAAK+I,uBAA0D,IAA3B/I,KAAKgJ,mBAGzChJ,KAAK+O,aAAanD,EAAS,GAEpB5L,KAAKyP,qBAAqB7D,KAKjC5L,KAAK+O,aAAanD,EAAS,GAEpB,KAuBfoB,qBAAsB,SAAUpB,GAQ5B,GALmC,IAA/B5L,KAAKiM,aAAaL,IAElB5L,KAAKkM,0BAA0BN,EAAS5L,KAAKmI,QAAQ/G,KAAKqP,KAAKC,KAGhC,IAA/B1Q,KAAKiM,aAAaL,GAElB,OAAO,EAQX,IAJA,IAAI+E,EAAY3Q,KAAKkJ,WAEjBwG,EAAO1P,KAAKuJ,MAAMqC,EAAQrI,IAErBX,EAAI,EAAGA,EAAI8M,EAAK7M,OAAQD,IACjC,CACI,IAuEIsN,EACAC,EAxEAnF,EAAa0E,EAAK9M,GAElBvB,EAAQ2J,EAAW3J,MAEnBhB,EAASgB,EAAMhB,OAGnB,GAAIA,EACJ,CACI,IAAImD,EAAQmN,EAAU1F,QAAQ5K,GAGhB,IAAVmD,GAGAwH,EAAW7G,KAAK1F,EAAOmS,qBAAsBhF,EAASvL,GAEtDL,KAAKmE,KAAK1F,EAAOoS,UAAWjF,EAASZ,EAAY3K,IAE5CmD,EAAQ,GAGbwH,EAAW7G,KAAK1F,EAAOqS,sBAAuBlF,EAASvL,GAEvDL,KAAKmE,KAAK1F,EAAOsS,WAAYnF,EAASZ,EAAY3K,GAElDgB,EAAMhB,OAASsQ,EAAU,GAEzBtQ,EAASgB,EAAMhB,OAEf2K,EAAW7G,KAAK1F,EAAOuS,sBAAuBpF,EAASvL,GAEvDL,KAAKmE,KAAK1F,EAAOwS,WAAYrF,EAASZ,EAAY3K,KAKlD2K,EAAW7G,KAAK1F,EAAOqS,sBAAuBlF,EAASvL,GAEvDL,KAAKmE,KAAK1F,EAAOsS,WAAYnF,EAASZ,EAAY3K,GAI9CsQ,EAAU,IAEVtP,EAAMhB,OAASsQ,EAAU,GAEzBtQ,EAASgB,EAAMhB,OAEf2K,EAAW7G,KAAK1F,EAAOuS,sBAAuBpF,EAASvL,GAEvDL,KAAKmE,KAAK1F,EAAOwS,WAAYrF,EAASZ,EAAY3K,IAKlDgB,EAAMhB,OAAS,WAIjBA,GAAUsQ,EAAU,KAE1BtP,EAAMhB,OAASsQ,EAAU,GAEzBtQ,EAASgB,EAAMhB,OAEf2K,EAAW7G,KAAK1F,EAAOuS,sBAAuBpF,EAASvL,GAEvDL,KAAKmE,KAAK1F,EAAOwS,WAAYrF,EAASZ,EAAY3K,IAMtD,GAAK2K,EAAWkG,gBAMhB,CACI,IAAIC,EAAKvF,EAAQmE,OAAS1O,EAAMyO,iBAC5BsB,EAAKxF,EAAQqE,OAAS5O,EAAM2O,iBAE5BqB,EAAWrG,EAAWsG,oBAEtBC,EAAYJ,EAAKK,KAAKC,IAAIJ,GAAYD,EAAKI,KAAKE,IAAIL,GACpDM,EAAYP,EAAKI,KAAKC,IAAIJ,GAAYF,EAAKK,KAAKE,IAAIL,GAExDE,GAAc,EAAIvG,EAAWkG,gBAAgBU,OAC7CD,GAAc,EAAI3G,EAAWkG,gBAAgBW,OAE7C3B,EAAQqB,EAAYlQ,EAAMuO,WAC1BO,EAAQwB,EAAYtQ,EAAMwO,gBAjB1BK,EAAQtE,EAAQmE,OAAS1O,EAAM6O,MAC/BC,EAAQvE,EAAQqE,OAAS5O,EAAM8O,MAmBnCnF,EAAW7G,KAAK1F,EAAOqT,gBAAiBlG,EAASsE,EAAOC,GAExDnQ,KAAKmE,KAAK1F,EAAOsT,KAAMnG,EAASZ,EAAYkF,EAAOC,GAGvD,OAAOT,EAAK7M,QAmBhB0J,mBAAoB,SAAUX,GAK1B,IAFA,IAAI8D,EAAO1P,KAAKuJ,MAAMqC,EAAQrI,IAErBX,EAAI,EAAGA,EAAI8M,EAAK7M,OAAQD,IACjC,CACI,IAAIoI,EAAa0E,EAAK9M,GAElBvB,EAAQ2J,EAAW3J,MAEvB,GAAIA,GAA6B,IAApBA,EAAMsO,UACnB,CACItO,EAAMsO,UAAY,EAElBtO,EAAM6O,MAAQ7O,EAAMmN,OAASxD,EAAWgH,eACxC3Q,EAAM8O,MAAQ9O,EAAMoN,OAASzD,EAAWiH,eAExC,IAAIC,GAAU,EAEV7R,EAASgB,EAAMhB,OAEfA,IAEA2K,EAAW7G,KAAK1F,EAAO0T,gBAAiBvG,EAASvL,GAEjDL,KAAKmE,KAAK1F,EAAO2T,KAAMxG,EAASZ,EAAY3K,GAE5CgB,EAAMhB,OAAS,KAEf6R,GAAU,GAKVlH,EAAW3J,QAEX2J,EAAW7G,KAAK1F,EAAO4T,oBAAqBzG,EAASvK,EAAM6O,MAAO7O,EAAM8O,MAAO+B,GAE/ElS,KAAKmE,KAAK1F,EAAO6T,SAAU1G,EAASZ,EAAYkH,KAS5D,OAJAlS,KAAK+O,aAAanD,EAAS,GAE3B8D,EAAK1L,OAAO,GAEL,GAiBXiJ,kBAAmB,SAAUrB,GAEzB,IAAItH,EAAQ,EACR+J,EAAgBrO,KAAKiJ,MAErBN,EAAa3I,KAAK2I,WAClBE,EAAkB7I,KAAK6I,gBAE3BF,EAAWC,WAAY,EAKvB,IAHA,IAAI0F,GAAU,EAGL1L,EAAI,EAAGA,EAAIyL,EAAcxL,OAAQD,IAC1C,CACI,IAAIoI,EAAaqD,EAAczL,GAE/B,GAAKoI,EAAW3J,MAAhB,CASA,GAJAiD,IAEA0G,EAAW7G,KAAK1F,EAAO8T,wBAAyB3G,EAASZ,EAAW3J,MAAMmN,OAAQxD,EAAW3J,MAAMoN,OAAQ5F,GAEvGF,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,MAKJ,GAFAtO,KAAKmE,KAAK1F,EAAO+T,gBAAiB5G,EAASZ,EAAYnC,GAEnDF,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,MAGJ,GAAItO,KAAKwI,QAEL,OASR,OALK8F,GAEDtO,KAAKmE,KAAK1F,EAAOgU,aAAc7G,EAASyC,GAGrC/J,GAiBX6I,kBAAmB,SAAUvB,GAEzB,IAAItH,EAAQ,EACR+J,EAAgBrO,KAAKiJ,MAErBN,EAAa3I,KAAK2I,WAClBE,EAAkB7I,KAAK6I,gBAE3BF,EAAWC,WAAY,EASvB,IAPA,IAAI0F,GAAU,EAEV6C,EAAKvF,EAAQ8G,OACbtB,EAAKxF,EAAQ+G,OACbC,EAAKhH,EAAQiH,OAGRjQ,EAAI,EAAGA,EAAIyL,EAAcxL,OAAQD,IAC1C,CACI,IAAIoI,EAAaqD,EAAczL,GAE/B,GAAKoI,EAAW3J,MAAhB,CASA,GAJAiD,IAEA0G,EAAW7G,KAAK1F,EAAOqU,yBAA0BlH,EAASuF,EAAIC,EAAIwB,EAAI/J,GAElEF,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,MAKJ,GAFAtO,KAAKmE,KAAK1F,EAAOsU,iBAAkBnH,EAASZ,EAAYmG,EAAIC,EAAIwB,EAAI/J,GAEhEF,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,QASR,OALKA,GAEDtO,KAAKmE,KAAK1F,EAAOuU,cAAepH,EAASyC,EAAe8C,EAAIC,EAAIwB,GAG7DtO,GAkBXoI,kBAAmB,SAAUd,GAEzB,IAAIyC,EAAgBrO,KAAKiJ,MAErBgK,EAAkB,EAElB3O,EAAQ+J,EAAcxL,OAEtBqQ,EAAW,GAEf,GAAI5O,EAAQ,EACZ,CACI,IAAI6D,EAAUnI,KAAKmI,QAEfQ,EAAa3I,KAAK2I,WAClBE,EAAkB7I,KAAK6I,gBAE3BF,EAAWC,WAAY,EAIvB,IAFA,IAAI0F,GAAU,EAEL1L,EAAI,EAAGA,EAAI0B,EAAO1B,IAC3B,CACI,IAAIoI,EAAaqD,EAAczL,GAE/B,GAAKoI,EAAW3J,MAAhB,CAaA,GARA6R,EAAS7Q,KAAK2I,GAEd7C,EAAQgL,UAAUnI,EAAW3J,OAE7B2J,EAAW7G,KAAK1F,EAAO2U,wBAAyBxH,EAASZ,EAAW3J,MAAMmN,OAAQxD,EAAW3J,MAAMoN,OAAQ5F,GAE3GoK,IAEItK,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,MAKJ,GAFAtO,KAAKmE,KAAK1F,EAAO4U,gBAAiBzH,EAASZ,EAAYnC,GAEnDF,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,QAIHA,GAEDtO,KAAKmE,KAAK1F,EAAO6U,aAAc1H,EAASsH,GAOhD,OAFAlT,KAAKyJ,MAAMmC,EAAQrI,IAAM2P,EAElBD,GAkBXpG,iBAAkB,SAAUjB,GAExB,IAAI2H,EAAiBvT,KAAKyJ,MAAMmC,EAAQrI,IAEpC0P,EAAkB,EAElB3O,EAAQiP,EAAe1Q,OAE3B,GAAIyB,EAAQ,EACZ,CACI,IAAI6D,EAAUnI,KAAKmI,QAEfQ,EAAa3I,KAAK2I,WAClBE,EAAkB7I,KAAK6I,gBAE3BF,EAAWC,WAAY,EAEvB,IAAI0F,GAAU,EAEdtO,KAAK8L,gBAAgByH,EAAgB3H,GAErC,IAAK,IAAIhJ,EAAI,EAAGA,EAAI0B,EAAO1B,IAC3B,CACI,IAAIoI,EAAauI,EAAe3Q,GAKhC,IAFAoI,EAAauI,EAAe3Q,IAEZvB,MAAhB,CAWA,GANA8G,EAAQuF,YAAY1C,EAAW3J,OAE/B2J,EAAW7G,KAAK1F,EAAO+U,uBAAwB5H,EAAS/C,GAExDoK,IAEItK,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,MAKJ,GAFAtO,KAAKmE,KAAK1F,EAAOgV,eAAgB7H,EAASZ,EAAYnC,GAElDF,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,MAGCA,GAEDtO,KAAKmE,KAAK1F,EAAOiV,YAAa9H,EAAS2H,IAI/CvT,KAAKyJ,MAAMmC,EAAQrI,IAAM,GAG7B,OAAO0P,GAoBXjH,qBAAsB,SAAUJ,GAE5B,IAEIhJ,EACAoI,EAHAqD,EAAgBrO,KAAKiJ,MAIrB0K,EAAU,GACVT,EAAW,GACXU,EAAY,GACZL,EAAiBvT,KAAKyJ,MAAMmC,EAAQrI,IACpCsQ,EAAoB7T,KAAKuJ,MAAMqC,EAAQrI,IAEvC4E,EAAUnI,KAAKmI,QAKnB,IAAKvF,EAAI,EAAGA,EAAI2Q,EAAe1Q,OAAQD,IAEnCoI,EAAauI,EAAe3Q,IAEe,IAAvCyL,EAAcpD,QAAQD,KAAiE,IAA3C6I,EAAkB5I,QAAQD,GAGtE2I,EAAQtR,KAAK2I,GAKb4I,EAAUvR,KAAK2I,GAMvB,IAAKpI,EAAI,EAAGA,EAAIyL,EAAcxL,OAAQD,IAElCoI,EAAaqD,EAAczL,IAIiB,IAAxC2Q,EAAetI,QAAQD,IAEvBkI,EAAS7Q,KAAK2I,GAOtB,IAAI1G,EAAQqP,EAAQ9Q,OAEhBoQ,EAAkB,EAElBtK,EAAa3I,KAAK2I,WAClBE,EAAkB7I,KAAK6I,gBAE3BF,EAAWC,WAAY,EAEvB,IAAI0F,GAAU,EAEd,GAAIhK,EAAQ,EACZ,CAII,IAHAtE,KAAK8L,gBAAgB6H,EAAS/H,GAGzBhJ,EAAI,EAAGA,EAAI0B,EAAO1B,IAInB,IAFAoI,EAAa2I,EAAQ/Q,IAELvB,MAAhB,CAYA,GANA8G,EAAQuF,YAAY1C,EAAW3J,OAE/B2J,EAAW7G,KAAK1F,EAAO+U,uBAAwB5H,EAAS/C,GAExDoK,IAEItK,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,MAKJ,GAFAtO,KAAKmE,KAAK1F,EAAOgV,eAAgB7H,EAASZ,EAAYnC,GAElDF,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,OAIHA,GAEDtO,KAAKmE,KAAK1F,EAAOiV,YAAa9H,EAAS+H,GAW/C,GANArP,EAAQ4O,EAASrQ,OAEjB8F,EAAWC,WAAY,EAEvB0F,GAAU,EAENhK,EAAQ,EACZ,CAII,IAHAtE,KAAK8L,gBAAgBoH,EAAUtH,GAG1BhJ,EAAI,EAAGA,EAAI0B,EAAO1B,IAInB,IAFAoI,EAAakI,EAAStQ,IAENvB,MAAhB,CAYA,GANA8G,EAAQgL,UAAUnI,EAAW3J,OAE7B2J,EAAW7G,KAAK1F,EAAO2U,wBAAyBxH,EAASZ,EAAW3J,MAAMmN,OAAQxD,EAAW3J,MAAMoN,OAAQ5F,GAE3GoK,IAEItK,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,MAKJ,GAFAtO,KAAKmE,KAAK1F,EAAO4U,gBAAiBzH,EAASZ,EAAYnC,GAEnDF,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,OAIHA,GAEDtO,KAAKmE,KAAK1F,EAAO6U,aAAc1H,EAASsH,GAUhD,OALAK,EAAiBK,EAAUzI,OAAO+H,GAGlClT,KAAKyJ,MAAMmC,EAAQrI,IAAMvD,KAAK8L,gBAAgByH,EAAgB3H,GAEvDqH,GAkBXzG,gBAAiB,SAAUZ,GAEvB,IAAIyC,EAAgBrO,KAAKiJ,MAErBN,EAAa3I,KAAK2I,WAClBE,EAAkB7I,KAAK6I,gBAE3BF,EAAWC,WAAY,EAKvB,IAHA,IAAI0F,GAAU,EAGL1L,EAAI,EAAGA,EAAIyL,EAAcxL,OAAQD,IAC1C,CACI,IAAIoI,EAAaqD,EAAczL,GAE/B,GAAKoI,EAAW3J,MAAhB,CAOA,GAFA2J,EAAW7G,KAAK1F,EAAOqV,sBAAuBlI,EAASZ,EAAW3J,MAAMmN,OAAQxD,EAAW3J,MAAMoN,OAAQ5F,GAErGF,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,MAKJ,GAFAtO,KAAKmE,KAAK1F,EAAOsV,cAAenI,EAASZ,EAAYnC,GAEjDF,EAAWC,YAAcoC,EAAW3J,MACxC,CACIiN,GAAU,EACV,QAiBR,OAZKA,GAAWtO,KAAKmI,UAEbyD,EAAQoI,YAAchU,KAAKmI,QAAQ/G,KAAKwN,OAExC5O,KAAKmE,KAAK1F,EAAOwV,WAAYrI,EAASyC,GAItCrO,KAAKmE,KAAK1F,EAAOyV,mBAAoBtI,IAItCyC,EAAcxL,QAczBsR,kBAAmB,SAAUC,GAOzB,OAL+C,IAA3CpU,KAAKoJ,kBAAkB6B,QAAQmJ,KAAgD,IAA/BpU,KAAKmJ,MAAM8B,QAAQmJ,IAEnEpU,KAAKoJ,kBAAkB/G,KAAK+R,GAGzBpU,MAcXsN,gBAAiB,SAAU8G,GAIvB,OAFApU,KAAKqJ,gBAAgBhH,KAAK+R,GAEnBpU,MAkBXqU,aAAc,SAAUC,EAAaC,QAEnBlH,IAAVkH,IAAuBA,GAAQ,GAE9BC,MAAMC,QAAQH,KAEfA,EAAc,CAAEA,IAGpB,IAAK,IAAI1R,EAAI,EAAGA,EAAI0R,EAAYzR,OAAQD,IACxC,CACI,IAAIoI,EAAasJ,EAAY1R,GAE7BoI,EAAW3J,MAAMmP,UAAY+D,EAE7B,IAAI/Q,EAAQxD,KAAKsJ,WAAW2B,QAAQD,GAEhCuJ,IAAoB,IAAX/Q,EAETxD,KAAKsJ,WAAWjH,KAAK2I,IAEfuJ,GAAS/Q,GAAS,GAExBxD,KAAKsJ,WAAWtF,OAAOR,EAAO,GAItC,OAAOxD,MAoCX0U,iBAAkB,SAAUC,QAEDtH,IAAnBsH,IAAgCA,EAAiB,GAErD,IAAIC,EAAiB5U,KAAKkI,QAAQ2M,SAElC,OAAOtW,EAA0BqW,EAAgBD,IAyBrD7G,WAAY,SAAUwG,EAAa/G,EAASC,GAExC,QAAgBH,IAAZE,EAEA,OAAOvN,KAAK8U,sBAAsBR,GAGjCE,MAAMC,QAAQH,KAEfA,EAAc,CAAEA,IAGpB,IAAI9D,GAAY,EACZ3C,GAAW,EACXkH,GAAS,EACTC,GAAgB,EAChBC,GAAe,EACfC,GAAgB,EAGpB,GAAIvN,EAAc4F,GAClB,CACI,IAAIjM,EAASiM,EAEbA,EAAU9F,EAAanG,EAAQ,UAAW,MAC1CkM,EAAkB/F,EAAanG,EAAQ,kBAAmB,MAC1DkP,EAAY/I,EAAanG,EAAQ,aAAa,GAC9CuM,EAAWpG,EAAanG,EAAQ,YAAY,GAC5CyT,EAAStN,EAAanG,EAAQ,UAAU,GACxC0T,EAAgBvN,EAAanG,EAAQ,iBAAiB,GAEtD2T,EAAexN,EAAanG,EAAQ,gBAAgB,GACpD,IAAIqT,EAAiBlN,EAAanG,EAAQ,iBAAkB,GAExD2T,IAEA1H,EAAU,GACVC,EAAkBxN,KAAK0U,iBAAiBC,IAIvCpH,GAAYC,IAEbxN,KAAK8U,sBAAsBR,GAC3BY,GAAgB,OAGI,mBAAZ3H,GAA2BC,IAEvCA,EAAkBD,EAClBA,EAAU,IAGd,IAAK,IAAI3K,EAAI,EAAGA,EAAI0R,EAAYzR,OAAQD,IACxC,CACI,IAAIoI,EAAasJ,EAAY1R,GAE7B,GAAIqS,GAAoC,cAApBjK,EAAW9G,KAE3BiR,QAAQC,KAAK,oEAFjB,CAMA,IAAIC,EAAOrK,EAAW3J,MAAyE2J,EAAW3J,MAA3E7C,EAAwBwM,EAAYuC,EAASC,GAE5E6H,EAAGH,cAAgBA,EACnBG,EAAGxH,SAAWA,EACdwH,EAAGN,OAAS,EAAkB,UAAYA,EAE1C/J,EAAW3J,MAAQgU,EAEf7E,GAEAxQ,KAAKqU,aAAarJ,GAGtBhL,KAAKmU,kBAAkBnJ,IAG3B,OAAOhL,MAkBXsV,iBAAkB,SAAUhB,EAAalF,EAAGC,EAAGkG,EAAQC,QAElCnI,IAAbmI,IAA0BA,EAAWnO,GAEzC,IAAIoO,EAAQ,IAAIrO,EAAOgI,EAAGC,EAAGkG,GAE7B,OAAOvV,KAAK8N,WAAWwG,EAAamB,EAAOD,IAmB/CE,kBAAmB,SAAUpB,EAAalF,EAAGC,EAAGsG,EAAOC,EAAQJ,QAE1CnI,IAAbmI,IAA0BA,EAAWhO,GAEzC,IAAIiO,EAAQ,IAAIlO,EAAQ6H,EAAGC,EAAGsG,EAAOC,GAErC,OAAO5V,KAAK8N,WAAWwG,EAAamB,EAAOD,IAe/CV,sBAAuB,SAAUR,EAAakB,QAEzBnI,IAAbmI,IAA0BA,EAAW1N,GAEpC0M,MAAMC,QAAQH,KAEfA,EAAc,CAAEA,IAGpB,IAAK,IAAI1R,EAAI,EAAGA,EAAI0R,EAAYzR,OAAQD,IACxC,CACI,IAAIoI,EAAasJ,EAAY1R,GAEzBiT,EAAQ7K,EAAW6K,MAEnBF,EAAQ,EACRC,EAAS,EAET5K,EAAW2K,OAEXA,EAAQ3K,EAAW2K,MACnBC,EAAS5K,EAAW4K,QAEfC,IAELF,EAAQE,EAAMC,UACdF,EAASC,EAAME,YAGK,cAApB/K,EAAW9G,MAAmC,IAAVyR,GAA0B,IAAXC,EAMzC,IAAVD,GAA0B,IAAXC,IAEf5K,EAAW3J,MAAQ7C,EAAwBwM,EAAY,IAAInD,EAAU,EAAG,EAAG8N,EAAOC,GAASJ,GAE3FxV,KAAKmU,kBAAkBnJ,IARvBmK,QAAQC,KAAK,yEAYrB,OAAOpV,MAmBXgW,oBAAqB,SAAU1B,EAAalF,EAAGC,EAAGsG,EAAOC,EAAQJ,QAE5CnI,IAAbmI,IAA0BA,EAAW1N,GAEzC,IAAI2N,EAAQ,IAAI5N,EAAUuH,EAAGC,EAAGsG,EAAOC,GAEvC,OAAO5V,KAAK8N,WAAWwG,EAAamB,EAAOD,IAqB/CS,mBAAoB,SAAU3B,EAAa4B,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIf,QAE9CnI,IAAbmI,IAA0BA,EAAWvN,GAEzC,IAAIwN,EAAQ,IAAIzN,EAASkO,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,GAE7C,OAAOvW,KAAK8N,WAAWwG,EAAamB,EAAOD,IAoC/CgB,YAAa,SAAUxL,EAAYyL,QAEjBpJ,IAAVoJ,IAAuBA,EAAQ,OAEnC,IAAIpV,EAAQ2J,EAAW3J,MAEvB,IAAKA,IAAUA,EAAMkM,QAEjB,OAAOvN,KAGX,IAAIyV,EAAQpU,EAAMkM,QACdmJ,EAAYjB,EAAMvR,KAClByS,EAAQtV,EAAMuV,aACdC,EAAU7W,KAAKkI,QAAQ4O,IACvBC,EAAa/W,KAAKkI,QAAQ6O,WAE1BJ,IAEAI,EAAWC,OAAOL,GAElBA,EAAMhV,UAENgV,EAAQ,MAGZ,IAAIM,EAAU,EACVC,EAAU,EACd,OAAQR,GAEJ,KAAKhP,EAAWjC,OACZkR,EAAQE,EAAQM,IAAI,EAAG,EAAG1B,EAAMF,QAChC0B,EAAUxB,EAAMrG,EAAIqG,EAAMF,OAC1B2B,EAAUzB,EAAMpG,EAAIoG,EAAMF,OAC1B,MAEJ,KAAK7N,EAAW0P,QACZT,EAAQE,EAAQQ,QAAQ,EAAG,EAAG5B,EAAME,MAAOF,EAAMG,QACjDqB,EAAUxB,EAAMrG,EAAIqG,EAAME,MAAQ,EAClCuB,EAAUzB,EAAMpG,EAAIoG,EAAMG,OAAS,EACnC,MAEJ,KAAKlO,EAAW4P,KACZX,EAAQE,EAAQU,KAAK,EAAG,EAAG9B,EAAMS,GAAIT,EAAMU,GAAIV,EAAMW,GAAIX,EAAMY,IAC/D,MAEJ,KAAK3O,EAAW8P,QACZb,EAAQE,EAAQY,QAAQ,EAAG,EAAGhC,EAAMiC,QACpC,MAEJ,KAAKhQ,EAAWiQ,UACZhB,EAAQE,EAAQe,UAAU,EAAG,EAAGnC,EAAME,MAAOF,EAAMG,QACnDqB,EAAUxB,EAAMrG,EAChB8H,EAAUzB,EAAMpG,EAChB,MAEJ,KAAK3H,EAAW/B,SACZgR,EAAQE,EAAQgB,SAAS,EAAG,EAAGpC,EAAMS,GAAIT,EAAMU,GAAIV,EAAMW,GAAIX,EAAMY,GAAIZ,EAAMa,GAAIb,EAAMc,IA2C/F,OAvCII,IAEAA,EAAMmB,UAAW,EAEjBnB,EAAMtM,UAAY,WAEdsM,EAAMoB,eAAe,EAAI/M,EAAWgN,MAAOvB,GAE3CE,EAAMsB,iBAAiBjN,EAAWgH,eAAgBhH,EAAWiH,gBAE7D,IAAI7C,EAAIpE,EAAWoE,EACfC,EAAIrE,EAAWqE,EACfgC,EAAWrG,EAAWqG,SACtBO,EAAS5G,EAAW4G,OACpBC,EAAS7G,EAAW6G,OAExB,GAAI7G,EAAWkG,gBACf,CACI,IAAIgH,EAASlN,EAAWmN,0BAExB/I,EAAI8I,EAAOE,GACX/I,EAAI6I,EAAOG,GACXhH,EAAW6G,EAAO7G,SAClBO,EAASsG,EAAOtG,OAChBC,EAASqG,EAAOrG,OAGpB8E,EAAM2B,YAAYjH,GAClBsF,EAAM4B,SAAS3G,EAAQC,GACvB8E,EAAM6B,YAAYpJ,EAAI6H,EAAS5H,EAAI6H,GACnCP,EAAM8B,gBAAgBzN,EAAW0N,cAAe1N,EAAW2N,eAC3DhC,EAAMiC,SAAS5N,EAAW6N,QAG9B9B,EAAWD,IAAIH,GAEftV,EAAMuV,aAAeD,GAGlB3W,MAeX8Y,YAAa,SAAU9N,GAEnB,IAAI3J,EAAQ2J,EAAW3J,MAEvB,GAAIA,GAASA,EAAMuV,aACnB,CACI,IAAID,EAAQtV,EAAMuV,aAElB5W,KAAKkI,QAAQ6O,WAAWC,OAAOL,GAE/BA,EAAMhV,UAENN,EAAMuV,aAAe,KAGzB,OAAO5W,MAkBX+Y,cAAe,WAEX,OAAO/Y,KAAKgZ,YAAY,IAc5BC,cAAe,WAEX,OAAOjZ,KAAKgZ,aAAa,IAc7BA,YAAa,SAAUzE,GAKnB,OAHAvU,KAAKyI,SAAW8L,EAChBvU,KAAK0I,WAAa,EAEX1I,MAeXkZ,iBAAkB,SAAU3E,GAIxB,OAFAvU,KAAKmI,QAAQgR,cAAgB5E,EAEtBvU,MAgBXoZ,WAAY,SAAU7E,GAIlB,OAFAvU,KAAKwI,QAAU+L,EAERvU,MAeX8L,gBAAiB,SAAUwI,EAAa1I,GAEpC,GAAI0I,EAAYzR,OAAS,EAErB,OAAOyR,EAGX,IAAI5E,EAAO9D,EAAQqC,OAAOoL,WAE1B,OAAO/E,EAAYgF,MAAK,SAAUC,EAAQC,GAEtC,OAAO9J,EAAKzE,QAAQuO,GAAU9J,EAAKzE,QAAQsO,OAenDxN,cAAe,SAAUuI,GAErB,OAAIA,EAAYzR,OAAS,EAEdyR,GAGXtU,KAAKC,MAAME,IAAIsZ,YAERnF,EAAYgF,KAAKtZ,KAAK0Z,oBAAoBC,KAAK3Z,SAkB1D0Z,oBAAqB,SAAUH,EAAQC,GAEnC,GAAKD,EAAOrI,iBAAoBsI,EAAOtI,gBAKlC,IAAIqI,EAAOrI,kBAAoBsI,EAAOtI,gBAGvC,OAAOsI,EAAOtI,gBAAgB0I,SAASJ,GAAUD,EAAOrI,gBAAgB0I,SAASL,GAEhF,GAAIA,EAAOrI,kBAAoBsI,EAGhC,OAAQ,EAEP,GAAIA,EAAOtI,kBAAoBqI,EAGhC,OAAO,EASP,IAJA,IAAIM,EAAQN,EAAOO,eACfC,EAAQP,EAAOM,eACf/V,EAAMyN,KAAKwI,IAAIH,EAAMhX,OAAQkX,EAAMlX,QAE9BD,EAAI,EAAGA,EAAImB,EAAKnB,IACzB,CACI,IAAIqX,EAASJ,EAAMjX,GACfsX,EAASH,EAAMnX,GAEnB,GAAIqX,IAAWC,EAQX,OAAOA,EAASD,EAIxB,OAAOF,EAAMlX,OAASgX,EAAMhX,OAzC5B,OAAO7C,KAAKoI,YAAYwR,SAASJ,GAAUxZ,KAAKoI,YAAYwR,SAASL,IA4D7EzQ,gBAAiB,WAIb,OAFA9I,KAAKmI,QAAQgS,WAAY,EAElBna,MAqBXoa,WAAY,SAAUC,GAElB,OAAOra,KAAKmI,QAAQiS,WAAWC,IA8BnCC,iBAAkB,SAAUvF,GAIxB,OAFA/U,KAAKmI,QAAQmS,iBAAiBvF,GAEvB/U,MAUX+J,aAAc,WAEV/J,KAAKI,QAAUJ,KAAKE,SAASqa,sBAUjCpQ,mBAAoB,WAEXnK,KAAKE,SAASqa,uBAEfva,KAAKI,SAAU,IAWvB6J,cAAe,WAEXjK,KAAKI,QAAUJ,KAAKE,SAASqa,sBAYjCxY,SAAU,WAGN/B,KAAKa,aAAasD,KAAK1F,EAAOqD,UAE9B9B,KAAKiJ,MAAMpG,OAAS,EACpB7C,KAAKmJ,MAAMtG,OAAS,EACpB7C,KAAKsJ,WAAWzG,OAAS,EACzB7C,KAAKqJ,gBAAgBxG,OAAS,EAC9B7C,KAAKoJ,kBAAkBvG,OAAS,EAChC7C,KAAKwJ,WAAW3G,OAAS,EAEzB,IAAK,IAAID,EAAI,EAAGA,EAAI,GAAIA,IAEpB5C,KAAKuJ,MAAM3G,GAAK,GAChB5C,KAAKyJ,MAAM7G,GAAK,GAGpB5C,KAAK8C,qBAEL,IAAIqF,EAAUnI,KAAKmI,QAEnBA,EAAQyG,OAAO4L,MAAMzF,OAAS5M,EAAQsS,cAEtC,IAAI5Q,EAAe7J,KAAKkI,QAAQ0B,OAEhCC,EAAalH,IAAIoF,EAAY+B,iBAAkB9J,KAAK+J,aAAc/J,MAClE6J,EAAalH,IAAIoF,EAAYiC,eAAgBhK,KAAKiK,cAAejK,MACjE6J,EAAalH,IAAIoF,EAAYmC,oBAAqBlK,KAAKmK,mBAAoBnK,MAC3E6J,EAAalH,IAAIoF,EAAYqC,WAAYpK,KAAKqK,UAAWrK,MAEzDmI,EAAQyB,OAAOjH,IAAIlE,EAAO6L,SAAUtK,KAAKuK,UAAWvK,MACpDmI,EAAQyB,OAAOjH,IAAIlE,EAAO+L,UAAWxK,KAAKyK,WAAYzK,MAEtD6J,EAAalH,IAAIoF,EAAYjG,SAAU9B,KAAK+B,SAAU/B,OAY1D2B,QAAS,WAEL3B,KAAK+B,WAGL/B,KAAKa,aAAasD,KAAK1F,EAAOiD,SAE9B1B,KAAKa,aAAaiC,qBAElB9C,KAAKC,MAAME,IAAIyJ,OAAOjH,IAAIoF,EAAY7G,MAAOlB,KAAKmB,MAAOnB,MAEzDA,KAAKC,MAAQ,KACbD,KAAKqI,QAAU,KACfrI,KAAKmI,QAAU,KACfnI,KAAK4J,OAAS,KACd5J,KAAKuI,MAAQ,MAYjB6G,EAAG,CAEC7K,IAAK,WAED,OAAOvE,KAAKmI,QAAQuS,cAActL,IAc1CC,EAAG,CAEC9K,IAAK,WAED,OAAOvE,KAAKmI,QAAQuS,cAAcrL,IAa1CsL,OAAQ,CAEJpW,IAAK,WAED,OAAOvE,KAAKmI,QAAQwS,SAe5BC,aAAc,CAEVrW,IAAK,WAED,OAAOvE,KAAKmI,QAAQyS,eAa5BF,cAAe,CAEXnW,IAAK,WAED,OAAOvE,KAAKmI,QAAQuS,gBAc5BG,SAAU,CAENtW,IAAK,WAED,OAAOvE,KAAKmI,QAAQoD,SAAS,KAcrCuP,SAAU,CAENvW,IAAK,WAED,OAAOvE,KAAKmI,QAAQoD,SAAS,KAcrCwP,SAAU,CAENxW,IAAK,WAED,OAAOvE,KAAKmI,QAAQoD,SAAS,KAcrCyP,SAAU,CAENzW,IAAK,WAED,OAAOvE,KAAKmI,QAAQoD,SAAS,KAcrC0P,SAAU,CAEN1W,IAAK,WAED,OAAOvE,KAAKmI,QAAQoD,SAAS,KAcrC2P,SAAU,CAEN3W,IAAK,WAED,OAAOvE,KAAKmI,QAAQoD,SAAS,KAcrC4P,SAAU,CAEN5W,IAAK,WAED,OAAOvE,KAAKmI,QAAQoD,SAAS,KAcrC6P,SAAU,CAEN7W,IAAK,WAED,OAAOvE,KAAKmI,QAAQoD,SAAS,KAcrC8P,SAAU,CAEN9W,IAAK,WAED,OAAOvE,KAAKmI,QAAQoD,SAAS,KAcrC+P,UAAW,CAEP/W,IAAK,WAED,OAAOvE,KAAKmI,QAAQoD,SAAS,QAOzC3D,EAAYhD,SAAS,cAAehG,EAAa,SAEjDM,EAAOC,QAAUP,G,qBC1nGjBM,EAAOC,QAAU,CAEbV,OAAQ,EAAQ,KAEhB8c,gBAAiB,EAAQ,KACzBC,eAAgB,EAAQ,MAExBC,IAAK,EAAQ,KACbC,SAAU,EAAQ,KAElBC,SAAU,EAAQ,KAElBC,gBAAiB,EAAQ,KACzBC,gBAAiB,EAAQ,KACzBC,cAAe,EAAQ,KAEvBC,SAAU,EAAQ,MAClBC,OAAQ,EAAQ,MAChBC,aAAc,EAAQ,MACtBC,WAAY,EAAQ,Q,mBCAxBhd,EAAOC,QAAU,W,mBCPjBD,EAAOC,QAAU,S,mBCKjBD,EAAOC,QAAU,iB,mBCAjBD,EAAOC,QAAU,Q,mBCKjBD,EAAOC,QAAU,Y,mBCPjBD,EAAOC,QAAU,U,mBCEjBD,EAAOC,QAAU,M,qBCrBjB,IAAIK,EAAQ,EAAQ,GAChBC,EAAe,EAAQ,IACvBhB,EAAS,EAAQ,KACjB0d,EAAa,EAAQ,IACrBzc,EAAW,EAAQ,GACnBC,EAAc,EAAQ,IACtBd,EAAmB,EAAQ,KAC3B4c,EAAM,EAAQ,KACdC,EAAW,EAAQ,KACnBC,EAAW,EAAQ,KACnBS,EAAS,EAAQ,MACjBrU,EAAc,EAAQ,IACtBsU,EAAY,EAAQ,IA+CpBb,EAAiB,IAAIhc,EAAM,CAE3BI,QAASH,EAETI,WAEA,SAAyBC,GAErBL,EAAaM,KAAKC,MASlBA,KAAKoB,KAAOtB,EAAiBoI,QAAQ9G,KASrCpB,KAAKC,MAAQH,EAAiBG,MAS9BD,KAAKE,SAAWF,KAAKC,MAAME,IAAID,SAS/BF,KAAKF,iBAAmBA,EASxBE,KAAKmI,QAAUrI,EAAiBqI,QAAQmU,SAWxCtc,KAAKI,SAAU,EASfJ,KAAKuc,KAAO,GASZvc,KAAKwc,OAAS,GAUdxc,KAAKyc,SAAW,KAUhBzc,KAAK0c,SAAW,EAUhB1c,KAAK2c,SAAW,KAEhB7c,EAAiBe,aAAaC,KAAKnB,EAAYoB,KAAMf,KAAKgB,KAAMhB,MAChEF,EAAiBe,aAAaI,GAAGtB,EAAYuB,MAAOlB,KAAKmB,MAAOnB,OAWpEgB,KAAM,WAEF,IAAId,EAAWF,KAAKE,SAASmB,MAE7BrB,KAAKI,QAAUV,EAASQ,EAAU,YAAY,GAE9C,IAAI0c,EAAWld,EAASQ,EAAU,mBAAoB,MAElD0c,GAEA5c,KAAK6c,YAAYD,GAGrB5c,KAAKF,iBAAiBe,aAAaC,KAAKnB,EAAY+B,QAAS1B,KAAK2B,QAAS3B,OAY/EmB,MAAO,WAEHnB,KAAKF,iBAAiBqI,QAAQyB,OAAO3I,GAAGtB,EAAYmd,gBAAiB9c,KAAKwC,OAAQxC,MAElFA,KAAKF,iBAAiBe,aAAaC,KAAKnB,EAAYmC,SAAU9B,KAAK+B,SAAU/B,MAE7EA,KAAKoB,KAAKwI,OAAO3I,GAAGkb,EAAWY,KAAM/c,KAAKgd,UAAWhd,MAErDA,KAAKC,MAAME,IAAIyJ,OAAO3I,GAAG8G,EAAYkV,MAAOjd,KAAKgd,UAAWhd,MAC5DA,KAAKC,MAAME,IAAIyJ,OAAO3I,GAAG8G,EAAYmV,MAAOld,KAAKgd,UAAWhd,OAWhEgC,SAAU,WAEN,OAAQhC,KAAKI,SAAWJ,KAAKC,MAAME,IAAI6B,YA0C3Cmb,WAAY,SAAUC,GAIlB,OAFApd,KAAKmI,QAAQgV,WAAWC,GAEjBpd,MAsCXqd,cAAe,SAAUD,GAIrB,OAFApd,KAAKmI,QAAQkV,cAAcD,GAEpBpd,MAWXsd,YAAa,WAET,OAAOtd,KAAKmI,QAAQyU,UAYxBW,oBAAqB,WAIjB,OAFAvd,KAAKmI,QAAQqV,gBAAiB,EAEvBxd,MAYXyd,qBAAsB,WAIlB,OAFAzd,KAAKmI,QAAQqV,gBAAiB,EAEvBxd,MAaX0d,cAAe,WAIX,OAFA1d,KAAKmI,QAAQuV,gBAEN1d,MAWX2d,iBAAkB,WAEd,OAAO3d,KAAK4d,QAAQ,CAChBC,GAAInC,EAAS1W,GACb8Y,KAAMpC,EAASzW,KACf8Y,KAAMrC,EAASxW,KACf8Y,MAAOtC,EAASvW,MAChB8Y,MAAOvC,EAASwC,MAChBC,MAAOzC,EAAS0C,SAkCxBR,QAAS,SAAUrB,EAAM8B,EAAeC,QAEdjR,IAAlBgR,IAA+BA,GAAgB,QAC9BhR,IAAjBiR,IAA8BA,GAAe,GAEjD,IAAIC,EAAS,GAEb,GAAoB,iBAAThC,EACX,CACIA,EAAOA,EAAKiC,MAAM,KAElB,IAAK,IAAI5b,EAAI,EAAGA,EAAI2Z,EAAK1Z,OAAQD,IACjC,CACI,IAAI6b,EAAalC,EAAK3Z,GAAG8b,OAErBD,IAEAF,EAAOE,GAAcze,KAAK2e,OAAOF,EAAYJ,EAAeC,UAMpE,IAAK,IAAIM,KAAOrC,EAEZgC,EAAOK,GAAO5e,KAAK2e,OAAOpC,EAAKqC,GAAMP,EAAeC,GAI5D,OAAOC,GAmBXI,OAAQ,SAAUC,EAAKP,EAAeC,QAEZjR,IAAlBgR,IAA+BA,GAAgB,QAC9BhR,IAAjBiR,IAA8BA,GAAe,GAEjD,IAAI/B,EAAOvc,KAAKuc,KAEhB,GAAIqC,aAAenD,EACnB,CACI,IAAIoD,EAAMtC,EAAKtR,QAAQ2T,GAkBvB,OAhBIC,GAAO,EAEPtC,EAAKsC,GAAOD,EAIZrC,EAAKqC,EAAIE,SAAWF,EAGpBP,GAEAre,KAAKmd,WAAWyB,EAAIE,SAGxBF,EAAIG,gBAAgBT,GAEbM,EAoBX,MAjBmB,iBAARA,IAEPA,EAAMlD,EAASkD,EAAII,gBAGlBzC,EAAKqC,KAENrC,EAAKqC,GAAO,IAAInD,EAAIzb,KAAM4e,GAEtBP,GAEAre,KAAKmd,WAAWyB,GAGpBrC,EAAKqC,GAAKG,gBAAgBT,IAGvB/B,EAAKqC,IAgBhBK,UAAW,SAAUL,EAAKjd,QAEN0L,IAAZ1L,IAAyBA,GAAU,GAEvC,IACIud,EADA3C,EAAOvc,KAAKuc,KAGhB,GAAIqC,aAAenD,EACnB,CACI,IAAIoD,EAAMtC,EAAKtR,QAAQ2T,GAEnBC,GAAO,IAEPK,EAAMlf,KAAKuc,KAAKsC,GAEhB7e,KAAKuc,KAAKsC,QAAOxR,OAGD,iBAARuR,IAEZA,EAAMlD,EAASkD,EAAII,gBAoBvB,OAjBIzC,EAAKqC,KAELM,EAAM3C,EAAKqC,GAEXrC,EAAKqC,QAAOvR,GAGZ6R,IAEAA,EAAIC,OAAS,KAETxd,GAEAud,EAAIvd,WAIL3B,MAaXof,cAAe,SAAUzd,GAIrB,IAFA,IAAI4a,EAAOvc,KAAKuc,KAEP3Z,EAAI,EAAGA,EAAI2Z,EAAK1Z,OAAQD,IACjC,CACI,IAAIgc,EAAMrC,EAAK3Z,GAEXgc,IAEArC,EAAK3Z,QAAKyK,EAEN1L,GAEAid,EAAIjd,WAKhB,OAAO3B,MAwCXqf,YAAa,SAAU9C,EAAMjb,GAEzB,OAAO,IAAIqa,EAAS3b,KAAMuc,EAAMjb,IAqBpCge,UAAW,SAAUV,EAAKW,GAItB,QAFiBlS,IAAbkS,IAA0BA,EAAW,GAErCvf,KAAKI,SAAWwe,EAAIY,OACxB,CACI,IAAIC,EAAIpD,EAAUrc,KAAKqL,KAAOuT,EAAIc,SAAUH,GAE5C,GAAIE,EAAIb,EAAIe,MAIR,OAFAf,EAAIe,MAAQF,GAEL,EAIf,OAAO,GAUXjd,OAAQ,WAEJ,IAAIjC,EAAQP,KAAKmI,QAAQ5H,MACrBwD,EAAMxD,EAAMsC,OAEhB,GAAK7C,KAAKgC,YAAsB,IAAR+B,EAQxB,IAHA,IAAIwY,EAAOvc,KAAKuc,KAGP3Z,EAAI,EAAGA,EAAImB,EAAKnB,IACzB,CACI,IAAIT,EAAQ5B,EAAMqC,GACdgd,EAAOzd,EAAM2c,QACbF,EAAMrC,EAAKqD,GACXC,GAAS,OAGWxS,IAApBlL,EAAMyG,YAGNzG,EAAMyG,UAAY,EAGlBzG,EAAM2d,yBAA2B,WAE7B3d,EAAMyG,UAAY,GAItBzG,EAAM2G,gBAAkB,WAEpB3G,EAAMyG,WAAa,KAIF,IAArBzG,EAAMyG,YAONgX,IAAS5f,KAAKyc,UAAYta,EAAMuI,YAAc1K,KAAK0c,UAAYva,EAAM+B,OAASlE,KAAK2c,WAMvF3c,KAAKyc,SAAWmD,EAChB5f,KAAK0c,SAAWva,EAAMuI,UACtB1K,KAAK2c,SAAWxa,EAAM+B,KAEH,YAAf/B,EAAM+B,MAGF0a,IAEAiB,EAASjB,EAAIY,OAEbZ,EAAImB,OAAO5d,IAGVA,EAAMyG,WAAegW,GAAQiB,IAE1BzD,EAAOwD,IAEP5f,KAAKmE,KAAK1F,EAAOuhB,SAAW5D,EAAOwD,GAAOzd,GAGzCA,EAAMyG,WAEP5I,KAAKmE,KAAK1F,EAAOwhB,aAAc9d,MAOnCyc,GAEAA,EAAIsB,KAAK/d,GAGRA,EAAMyG,YAEHwT,EAAOwD,IAEP5f,KAAKmE,KAAK1F,EAAO0hB,OAAS/D,EAAOwD,GAAOzd,GAGvCA,EAAMyG,WAEP5I,KAAKmE,KAAK1F,EAAO2hB,WAAYje,KAMjB,IAApBA,EAAMyG,YAENzG,EAAMyG,UAAY,OAkB9BoU,UAAW,WAIP,IAFA,IAAIT,EAAOvc,KAAKuc,KAEP3Z,EAAI,EAAGA,EAAI2Z,EAAK1Z,OAAQD,IAGzB2Z,EAAK3Z,IAEL2Z,EAAK3Z,GAAGyd,QAIhB,OAAOrgB,MAcX+B,SAAU,WAEN/B,KAAKof,eAAc,GACnBpf,KAAK8C,qBAEL9C,KAAKF,iBAAiBqI,QAAQyB,OAAOjH,IAAIhD,EAAYmd,gBAAiB9c,KAAKwC,OAAQxC,MAEnFA,KAAKoB,KAAKwI,OAAOjH,IAAIwZ,EAAWY,KAAM/c,KAAKgd,WAE3Chd,KAAKC,MAAME,IAAIyJ,OAAOjH,IAAIoF,EAAYkV,MAAOjd,KAAKgd,UAAWhd,MAC7DA,KAAKC,MAAME,IAAIyJ,OAAOjH,IAAIoF,EAAYmV,MAAOld,KAAKgd,UAAWhd,MAE7DA,KAAKO,MAAQ,IAUjBoB,QAAS,WAEL3B,KAAK+B,WAIL,IAFA,IAAIwa,EAAOvc,KAAKuc,KAEP3Z,EAAI,EAAGA,EAAI2Z,EAAK1Z,OAAQD,IAGzB2Z,EAAK3Z,IAEL2Z,EAAK3Z,GAAGjB,UAIhB3B,KAAKuc,KAAO,GACZvc,KAAKwc,OAAS,GACdxc,KAAKO,MAAQ,GAEbP,KAAKC,MAAQ,KACbD,KAAKE,SAAW,KAChBF,KAAKF,iBAAmB,KACxBE,KAAKmI,QAAU,MAWnBkD,KAAM,CAEF9G,IAAK,WAED,OAAOvE,KAAKF,iBAAiBqI,QAAQkD,SAejDxM,EAAiB+F,SAAS,iBAAkB4W,EAAgB,WAAY,WAAY,iBAEpFtc,EAAOC,QAAUqc,G,qBCp6BjB,IAAIE,EAAW,EAAQ,KAEnBU,EAAS,GAEb,IAAK,IAAIwC,KAAOlD,EAEZU,EAAOV,EAASkD,IAAQA,EAG5B1f,EAAOC,QAAUid,G,mBCoBjBld,EAAOC,QAdQ,SAAUyf,GAErB,QAAIA,EAAI0B,YAEJ1B,EAAI0B,WAAY,GAET,K,mBCQfphB,EAAOC,QAdM,SAAUyf,GAEnB,QAAIA,EAAI2B,UAEJ3B,EAAI2B,SAAU,GAEP,K,mBCAfrhB,EAAOC,QATY,SAAUyf,EAAKW,QAEblS,IAAbkS,IAA0BA,EAAW,IAEzC,IAAIxU,EAAU6T,EAAIO,OAAO/d,KAAKqP,KAAKpF,KAAOuT,EAAIc,SAE9C,OAAQd,EAAIY,QAAUzU,EAAUwU,I,mBCGpCrgB,EAAOC,QATU,SAAUyf,EAAKW,QAEXlS,IAAbkS,IAA0BA,EAAW,IAEzC,IAAIxU,EAAU6T,EAAIO,OAAO/d,KAAKqP,KAAKpF,KAAOuT,EAAI4B,OAE9C,OAAQ5B,EAAI6B,MAAQ1V,EAAUwU,I,qBCblCrgB,EAAOC,QAAU,CAEbuhB,aAAc,EAAQ,O,qBCF1BxhB,EAAOC,QAAU,CAEbwhB,aAAc,EAAQ,O,oBCP1B,IAAIjhB,EAAW,EAAQ,GAInBkhB,EAAe,GAMf/hB,EAAmB,CAkBvBA,SAA4B,SAAU+f,EAAKO,EAAQ0B,EAASC,EAAaC,GAErEH,EAAahC,GAAO,CAAEO,OAAQA,EAAQ0B,QAASA,EAASC,YAAaA,EAAaC,UAAWA,IAcjGliB,UAA6B,SAAU+f,GAEnC,OAAOgC,EAAahC,IAYxB/f,QAA2B,SAAUwB,GAEjC,IAAIF,EAAME,EAAOJ,MAAME,IACnBD,EAAWC,EAAID,SAASmB,MACxBC,EAASnB,EAAIiB,KAAKE,OAEtB,IAAK,IAAIsd,KAAOgC,EAChB,CACI,IAAII,EAASJ,EAAahC,GAAKO,OAC3B0B,EAAUD,EAAahC,GAAKiC,QAC5BC,EAAcF,EAAahC,GAAKkC,YAChCC,EAAYH,EAAahC,GAAKmC,UAE9BrhB,EAASQ,EAAU4gB,EAAaxf,EAAOyf,MAEvC1gB,EAAOwgB,GAAW,IAAIG,EAAO3gB,MAczCxB,OAA0B,SAAU+f,GAE5BgC,EAAaK,eAAerC,WAErBgC,EAAahC,KAI5B1f,EAAOC,QAAUN,G,oBC3FjBK,EAAOC,QAAU,CAEb8gB,aAAc,EAAQ,MACtBG,WAAY,EAAQ,MACpBc,YAAa,EAAQ,MACrBjc,KAAM,EAAQ,MACd+a,SAAU,EAAQ,MAClBG,OAAQ,EAAQ,MAChBnb,GAAI,EAAQ,Q,oBCRhB9F,EAAOC,QAAU,CAEbgiB,YAAa,EAAQ,MACrBC,UAAW,EAAQ,MACnBhd,UAAW,EAAQ,MACnBC,aAAc,EAAQ,MACtBgd,oBAAqB,EAAQ,MAC7BC,kBAAmB,EAAQ,Q,kBCY/BpiB,EAAOC,QAVyB,SAAUyV,EAAgBD,GAEtD,OAAO,SAAUpH,EAAS6B,EAAGC,EAAGrE,GAE5B,IAAIuW,EAAQ3M,EAAe4M,cAAcpS,EAAGC,EAAGrE,EAAWyW,QAAQ7C,IAAK5T,EAAW6K,MAAM6L,MAExF,OAAQH,GAASA,GAAS5M,K,kBCuClCzV,EAAOC,QA1CuB,SAAU6L,EAAYuC,EAASC,GAEzD,MAAO,CAEHxC,WAAYA,EAEZ5K,SAAS,EACTuhB,eAAe,EACfnR,WAAW,EACX3C,UAAU,EACVkH,QAAQ,EAER1U,OAAQ,KAER4N,OAAQ,KAERV,QAASA,EACTC,gBAAiBA,EACjBoJ,aAAc,KAGd1B,eAAe,EAEf1G,OAAQ,EACRC,OAAQ,EAKRkB,UAAW,EAEXC,WAAY,EACZC,WAAY,EACZC,iBAAkB,EAClBE,iBAAkB,EAElBE,MAAO,EACPC,MAAO,K,oBCrDf,IAeI/Q,EAAO,IAfC,EAAQ,GAeT,CAAU,CAEjBS,WAEA,SAAemD,EAAKQ,GAShBxD,KAAKgD,IAAMA,EASXhD,KAAK4J,OAAS5G,EAAI4G,OASlB5J,KAAKwD,MAAQA,EAWbxD,KAAKuU,MAAQ,EAUbvU,KAAK4hB,UAAY,IAarBpf,OAAQ,SAAU+R,GAEdvU,KAAKuU,MAAQA,GAWjBsN,SAAU,WAEN,OAAQrQ,KAAKsQ,IAAI9hB,KAAKuU,OAASvU,KAAK4hB,UAAa,EAAI5hB,KAAKuU,OAS9D5S,QAAS,WAEL3B,KAAKgD,IAAM,KACXhD,KAAK4J,OAAS,QAKtB1K,EAAOC,QAAUC,G,oBChHjB,IAAII,EAAQ,EAAQ,GAChBf,EAAS,EAAQ,KAejBY,EAAS,IAAIG,EAAM,CAEnBK,WAEA,SAAiBmD,EAAKQ,GASlBxD,KAAKgD,IAAMA,EASXhD,KAAK4J,OAAS5G,EAAImF,QASlBnI,KAAKwD,MAAQA,EAUbxD,KAAKuU,MAAQ,EAWbvU,KAAK4hB,UAAY,EAUjB5hB,KAAK+hB,SAAU,GAiBnBvf,OAAQ,SAAU+R,GAEdvU,KAAKuU,MAAQA,EAEb,IAAIvR,EAAMhD,KAAKgD,IACXQ,EAAQxD,KAAKwD,MAEb+Q,GAASvU,KAAK4hB,UAET5hB,KAAK+hB,UAEN/hB,KAAK+hB,SAAU,EACf/hB,KAAK4J,OAAOzF,KAAK1F,EAAO0iB,YAAane,EAAKhD,KAAMuU,GAChDvU,KAAKgD,IAAImB,KAAK1F,EAAO4iB,oBAAqB7d,EAAO+Q,EAAOvU,OAGvDA,KAAK+hB,UAEV/hB,KAAK+hB,SAAU,EACf/hB,KAAK4J,OAAOzF,KAAK1F,EAAO2iB,UAAWpe,EAAKhD,KAAMuU,GAC9CvU,KAAKgD,IAAImB,KAAK1F,EAAO6iB,kBAAmB9d,EAAO+Q,EAAOvU,QAU9D2B,QAAS,WAEL3B,KAAKgD,IAAM,KACXhD,KAAK4J,OAAS,QAKtB1K,EAAOC,QAAUE,G,oBCrIjB,IAAID,EAAO,EAAQ,KACfC,EAAS,EAAQ,KACjBG,EAAQ,EAAQ,GAChBC,EAAe,EAAQ,IACvBuiB,EAAU,EAAQ,GAiBlBtjB,EAAU,IAAIc,EAAM,CAEpBI,QAASH,EAETI,WAEA,SAAkBsI,EAASnF,GAEvBvD,EAAaM,KAAKC,MASlBA,KAAKmI,QAAUA,EASfnI,KAAKgD,IAAMA,EAeXhD,KAAKuD,GAAKP,EAAIO,GAWdvD,KAAKwD,MAAQR,EAAIQ,MAIjB,IAFA,IAAIye,EAAU,GAELrf,EAAI,EAAGA,EAAII,EAAIif,QAAQpf,OAAQD,IAEpCqf,EAAQ5f,KAAK,IAAIhD,EAAOW,KAAM4C,IAUlC5C,KAAKiiB,QAAUA,EAEf,IAAIC,EAAO,GAEX,IAAKtf,EAAI,EAAGA,EAAII,EAAIkf,KAAKrf,OAAQD,IAE7Bsf,EAAK7f,KAAK,IAAIjD,EAAKY,KAAM4C,IAU7B5C,KAAKkiB,KAAOA,EAWZliB,KAAKmiB,UAAYnf,EAAIof,kBAIrB,IAAIC,EAAY,CAAE9N,MAAO,EAAGwN,SAAS,GAUrC/hB,KAAKsiB,QAAWL,EAAQ,IAAOA,EAAQ,IAAMI,EAU7CriB,KAAKuiB,SAAYN,EAAQ,IAAOA,EAAQ,IAAMI,EAU9CriB,KAAKwiB,OAAUP,EAAQ,IAAOA,EAAQ,IAAMI,EAU5CriB,KAAKyiB,UAAaR,EAAQ,IAAOA,EAAQ,IAAMI,EAU/CriB,KAAK0iB,QAAWT,EAAQ,GAAMA,EAAQ,GAAKI,EAU3CriB,KAAK2iB,SAAYV,EAAQ,GAAMA,EAAQ,GAAKI,EAU5CriB,KAAK4iB,OAAUX,EAAQ,GAAMA,EAAQ,GAAKI,EAU1CriB,KAAK6iB,UAAaZ,EAAQ,GAAMA,EAAQ,GAAKI,EAU7CriB,KAAK8iB,WAAcb,EAAQ,GAAMA,EAAQ,GAAKI,EAU9CriB,KAAK+iB,cAAiBd,EAAQ,GAAMA,EAAQ,GAAKI,EAUjDriB,KAAKgjB,YAAef,EAAQ,GAAMA,EAAQ,GAAKI,EAU/CriB,KAAKijB,eAAkBhB,EAAQ,GAAMA,EAAQ,GAAKI,EAElD,IAAIa,EAAU,CAAE3O,MAAO,GAUvBvU,KAAKmjB,WAAcjB,EAAK,GAAMA,EAAK,GAAKgB,EAUxCljB,KAAKojB,WAAclB,EAAK,GAAMA,EAAK,GAAKgB,EAUxCljB,KAAKqjB,YAAenB,EAAK,GAAMA,EAAK,GAAKgB,EAUzCljB,KAAKsjB,YAAepB,EAAK,GAAMA,EAAK,GAAKgB,EAazCljB,KAAKujB,UAAY,IAAIvB,EAarBhiB,KAAKwjB,WAAa,IAAIxB,EAUtBhiB,KAAKyjB,SAAWC,YAAYhT,OAWhCiT,aAAc,WAEV,OAAO3jB,KAAKkiB,KAAKrf,QAerB+gB,aAAc,SAAUpgB,GAEpB,OAAOxD,KAAKkiB,KAAK1e,GAAOqe,YAY5BgC,iBAAkB,SAAUtP,GAExB,IAAK,IAAI3R,EAAI,EAAGA,EAAI5C,KAAKkiB,KAAKrf,OAAQD,IAElC5C,KAAKkiB,KAAKtf,GAAGgf,UAAYrN,GAYjCuP,eAAgB,WAEZ,OAAO9jB,KAAKiiB,QAAQpf,QAiBxBkhB,eAAgB,SAAUvgB,GAEtB,OAAOxD,KAAKiiB,QAAQze,GAAO+Q,OAc/ByP,aAAc,SAAUxgB,GAEpB,OAAOxD,KAAKiiB,QAAQze,GAAOue,SAW/Bvf,OAAQ,SAAUQ,GAEd,KAAIA,EAAIihB,UAAYjkB,KAAKyjB,UAAzB,CAKA,IAAI7gB,EAIAshB,EAAelkB,KAAKiiB,QACpBkC,EAAiBnhB,EAAIif,QAErBle,EAAMmgB,EAAarhB,OAEvB,IAAKD,EAAI,EAAGA,EAAImB,EAAKnB,IAEjBshB,EAAathB,GAAGJ,OAAO2hB,EAAevhB,GAAG2R,OAK7C,IAAI6P,EAAYpkB,KAAKkiB,KACjBmC,EAAcrhB,EAAIkf,KAItB,IAFAne,EAAMqgB,EAAUvhB,OAEXD,EAAI,EAAGA,EAAImB,EAAKnB,IAEjBwhB,EAAUxhB,GAAGJ,OAAO6hB,EAAYzhB,IAGhCmB,GAAO,IAEP/D,KAAKujB,UAAUe,IAAIF,EAAU,GAAGvC,WAAYuC,EAAU,GAAGvC,YAErD9d,GAAO,GAEP/D,KAAKwjB,WAAWc,IAAIF,EAAU,GAAGvC,WAAYuC,EAAU,GAAGvC,eAWtElgB,QAAS,WAOL,IAAIiB,EAEJ,IAPA5C,KAAK8C,qBAEL9C,KAAKmI,QAAU,KACfnI,KAAKgD,IAAM,KAINJ,EAAI,EAAGA,EAAI5C,KAAKiiB,QAAQpf,OAAQD,IAEjC5C,KAAKiiB,QAAQrf,GAAGjB,UAGpB,IAAKiB,EAAI,EAAGA,EAAI5C,KAAKkiB,KAAKrf,OAAQD,IAE9B5C,KAAKkiB,KAAKtf,GAAGjB,UAGjB3B,KAAKiiB,QAAU,GACfjiB,KAAKkiB,KAAO,IAWhBjf,UAAW,CAEPsB,IAAK,WAED,OAAOvE,KAAKgD,IAAIC,YAYxBghB,UAAW,CAEP1f,IAAK,WAED,OAAOvE,KAAKgD,IAAIihB,YAcxBlG,KAAM,CAEFxZ,IAAK,WAED,OAAOvE,KAAKsiB,QAAQP,UAc5B/D,MAAO,CAEHzZ,IAAK,WAED,OAAOvE,KAAKuiB,SAASR,UAc7BlE,GAAI,CAEAtZ,IAAK,WAED,OAAOvE,KAAKwiB,OAAOT,UAc3BjE,KAAM,CAEFvZ,IAAK,WAED,OAAOvE,KAAKyiB,UAAUV,UAe9Bvb,EAAG,CAECjC,IAAK,WAED,OAAOvE,KAAK6iB,UAAUd,UAe9Btb,EAAG,CAEClC,IAAK,WAED,OAAOvE,KAAK4iB,OAAOb,UAe3Bvc,EAAG,CAECjB,IAAK,WAED,OAAOvE,KAAK0iB,QAAQX,UAe5Bxb,EAAG,CAEChC,IAAK,WAED,OAAOvE,KAAK2iB,SAASZ,UAgB7Bnc,GAAI,CAEArB,IAAK,WAED,OAAOvE,KAAK8iB,WAAWvO,QAgB/BzO,GAAI,CAEAvB,IAAK,WAED,OAAOvE,KAAK+iB,cAAcxO,QAgBlC1O,GAAI,CAEAtB,IAAK,WAED,OAAOvE,KAAKgjB,YAAYzO,QAgBhCxO,GAAI,CAEAxB,IAAK,WAED,OAAOvE,KAAKijB,eAAe1O,UAOvCrV,EAAOC,QAAUT,G,oBCxvBjB,IAAIc,EAAQ,EAAQ,GAChBC,EAAe,EAAQ,IACvBhB,EAAS,EAAQ,KAgBjBgd,EAAM,IAAIjc,EAAM,CAEhBI,QAASH,EAETI,WAEA,SAAcsf,EAAQL,GAElBrf,EAAaM,KAAKC,MASlBA,KAAKmf,OAASA,EASdnf,KAAK8e,QAAUA,EASf9e,KAAKukB,mBAAgBlX,EAUrBrN,KAAKI,SAAU,EAUfJ,KAAKwf,QAAS,EAUdxf,KAAKygB,MAAO,EAUZzgB,KAAKwkB,QAAS,EAUdxkB,KAAKykB,SAAU,EAUfzkB,KAAK0kB,UAAW,EAWhB1kB,KAAK2kB,SAAU,EAUf3kB,KAAK4kB,SAAW,EAUhB5kB,KAAK0f,SAAW,EAYhB1f,KAAKuf,SAAW,EAUhBvf,KAAKwgB,OAAS,EAadxgB,KAAKse,cAAe,EAUpBte,KAAK6kB,QAAU,EAWf7kB,KAAKsgB,WAAY,EAWjBtgB,KAAKugB,SAAU,EAUfvgB,KAAK2f,OAAS,GAclBZ,gBAAiB,SAAUxK,GAIvB,OAFAvU,KAAKse,aAAe/J,EAEbvU,MAaX+f,OAAQ,SAAU5d,GAEdnC,KAAKukB,cAAgBpiB,EAEhBnC,KAAKI,UAKVJ,KAAKwkB,OAASriB,EAAMqiB,OACpBxkB,KAAKykB,QAAUtiB,EAAMsiB,QACrBzkB,KAAK0kB,SAAWviB,EAAMuiB,SACtB1kB,KAAK2kB,QAAUxiB,EAAMwiB,QACrB3kB,KAAK4kB,SAAWziB,EAAMyiB,SAEtB5kB,KAAK6kB,UAEA7kB,KAAKwf,OAWDxf,KAAKse,cAEVte,KAAKmE,KAAK1F,EAAOwG,KAAMjF,KAAMmC,IAX7BnC,KAAKwf,QAAS,EACdxf,KAAKygB,MAAO,EACZzgB,KAAK0f,SAAWvd,EAAMuI,UACtB1K,KAAKuf,SAAW,EAChBvf,KAAKsgB,WAAY,EACjBtgB,KAAKugB,SAAU,EAEfvgB,KAAKmE,KAAK1F,EAAOwG,KAAMjF,KAAMmC,MAkBrC+d,KAAM,SAAU/d,GAEZnC,KAAKukB,cAAgBpiB,EAEhBnC,KAAKI,UAKVJ,KAAKwf,QAAS,EACdxf,KAAKygB,MAAO,EACZzgB,KAAKwgB,OAASre,EAAMuI,UACpB1K,KAAKuf,SAAWvf,KAAKwgB,OAASxgB,KAAK0f,SACnC1f,KAAK6kB,QAAU,EAEf7kB,KAAKsgB,WAAY,EACjBtgB,KAAKugB,SAAU,EACfvgB,KAAK2f,OAAS,EAEd3f,KAAKmE,KAAK1F,EAAOuG,GAAIhF,KAAMmC,KAW/Bke,MAAO,WAkBH,OAhBArgB,KAAKwd,gBAAiB,EACtBxd,KAAKI,SAAU,EACfJ,KAAKwf,QAAS,EACdxf,KAAKygB,MAAO,EACZzgB,KAAKwkB,QAAS,EACdxkB,KAAKykB,SAAU,EACfzkB,KAAK0kB,UAAW,EAChB1kB,KAAK2kB,SAAU,EACf3kB,KAAK0f,SAAW,EAChB1f,KAAKuf,SAAW,EAChBvf,KAAKwgB,OAAS,EACdxgB,KAAK6kB,QAAU,EACf7kB,KAAKsgB,WAAY,EACjBtgB,KAAKugB,SAAU,EACfvgB,KAAK2f,OAAS,EAEP3f,MAgBX8kB,YAAa,WAET,OAAI9kB,KAAKwf,OAEGxf,KAAKmf,OAAO/d,KAAKqP,KAAKpF,KAAOrL,KAAK0f,SAInC,GAUf/d,QAAS,WAEL3B,KAAK8C,qBAEL9C,KAAKukB,cAAgB,KAErBvkB,KAAKmf,OAAS,QAKtBjgB,EAAOC,QAAUsc,G,oBCrYjB,IAAIjc,EAAQ,EAAQ,GAChBf,EAAS,EAAQ,KACjBgJ,EAAe,EAAQ,GACvBoU,EAAkB,EAAQ,KAC1BC,EAAgB,EAAQ,KAwCxBH,EAAW,IAAInc,EAAM,CAErBK,WAEA,SAAmBklB,EAAgBxI,EAAMjb,GAKrC,QAHe+L,IAAX/L,IAAwBA,EAAS,IAGjCib,EAAK1Z,OAAS,EAEd,OAAO,EAUX7C,KAAKmI,QAAU4c,EAUf/kB,KAAKI,SAAU,EAUfJ,KAAKglB,SAAW,GAIhB,IAAK,IAAIpiB,EAAI,EAAGA,EAAI2Z,EAAK1Z,OAAQD,IACjC,CACI,IAAIqiB,EAAO1I,EAAK3Z,GAEI,iBAATqiB,EAEPjlB,KAAKglB,SAAS3iB,KAAK4iB,EAAKjG,cAAckG,WAAW,IAE5B,iBAATD,EAEZjlB,KAAKglB,SAAS3iB,KAAK4iB,GAEdA,EAAKhE,eAAe,YAEzBjhB,KAAKglB,SAAS3iB,KAAK4iB,EAAKnG,SAWhC9e,KAAK+K,QAAU/K,KAAKglB,SAAS,GAU7BhlB,KAAKwD,MAAQ,EASbxD,KAAKmlB,KAAOnlB,KAAKglB,SAASniB,OAU1B7C,KAAKolB,gBAAkB,EAUvBplB,KAAKqlB,SAAU,EAUfrlB,KAAKslB,YAAc,EAUnBtlB,KAAKulB,gBAAkB9d,EAAanG,EAAQ,mBAAmB,GAU/DtB,KAAKwlB,YAAc/d,EAAanG,EAAQ,cAAe,GAUvDtB,KAAKylB,aAAehe,EAAanG,EAAQ,gBAAgB,GAUzDtB,KAAK0lB,cAAgBje,EAAanG,EAAQ,iBAAiB,GAE3D,IAAIW,EAAQjC,KAmCZA,KAAK2lB,UAjCkB,SAAUxjB,IAEzBF,EAAMojB,SAAYpjB,EAAM7B,UAKdyb,EAAgB1Z,EAAOF,KAIjCA,EAAMkG,QAAQhE,KAAK1F,EAAOyiB,YAAajf,EAAOE,GAE1CF,EAAMwjB,aAEN3J,EAAc7Z,GAETA,EAAMyjB,eAEXzjB,EAAMN,aAgBlB3B,KAAKmI,QAAQlH,GAAGxC,EAAOwhB,aAAcjgB,KAAK2lB,YAW9CC,SAAU,CAENrhB,IAAK,WAED,OAAOvE,KAAKwD,MAAQxD,KAAKmlB,OAWjCxjB,QAAS,WAEL3B,KAAKI,SAAU,EACfJ,KAAKglB,SAAW,GAEhBhlB,KAAKmI,QAAQxF,IAAIlE,EAAOwhB,aAAcjgB,KAAK2lB,WAE3C3lB,KAAKmI,QAAU,QAKvBjJ,EAAOC,QAAUwc,G,oBCxRjB,IAAIC,EAAkB,EAAQ,KAoE9B1c,EAAOC,QAtDe,SAAUgD,EAAO0jB,GAEnC,GAAIA,EAAMR,QAEN,OAAO,EAGX,IAAIS,GAAe,EACfC,GAAa,EAEjB,GAAI5jB,EAAM2c,UAAY+G,EAAM9a,QAIxB,GAAI8a,EAAMriB,MAAQ,GAAKqiB,EAAML,YAAc,EAC3C,CAII,IAAIQ,EAAYH,EAAMT,gBAAkBS,EAAML,YAG1CrjB,EAAMuI,WAAasb,IAEnBD,GAAa,EACbD,EAAelK,EAAgBzZ,EAAO0jB,SAK1CE,GAAa,EAGbD,EAAelK,EAAgBzZ,EAAO0jB,GAkB9C,OAdKE,GAAcF,EAAMN,kBAGrBM,EAAMriB,MAAQ,EACdqiB,EAAM9a,QAAU8a,EAAMb,SAAS,IAG/Bc,IAEAD,EAAMT,gBAAkBjjB,EAAMuI,UAC9Bmb,EAAMR,SAAU,EAChBQ,EAAMP,YAAcnjB,EAAMuI,WAGvBob,I,kBCpCX5mB,EAAOC,QAhBe,SAAUgD,EAAO0jB,GAKnC,OAHAA,EAAMT,gBAAkBjjB,EAAMuI,UAC9Bmb,EAAMriB,QAEFqiB,EAAMriB,QAAUqiB,EAAMV,OAMtBU,EAAM9a,QAAU8a,EAAMb,SAASa,EAAMriB,QAC9B,K,kBCHftE,EAAOC,QAXa,SAAU0mB,GAQ1B,OANAA,EAAM9a,QAAU8a,EAAMb,SAAS,GAC/Ba,EAAMriB,MAAQ,EACdqiB,EAAMT,gBAAkB,EACxBS,EAAMR,SAAU,EAChBQ,EAAMP,YAAc,EAEbO","file":"js/vendors~phaser~input.f7826b655f014826a933.js","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Input\r\n */\r\n\r\nvar Input = {\r\n\r\n    CreatePixelPerfectHandler: require('./CreatePixelPerfectHandler'),\r\n    CreateInteractiveObject: require('./CreateInteractiveObject'),\r\n    Events: require('./events'),\r\n    Gamepad: require('./gamepad'),\r\n    InputManager: require('./InputManager'),\r\n    InputPlugin: require('./InputPlugin'),\r\n    InputPluginCache: require('./InputPluginCache'),\r\n    Keyboard: require('./keyboard'),\r\n    Mouse: require('./mouse'),\r\n    Pointer: require('./Pointer'),\r\n    Touch: require('./touch')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\nInput = Extend(false, Input, CONST);\r\n\r\nmodule.exports = Input;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Gamepad\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Axis: require('./Axis'),\r\n    Button: require('./Button'),\r\n    Events: require('./events'),\r\n    Gamepad: require('./Gamepad'),\r\n    GamepadPlugin: require('./GamepadPlugin'),\r\n    \r\n    Configs: require('./configs/')\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Button Down Event.\r\n * \r\n * This event is dispatched by the Gamepad Plugin when a button has been pressed on any active Gamepad.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.gamepad.on('down', listener)`.\r\n * \r\n * You can also listen for a DOWN event from a Gamepad instance. See the [GAMEPAD_BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_DOWN} event for details.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#BUTTON_DOWN\r\n * @since 3.10.0\r\n * \r\n * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad on which the button was pressed.\r\n * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was pressed.\r\n * @param {number} value - The value of the button at the time it was pressed. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.\r\n */\r\nmodule.exports = 'down';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Button Up Event.\r\n * \r\n * This event is dispatched by the Gamepad Plugin when a button has been released on any active Gamepad.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.gamepad.on('up', listener)`.\r\n * \r\n * You can also listen for an UP event from a Gamepad instance. See the [GAMEPAD_BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_UP} event for details.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#BUTTON_UP\r\n * @since 3.10.0\r\n * \r\n * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad on which the button was released.\r\n * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was released.\r\n * @param {number} value - The value of the button at the time it was released. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.\r\n */\r\nmodule.exports = 'up';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Connected Event.\r\n * \r\n * This event is dispatched by the Gamepad Plugin when a Gamepad has been connected.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.gamepad.once('connected', listener)`.\r\n * \r\n * Note that the browser may require you to press a button on a gamepad before it will allow you to access it,\r\n * this is for security reasons. However, it may also trust the page already, in which case you won't get the\r\n * 'connected' event and instead should check `GamepadPlugin.total` to see if it thinks there are any gamepads\r\n * already connected.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#CONNECTED\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad which was connected.\r\n * @param {Event} event - The native DOM Event that triggered the connection.\r\n */\r\nmodule.exports = 'connected';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Disconnected Event.\r\n * \r\n * This event is dispatched by the Gamepad Plugin when a Gamepad has been disconnected.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.gamepad.once('disconnected', listener)`.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#DISCONNECTED\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad which was disconnected.\r\n * @param {Event} event - The native DOM Event that triggered the disconnection.\r\n */\r\nmodule.exports = 'disconnected';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Button Down Event.\r\n * \r\n * This event is dispatched by a Gamepad instance when a button has been pressed on it.\r\n * \r\n * Listen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:\r\n * `this.input.gamepad.pad1.on('down', listener)`.\r\n * \r\n * Note that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.\r\n * \r\n * You can also listen for a DOWN event from the Gamepad Plugin. See the [BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_DOWN} event for details.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_DOWN\r\n * @since 3.10.0\r\n * \r\n * @param {number} index - The index of the button that was pressed.\r\n * @param {number} value - The value of the button at the time it was pressed. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.\r\n * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was pressed.\r\n */\r\nmodule.exports = 'down';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Button Up Event.\r\n * \r\n * This event is dispatched by a Gamepad instance when a button has been released on it.\r\n * \r\n * Listen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:\r\n * `this.input.gamepad.pad1.on('up', listener)`.\r\n * \r\n * Note that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.\r\n * \r\n * You can also listen for an UP event from the Gamepad Plugin. See the [BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_UP} event for details.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_UP\r\n * @since 3.10.0\r\n * \r\n * @param {number} index - The index of the button that was released.\r\n * @param {number} value - The value of the button at the time it was released. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.\r\n * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was released.\r\n */\r\nmodule.exports = 'up';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar Gamepad = require('./Gamepad');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar InputPluginCache = require('../InputPluginCache');\r\nvar InputEvents = require('../events');\r\n\r\n/**\r\n * @classdesc\r\n * The Gamepad Plugin is an input plugin that belongs to the Scene-owned Input system.\r\n *\r\n * Its role is to listen for native DOM Gamepad Events and then process them.\r\n *\r\n * You do not need to create this class directly, the Input system will create an instance of it automatically.\r\n *\r\n * You can access it from within a Scene using `this.input.gamepad`.\r\n *\r\n * To listen for a gamepad being connected:\r\n *\r\n * ```javascript\r\n * this.input.gamepad.once('connected', function (pad) {\r\n *     //   'pad' is a reference to the gamepad that was just connected\r\n * });\r\n * ```\r\n *\r\n * Note that the browser may require you to press a button on a gamepad before it will allow you to access it,\r\n * this is for security reasons. However, it may also trust the page already, in which case you won't get the\r\n * 'connected' event and instead should check `GamepadPlugin.total` to see if it thinks there are any gamepads\r\n * already connected.\r\n *\r\n * Once you have received the connected event, or polled the gamepads and found them enabled, you can access\r\n * them via the built-in properties `GamepadPlugin.pad1` to `pad4`, for up to 4 game pads. With a reference\r\n * to the gamepads you can poll its buttons and axis sticks. See the properties and methods available on\r\n * the `Gamepad` class for more details.\r\n *\r\n * As of September 2020 Chrome, and likely other browsers, will soon start to require that games requesting\r\n * access to the Gamepad API are running under SSL. They will actively block API access if they are not.\r\n *\r\n * For more information about Gamepad support in browsers see the following resources:\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API\r\n * https://www.smashingmagazine.com/2015/11/gamepad-api-in-web-games/\r\n * http://html5gamepad.com/\r\n *\r\n * @class GamepadPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Input.InputPlugin} sceneInputPlugin - A reference to the Scene Input Plugin that the KeyboardPlugin belongs to.\r\n */\r\nvar GamepadPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function GamepadPlugin (sceneInputPlugin)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Scene that this Input Plugin is responsible for.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.10.0\r\n         */\r\n        this.scene = sceneInputPlugin.scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems Settings.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.10.0\r\n         */\r\n        this.settings = this.scene.sys.settings;\r\n\r\n        /**\r\n         * A reference to the Scene Input Plugin that created this Keyboard Plugin.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#sceneInputPlugin\r\n         * @type {Phaser.Input.InputPlugin}\r\n         * @since 3.10.0\r\n         */\r\n        this.sceneInputPlugin = sceneInputPlugin;\r\n\r\n        /**\r\n         * A boolean that controls if the Gamepad Manager is enabled or not.\r\n         * Can be toggled on the fly.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.10.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * The Gamepad Event target, as defined in the Game Config.\r\n         * Typically the browser window, but can be any interactive DOM element.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#target\r\n         * @type {any}\r\n         * @since 3.10.0\r\n         */\r\n        this.target;\r\n\r\n        /**\r\n         * An array of the connected Gamepads.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#gamepads\r\n         * @type {Phaser.Input.Gamepad.Gamepad[]}\r\n         * @default []\r\n         * @since 3.10.0\r\n         */\r\n        this.gamepads = [];\r\n\r\n        /**\r\n         * An internal event queue.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#queue\r\n         * @type {GamepadEvent[]}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.queue = [];\r\n\r\n        /**\r\n         * Internal event handler.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#onGamepadHandler\r\n         * @type {function}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.onGamepadHandler;\r\n\r\n        /**\r\n         * Internal Gamepad reference.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad1\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._pad1;\r\n\r\n        /**\r\n         * Internal Gamepad reference.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad2\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._pad2;\r\n\r\n        /**\r\n         * Internal Gamepad reference.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad3\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._pad3;\r\n\r\n        /**\r\n         * Internal Gamepad reference.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad4\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._pad4;\r\n\r\n        sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);\r\n        sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#boot\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var game = this.scene.sys.game;\r\n        var settings = this.settings.input;\r\n        var config = game.config;\r\n\r\n        this.enabled = GetValue(settings, 'gamepad', config.inputGamepad) && game.device.input.gamepads;\r\n        this.target = GetValue(settings, 'gamepad.target', config.inputGamepadEventTarget);\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#start\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    start: function ()\r\n    {\r\n        if (this.enabled)\r\n        {\r\n            this.startListeners();\r\n\r\n            this.refreshPads();\r\n        }\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#isActive\r\n     * @since 3.10.0\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.enabled && this.scene.sys.isActive());\r\n    },\r\n\r\n    /**\r\n     * Starts the Gamepad Event listeners running.\r\n     * This is called automatically and does not need to be manually invoked.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#startListeners\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    startListeners: function ()\r\n    {\r\n        var _this = this;\r\n        var target = this.target;\r\n\r\n        var handler = function (event)\r\n        {\r\n            if (event.defaultPrevented || !_this.isActive())\r\n            {\r\n                // Do nothing if event already handled\r\n                return;\r\n            }\r\n\r\n            _this.refreshPads();\r\n\r\n            _this.queue.push(event);\r\n        };\r\n\r\n        this.onGamepadHandler = handler;\r\n\r\n        target.addEventListener('gamepadconnected', handler, false);\r\n        target.addEventListener('gamepaddisconnected', handler, false);\r\n\r\n        //  FF also supports gamepadbuttondown, gamepadbuttonup and gamepadaxismove but\r\n        //  nothing else does, and we can get those values via the gamepads anyway, so we will\r\n        //  until more browsers support this\r\n\r\n        //  Finally, listen for an update event from the Input Plugin\r\n        this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);\r\n    },\r\n\r\n    /**\r\n     * Stops the Gamepad Event listeners.\r\n     * This is called automatically and does not need to be manually invoked.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#stopListeners\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    stopListeners: function ()\r\n    {\r\n        this.target.removeEventListener('gamepadconnected', this.onGamepadHandler);\r\n        this.target.removeEventListener('gamepaddisconnected', this.onGamepadHandler);\r\n\r\n        this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update);\r\n\r\n        for (var i = 0; i < this.gamepads.length; i++)\r\n        {\r\n            this.gamepads[i].removeAllListeners();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Disconnects all current Gamepads.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#disconnectAll\r\n     * @since 3.10.0\r\n     */\r\n    disconnectAll: function ()\r\n    {\r\n        for (var i = 0; i < this.gamepads.length; i++)\r\n        {\r\n            this.gamepads[i].pad.connected = false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Refreshes the list of connected Gamepads.\r\n     *\r\n     * This is called automatically when a gamepad is connected or disconnected,\r\n     * and during the update loop.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#refreshPads\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    refreshPads: function ()\r\n    {\r\n        var connectedPads = navigator.getGamepads();\r\n\r\n        if (!connectedPads)\r\n        {\r\n            this.disconnectAll();\r\n        }\r\n        else\r\n        {\r\n            var currentPads = this.gamepads;\r\n\r\n            for (var i = 0; i < connectedPads.length; i++)\r\n            {\r\n                var livePad = connectedPads[i];\r\n\r\n                //  Because sometimes they're null (yes, really)\r\n                if (!livePad)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                var id = livePad.id;\r\n                var index = livePad.index;\r\n                var currentPad = currentPads[index];\r\n\r\n                if (!currentPad)\r\n                {\r\n                    //  A new Gamepad, not currently stored locally\r\n                    var newPad = new Gamepad(this, livePad);\r\n\r\n                    currentPads[index] = newPad;\r\n\r\n                    if (!this._pad1)\r\n                    {\r\n                        this._pad1 = newPad;\r\n                    }\r\n                    else if (!this._pad2)\r\n                    {\r\n                        this._pad2 = newPad;\r\n                    }\r\n                    else if (!this._pad3)\r\n                    {\r\n                        this._pad3 = newPad;\r\n                    }\r\n                    else if (!this._pad4)\r\n                    {\r\n                        this._pad4 = newPad;\r\n                    }\r\n                }\r\n                else if (currentPad.id !== id)\r\n                {\r\n                    //  A new Gamepad with a different vendor string, but it has got the same index as an old one\r\n                    currentPad.destroy();\r\n\r\n                    currentPads[index] = new Gamepad(this, livePad);\r\n                }\r\n                else\r\n                {\r\n                    //  If neither of these, it's a pad we've already got, so update it\r\n                    currentPad.update(livePad);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an array of all currently connected Gamepads.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#getAll\r\n     * @since 3.10.0\r\n     *\r\n     * @return {Phaser.Input.Gamepad.Gamepad[]} An array of all currently connected Gamepads.\r\n     */\r\n    getAll: function ()\r\n    {\r\n        var out = [];\r\n        var pads = this.gamepads;\r\n\r\n        for (var i = 0; i < pads.length; i++)\r\n        {\r\n            if (pads[i])\r\n            {\r\n                out.push(pads[i]);\r\n            }\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Looks-up a single Gamepad based on the given index value.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#getPad\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} index - The index of the Gamepad to get.\r\n     *\r\n     * @return {Phaser.Input.Gamepad.Gamepad} The Gamepad matching the given index, or undefined if none were found.\r\n     */\r\n    getPad: function (index)\r\n    {\r\n        var pads = this.gamepads;\r\n\r\n        for (var i = 0; i < pads.length; i++)\r\n        {\r\n            if (pads[i] && pads[i].index === index)\r\n            {\r\n                return pads[i];\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The internal update loop. Refreshes all connected gamepads and processes their events.\r\n     *\r\n     * Called automatically by the Input Manager, invoked from the Game step.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#update\r\n     * @private\r\n     * @fires Phaser.Input.Gamepad.Events#CONNECTED\r\n     * @fires Phaser.Input.Gamepad.Events#DISCONNECTED\r\n     * @since 3.10.0\r\n     */\r\n    update: function ()\r\n    {\r\n        if (!this.enabled)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.refreshPads();\r\n\r\n        var len = this.queue.length;\r\n\r\n        if (len === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var queue = this.queue.splice(0, len);\r\n\r\n        //  Process the event queue, dispatching all of the events that have stored up\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            var event = queue[i];\r\n            var pad = this.getPad(event.gamepad.index);\r\n\r\n            if (event.type === 'gamepadconnected')\r\n            {\r\n                this.emit(Events.CONNECTED, pad, event);\r\n            }\r\n            else if (event.type === 'gamepaddisconnected')\r\n            {\r\n                this.emit(Events.DISCONNECTED, pad, event);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Shuts the Gamepad Plugin down.\r\n     * All this does is remove any listeners bound to it.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#shutdown\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.stopListeners();\r\n\r\n        this.removeAllListeners();\r\n    },\r\n\r\n    /**\r\n     * Destroys this Gamepad Plugin, disconnecting all Gamepads and releasing internal references.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#destroy\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        for (var i = 0; i < this.gamepads.length; i++)\r\n        {\r\n            if (this.gamepads[i])\r\n            {\r\n                this.gamepads[i].destroy();\r\n            }\r\n        }\r\n\r\n        this.gamepads = [];\r\n\r\n        this.scene = null;\r\n        this.settings = null;\r\n        this.sceneInputPlugin = null;\r\n        this.target = null;\r\n    },\r\n\r\n    /**\r\n     * The total number of connected game pads.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#total\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    total: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.gamepads.length;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A reference to the first connected Gamepad.\r\n     *\r\n     * This will be undefined if either no pads are connected, or the browser\r\n     * has not yet issued a gamepadconnect, which can happen even if a Gamepad\r\n     * is plugged in, but hasn't yet had any buttons pressed on it.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#pad1\r\n     * @type {Phaser.Input.Gamepad.Gamepad}\r\n     * @since 3.10.0\r\n     */\r\n    pad1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._pad1;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A reference to the second connected Gamepad.\r\n     *\r\n     * This will be undefined if either no pads are connected, or the browser\r\n     * has not yet issued a gamepadconnect, which can happen even if a Gamepad\r\n     * is plugged in, but hasn't yet had any buttons pressed on it.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#pad2\r\n     * @type {Phaser.Input.Gamepad.Gamepad}\r\n     * @since 3.10.0\r\n     */\r\n    pad2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._pad2;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A reference to the third connected Gamepad.\r\n     *\r\n     * This will be undefined if either no pads are connected, or the browser\r\n     * has not yet issued a gamepadconnect, which can happen even if a Gamepad\r\n     * is plugged in, but hasn't yet had any buttons pressed on it.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#pad3\r\n     * @type {Phaser.Input.Gamepad.Gamepad}\r\n     * @since 3.10.0\r\n     */\r\n    pad3: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._pad3;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A reference to the fourth connected Gamepad.\r\n     *\r\n     * This will be undefined if either no pads are connected, or the browser\r\n     * has not yet issued a gamepadconnect, which can happen even if a Gamepad\r\n     * is plugged in, but hasn't yet had any buttons pressed on it.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#pad4\r\n     * @type {Phaser.Input.Gamepad.Gamepad}\r\n     * @since 3.10.0\r\n     */\r\n    pad4: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._pad4;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * An instance of the Gamepad Plugin class, if enabled via the `input.gamepad` Scene or Game Config property.\r\n * Use this to create access Gamepads connected to the browser and respond to gamepad buttons.\r\n *\r\n * @name Phaser.Input.InputPlugin#gamepad\r\n * @type {?Phaser.Input.Gamepad.GamepadPlugin}\r\n * @since 3.10.0\r\n */\r\nInputPluginCache.register('GamepadPlugin', GamepadPlugin, 'gamepad', 'gamepad', 'inputGamepad');\r\n\r\nmodule.exports = GamepadPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Gamepad.Configs\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    DUALSHOCK_4: require('./Sony_PlayStation_DualShock_4'),\r\n    SNES_USB: require('./SNES_USB_Controller'),\r\n    XBOX_360: require('./XBox360_Controller')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * PlayStation DualShock 4 Gamepad Configuration.\r\n * Sony PlayStation DualShock 4 (v2) wireless controller\r\n *\r\n * @name Phaser.Input.Gamepad.Configs.DUALSHOCK_4\r\n * @type {object}\r\n * @since 3.0.0\r\n */\r\nmodule.exports = {\r\n\r\n    UP: 12,\r\n    DOWN: 13,\r\n    LEFT: 14,\r\n    RIGHT: 15,\r\n\r\n    SHARE: 8,\r\n    OPTIONS: 9,\r\n    PS: 16,\r\n    TOUCHBAR: 17,\r\n\r\n    X: 0,\r\n    CIRCLE: 1,\r\n    SQUARE: 2,\r\n    TRIANGLE: 3,\r\n\r\n    L1: 4,\r\n    R1: 5,\r\n    L2: 6,\r\n    R2: 7,\r\n    L3: 10,\r\n    R3: 11,\r\n\r\n    LEFT_STICK_H: 0,\r\n    LEFT_STICK_V: 1,\r\n    RIGHT_STICK_H: 2,\r\n    RIGHT_STICK_V: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Tatar SNES USB Controller Gamepad Configuration.\r\n * USB Gamepad  (STANDARD GAMEPAD Vendor: 0079 Product: 0011)\r\n *\r\n * @name Phaser.Input.Gamepad.Configs.SNES_USB\r\n * @type {object}\r\n * @since 3.0.0\r\n */\r\nmodule.exports = {\r\n\r\n    UP: 12,\r\n    DOWN: 13,\r\n    LEFT: 14,\r\n    RIGHT: 15,\r\n\r\n    SELECT: 8,\r\n    START: 9,\r\n\r\n    B: 0,\r\n    A: 1,\r\n    Y: 2,\r\n    X: 3,\r\n\r\n    LEFT_SHOULDER: 4,\r\n    RIGHT_SHOULDER: 5\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * XBox 360 Gamepad Configuration.\r\n *\r\n * @name Phaser.Input.Gamepad.Configs.XBOX_360\r\n * @type {object}\r\n * @since 3.0.0\r\n */\r\nmodule.exports = {\r\n\r\n    UP: 12,\r\n    DOWN: 13,\r\n    LEFT: 14,\r\n    RIGHT: 15,\r\n\r\n    MENU: 16,\r\n\r\n    A: 0,\r\n    B: 1,\r\n    X: 2,\r\n    Y: 3,\r\n\r\n    LB: 4,\r\n    RB: 5,\r\n\r\n    LT: 6,\r\n    RT: 7,\r\n\r\n    BACK: 8,\r\n    START: 9,\r\n\r\n    LS: 10,\r\n    RS: 11,\r\n\r\n    LEFT_STICK_H: 0,\r\n    LEFT_STICK_V: 1,\r\n    RIGHT_STICK_H: 2,\r\n    RIGHT_STICK_V: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Circle = require('../geom/circle/Circle');\r\nvar CircleContains = require('../geom/circle/Contains');\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar CreateInteractiveObject = require('./CreateInteractiveObject');\r\nvar CreatePixelPerfectHandler = require('./CreatePixelPerfectHandler');\r\nvar DistanceBetween = require('../math/distance/DistanceBetween');\r\nvar Ellipse = require('../geom/ellipse/Ellipse');\r\nvar EllipseContains = require('../geom/ellipse/Contains');\r\nvar Events = require('./events');\r\nvar EventEmitter = require('eventemitter3');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar GEOM_CONST = require('../geom/const');\r\nvar InputPluginCache = require('./InputPluginCache');\r\nvar IsPlainObject = require('../utils/object/IsPlainObject');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar RectangleContains = require('../geom/rectangle/Contains');\r\nvar SceneEvents = require('../scene/events');\r\nvar Triangle = require('../geom/triangle/Triangle');\r\nvar TriangleContains = require('../geom/triangle/Contains');\r\n\r\n/**\r\n * @classdesc\r\n * The Input Plugin belongs to a Scene and handles all input related events and operations for it.\r\n *\r\n * You can access it from within a Scene using `this.input`.\r\n *\r\n * It emits events directly. For example, you can do:\r\n *\r\n * ```javascript\r\n * this.input.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * To listen for a pointer down event anywhere on the game canvas.\r\n *\r\n * Game Objects can be enabled for input by calling their `setInteractive` method. After which they\r\n * will directly emit input events:\r\n *\r\n * ```javascript\r\n * var sprite = this.add.sprite(x, y, texture);\r\n * sprite.setInteractive();\r\n * sprite.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * There are lots of game configuration options available relating to input.\r\n * See the [Input Config object]{@linkcode Phaser.Types.Core.InputConfig} for more details, including how to deal with Phaser\r\n * listening for input events outside of the canvas, how to set a default number of pointers, input\r\n * capture settings and more.\r\n *\r\n * Please also see the Input examples and tutorials for further information.\r\n *\r\n * **Incorrect input coordinates with Angular**\r\n *\r\n * If you are using Phaser within Angular, and use nglf or the router, to make the component in which the Phaser game resides\r\n * change state (i.e. appear or disappear) then you'll need to notify the Scale Manager about this, as Angular will mess with\r\n * the DOM in a way in which Phaser can't detect directly. Call `this.scale.updateBounds()` as part of your game init in order\r\n * to refresh the canvas DOM bounds values, which Phaser uses for input point position calculations.\r\n *\r\n * @class InputPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that this Input Plugin is responsible for.\r\n */\r\nvar InputPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function InputPlugin (scene)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Scene that this Input Plugin is responsible for.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems class.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A reference to the Scene Systems Settings.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.5.0\r\n         */\r\n        this.settings = scene.sys.settings;\r\n\r\n        /**\r\n         * A reference to the Game Input Manager.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#manager\r\n         * @type {Phaser.Input.InputManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = scene.sys.game.input;\r\n\r\n        /**\r\n         * Internal event queue used for plugins only.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#pluginEvents\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.pluginEvents = new EventEmitter();\r\n\r\n        /**\r\n         * If `true` this Input Plugin will process DOM input events.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.5.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * A reference to the Scene Display List. This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */\r\n        this.displayList;\r\n\r\n        /**\r\n         * A reference to the Scene Cameras Manager. This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#cameras\r\n         * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.cameras;\r\n\r\n        //  Inject the available input plugins into this class\r\n        InputPluginCache.install(this);\r\n\r\n        /**\r\n         * A reference to the Mouse Manager.\r\n         *\r\n         * This property is only set if Mouse support has been enabled in your Game Configuration file.\r\n         *\r\n         * If you just wish to get access to the mouse pointer, use the `mousePointer` property instead.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#mouse\r\n         * @type {?Phaser.Input.Mouse.MouseManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.mouse = this.manager.mouse;\r\n\r\n        /**\r\n         * When set to `true` (the default) the Input Plugin will emulate DOM behavior by only emitting events from\r\n         * the top-most Game Objects in the Display List.\r\n         *\r\n         * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#topOnly\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.topOnly = true;\r\n\r\n        /**\r\n         * How often should the Pointers be checked?\r\n         *\r\n         * The value is a time, given in ms, and is the time that must have elapsed between game steps before\r\n         * the Pointers will be polled again. When a pointer is polled it runs a hit test to see which Game\r\n         * Objects are currently below it, or being interacted with it.\r\n         *\r\n         * Pointers will *always* be checked if they have been moved by the user, or press or released.\r\n         *\r\n         * This property only controls how often they will be polled if they have not been updated.\r\n         * You should set this if you want to have Game Objects constantly check against the pointers, even\r\n         * if the pointer didn't itself move.\r\n         *\r\n         * Set to 0 to poll constantly. Set to -1 to only poll on user movement.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#pollRate\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.pollRate = -1;\r\n\r\n        /**\r\n         * Internal poll timer value.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pollTimer\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._pollTimer = 0;\r\n\r\n        var _eventData = { cancelled: false };\r\n\r\n        /**\r\n         * Internal event propagation callback container.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_eventContainer\r\n         * @type {Phaser.Types.Input.EventData}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._eventContainer = {\r\n            stopPropagation: function ()\r\n            {\r\n                _eventData.cancelled = true;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Internal event propagation data object.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_eventData\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._eventData = _eventData;\r\n\r\n        /**\r\n         * The distance, in pixels, a pointer has to move while being held down, before it thinks it is being dragged.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#dragDistanceThreshold\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.dragDistanceThreshold = 0;\r\n\r\n        /**\r\n         * The amount of time, in ms, a pointer has to be held down before it thinks it is dragging.\r\n         *\r\n         * The default polling rate is to poll only on move so once the time threshold is reached the\r\n         * drag event will not start until you move the mouse. If you want it to start immediately\r\n         * when the time threshold is reached, you must increase the polling rate by calling\r\n         * [setPollAlways]{@linkcode Phaser.Input.InputPlugin#setPollAlways} or\r\n         * [setPollRate]{@linkcode Phaser.Input.InputPlugin#setPollRate}.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#dragTimeThreshold\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.dragTimeThreshold = 0;\r\n\r\n        /**\r\n         * Used to temporarily store the results of the Hit Test\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_temp\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._temp = [];\r\n\r\n        /**\r\n         * Used to temporarily store the results of the Hit Test dropZones\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_tempZones\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._tempZones = [];\r\n\r\n        /**\r\n         * A list of all Game Objects that have been set to be interactive in the Scene this Input Plugin is managing.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_list\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._list = [];\r\n\r\n        /**\r\n         * Objects waiting to be inserted to the list on the next call to 'begin'.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pendingInsertion\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._pendingInsertion = [];\r\n\r\n        /**\r\n         * Objects waiting to be removed from the list on the next call to 'begin'.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pendingRemoval\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._pendingRemoval = [];\r\n\r\n        /**\r\n         * A list of all Game Objects that have been enabled for dragging.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_draggable\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._draggable = [];\r\n\r\n        /**\r\n         * A list of all Interactive Objects currently considered as being 'draggable' by any pointer, indexed by pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_drag\r\n         * @type {{0:Array,1:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array,10:Array}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };\r\n\r\n        /**\r\n         * A array containing the dragStates, for this Scene, index by the Pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_dragState\r\n         * @type {number[]}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._dragState = [];\r\n\r\n        /**\r\n         * A list of all Interactive Objects currently considered as being 'over' by any pointer, indexed by pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_over\r\n         * @type {{0:Array,1:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array,10:Array}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._over = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };\r\n\r\n        /**\r\n         * A list of valid DOM event types.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_validTypes\r\n         * @type {string[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._validTypes = [ 'onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop' ];\r\n\r\n        /**\r\n         * Internal property that tracks frame event state.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_updatedThisFrame\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.18.0\r\n         */\r\n        this._updatedThisFrame = false;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#boot\r\n     * @fires Phaser.Input.Events#BOOT\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.cameras = this.systems.cameras;\r\n\r\n        this.displayList = this.systems.displayList;\r\n\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.BOOT);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#start\r\n     * @fires Phaser.Input.Events#START\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);\r\n        eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);\r\n        eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);\r\n        eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);\r\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n\r\n        this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);\r\n        this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);\r\n\r\n        this.enabled = true;\r\n\r\n        //  Populate the pointer drag states\r\n        this._dragState = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.START);\r\n    },\r\n\r\n    /**\r\n     * Game Over handler.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#onGameOver\r\n     * @fires Phaser.Input.Events#GAME_OVER\r\n     * @private\r\n     * @since 3.16.2\r\n     */\r\n    onGameOver: function (event)\r\n    {\r\n        if (this.isActive())\r\n        {\r\n            this.emit(Events.GAME_OVER, event.timeStamp, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Game Out handler.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#onGameOut\r\n     * @fires Phaser.Input.Events#GAME_OUT\r\n     * @private\r\n     * @since 3.16.2\r\n     */\r\n    onGameOut: function (event)\r\n    {\r\n        if (this.isActive())\r\n        {\r\n            this.emit(Events.GAME_OUT, event.timeStamp, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The pre-update handler is responsible for checking the pending removal and insertion lists and\r\n     * deleting old Game Objects.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#preUpdate\r\n     * @private\r\n     * @fires Phaser.Input.Events#PRE_UPDATE\r\n     * @since 3.0.0\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.PRE_UPDATE);\r\n\r\n        var removeList = this._pendingRemoval;\r\n        var insertList = this._pendingInsertion;\r\n\r\n        var toRemove = removeList.length;\r\n        var toInsert = insertList.length;\r\n\r\n        if (toRemove === 0 && toInsert === 0)\r\n        {\r\n            //  Quick bail\r\n            return;\r\n        }\r\n\r\n        var current = this._list;\r\n\r\n        //  Delete old gameObjects\r\n        for (var i = 0; i < toRemove; i++)\r\n        {\r\n            var gameObject = removeList[i];\r\n\r\n            var index = current.indexOf(gameObject);\r\n\r\n            if (index > -1)\r\n            {\r\n                current.splice(index, 1);\r\n\r\n                this.clear(gameObject, true);\r\n            }\r\n        }\r\n\r\n        //  Clear the removal list\r\n        removeList.length = 0;\r\n        this._pendingRemoval.length = 0;\r\n\r\n        //  Move pendingInsertion to list (also clears pendingInsertion at the same time)\r\n        this._list = current.concat(insertList.splice(0));\r\n    },\r\n\r\n    /**\r\n     * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#isActive\r\n     * @since 3.10.0\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.enabled && this.scene.sys.isActive());\r\n    },\r\n\r\n    /**\r\n     * This is called automatically by the Input Manager.\r\n     * It emits events for plugins to listen to and also handles polling updates, if enabled.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#updatePoll\r\n     * @since 3.18.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    updatePoll: function (time, delta)\r\n    {\r\n        if (!this.isActive())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  The plugins should update every frame, regardless if there has been\r\n        //  any DOM input events or not (such as the Gamepad and Keyboard)\r\n        this.pluginEvents.emit(Events.UPDATE, time, delta);\r\n\r\n        //  We can leave now if we've already updated once this frame via the immediate DOM event handlers\r\n        if (this._updatedThisFrame)\r\n        {\r\n            this._updatedThisFrame = false;\r\n\r\n            return false;\r\n        }\r\n\r\n        var i;\r\n        var manager = this.manager;\r\n\r\n        var pointers = manager.pointers;\r\n        var pointersTotal = manager.pointersTotal;\r\n\r\n        for (i = 0; i < pointersTotal; i++)\r\n        {\r\n            pointers[i].updateMotion();\r\n        }\r\n\r\n        //  No point going any further if there aren't any interactive objects\r\n        if (this._list.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var rate = this.pollRate;\r\n\r\n        if (rate === -1)\r\n        {\r\n            return false;\r\n        }\r\n        else if (rate > 0)\r\n        {\r\n            this._pollTimer -= delta;\r\n\r\n            if (this._pollTimer < 0)\r\n            {\r\n                //  Discard timer diff, we're ready to poll again\r\n                this._pollTimer = this.pollRate;\r\n            }\r\n            else\r\n            {\r\n                //  Not enough time has elapsed since the last poll, so abort now\r\n                return false;\r\n            }\r\n        }\r\n\r\n        //  We got this far? Then we should poll for movement\r\n        var captured = false;\r\n\r\n        for (i = 0; i < pointersTotal; i++)\r\n        {\r\n            var total = 0;\r\n\r\n            var pointer = pointers[i];\r\n\r\n            //  Always reset this array\r\n            this._tempZones = [];\r\n\r\n            //  _temp contains a hit tested and camera culled list of IO objects\r\n            this._temp = this.hitTestPointer(pointer);\r\n\r\n            this.sortGameObjects(this._temp, pointer);\r\n            this.sortDropZones(this._tempZones);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                //  Only the top-most one counts now, so safely ignore the rest\r\n                if (this._temp.length)\r\n                {\r\n                    this._temp.splice(1);\r\n                }\r\n\r\n                if (this._tempZones.length)\r\n                {\r\n                    this._tempZones.splice(1);\r\n                }\r\n            }\r\n\r\n            total += this.processOverOutEvents(pointer);\r\n\r\n            if (this.getDragState(pointer) === 2)\r\n            {\r\n                this.processDragThresholdEvent(pointer, time);\r\n            }\r\n\r\n            if (total > 0)\r\n            {\r\n                //  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\r\n                captured = true;\r\n            }\r\n        }\r\n\r\n        return captured;\r\n    },\r\n\r\n    /**\r\n     * This method is called when a DOM Event is received by the Input Manager. It handles dispatching the events\r\n     * to relevant input enabled Game Objects in this scene.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#update\r\n     * @private\r\n     * @fires Phaser.Input.Events#UPDATE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} type - The type of event to process.\r\n     * @param {Phaser.Input.Pointer[]} pointers - An array of Pointers on which the event occurred.\r\n     *\r\n     * @return {boolean} `true` if this Scene has captured the input events from all other Scenes, otherwise `false`.\r\n     */\r\n    update: function (type, pointers)\r\n    {\r\n        if (!this.isActive())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var pointersTotal = pointers.length;\r\n        var captured = false;\r\n\r\n        for (var i = 0; i < pointersTotal; i++)\r\n        {\r\n            var total = 0;\r\n            var pointer = pointers[i];\r\n\r\n            //  Always reset this array\r\n            this._tempZones = [];\r\n\r\n            //  _temp contains a hit tested and camera culled list of IO objects\r\n            this._temp = this.hitTestPointer(pointer);\r\n\r\n            this.sortGameObjects(this._temp, pointer);\r\n            this.sortDropZones(this._tempZones);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                //  Only the top-most one counts now, so safely ignore the rest\r\n                if (this._temp.length)\r\n                {\r\n                    this._temp.splice(1);\r\n                }\r\n\r\n                if (this._tempZones.length)\r\n                {\r\n                    this._tempZones.splice(1);\r\n                }\r\n            }\r\n\r\n            switch (type)\r\n            {\r\n                case CONST.MOUSE_DOWN:\r\n                    total += this.processDragDownEvent(pointer);\r\n                    total += this.processDownEvents(pointer);\r\n                    total += this.processOverOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.MOUSE_UP:\r\n                    total += this.processDragUpEvent(pointer);\r\n                    total += this.processUpEvents(pointer);\r\n                    total += this.processOverOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.TOUCH_START:\r\n                    total += this.processDragDownEvent(pointer);\r\n                    total += this.processDownEvents(pointer);\r\n                    total += this.processOverEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.TOUCH_END:\r\n                case CONST.TOUCH_CANCEL:\r\n                    total += this.processDragUpEvent(pointer);\r\n                    total += this.processUpEvents(pointer);\r\n                    total += this.processOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.MOUSE_MOVE:\r\n                case CONST.TOUCH_MOVE:\r\n                    total += this.processDragMoveEvent(pointer);\r\n                    total += this.processMoveEvents(pointer);\r\n                    total += this.processOverOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.MOUSE_WHEEL:\r\n                    total += this.processWheelEvent(pointer);\r\n                    break;\r\n            }\r\n\r\n            if (total > 0)\r\n            {\r\n                //  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\r\n                captured = true;\r\n            }\r\n        }\r\n\r\n        this._updatedThisFrame = true;\r\n\r\n        return captured;\r\n    },\r\n\r\n    /**\r\n     * Clears a Game Object so it no longer has an Interactive Object associated with it.\r\n     * The Game Object is then queued for removal from the Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will have its Interactive Object removed.\r\n     * @param {boolean} [skipQueue=false] - Skip adding this Game Object into the removal queue?\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that had its Interactive Object removed.\r\n     */\r\n    clear: function (gameObject, skipQueue)\r\n    {\r\n        if (skipQueue === undefined) { skipQueue = false; }\r\n\r\n        var input = gameObject.input;\r\n\r\n        // If GameObject.input already cleared from higher class\r\n        if (!input)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (!skipQueue)\r\n        {\r\n            this.queueForRemoval(gameObject);\r\n        }\r\n\r\n        input.gameObject = undefined;\r\n        input.target = undefined;\r\n        input.hitArea = undefined;\r\n        input.hitAreaCallback = undefined;\r\n        input.callbackContext = undefined;\r\n\r\n        gameObject.input = null;\r\n\r\n        //  Clear from _draggable, _drag and _over\r\n        var index = this._draggable.indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._draggable.splice(index, 1);\r\n        }\r\n\r\n        index = this._drag[0].indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._drag[0].splice(index, 1);\r\n        }\r\n\r\n        index = this._over[0].indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._over[0].splice(index, 1);\r\n\r\n            this.manager.resetCursor(input);\r\n        }\r\n\r\n        return gameObject;\r\n    },\r\n\r\n    /**\r\n     * Disables Input on a single Game Object.\r\n     *\r\n     * An input disabled Game Object still retains its Interactive Object component and can be re-enabled\r\n     * at any time, by passing it to `InputPlugin.enable`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to have its input system disabled.\r\n     */\r\n    disable: function (gameObject)\r\n    {\r\n        gameObject.input.enabled = false;\r\n    },\r\n\r\n    /**\r\n     * Enable a Game Object for interaction.\r\n     *\r\n     * If the Game Object already has an Interactive Object component, it is enabled and returned.\r\n     *\r\n     * Otherwise, a new Interactive Object component is created and assigned to the Game Object's `input` property.\r\n     *\r\n     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n     * input detection.\r\n     *\r\n     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n     * shape for it to use.\r\n     *\r\n     * You can also provide an Input Configuration Object as the only argument to this method.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to be enabled for input.\r\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [hitArea] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [hitAreaCallback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n     * @param {boolean} [dropZone=false] - Is this Game Object a drop zone or not?\r\n     *\r\n     * @return {this} This Input Plugin.\r\n     */\r\n    enable: function (gameObject, hitArea, hitAreaCallback, dropZone)\r\n    {\r\n        if (dropZone === undefined) { dropZone = false; }\r\n\r\n        if (gameObject.input)\r\n        {\r\n            //  If it is already has an InteractiveObject then just enable it and return\r\n            gameObject.input.enabled = true;\r\n        }\r\n        else\r\n        {\r\n            //  Create an InteractiveObject and enable it\r\n            this.setHitArea(gameObject, hitArea, hitAreaCallback);\r\n        }\r\n\r\n        if (gameObject.input && dropZone && !gameObject.input.dropZone)\r\n        {\r\n            gameObject.input.dropZone = dropZone;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes the given Pointer and performs a hit test against it, to see which interactive Game Objects\r\n     * it is currently above.\r\n     *\r\n     * The hit test is performed against which-ever Camera the Pointer is over. If it is over multiple\r\n     * cameras, it starts checking the camera at the top of the camera list, and if nothing is found, iterates down the list.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#hitTestPointer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array of all the interactive Game Objects the Pointer was above.\r\n     */\r\n    hitTestPointer: function (pointer)\r\n    {\r\n        var cameras = this.cameras.getCamerasBelowPointer(pointer);\r\n\r\n        for (var c = 0; c < cameras.length; c++)\r\n        {\r\n            var camera = cameras[c];\r\n\r\n            //  Get a list of all objects that can be seen by the camera below the pointer in the scene and store in 'over' array.\r\n            //  All objects in this array are input enabled, as checked by the hitTest method, so we don't need to check later on as well.\r\n            var over = this.manager.hitTest(pointer, this._list, camera);\r\n\r\n            //  Filter out the drop zones\r\n            for (var i = 0; i < over.length; i++)\r\n            {\r\n                var obj = over[i];\r\n\r\n                if (obj.input.dropZone)\r\n                {\r\n                    this._tempZones.push(obj);\r\n                }\r\n            }\r\n\r\n            if (over.length > 0)\r\n            {\r\n                pointer.camera = camera;\r\n\r\n                return over;\r\n            }\r\n        }\r\n\r\n        //  If we got this far then there were no Game Objects below the pointer, but it was still over\r\n        //  a camera, so set that the top-most one into the pointer\r\n\r\n        pointer.camera = cameras[0];\r\n\r\n        return [];\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer down event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDownEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_DOWN\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DOWN\r\n     * @fires Phaser.Input.Events#POINTER_DOWN\r\n     * @fires Phaser.Input.Events#POINTER_DOWN_OUTSIDE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer being tested.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processDownEvents: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //  If they released outside the canvas, but pressed down inside it, we'll still dispatch the event.\r\n        if (!aborted && this.manager)\r\n        {\r\n            if (pointer.downElement === this.manager.game.canvas)\r\n            {\r\n                this.emit(Events.POINTER_DOWN, pointer, currentlyOver);\r\n            }\r\n            else\r\n            {\r\n                this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);\r\n            }\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * Returns the drag state of the given Pointer for this Input Plugin.\r\n     *\r\n     * The state will be one of the following:\r\n     *\r\n     * 0 = Not dragging anything\r\n     * 1 = Primary button down and objects below, so collect a draglist\r\n     * 2 = Pointer being checked if meets drag criteria\r\n     * 3 = Pointer meets criteria, notify the draglist\r\n     * 4 = Pointer actively dragging the draglist and has moved\r\n     * 5 = Pointer actively dragging but has been released, notify draglist\r\n     *\r\n     * @method Phaser.Input.InputPlugin#getDragState\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to get the drag state for.\r\n     *\r\n     * @return {number} The drag state of the given Pointer.\r\n     */\r\n    getDragState: function (pointer)\r\n    {\r\n        return this._dragState[pointer.id];\r\n    },\r\n\r\n    /**\r\n     * Sets the drag state of the given Pointer for this Input Plugin.\r\n     *\r\n     * The state must be one of the following values:\r\n     *\r\n     * 0 = Not dragging anything\r\n     * 1 = Primary button down and objects below, so collect a draglist\r\n     * 2 = Pointer being checked if meets drag criteria\r\n     * 3 = Pointer meets criteria, notify the draglist\r\n     * 4 = Pointer actively dragging the draglist and has moved\r\n     * 5 = Pointer actively dragging but has been released, notify draglist\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDragState\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to set the drag state for.\r\n     * @param {number} state - The drag state value. An integer between 0 and 5.\r\n     */\r\n    setDragState: function (pointer, state)\r\n    {\r\n        this._dragState[pointer.id] = state;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if a Pointer is ready to drag the objects below it, based on either a distance\r\n     * or time threshold.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragThresholdEvent\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check the drag thresholds on.\r\n     * @param {number} time - The current time.\r\n     */\r\n    processDragThresholdEvent: function (pointer, time)\r\n    {\r\n        var passed = false;\r\n        var timeThreshold = this.dragTimeThreshold;\r\n        var distanceThreshold = this.dragDistanceThreshold;\r\n\r\n        if (distanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold)\r\n        {\r\n            //  It has moved far enough to be considered a drag\r\n            passed = true;\r\n        }\r\n        else if (timeThreshold > 0 && (time >= pointer.downTime + timeThreshold))\r\n        {\r\n            //  It has been held down long enough to be considered a drag\r\n            passed = true;\r\n        }\r\n\r\n        if (passed)\r\n        {\r\n            this.setDragState(pointer, 3);\r\n\r\n            return this.processDragStartList(pointer);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Processes the drag list for the given pointer and dispatches the start events for each object on it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragStartList\r\n     * @private\r\n     * @fires Phaser.Input.Events#DRAG_START\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_START\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {number} The number of items that DRAG_START was called on.\r\n     */\r\n    processDragStartList: function (pointer)\r\n    {\r\n        //  3 = Pointer meets criteria and is freshly down, notify the draglist\r\n        if (this.getDragState(pointer) !== 3)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        var list = this._drag[pointer.id];\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            var input = gameObject.input;\r\n\r\n            input.dragState = 2;\r\n\r\n            input.dragStartX = gameObject.x;\r\n            input.dragStartY = gameObject.y;\r\n\r\n            input.dragStartXGlobal = pointer.worldX;\r\n            input.dragStartYGlobal = pointer.worldY;\r\n\r\n            input.dragX = input.dragStartXGlobal - input.dragStartX;\r\n            input.dragY = input.dragStartYGlobal - input.dragStartY;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);\r\n\r\n            this.emit(Events.DRAG_START, pointer, gameObject);\r\n        }\r\n\r\n        this.setDragState(pointer, 4);\r\n\r\n        return list.length;\r\n    },\r\n\r\n    /**\r\n     * Processes a 'drag down' event for the given pointer. Checks the pointer state, builds-up the drag list\r\n     * and prepares them all for interaction.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragDownEvent\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {number} The number of items that were collected on the drag list.\r\n     */\r\n    processDragDownEvent: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        if (this._draggable.length === 0 || currentlyOver.length === 0 || !pointer.primaryDown || this.getDragState(pointer) !== 0)\r\n        {\r\n            //  There are no draggable items, no over items or the pointer isn't down, so let's not even bother going further\r\n            return 0;\r\n        }\r\n\r\n        //  1 = Primary button down and objects below, so collect a draglist\r\n        this.setDragState(pointer, 1);\r\n\r\n        //  Get draggable objects, sort them, pick the top (or all) and store them somewhere\r\n        var draglist = [];\r\n\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (gameObject.input.draggable && (gameObject.input.dragState === 0))\r\n            {\r\n                draglist.push(gameObject);\r\n            }\r\n        }\r\n\r\n        if (draglist.length === 0)\r\n        {\r\n            this.setDragState(pointer, 0);\r\n\r\n            return 0;\r\n        }\r\n        else if (draglist.length > 1)\r\n        {\r\n            this.sortGameObjects(draglist, pointer);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                draglist.splice(1);\r\n            }\r\n        }\r\n\r\n        //  draglist now contains all potential candidates for dragging\r\n        this._drag[pointer.id] = draglist;\r\n\r\n        if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0)\r\n        {\r\n            //  No drag criteria, so snap immediately to mode 3\r\n            this.setDragState(pointer, 3);\r\n\r\n            return this.processDragStartList(pointer);\r\n        }\r\n        else\r\n        {\r\n            //  Check the distance / time on the next event\r\n            this.setDragState(pointer, 2);\r\n\r\n            return 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Processes a 'drag move' event for the given pointer.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragMoveEvent\r\n     * @private\r\n     * @fires Phaser.Input.Events#DRAG_ENTER\r\n     * @fires Phaser.Input.Events#DRAG\r\n     * @fires Phaser.Input.Events#DRAG_LEAVE\r\n     * @fires Phaser.Input.Events#DRAG_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_ENTER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_LEAVE\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_OVER\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {number} The number of items that were updated by this drag event.\r\n     */\r\n    processDragMoveEvent: function (pointer)\r\n    {\r\n        //  2 = Pointer being checked if meets drag criteria\r\n        if (this.getDragState(pointer) === 2)\r\n        {\r\n            this.processDragThresholdEvent(pointer, this.manager.game.loop.now);\r\n        }\r\n\r\n        if (this.getDragState(pointer) !== 4)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        //  4 = Pointer actively dragging the draglist and has moved\r\n        var dropZones = this._tempZones;\r\n\r\n        var list = this._drag[pointer.id];\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            var input = gameObject.input;\r\n\r\n            var target = input.target;\r\n\r\n            //  If this GO has a target then let's check it\r\n            if (target)\r\n            {\r\n                var index = dropZones.indexOf(target);\r\n\r\n                //  Got a target, are we still over it?\r\n                if (index === 0)\r\n                {\r\n                    //  We're still over it, and it's still the top of the display list, phew ...\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_OVER, pointer, gameObject, target);\r\n                }\r\n                else if (index > 0)\r\n                {\r\n                    //  Still over it but it's no longer top of the display list (targets must always be at the top)\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);\r\n\r\n                    input.target = dropZones[0];\r\n\r\n                    target = input.target;\r\n\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\r\n                }\r\n                else\r\n                {\r\n                    //  Nope, we've moved on (or the target has!), leave the old target\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);\r\n\r\n                    //  Anything new to replace it?\r\n                    //  Yup!\r\n                    if (dropZones[0])\r\n                    {\r\n                        input.target = dropZones[0];\r\n\r\n                        target = input.target;\r\n\r\n                        gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\r\n\r\n                        this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\r\n                    }\r\n                    else\r\n                    {\r\n                        //  Nope\r\n                        input.target = null;\r\n                    }\r\n                }\r\n            }\r\n            else if (!target && dropZones[0])\r\n            {\r\n                input.target = dropZones[0];\r\n\r\n                target = input.target;\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\r\n\r\n                this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\r\n            }\r\n\r\n            var dragX;\r\n            var dragY;\r\n\r\n            if (!gameObject.parentContainer)\r\n            {\r\n                dragX = pointer.worldX - input.dragX;\r\n                dragY = pointer.worldY - input.dragY;\r\n            }\r\n            else\r\n            {\r\n                var dx = pointer.worldX - input.dragStartXGlobal;\r\n                var dy = pointer.worldY - input.dragStartYGlobal;\r\n\r\n                var rotation = gameObject.getParentRotation();\r\n\r\n                var dxRotated = dx * Math.cos(rotation) + dy * Math.sin(rotation);\r\n                var dyRotated = dy * Math.cos(rotation) - dx * Math.sin(rotation);\r\n\r\n                dxRotated *= (1 / gameObject.parentContainer.scaleX);\r\n                dyRotated *= (1 / gameObject.parentContainer.scaleY);\r\n\r\n                dragX = dxRotated + input.dragStartX;\r\n                dragY = dyRotated + input.dragStartY;\r\n            }\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);\r\n\r\n            this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);\r\n        }\r\n\r\n        return list.length;\r\n    },\r\n\r\n    /**\r\n     * Processes a 'drag down' event for the given pointer. Checks the pointer state, builds-up the drag list\r\n     * and prepares them all for interaction.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragUpEvent\r\n     * @fires Phaser.Input.Events#DRAG_END\r\n     * @fires Phaser.Input.Events#DROP\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_END\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DROP\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {number} The number of items that were updated by this drag event.\r\n     */\r\n    processDragUpEvent: function (pointer)\r\n    {\r\n        //  5 = Pointer was actively dragging but has been released, notify draglist\r\n        var list = this._drag[pointer.id];\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            var input = gameObject.input;\r\n\r\n            if (input && input.dragState === 2)\r\n            {\r\n                input.dragState = 0;\r\n\r\n                input.dragX = input.localX - gameObject.displayOriginX;\r\n                input.dragY = input.localY - gameObject.displayOriginY;\r\n\r\n                var dropped = false;\r\n\r\n                var target = input.target;\r\n\r\n                if (target)\r\n                {\r\n                    gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target);\r\n\r\n                    this.emit(Events.DROP, pointer, gameObject, target);\r\n\r\n                    input.target = null;\r\n\r\n                    dropped = true;\r\n                }\r\n\r\n                //  And finally the dragend event\r\n\r\n                if (gameObject.input)\r\n                {\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);\r\n\r\n                    this.emit(Events.DRAG_END, pointer, gameObject, dropped);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setDragState(pointer, 0);\r\n\r\n        list.splice(0);\r\n\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer movement event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processMoveEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_MOVE\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_MOVE\r\n     * @fires Phaser.Input.Events#POINTER_MOVE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processMoveEvents: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            if (this.topOnly)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!aborted)\r\n        {\r\n            this.emit(Events.POINTER_MOVE, pointer, currentlyOver);\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles a mouse wheel event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processWheelEvent\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_WHEEL\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_WHEEL\r\n     * @fires Phaser.Input.Events#POINTER_WHEEL\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processWheelEvent: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        var dx = pointer.deltaX;\r\n        var dy = pointer.deltaY;\r\n        var dz = pointer.deltaZ;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!aborted)\r\n        {\r\n            this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz);\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer over events.\r\n     * This is called when a touch input hits the canvas, having previously been off of it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOverEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OVER\r\n     * @fires Phaser.Input.Events#POINTER_OVER\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processOverEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var total = currentlyOver.length;\r\n\r\n        var justOver = [];\r\n\r\n        if (total > 0)\r\n        {\r\n            var manager = this.manager;\r\n\r\n            var _eventData = this._eventData;\r\n            var _eventContainer = this._eventContainer;\r\n\r\n            _eventData.cancelled = false;\r\n\r\n            var aborted = false;\r\n\r\n            for (var i = 0; i < total; i++)\r\n            {\r\n                var gameObject = currentlyOver[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                justOver.push(gameObject);\r\n\r\n                manager.setCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit(Events.POINTER_OVER, pointer, justOver);\r\n            }\r\n        }\r\n\r\n        //  Then sort it into display list order\r\n        this._over[pointer.id] = justOver;\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer out events.\r\n     * This is called when a touch input leaves the canvas, as it can never be 'over' in this case.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOutEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OUT\r\n     * @fires Phaser.Input.Events#POINTER_OUT\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processOutEvents: function (pointer)\r\n    {\r\n        var previouslyOver = this._over[pointer.id];\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var total = previouslyOver.length;\r\n\r\n        if (total > 0)\r\n        {\r\n            var manager = this.manager;\r\n\r\n            var _eventData = this._eventData;\r\n            var _eventContainer = this._eventContainer;\r\n\r\n            _eventData.cancelled = false;\r\n\r\n            var aborted = false;\r\n\r\n            this.sortGameObjects(previouslyOver, pointer);\r\n\r\n            for (var i = 0; i < total; i++)\r\n            {\r\n                var gameObject = previouslyOver[i];\r\n\r\n                //  Call onOut for everything in the previouslyOver array\r\n                gameObject = previouslyOver[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                manager.resetCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                if (!aborted)\r\n                {\r\n                    this.emit(Events.POINTER_OUT, pointer, previouslyOver);\r\n                }\r\n            }\r\n\r\n            this._over[pointer.id] = [];\r\n        }\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer over and out events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOverOutEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OVER\r\n     * @fires Phaser.Input.Events#POINTER_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OUT\r\n     * @fires Phaser.Input.Events#POINTER_OUT\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processOverOutEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var i;\r\n        var gameObject;\r\n        var justOut = [];\r\n        var justOver = [];\r\n        var stillOver = [];\r\n        var previouslyOver = this._over[pointer.id];\r\n        var currentlyDragging = this._drag[pointer.id];\r\n\r\n        var manager = this.manager;\r\n\r\n        //  Go through all objects the pointer was previously over, and see if it still is.\r\n        //  Splits the previouslyOver array into two parts: justOut and stillOver\r\n\r\n        for (i = 0; i < previouslyOver.length; i++)\r\n        {\r\n            gameObject = previouslyOver[i];\r\n\r\n            if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1)\r\n            {\r\n                //  Not in the currentlyOver array, so must be outside of this object now\r\n                justOut.push(gameObject);\r\n            }\r\n            else\r\n            {\r\n                //  In the currentlyOver array\r\n                stillOver.push(gameObject);\r\n            }\r\n        }\r\n\r\n        //  Go through all objects the pointer is currently over (the hit test results)\r\n        //  and if not in the previouslyOver array we know it's a new entry, so add to justOver\r\n        for (i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            gameObject = currentlyOver[i];\r\n\r\n            //  Is this newly over?\r\n\r\n            if (previouslyOver.indexOf(gameObject) === -1)\r\n            {\r\n                justOver.push(gameObject);\r\n            }\r\n        }\r\n\r\n        //  By this point the arrays are filled, so now we can process what happened...\r\n\r\n        //  Process the Just Out objects\r\n        var total = justOut.length;\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        if (total > 0)\r\n        {\r\n            this.sortGameObjects(justOut, pointer);\r\n\r\n            //  Call onOut for everything in the justOut array\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                gameObject = justOut[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  Reset cursor before we emit the event, in case they want to change it during the event\r\n                manager.resetCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit(Events.POINTER_OUT, pointer, justOut);\r\n            }\r\n        }\r\n\r\n        //  Process the Just Over objects\r\n        total = justOver.length;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        aborted = false;\r\n\r\n        if (total > 0)\r\n        {\r\n            this.sortGameObjects(justOver, pointer);\r\n\r\n            //  Call onOver for everything in the justOver array\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                gameObject = justOver[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  Set cursor before we emit the event, in case they want to change it during the event\r\n                manager.setCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit(Events.POINTER_OVER, pointer, justOver);\r\n            }\r\n        }\r\n\r\n        //  Add the contents of justOver to the previously over array\r\n        previouslyOver = stillOver.concat(justOver);\r\n\r\n        //  Then sort it into display list order\r\n        this._over[pointer.id] = this.sortGameObjects(previouslyOver, pointer);\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer up events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processUpEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_UP\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_UP\r\n     * @fires Phaser.Input.Events#POINTER_UP\r\n     * @fires Phaser.Input.Events#POINTER_UP_OUTSIDE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processUpEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //  If they released outside the canvas, but pressed down inside it, we'll still dispatch the event.\r\n        if (!aborted && this.manager)\r\n        {\r\n            if (pointer.upElement === this.manager.game.canvas)\r\n            {\r\n                this.emit(Events.POINTER_UP, pointer, currentlyOver);\r\n            }\r\n            else\r\n            {\r\n                this.emit(Events.POINTER_UP_OUTSIDE, pointer);\r\n            }\r\n        }\r\n\r\n        return currentlyOver.length;\r\n    },\r\n\r\n    /**\r\n     * Queues a Game Object for insertion into this Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#queueForInsertion\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    queueForInsertion: function (child)\r\n    {\r\n        if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1)\r\n        {\r\n            this._pendingInsertion.push(child);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Queues a Game Object for removal from this Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#queueForRemoval\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    queueForRemoval: function (child)\r\n    {\r\n        this._pendingRemoval.push(child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the draggable state of the given array of Game Objects.\r\n     *\r\n     * They can either be set to be draggable, or can have their draggable state removed by passing `false`.\r\n     *\r\n     * A Game Object will not fire drag events unless it has been specifically enabled for drag.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDraggable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to change the draggable state on.\r\n     * @param {boolean} [value=true] - Set to `true` if the Game Objects should be made draggable, `false` if they should be unset.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setDraggable: function (gameObjects, value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            gameObject.input.draggable = value;\r\n\r\n            var index = this._draggable.indexOf(gameObject);\r\n\r\n            if (value && index === -1)\r\n            {\r\n                this._draggable.push(gameObject);\r\n            }\r\n            else if (!value && index > -1)\r\n            {\r\n                this._draggable.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a function that can be passed to `setInteractive`, `enable` or `setHitArea` that will handle\r\n     * pixel-perfect input detection on an Image or Sprite based Game Object, or any custom class that extends them.\r\n     *\r\n     * The following will create a sprite that is clickable on any pixel that has an alpha value >= 1.\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect());\r\n     * ```\r\n     *\r\n     * The following will create a sprite that is clickable on any pixel that has an alpha value >= 150.\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect(150));\r\n     * ```\r\n     *\r\n     * Once you have made an Interactive Object pixel perfect it impacts all input related events for it: down, up,\r\n     * dragstart, drag, etc.\r\n     *\r\n     * As a pointer interacts with the Game Object it will constantly poll the texture, extracting a single pixel from\r\n     * the given coordinates and checking its color values. This is an expensive process, so should only be enabled on\r\n     * Game Objects that really need it.\r\n     *\r\n     * You cannot make non-texture based Game Objects pixel perfect. So this will not work on Graphics, BitmapText,\r\n     * Render Textures, Text, Tilemaps, Containers or Particles.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#makePixelPerfect\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} [alphaTolerance=1] - The alpha level that the pixel should be above to be included as a successful interaction.\r\n     *\r\n     * @return {function} A Pixel Perfect Handler for use as a hitArea shape callback.\r\n     */\r\n    makePixelPerfect: function (alphaTolerance)\r\n    {\r\n        if (alphaTolerance === undefined) { alphaTolerance = 1; }\r\n\r\n        var textureManager = this.systems.textures;\r\n\r\n        return CreatePixelPerfectHandler(textureManager, alphaTolerance);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for the given array of Game Objects.\r\n     *\r\n     * A hit area is typically one of the geometric shapes Phaser provides, such as a `Phaser.Geom.Rectangle`\r\n     * or `Phaser.Geom.Circle`. However, it can be any object as long as it works with the provided callback.\r\n     *\r\n     * If no hit area is provided a Rectangle is created based on the size of the Game Object, if possible\r\n     * to calculate.\r\n     *\r\n     * The hit area callback is the function that takes an `x` and `y` coordinate and returns a boolean if\r\n     * those values fall within the area of the shape or not. All of the Phaser geometry objects provide this,\r\n     * such as `Phaser.Geom.Rectangle.Contains`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitArea\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set the hit area on.\r\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [hitArea] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [hitAreaCallback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitArea: function (gameObjects, hitArea, hitAreaCallback)\r\n    {\r\n        if (hitArea === undefined)\r\n        {\r\n            return this.setHitAreaFromTexture(gameObjects);\r\n        }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        var draggable = false;\r\n        var dropZone = false;\r\n        var cursor = false;\r\n        var useHandCursor = false;\r\n        var pixelPerfect = false;\r\n        var customHitArea = true;\r\n\r\n        //  Config object?\r\n        if (IsPlainObject(hitArea))\r\n        {\r\n            var config = hitArea;\r\n\r\n            hitArea = GetFastValue(config, 'hitArea', null);\r\n            hitAreaCallback = GetFastValue(config, 'hitAreaCallback', null);\r\n            draggable = GetFastValue(config, 'draggable', false);\r\n            dropZone = GetFastValue(config, 'dropZone', false);\r\n            cursor = GetFastValue(config, 'cursor', false);\r\n            useHandCursor = GetFastValue(config, 'useHandCursor', false);\r\n\r\n            pixelPerfect = GetFastValue(config, 'pixelPerfect', false);\r\n            var alphaTolerance = GetFastValue(config, 'alphaTolerance', 1);\r\n\r\n            if (pixelPerfect)\r\n            {\r\n                hitArea = {};\r\n                hitAreaCallback = this.makePixelPerfect(alphaTolerance);\r\n            }\r\n\r\n            //  Still no hitArea or callback?\r\n            if (!hitArea || !hitAreaCallback)\r\n            {\r\n                this.setHitAreaFromTexture(gameObjects);\r\n                customHitArea = false;\r\n            }\r\n        }\r\n        else if (typeof hitArea === 'function' && !hitAreaCallback)\r\n        {\r\n            hitAreaCallback = hitArea;\r\n            hitArea = {};\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            if (pixelPerfect && gameObject.type === 'Container')\r\n            {\r\n                console.warn('Cannot pixelPerfect test a Container. Use a custom callback.');\r\n                continue;\r\n            }\r\n\r\n            var io = (!gameObject.input) ? CreateInteractiveObject(gameObject, hitArea, hitAreaCallback) : gameObject.input;\r\n\r\n            io.customHitArea = customHitArea;\r\n            io.dropZone = dropZone;\r\n            io.cursor = (useHandCursor) ? 'pointer' : cursor;\r\n\r\n            gameObject.input = io;\r\n\r\n            if (draggable)\r\n            {\r\n                this.setDraggable(gameObject);\r\n            }\r\n\r\n            this.queueForInsertion(gameObject);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Circle` shape, using\r\n     * the given coordinates and radius to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a circle hit area.\r\n     * @param {number} x - The center of the circle.\r\n     * @param {number} y - The center of the circle.\r\n     * @param {number} radius - The radius of the circle.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Circle.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaCircle: function (gameObjects, x, y, radius, callback)\r\n    {\r\n        if (callback === undefined) { callback = CircleContains; }\r\n\r\n        var shape = new Circle(x, y, radius);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Ellipse` shape, using\r\n     * the given coordinates and dimensions to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaEllipse\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n     * @param {number} x - The center of the ellipse.\r\n     * @param {number} y - The center of the ellipse.\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Ellipse.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaEllipse: function (gameObjects, x, y, width, height, callback)\r\n    {\r\n        if (callback === undefined) { callback = EllipseContains; }\r\n\r\n        var shape = new Ellipse(x, y, width, height);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n     * the Game Objects texture frame to define the position and size of the hit area.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaFromTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaFromTexture: function (gameObjects, callback)\r\n    {\r\n        if (callback === undefined) { callback = RectangleContains; }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            var frame = gameObject.frame;\r\n\r\n            var width = 0;\r\n            var height = 0;\r\n\r\n            if (gameObject.width)\r\n            {\r\n                width = gameObject.width;\r\n                height = gameObject.height;\r\n            }\r\n            else if (frame)\r\n            {\r\n                width = frame.realWidth;\r\n                height = frame.realHeight;\r\n            }\r\n\r\n            if (gameObject.type === 'Container' && (width === 0 || height === 0))\r\n            {\r\n                console.warn('Container.setInteractive must specify a Shape or call setSize() first');\r\n                continue;\r\n            }\r\n\r\n            if (width !== 0 && height !== 0)\r\n            {\r\n                gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);\r\n\r\n                this.queueForInsertion(gameObject);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n     * the given coordinates and dimensions to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a rectangular hit area.\r\n     * @param {number} x - The top-left of the rectangle.\r\n     * @param {number} y - The top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaRectangle: function (gameObjects, x, y, width, height, callback)\r\n    {\r\n        if (callback === undefined) { callback = RectangleContains; }\r\n\r\n        var shape = new Rectangle(x, y, width, height);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Triangle` shape, using\r\n     * the given coordinates to control the position of its points.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a  triangular hit area.\r\n     * @param {number} x1 - The x coordinate of the first point of the triangle.\r\n     * @param {number} y1 - The y coordinate of the first point of the triangle.\r\n     * @param {number} x2 - The x coordinate of the second point of the triangle.\r\n     * @param {number} y2 - The y coordinate of the second point of the triangle.\r\n     * @param {number} x3 - The x coordinate of the third point of the triangle.\r\n     * @param {number} y3 - The y coordinate of the third point of the triangle.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Triangle.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaTriangle: function (gameObjects, x1, y1, x2, y2, x3, y3, callback)\r\n    {\r\n        if (callback === undefined) { callback = TriangleContains; }\r\n\r\n        var shape = new Triangle(x1, y1, x2, y2, x3, y3);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Creates an Input Debug Shape for the given Game Object.\r\n     *\r\n     * The Game Object must have _already_ been enabled for input prior to calling this method.\r\n     *\r\n     * This is intended to assist you during development and debugging.\r\n     *\r\n     * Debug Shapes can only be created for Game Objects that are using standard Phaser Geometry for input,\r\n     * including: Circle, Ellipse, Line, Polygon, Rectangle and Triangle.\r\n     *\r\n     * Game Objects that are using their automatic hit areas are using Rectangles by default, so will also work.\r\n     *\r\n     * The Debug Shape is created and added to the display list and is then kept in sync with the Game Object\r\n     * it is connected with. Should you need to modify it yourself, such as to hide it, you can access it via\r\n     * the Game Object property: `GameObject.input.hitAreaDebug`.\r\n     *\r\n     * Calling this method on a Game Object that already has a Debug Shape will first destroy the old shape,\r\n     * before creating a new one. If you wish to remove the Debug Shape entirely, you should call the\r\n     * method `InputPlugin.removeDebug`.\r\n     *\r\n     * Note that the debug shape will only show the outline of the input area. If the input test is using a\r\n     * pixel perfect check, for example, then this is not displayed. If you are using a custom shape, that\r\n     * doesn't extend one of the base Phaser Geometry objects, as your hit area, then this method will not\r\n     * work.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#enableDebug\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to create the input debug shape for.\r\n     * @param {number} [color=0x00ff00] - The outline color of the debug shape.\r\n     *\r\n     * @return {this} This Input Plugin.\r\n     */\r\n    enableDebug: function (gameObject, color)\r\n    {\r\n        if (color === undefined) { color = 0x00ff00; }\r\n\r\n        var input = gameObject.input;\r\n\r\n        if (!input || !input.hitArea)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var shape = input.hitArea;\r\n        var shapeType = shape.type;\r\n        var debug = input.hitAreaDebug;\r\n        var factory = this.systems.add;\r\n        var updateList = this.systems.updateList;\r\n\r\n        if (debug)\r\n        {\r\n            updateList.remove(debug);\r\n\r\n            debug.destroy();\r\n\r\n            debug = null;\r\n        }\r\n\r\n        var offsetx = 0;\r\n        var offsety = 0;\r\n        switch (shapeType)\r\n        {\r\n            case GEOM_CONST.CIRCLE:\r\n                debug = factory.arc(0, 0, shape.radius);\r\n                offsetx = shape.x - shape.radius;\r\n                offsety = shape.y - shape.radius;\r\n                break;\r\n\r\n            case GEOM_CONST.ELLIPSE:\r\n                debug = factory.ellipse(0, 0, shape.width, shape.height);\r\n                offsetx = shape.x - shape.width / 2;\r\n                offsety = shape.y - shape.height / 2;\r\n                break;\r\n\r\n            case GEOM_CONST.LINE:\r\n                debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);\r\n                break;\r\n\r\n            case GEOM_CONST.POLYGON:\r\n                debug = factory.polygon(0, 0, shape.points);\r\n                break;\r\n\r\n            case GEOM_CONST.RECTANGLE:\r\n                debug = factory.rectangle(0, 0, shape.width, shape.height);\r\n                offsetx = shape.x;\r\n                offsety = shape.y;\r\n                break;\r\n\r\n            case GEOM_CONST.TRIANGLE:\r\n                debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);\r\n                break;\r\n        }\r\n\r\n        if (debug)\r\n        {\r\n            debug.isFilled = false;\r\n\r\n            debug.preUpdate = function ()\r\n            {\r\n                debug.setStrokeStyle(1 / gameObject.scale, color);\r\n\r\n                debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);\r\n\r\n                var x = gameObject.x;\r\n                var y = gameObject.y;\r\n                var rotation = gameObject.rotation;\r\n                var scaleX = gameObject.scaleX;\r\n                var scaleY = gameObject.scaleY;\r\n\r\n                if (gameObject.parentContainer)\r\n                {\r\n                    var matrix = gameObject.getWorldTransformMatrix();\r\n\r\n                    x = matrix.tx;\r\n                    y = matrix.ty;\r\n                    rotation = matrix.rotation;\r\n                    scaleX = matrix.scaleX;\r\n                    scaleY = matrix.scaleY;\r\n                }\r\n\r\n                debug.setRotation(rotation);\r\n                debug.setScale(scaleX, scaleY);\r\n                debug.setPosition(x + offsetx, y + offsety);\r\n                debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY);\r\n                debug.setDepth(gameObject.depth);\r\n            };\r\n\r\n            updateList.add(debug);\r\n\r\n            input.hitAreaDebug = debug;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes an Input Debug Shape from the given Game Object.\r\n     *\r\n     * The shape is destroyed immediately and the `hitAreaDebug` property is set to `null`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#removeDebug\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to remove the input debug shape from.\r\n     *\r\n     * @return {this} This Input Plugin.\r\n     */\r\n    removeDebug: function (gameObject)\r\n    {\r\n        var input = gameObject.input;\r\n\r\n        if (input && input.hitAreaDebug)\r\n        {\r\n            var debug = input.hitAreaDebug;\r\n\r\n            this.systems.updateList.remove(debug);\r\n\r\n            debug.destroy();\r\n\r\n            input.hitAreaDebug = null;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Pointers to always poll.\r\n     *\r\n     * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n     * or being interacted with it, regardless if the Pointer has actually moved or not.\r\n     *\r\n     * You should enable this if you want objects in your game to fire over / out events, and the objects\r\n     * are constantly moving, but the pointer may not have. Polling every frame has additional computation\r\n     * costs, especially if there are a large number of interactive objects in your game.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollAlways\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setPollAlways: function ()\r\n    {\r\n        return this.setPollRate(0);\r\n    },\r\n\r\n    /**\r\n     * Sets the Pointers to only poll when they are moved or updated.\r\n     *\r\n     * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n     * or being interacted with it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollOnMove\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setPollOnMove: function ()\r\n    {\r\n        return this.setPollRate(-1);\r\n    },\r\n\r\n    /**\r\n     * Sets the poll rate value. This is the amount of time that should have elapsed before a pointer\r\n     * will be polled again. See the `setPollAlways` and `setPollOnMove` methods.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollRate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount of time, in ms, that should elapsed before re-polling the pointers.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setPollRate: function (value)\r\n    {\r\n        this.pollRate = value;\r\n        this._pollTimer = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When set to `true` the global Input Manager will emulate DOM behavior by only emitting events from\r\n     * the top-most Scene in the Scene List. By default, if a Scene receives an input event it will then stop the event\r\n     * from flowing down to any Scenes below it in the Scene list. To disable this behavior call this method with `false`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setGlobalTopOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - Set to `true` to stop processing input events on the Scene that receives it, or `false` to let the event continue down the Scene list.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setGlobalTopOnly: function (value)\r\n    {\r\n        this.manager.globalTopOnly = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When set to `true` this Input Plugin will emulate DOM behavior by only emitting events from\r\n     * the top-most Game Objects in the Display List.\r\n     *\r\n     * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setTopOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to only include the top-most Game Object, or `false` to include all Game Objects in a hit test.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setTopOnly: function (value)\r\n    {\r\n        this.topOnly = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Given an array of Game Objects and a Pointer, sort the array and return it,\r\n     * so that the objects are in render order with the lowest at the bottom.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortGameObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} gameObjects - An array of Game Objects to be sorted.\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The sorted array of Game Objects.\r\n     */\r\n    sortGameObjects: function (gameObjects, pointer)\r\n    {\r\n        if (gameObjects.length < 2)\r\n        {\r\n            return gameObjects;\r\n        }\r\n\r\n        var list = pointer.camera.renderList;\r\n\r\n        return gameObjects.sort(function (childA, childB)\r\n        {\r\n            return list.indexOf(childB) - list.indexOf(childA);\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Given an array of Drop Zone Game Objects, sort the array and return it,\r\n     * so that the objects are in depth index order with the lowest at the bottom.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortDropZones\r\n     * @since 3.52.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} gameObjects - An array of Game Objects to be sorted.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The sorted array of Game Objects.\r\n     */\r\n    sortDropZones: function (gameObjects)\r\n    {\r\n        if (gameObjects.length < 2)\r\n        {\r\n            return gameObjects;\r\n        }\r\n\r\n        this.scene.sys.depthSort();\r\n\r\n        return gameObjects.sort(this.sortDropZoneHandler.bind(this));\r\n    },\r\n\r\n    /**\r\n     * Return the child lowest down the display list (with the smallest index)\r\n     * Will iterate through all parent containers, if present.\r\n     *\r\n     * Prior to version 3.52.0 this method was called `sortHandlerGO`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortDropZoneHandler\r\n     * @private\r\n     * @since 3.52.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - The first Game Object to compare.\r\n     * @param {Phaser.GameObjects.GameObject} childB - The second Game Object to compare.\r\n     *\r\n     * @return {number} Returns either a negative or positive integer, or zero if they match.\r\n     */\r\n    sortDropZoneHandler: function (childA, childB)\r\n    {\r\n        if (!childA.parentContainer && !childB.parentContainer)\r\n        {\r\n            //  Quick bail out when neither child has a container\r\n            return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);\r\n        }\r\n        else if (childA.parentContainer === childB.parentContainer)\r\n        {\r\n            //  Quick bail out when both children have the same container\r\n            return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);\r\n        }\r\n        else if (childA.parentContainer === childB)\r\n        {\r\n            //  Quick bail out when childA is a child of childB\r\n            return -1;\r\n        }\r\n        else if (childB.parentContainer === childA)\r\n        {\r\n            //  Quick bail out when childA is a child of childB\r\n            return 1;\r\n        }\r\n        else\r\n        {\r\n            //  Container index check\r\n            var listA = childA.getIndexList();\r\n            var listB = childB.getIndexList();\r\n            var len = Math.min(listA.length, listB.length);\r\n\r\n            for (var i = 0; i < len; i++)\r\n            {\r\n                var indexA = listA[i];\r\n                var indexB = listB[i];\r\n\r\n                if (indexA === indexB)\r\n                {\r\n                    //  Go to the next level down\r\n                    continue;\r\n                }\r\n                else\r\n                {\r\n                    //  Non-matching parents, so return\r\n                    return indexB - indexA;\r\n                }\r\n            }\r\n\r\n            return listB.length - listA.length;\r\n        }\r\n\r\n        //  Technically this shouldn't happen, but ...\r\n        // eslint-disable-next-line no-unreachable\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * This method should be called from within an input event handler, such as `pointerdown`.\r\n     *\r\n     * When called, it stops the Input Manager from allowing _this specific event_ to be processed by any other Scene\r\n     * not yet handled in the scene list.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#stopPropagation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    stopPropagation: function ()\r\n    {\r\n        this.manager._tempSkip = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds new Pointer objects to the Input Manager.\r\n     *\r\n     * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.\r\n     *\r\n     * You can create more either by calling this method, or by setting the `input.activePointers` property\r\n     * in the Game Config, up to a maximum of 10 pointers.\r\n     *\r\n     * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added\r\n     * via this method.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#addPointer\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.\r\n     *\r\n     * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.\r\n     */\r\n    addPointer: function (quantity)\r\n    {\r\n        return this.manager.addPointer(quantity);\r\n    },\r\n\r\n    /**\r\n     * Tells the Input system to set a custom cursor.\r\n     *\r\n     * This cursor will be the default cursor used when interacting with the game canvas.\r\n     *\r\n     * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.\r\n     *\r\n     * Any valid CSS cursor value is allowed, including paths to image files, i.e.:\r\n     *\r\n     * ```javascript\r\n     * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');\r\n     * ```\r\n     *\r\n     * Please read about the differences between browsers when it comes to the file formats and sizes they support:\r\n     *\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property\r\n     *\r\n     * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDefaultCursor\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} cursor - The CSS to be used when setting the default cursor.\r\n     *\r\n     * @return {this} This Input instance.\r\n     */\r\n    setDefaultCursor: function (cursor)\r\n    {\r\n        this.manager.setDefaultCursor(cursor);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is transitioning in.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionIn\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionIn: function ()\r\n    {\r\n        this.enabled = this.settings.transitionAllowInput;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin has finished transitioning in.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionComplete\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionComplete: function ()\r\n    {\r\n        if (!this.settings.transitionAllowInput)\r\n        {\r\n            this.enabled = true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is transitioning out.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionOut\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionOut: function ()\r\n    {\r\n        this.enabled = this.settings.transitionAllowInput;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#shutdown\r\n     * @fires Phaser.Input.Events#SHUTDOWN\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.SHUTDOWN);\r\n\r\n        this._temp.length = 0;\r\n        this._list.length = 0;\r\n        this._draggable.length = 0;\r\n        this._pendingRemoval.length = 0;\r\n        this._pendingInsertion.length = 0;\r\n        this._dragState.length = 0;\r\n\r\n        for (var i = 0; i < 10; i++)\r\n        {\r\n            this._drag[i] = [];\r\n            this._over[i] = [];\r\n        }\r\n\r\n        this.removeAllListeners();\r\n\r\n        var manager = this.manager;\r\n\r\n        manager.canvas.style.cursor = manager.defaultCursor;\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);\r\n        eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);\r\n        eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);\r\n        eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);\r\n\r\n        manager.events.off(Events.GAME_OUT, this.onGameOut, this);\r\n        manager.events.off(Events.GAME_OVER, this.onGameOver, this);\r\n\r\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#destroy\r\n     * @fires Phaser.Input.Events#DESTROY\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.DESTROY);\r\n\r\n        this.pluginEvents.removeAllListeners();\r\n\r\n        this.scene.sys.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.cameras = null;\r\n        this.manager = null;\r\n        this.events = null;\r\n        this.mouse = null;\r\n    },\r\n\r\n    /**\r\n     * The x coordinates of the ActivePointer based on the first camera in the camera list.\r\n     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#x\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer.x;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y coordinates of the ActivePointer based on the first camera in the camera list.\r\n     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#y\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer.y;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Are any mouse or touch pointers currently over the game canvas?\r\n     *\r\n     * @name Phaser.Input.InputPlugin#isOver\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isOver: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.isOver;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.\r\n     * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`\r\n     * which will always map to the most recently interacted pointer.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#mousePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    mousePointer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.mousePointer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The current active input Pointer.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#activePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    activePointer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer1\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[1];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer2\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[2];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer3\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer3: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[3];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer4\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer4: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[4];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer5\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer5: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[5];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer6\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer6: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[6];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer7\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer7: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[7];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer8\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer8: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[8];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer9\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer9: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[9];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer10\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer10: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[10];\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('InputPlugin', InputPlugin, 'input');\r\n\r\nmodule.exports = InputPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Keyboard\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Events: require('./events'),\r\n\r\n    KeyboardManager: require('./KeyboardManager'),\r\n    KeyboardPlugin: require('./KeyboardPlugin'),\r\n\r\n    Key: require('./keys/Key'),\r\n    KeyCodes: require('./keys/KeyCodes'),\r\n\r\n    KeyCombo: require('./combo/KeyCombo'),\r\n\r\n    AdvanceKeyCombo: require('./combo/AdvanceKeyCombo'),\r\n    ProcessKeyCombo: require('./combo/ProcessKeyCombo'),\r\n    ResetKeyCombo: require('./combo/ResetKeyCombo'),\r\n\r\n    JustDown: require('./keys/JustDown'),\r\n    JustUp: require('./keys/JustUp'),\r\n    DownDuration: require('./keys/DownDuration'),\r\n    UpDuration: require('./keys/UpDuration')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Global Key Down Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.keyboard.on('keydown', listener)`.\r\n * \r\n * You can also listen for a specific key being pressed. See [Keyboard.Events.KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_DOWN} for details.\r\n * \r\n * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.\r\n * \r\n * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\r\n * Read [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.\r\n *\r\n * Also, please be aware that some browser extensions can disable or override Phaser keyboard handling.\r\n * For example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\r\n * There are others. So, please check your extensions if you find you have specific keys that don't work.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#ANY_KEY_DOWN\r\n * @since 3.0.0\r\n * \r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was pressed, any modifiers, etc.\r\n */\r\nmodule.exports = 'keydown';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Global Key Up Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when any key on the keyboard is released.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.keyboard.on('keyup', listener)`.\r\n * \r\n * You can also listen for a specific key being released. See [Keyboard.Events.KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_UP} for details.\r\n * \r\n * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#ANY_KEY_UP\r\n * @since 3.0.0\r\n * \r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was released, any modifiers, etc.\r\n */\r\nmodule.exports = 'keyup';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Combo Match Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when a [Key Combo]{@link Phaser.Input.Keyboard.KeyCombo} is matched.\r\n * \r\n * Listen for this event from the Key Plugin after a combo has been created:\r\n * \r\n * ```javascript\r\n * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n *\r\n * this.input.keyboard.on('keycombomatch', function (event) {\r\n *     console.log('Konami Code entered!');\r\n * });\r\n * ```\r\n *\r\n * @event Phaser.Input.Keyboard.Events#COMBO_MATCH\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Keyboard.KeyCombo} keycombo - The Key Combo object that was matched.\r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event of the final key in the combo. You can inspect this to learn more about any modifiers, etc.\r\n */\r\nmodule.exports = 'keycombomatch';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Down Event.\r\n * \r\n * This event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is pressed.\r\n * \r\n * Listen for this event from the Key object instance directly:\r\n * \r\n * ```javascript\r\n * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\r\n * \r\n * spaceBar.on('down', listener)\r\n * ```\r\n * \r\n * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#DOWN\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Keyboard.Key} key - The Key object that was pressed.\r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about any modifiers, etc.\r\n */\r\nmodule.exports = 'down';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Down Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.\r\n * \r\n * Unlike the `ANY_KEY_DOWN` event, this one has a special dynamic event name. For example, to listen for the `A` key being pressed\r\n * use the following from within a Scene: `this.input.keyboard.on('keydown-A', listener)`. You can replace the `-A` part of the event\r\n * name with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar: \r\n * `this.input.keyboard.on('keydown-SPACE', listener)`.\r\n * \r\n * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.\r\n * \r\n * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.\r\n * \r\n * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\r\n * Read [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.\r\n *\r\n * Also, please be aware that some browser extensions can disable or override Phaser keyboard handling.\r\n * For example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\r\n * There are others. So, please check your extensions if you find you have specific keys that don't work.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#KEY_DOWN\r\n * @since 3.0.0\r\n * \r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was pressed, any modifiers, etc.\r\n */\r\nmodule.exports = 'keydown-';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Up Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when any key on the keyboard is released.\r\n * \r\n * Unlike the `ANY_KEY_UP` event, this one has a special dynamic event name. For example, to listen for the `A` key being released\r\n * use the following from within a Scene: `this.input.keyboard.on('keyup-A', listener)`. You can replace the `-A` part of the event\r\n * name with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar: \r\n * `this.input.keyboard.on('keyup-SPACE', listener)`.\r\n * \r\n * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.\r\n * \r\n * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#KEY_UP\r\n * @since 3.0.0\r\n * \r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was released, any modifiers, etc.\r\n */\r\nmodule.exports = 'keyup-';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Up Event.\r\n * \r\n * This event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is released.\r\n * \r\n * Listen for this event from the Key object instance directly:\r\n * \r\n * ```javascript\r\n * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\r\n * \r\n * spaceBar.on('up', listener)\r\n * ```\r\n * \r\n * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#UP\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Keyboard.Key} key - The Key object that was released.\r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about any modifiers, etc.\r\n */\r\nmodule.exports = 'up';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../../core/events');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar InputEvents = require('../events');\r\nvar InputPluginCache = require('../InputPluginCache');\r\nvar Key = require('./keys/Key');\r\nvar KeyCodes = require('./keys/KeyCodes');\r\nvar KeyCombo = require('./combo/KeyCombo');\r\nvar KeyMap = require('./keys/KeyMap');\r\nvar SceneEvents = require('../../scene/events');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\n/**\r\n * @classdesc\r\n * The Keyboard Plugin is an input plugin that belongs to the Scene-owned Input system.\r\n *\r\n * Its role is to listen for native DOM Keyboard Events and then process them.\r\n *\r\n * You do not need to create this class directly, the Input system will create an instance of it automatically.\r\n *\r\n * You can access it from within a Scene using `this.input.keyboard`. For example, you can do:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.on('keydown', callback, context);\r\n * ```\r\n *\r\n * Or, to listen for a specific key:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.on('keydown-A', callback, context);\r\n * ```\r\n *\r\n * You can also create Key objects, which you can then poll in your game loop:\r\n *\r\n * ```javascript\r\n * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\r\n * ```\r\n *\r\n * If you have multiple parallel Scenes, each trying to get keyboard input, be sure to disable capture on them to stop them from\r\n * stealing input from another Scene in the list. You can do this with `this.input.keyboard.enabled = false` within the\r\n * Scene to stop all input, or `this.input.keyboard.preventDefault = false` to stop a Scene halting input on another Scene.\r\n *\r\n * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\r\n * See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.\r\n *\r\n * Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.\r\n * For example the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\r\n * And there are others. So, please check your extensions before opening Phaser issues about keys that don't work.\r\n *\r\n * @class KeyboardPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Input.InputPlugin} sceneInputPlugin - A reference to the Scene Input Plugin that the KeyboardPlugin belongs to.\r\n */\r\nvar KeyboardPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function KeyboardPlugin (sceneInputPlugin)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the core game, so we can listen for visibility events.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.16.0\r\n         */\r\n        this.game = sceneInputPlugin.systems.game;\r\n\r\n        /**\r\n         * A reference to the Scene that this Input Plugin is responsible for.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.10.0\r\n         */\r\n        this.scene = sceneInputPlugin.scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems Settings.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.10.0\r\n         */\r\n        this.settings = this.scene.sys.settings;\r\n\r\n        /**\r\n         * A reference to the Scene Input Plugin that created this Keyboard Plugin.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#sceneInputPlugin\r\n         * @type {Phaser.Input.InputPlugin}\r\n         * @since 3.10.0\r\n         */\r\n        this.sceneInputPlugin = sceneInputPlugin;\r\n\r\n        /**\r\n         * A reference to the global Keyboard Manager.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#manager\r\n         * @type {Phaser.Input.Keyboard.KeyboardManager}\r\n         * @since 3.16.0\r\n         */\r\n        this.manager = sceneInputPlugin.manager.keyboard;\r\n\r\n        /**\r\n         * A boolean that controls if this Keyboard Plugin is enabled or not.\r\n         * Can be toggled on the fly.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.10.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * An array of Key objects to process.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#keys\r\n         * @type {Phaser.Input.Keyboard.Key[]}\r\n         * @since 3.10.0\r\n         */\r\n        this.keys = [];\r\n\r\n        /**\r\n         * An array of KeyCombo objects to process.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#combos\r\n         * @type {Phaser.Input.Keyboard.KeyCombo[]}\r\n         * @since 3.10.0\r\n         */\r\n        this.combos = [];\r\n\r\n        /**\r\n         * Internal repeat key flag.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#prevCode\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.prevCode = null;\r\n\r\n        /**\r\n         * Internal repeat key flag.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#prevTime\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.prevTime = 0;\r\n\r\n        /**\r\n         * Internal repeat key flag.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#prevType\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.50.1\r\n         */\r\n        this.prevType = null;\r\n\r\n        sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);\r\n        sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#boot\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var settings = this.settings.input;\r\n\r\n        this.enabled = GetValue(settings, 'keyboard', true);\r\n\r\n        var captures = GetValue(settings, 'keyboard.capture', null);\r\n\r\n        if (captures)\r\n        {\r\n            this.addCaptures(captures);\r\n        }\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#start\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    start: function ()\r\n    {\r\n        this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this);\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);\r\n\r\n        this.game.events.on(GameEvents.BLUR, this.resetKeys, this);\r\n\r\n        this.scene.sys.events.on(SceneEvents.PAUSE, this.resetKeys, this);\r\n        this.scene.sys.events.on(SceneEvents.SLEEP, this.resetKeys, this);\r\n    },\r\n\r\n    /**\r\n     * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#isActive\r\n     * @since 3.10.0\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.enabled && this.scene.sys.isActive());\r\n    },\r\n\r\n    /**\r\n     * By default when a key is pressed Phaser will not stop the event from propagating up to the browser.\r\n     * There are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.\r\n     *\r\n     * This `addCapture` method enables consuming keyboard events for specific keys, so they don't bubble up the browser\r\n     * and cause the default behaviors.\r\n     *\r\n     * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to say prevent\r\n     * the SPACE BAR from triggering a page scroll, then it will prevent it for any Scene in your game, not just the calling one.\r\n     *\r\n     * You can pass a single key code value:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addCapture(62);\r\n     * ```\r\n     *\r\n     * An array of key codes:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addCapture([ 62, 63, 64 ]);\r\n     * ```\r\n     *\r\n     * Or, a comma-delimited string:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addCapture('W,S,A,D');\r\n     * ```\r\n     *\r\n     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n     *\r\n     * You can also provide an array mixing both strings and key code integers.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#addCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(string|number|number[]|any[])} keycode - The Key Codes to enable event capture for.\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    addCapture: function (keycode)\r\n    {\r\n        this.manager.addCapture(keycode);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes an existing key capture.\r\n     *\r\n     * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to remove\r\n     * the capture of a key, then it will remove it for any Scene in your game, not just the calling one.\r\n     *\r\n     * You can pass a single key code value:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.removeCapture(62);\r\n     * ```\r\n     *\r\n     * An array of key codes:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.removeCapture([ 62, 63, 64 ]);\r\n     * ```\r\n     *\r\n     * Or, a comma-delimited string:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.removeCapture('W,S,A,D');\r\n     * ```\r\n     *\r\n     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n     *\r\n     * You can also provide an array mixing both strings and key code integers.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(string|number|number[]|any[])} keycode - The Key Codes to disable event capture for.\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    removeCapture: function (keycode)\r\n    {\r\n        this.manager.removeCapture(keycode);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns an array that contains all of the keyboard captures currently enabled.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#getCaptures\r\n     * @since 3.16.0\r\n     *\r\n     * @return {number[]} An array of all the currently capturing key codes.\r\n     */\r\n    getCaptures: function ()\r\n    {\r\n        return this.manager.captures;\r\n    },\r\n\r\n    /**\r\n     * Allows Phaser to prevent any key captures you may have defined from bubbling up the browser.\r\n     * You can use this to re-enable event capturing if you had paused it via `disableGlobalCapture`.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#enableGlobalCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    enableGlobalCapture: function ()\r\n    {\r\n        this.manager.preventDefault = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Disables Phaser from preventing any key captures you may have defined, without actually removing them.\r\n     * You can use this to temporarily disable event capturing if, for example, you swap to a DOM element.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#disableGlobalCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    disableGlobalCapture: function ()\r\n    {\r\n        this.manager.preventDefault = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all keyboard captures.\r\n     *\r\n     * Note that this is a global change. It will clear all event captures across your game, not just for this specific Scene.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#clearCaptures\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    clearCaptures: function ()\r\n    {\r\n        this.manager.clearCaptures();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right, and also Space Bar and shift.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#createCursorKeys\r\n     * @since 3.10.0\r\n     *\r\n     * @return {Phaser.Types.Input.Keyboard.CursorKeys} An object containing the properties: `up`, `down`, `left`, `right`, `space` and `shift`.\r\n     */\r\n    createCursorKeys: function ()\r\n    {\r\n        return this.addKeys({\r\n            up: KeyCodes.UP,\r\n            down: KeyCodes.DOWN,\r\n            left: KeyCodes.LEFT,\r\n            right: KeyCodes.RIGHT,\r\n            space: KeyCodes.SPACE,\r\n            shift: KeyCodes.SHIFT\r\n        });\r\n    },\r\n\r\n    /**\r\n     * A practical way to create an object containing user selected hotkeys.\r\n     *\r\n     * For example:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addKeys({ 'up': Phaser.Input.Keyboard.KeyCodes.W, 'down': Phaser.Input.Keyboard.KeyCodes.S });\r\n     * ```\r\n     *\r\n     * would return an object containing the properties (`up` and `down`) mapped to W and S {@link Phaser.Input.Keyboard.Key} objects.\r\n     *\r\n     * You can also pass in a comma-separated string:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addKeys('W,S,A,D');\r\n     * ```\r\n     *\r\n     * Which will return an object with the properties W, S, A and D mapped to the relevant Key objects.\r\n     *\r\n     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#addKeys\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(object|string)} keys - An object containing Key Codes, or a comma-separated string.\r\n     * @param {boolean} [enableCapture=true] - Automatically call `preventDefault` on the native DOM browser event for the key codes being added.\r\n     * @param {boolean} [emitOnRepeat=false] - Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default).\r\n     *\r\n     * @return {object} An object containing Key objects mapped to the input properties.\r\n     */\r\n    addKeys: function (keys, enableCapture, emitOnRepeat)\r\n    {\r\n        if (enableCapture === undefined) { enableCapture = true; }\r\n        if (emitOnRepeat === undefined) { emitOnRepeat = false; }\r\n\r\n        var output = {};\r\n\r\n        if (typeof keys === 'string')\r\n        {\r\n            keys = keys.split(',');\r\n\r\n            for (var i = 0; i < keys.length; i++)\r\n            {\r\n                var currentKey = keys[i].trim();\r\n\r\n                if (currentKey)\r\n                {\r\n                    output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat);\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (var key in keys)\r\n            {\r\n                output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Adds a Key object to this Keyboard Plugin.\r\n     *\r\n     * The given argument can be either an existing Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     *\r\n     * If a Key object is given, and one already exists matching the same key code, the existing one is replaced with the new one.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#addKey\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(Phaser.Input.Keyboard.Key|string|number)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     * @param {boolean} [enableCapture=true] - Automatically call `preventDefault` on the native DOM browser event for the key codes being added.\r\n     * @param {boolean} [emitOnRepeat=false] - Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default).\r\n     *\r\n     * @return {Phaser.Input.Keyboard.Key} The newly created Key object, or a reference to it if it already existed in the keys array.\r\n     */\r\n    addKey: function (key, enableCapture, emitOnRepeat)\r\n    {\r\n        if (enableCapture === undefined) { enableCapture = true; }\r\n        if (emitOnRepeat === undefined) { emitOnRepeat = false; }\r\n\r\n        var keys = this.keys;\r\n\r\n        if (key instanceof Key)\r\n        {\r\n            var idx = keys.indexOf(key);\r\n\r\n            if (idx > -1)\r\n            {\r\n                keys[idx] = key;\r\n            }\r\n            else\r\n            {\r\n                keys[key.keyCode] = key;\r\n            }\r\n\r\n            if (enableCapture)\r\n            {\r\n                this.addCapture(key.keyCode);\r\n            }\r\n\r\n            key.setEmitOnRepeat(emitOnRepeat);\r\n\r\n            return key;\r\n        }\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            key = KeyCodes[key.toUpperCase()];\r\n        }\r\n\r\n        if (!keys[key])\r\n        {\r\n            keys[key] = new Key(this, key);\r\n\r\n            if (enableCapture)\r\n            {\r\n                this.addCapture(key);\r\n            }\r\n\r\n            keys[key].setEmitOnRepeat(emitOnRepeat);\r\n        }\r\n\r\n        return keys[key];\r\n    },\r\n\r\n    /**\r\n     * Removes a Key object from this Keyboard Plugin.\r\n     *\r\n     * The given argument can be either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeKey\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(Phaser.Input.Keyboard.Key|string|number)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     * @param {boolean} [destroy=false] - Call `Key.destroy` on the removed Key object?\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    removeKey: function (key, destroy)\r\n    {\r\n        if (destroy === undefined) { destroy = false; }\r\n\r\n        var keys = this.keys;\r\n        var ref;\r\n\r\n        if (key instanceof Key)\r\n        {\r\n            var idx = keys.indexOf(key);\r\n\r\n            if (idx > -1)\r\n            {\r\n                ref = this.keys[idx];\r\n\r\n                this.keys[idx] = undefined;\r\n            }\r\n        }\r\n        else if (typeof key === 'string')\r\n        {\r\n            key = KeyCodes[key.toUpperCase()];\r\n        }\r\n\r\n        if (keys[key])\r\n        {\r\n            ref = keys[key];\r\n\r\n            keys[key] = undefined;\r\n        }\r\n\r\n        if (ref)\r\n        {\r\n            ref.plugin = null;\r\n\r\n            if (destroy)\r\n            {\r\n                ref.destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all Key objects created by _this_ Keyboard Plugin.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeAllKeys\r\n     * @since 3.24.0\r\n     *\r\n     * @param {boolean} [destroy=false] - Call `Key.destroy` on each removed Key object?\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    removeAllKeys: function (destroy)\r\n    {\r\n        var keys = this.keys;\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            var key = keys[i];\r\n\r\n            if (key)\r\n            {\r\n                keys[i] = undefined;\r\n\r\n                if (destroy)\r\n                {\r\n                    key.destroy();\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a new KeyCombo.\r\n     *\r\n     * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them\r\n     * it will emit a `keycombomatch` event from this Keyboard Plugin.\r\n     *\r\n     * The keys to be listened for can be defined as:\r\n     *\r\n     * A string (i.e. 'ATARI')\r\n     * An array of either integers (key codes) or strings, or a mixture of both\r\n     * An array of objects (such as Key objects) with a public 'keyCode' property\r\n     *\r\n     * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)\r\n     * you could pass the following array of key codes:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n     *\r\n     * this.input.keyboard.on('keycombomatch', function (event) {\r\n     *     console.log('Konami Code entered!');\r\n     * });\r\n     * ```\r\n     *\r\n     * Or, to listen for the user entering the word PHASER:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.createCombo('PHASER');\r\n     * ```\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#createCombo\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(string|number[]|object[])} keys - The keys that comprise this combo.\r\n     * @param {Phaser.Types.Input.Keyboard.KeyComboConfig} [config] - A Key Combo configuration object.\r\n     *\r\n     * @return {Phaser.Input.Keyboard.KeyCombo} The new KeyCombo object.\r\n     */\r\n    createCombo: function (keys, config)\r\n    {\r\n        return new KeyCombo(this, keys, config);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Key object is currently being held down.\r\n     *\r\n     * The difference between this method and checking the `Key.isDown` property directly is that you can provide\r\n     * a duration to this method. For example, if you wanted a key press to fire a bullet, but you only wanted\r\n     * it to be able to fire every 100ms, then you can call this method with a `duration` of 100 and it\r\n     * will only return `true` every 100ms.\r\n     *\r\n     * If the Keyboard Plugin has been disabled, this method will always return `false`.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#checkDown\r\n     * @since 3.11.0\r\n     *\r\n     * @param {Phaser.Input.Keyboard.Key} key - A Key object.\r\n     * @param {number} [duration=0] - The duration which must have elapsed before this Key is considered as being down.\r\n     *\r\n     * @return {boolean} `true` if the Key is down within the duration specified, otherwise `false`.\r\n     */\r\n    checkDown: function (key, duration)\r\n    {\r\n        if (duration === undefined) { duration = 0; }\r\n\r\n        if (this.enabled && key.isDown)\r\n        {\r\n            var t = SnapFloor(this.time - key.timeDown, duration);\r\n\r\n            if (t > key._tick)\r\n            {\r\n                key._tick = t;\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler called by the Input Plugin, which is in turn invoked by the Game step.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#update\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    update: function ()\r\n    {\r\n        var queue = this.manager.queue;\r\n        var len = queue.length;\r\n\r\n        if (!this.isActive() || len === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var keys = this.keys;\r\n\r\n        //  Process the event queue, dispatching all of the events that have stored up\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            var event = queue[i];\r\n            var code = event.keyCode;\r\n            var key = keys[code];\r\n            var repeat = false;\r\n\r\n            //  Override the default functions (it's too late for the browser to use them anyway, so we may as well)\r\n            if (event.cancelled === undefined)\r\n            {\r\n                //  Event allowed to flow across all handlers in this Scene, and any other Scene in the Scene list\r\n                event.cancelled = 0;\r\n\r\n                //  Won't reach any more local (Scene level) handlers\r\n                event.stopImmediatePropagation = function ()\r\n                {\r\n                    event.cancelled = 1;\r\n                };\r\n\r\n                //  Won't reach any more handlers in any Scene further down the Scene list\r\n                event.stopPropagation = function ()\r\n                {\r\n                    event.cancelled = -1;\r\n                };\r\n            }\r\n\r\n            if (event.cancelled === -1)\r\n            {\r\n                //  This event has been stopped from broadcasting to any other Scene, so abort.\r\n                continue;\r\n            }\r\n\r\n            //  Duplicate event bailout\r\n            if (code === this.prevCode && event.timeStamp === this.prevTime && event.type === this.prevType)\r\n            {\r\n                //  On some systems, the exact same event will fire multiple times. This prevents it.\r\n                continue;\r\n            }\r\n\r\n            this.prevCode = code;\r\n            this.prevTime = event.timeStamp;\r\n            this.prevType = event.type;\r\n\r\n            if (event.type === 'keydown')\r\n            {\r\n                //  Key specific callback first\r\n                if (key)\r\n                {\r\n                    repeat = key.isDown;\r\n\r\n                    key.onDown(event);\r\n                }\r\n\r\n                if (!event.cancelled && (!key || !repeat))\r\n                {\r\n                    if (KeyMap[code])\r\n                    {\r\n                        this.emit(Events.KEY_DOWN + KeyMap[code], event);\r\n                    }\r\n\r\n                    if (!event.cancelled)\r\n                    {\r\n                        this.emit(Events.ANY_KEY_DOWN, event);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Key specific callback first\r\n                if (key)\r\n                {\r\n                    key.onUp(event);\r\n                }\r\n\r\n                if (!event.cancelled)\r\n                {\r\n                    if (KeyMap[code])\r\n                    {\r\n                        this.emit(Events.KEY_UP + KeyMap[code], event);\r\n                    }\r\n\r\n                    if (!event.cancelled)\r\n                    {\r\n                        this.emit(Events.ANY_KEY_UP, event);\r\n                    }\r\n                }\r\n            }\r\n\r\n            //  Reset the cancel state for other Scenes to use\r\n            if (event.cancelled === 1)\r\n            {\r\n                event.cancelled = 0;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resets all Key objects created by _this_ Keyboard Plugin back to their default un-pressed states.\r\n     * This can only reset keys created via the `addKey`, `addKeys` or `createCursorKeys` methods.\r\n     * If you have created a Key object directly you'll need to reset it yourself.\r\n     *\r\n     * This method is called automatically when the Keyboard Plugin shuts down, but can be\r\n     * invoked directly at any time you require.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#resetKeys\r\n     * @since 3.15.0\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    resetKeys: function ()\r\n    {\r\n        var keys = this.keys;\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            //  Because it's a sparsely populated array\r\n            if (keys[i])\r\n            {\r\n                keys[i].reset();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuts this Keyboard Plugin down. This performs the following tasks:\r\n     *\r\n     * 1 - Removes all keys created by this Keyboard plugin.\r\n     * 2 - Stops and removes the keyboard event listeners.\r\n     * 3 - Clears out any pending requests in the queue, without processing them.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#shutdown\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.removeAllKeys(true);\r\n        this.removeAllListeners();\r\n\r\n        this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this);\r\n\r\n        this.game.events.off(GameEvents.BLUR, this.resetKeys);\r\n\r\n        this.scene.sys.events.off(SceneEvents.PAUSE, this.resetKeys, this);\r\n        this.scene.sys.events.off(SceneEvents.SLEEP, this.resetKeys, this);\r\n\r\n        this.queue = [];\r\n    },\r\n\r\n    /**\r\n     * Destroys this Keyboard Plugin instance and all references it holds, plus clears out local arrays.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#destroy\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        var keys = this.keys;\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            //  Because it's a sparsely populated array\r\n            if (keys[i])\r\n            {\r\n                keys[i].destroy();\r\n            }\r\n        }\r\n\r\n        this.keys = [];\r\n        this.combos = [];\r\n        this.queue = [];\r\n\r\n        this.scene = null;\r\n        this.settings = null;\r\n        this.sceneInputPlugin = null;\r\n        this.manager = null;\r\n    },\r\n\r\n    /**\r\n     * Internal time value.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyboardPlugin#time\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.11.0\r\n     */\r\n    time: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.sceneInputPlugin.manager.time;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * An instance of the Keyboard Plugin class, if enabled via the `input.keyboard` Scene or Game Config property.\r\n * Use this to create Key objects and listen for keyboard specific events.\r\n *\r\n * @name Phaser.Input.InputPlugin#keyboard\r\n * @type {?Phaser.Input.Keyboard.KeyboardPlugin}\r\n * @since 3.10.0\r\n */\r\nInputPluginCache.register('KeyboardPlugin', KeyboardPlugin, 'keyboard', 'keyboard', 'inputKeyboard');\r\n\r\nmodule.exports = KeyboardPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar KeyCodes = require('./KeyCodes');\r\n\r\nvar KeyMap = {};\r\n\r\nfor (var key in KeyCodes)\r\n{\r\n    KeyMap[KeyCodes[key]] = key;\r\n}\r\n\r\nmodule.exports = KeyMap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The justDown value allows you to test if this Key has just been pressed down or not.\r\n * \r\n * When you check this value it will return `true` if the Key is down, otherwise `false`.\r\n * \r\n * You can only call justDown once per key press. It will only return `true` once, until the Key is released and pressed down again.\r\n * This allows you to use it in situations where you want to check if this key is down without using an event, such as in a core game loop.\r\n *\r\n * @function Phaser.Input.Keyboard.JustDown\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - The Key to check to see if it's just down or not.\r\n *\r\n * @return {boolean} `true` if the Key was just pressed, otherwise `false`.\r\n */\r\nvar JustDown = function (key)\r\n{\r\n    if (key._justDown)\r\n    {\r\n        key._justDown = false;\r\n\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = JustDown;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The justUp value allows you to test if this Key has just been released or not.\r\n * \r\n * When you check this value it will return `true` if the Key is up, otherwise `false`.\r\n * \r\n * You can only call JustUp once per key release. It will only return `true` once, until the Key is pressed down and released again.\r\n * This allows you to use it in situations where you want to check if this key is up without using an event, such as in a core game loop.\r\n *\r\n * @function Phaser.Input.Keyboard.JustUp\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - The Key to check to see if it's just up or not.\r\n *\r\n * @return {boolean} `true` if the Key was just released, otherwise `false`.\r\n */\r\nvar JustUp = function (key)\r\n{\r\n    if (key._justUp)\r\n    {\r\n        key._justUp = false;\r\n\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = JustUp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns `true` if the Key was pressed down within the `duration` value given, based on the current\r\n * game clock time. Or `false` if it either isn't down, or was pressed down longer ago than the given duration.\r\n *\r\n * @function Phaser.Input.Keyboard.DownDuration\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - The Key object to test.\r\n * @param {number} [duration=50] - The duration, in ms, within which the key must have been pressed down.\r\n *\r\n * @return {boolean} `true` if the Key was pressed down within `duration` ms ago, otherwise `false`.\r\n */\r\nvar DownDuration = function (key, duration)\r\n{\r\n    if (duration === undefined) { duration = 50; }\r\n\r\n    var current = key.plugin.game.loop.time - key.timeDown;\r\n\r\n    return (key.isDown && current < duration);\r\n};\r\n\r\nmodule.exports = DownDuration;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns `true` if the Key was released within the `duration` value given, based on the current\r\n * game clock time. Or returns `false` if it either isn't up, or was released longer ago than the given duration.\r\n *\r\n * @function Phaser.Input.Keyboard.UpDuration\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - The Key object to test.\r\n * @param {number} [duration=50] - The duration, in ms, within which the key must have been released.\r\n *\r\n * @return {boolean} `true` if the Key was released within `duration` ms ago, otherwise `false`.\r\n */\r\nvar UpDuration = function (key, duration)\r\n{\r\n    if (duration === undefined) { duration = 50; }\r\n\r\n    var current = key.plugin.game.loop.time - key.timeUp;\r\n\r\n    return (key.isUp && current < duration);\r\n};\r\n\r\nmodule.exports = UpDuration;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Mouse\r\n */\r\n\r\n/* eslint-disable */\r\nmodule.exports = {\r\n\r\n    MouseManager: require('./MouseManager')\r\n       \r\n};\r\n/* eslint-enable */\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Touch\r\n */\r\n\r\n/* eslint-disable */\r\nmodule.exports = {\r\n\r\n    TouchManager: require('./TouchManager')\r\n       \r\n};\r\n/* eslint-enable */\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetValue = require('../utils/object/GetValue');\r\n\r\n//  Contains the plugins that Phaser uses globally and locally.\r\n//  These are the source objects, not instantiated.\r\nvar inputPlugins = {};\r\n\r\n/**\r\n * @namespace Phaser.Input.InputPluginCache\r\n */\r\n\r\nvar InputPluginCache = {};\r\n\r\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @function Phaser.Input.InputPluginCache.register\r\n * @static\r\n * @since 3.10.0\r\n *\r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Input Plugin, this is the property key used.\r\n * @param {string} settingsKey - The key in the Scene Settings to check to see if this plugin should install or not.\r\n * @param {string} configKey - The key in the Game Config to check to see if this plugin should install or not.\r\n */\r\nInputPluginCache.register = function (key, plugin, mapping, settingsKey, configKey)\r\n{\r\n    inputPlugins[key] = { plugin: plugin, mapping: mapping, settingsKey: settingsKey, configKey: configKey };\r\n};\r\n\r\n/**\r\n * Returns the input plugin object from the cache based on the given key.\r\n *\r\n * @function Phaser.Input.InputPluginCache.getPlugin\r\n * @static\r\n * @since 3.10.0\r\n *\r\n * @param {string} key - The key of the input plugin to get.\r\n *\r\n * @return {Phaser.Types.Input.InputPluginContainer} The input plugin object.\r\n */\r\nInputPluginCache.getPlugin = function (key)\r\n{\r\n    return inputPlugins[key];\r\n};\r\n\r\n/**\r\n * Installs all of the registered Input Plugins into the given target.\r\n *\r\n * @function Phaser.Input.InputPluginCache.install\r\n * @static\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Input.InputPlugin} target - The target InputPlugin to install the plugins into.\r\n */\r\nInputPluginCache.install = function (target)\r\n{\r\n    var sys = target.scene.sys;\r\n    var settings = sys.settings.input;\r\n    var config = sys.game.config;\r\n\r\n    for (var key in inputPlugins)\r\n    {\r\n        var source = inputPlugins[key].plugin;\r\n        var mapping = inputPlugins[key].mapping;\r\n        var settingsKey = inputPlugins[key].settingsKey;\r\n        var configKey = inputPlugins[key].configKey;\r\n\r\n        if (GetValue(settings, settingsKey, config[configKey]))\r\n        {\r\n            target[mapping] = new source(target);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Removes an input plugin based on the given key.\r\n *\r\n * @function Phaser.Input.InputPluginCache.remove\r\n * @static\r\n * @since 3.10.0\r\n *\r\n * @param {string} key - The key of the input plugin to remove.\r\n */\r\nInputPluginCache.remove = function (key)\r\n{\r\n    if (inputPlugins.hasOwnProperty(key))\r\n    {\r\n        delete inputPlugins[key];\r\n    }\r\n};\r\n\r\nmodule.exports = InputPluginCache;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Keyboard.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ANY_KEY_DOWN: require('./ANY_KEY_DOWN_EVENT'),\r\n    ANY_KEY_UP: require('./ANY_KEY_UP_EVENT'),\r\n    COMBO_MATCH: require('./COMBO_MATCH_EVENT'),\r\n    DOWN: require('./DOWN_EVENT'),\r\n    KEY_DOWN: require('./KEY_DOWN_EVENT'),\r\n    KEY_UP: require('./KEY_UP_EVENT'),\r\n    UP: require('./UP_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Gamepad.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    BUTTON_DOWN: require('./BUTTON_DOWN_EVENT'),\r\n    BUTTON_UP: require('./BUTTON_UP_EVENT'),\r\n    CONNECTED: require('./CONNECTED_EVENT'),\r\n    DISCONNECTED: require('./DISCONNECTED_EVENT'),\r\n    GAMEPAD_BUTTON_DOWN: require('./GAMEPAD_BUTTON_DOWN_EVENT'),\r\n    GAMEPAD_BUTTON_UP: require('./GAMEPAD_BUTTON_UP_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Creates a new Pixel Perfect Handler function.\r\n *\r\n * Access via `InputPlugin.makePixelPerfect` rather than calling it directly.\r\n *\r\n * @function Phaser.Input.CreatePixelPerfectHandler\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Textures.TextureManager} textureManager - A reference to the Texture Manager.\r\n * @param {number} alphaTolerance - The alpha level that the pixel should be above to be included as a successful interaction.\r\n *\r\n * @return {function} The new Pixel Perfect Handler function.\r\n */\r\nvar CreatePixelPerfectHandler = function (textureManager, alphaTolerance)\r\n{\r\n    return function (hitArea, x, y, gameObject)\r\n    {\r\n        var alpha = textureManager.getPixelAlpha(x, y, gameObject.texture.key, gameObject.frame.name);\r\n\r\n        return (alpha && alpha >= alphaTolerance);\r\n    };\r\n};\r\n\r\nmodule.exports = CreatePixelPerfectHandler;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Creates a new Interactive Object.\r\n * \r\n * This is called automatically by the Input Manager when you enable a Game Object for input.\r\n *\r\n * The resulting Interactive Object is mapped to the Game Object's `input` property.\r\n *\r\n * @function Phaser.Input.CreateInteractiveObject\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to which this Interactive Object is bound.\r\n * @param {any} hitArea - The hit area for this Interactive Object. Typically a geometry shape, like a Rectangle or Circle.\r\n * @param {Phaser.Types.Input.HitAreaCallback} hitAreaCallback - The 'contains' check callback that the hit area shape will use for all hit tests.\r\n *\r\n * @return {Phaser.Types.Input.InteractiveObject} The new Interactive Object.\r\n */\r\nvar CreateInteractiveObject = function (gameObject, hitArea, hitAreaCallback)\r\n{\r\n    return {\r\n\r\n        gameObject: gameObject,\r\n\r\n        enabled: true,\r\n        alwaysEnabled: false,\r\n        draggable: false,\r\n        dropZone: false,\r\n        cursor: false,\r\n\r\n        target: null,\r\n\r\n        camera: null,\r\n\r\n        hitArea: hitArea,\r\n        hitAreaCallback: hitAreaCallback,\r\n        hitAreaDebug: null,\r\n\r\n        //  Has the dev specified their own shape, or is this bound to the texture size?\r\n        customHitArea: false,\r\n\r\n        localX: 0,\r\n        localY: 0,\r\n\r\n        //  0 = Not being dragged\r\n        //  1 = Being checked for dragging\r\n        //  2 = Being dragged\r\n        dragState: 0,\r\n\r\n        dragStartX: 0,\r\n        dragStartY: 0,\r\n        dragStartXGlobal: 0,\r\n        dragStartYGlobal: 0,\r\n\r\n        dragX: 0,\r\n        dragY: 0\r\n\r\n    };\r\n};\r\n\r\nmodule.exports = CreateInteractiveObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * Contains information about a specific Gamepad Axis.\r\n * Axis objects are created automatically by the Gamepad as they are needed.\r\n *\r\n * @class Axis\r\n * @memberof Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Gamepad.Gamepad} pad - A reference to the Gamepad that this Axis belongs to.\r\n * @param {number} index - The index of this Axis.\r\n */\r\nvar Axis = new Class({\r\n\r\n    initialize:\r\n\r\n    function Axis (pad, index)\r\n    {\r\n        /**\r\n         * A reference to the Gamepad that this Axis belongs to.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#pad\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @since 3.0.0\r\n         */\r\n        this.pad = pad;\r\n\r\n        /**\r\n         * An event emitter to use to emit the axis events.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events = pad.events;\r\n\r\n        /**\r\n         * The index of this Axis.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = index;\r\n\r\n        /**\r\n         * The raw axis value, between -1 and 1 with 0 being dead center.\r\n         * Use the method `getValue` to get a normalized value with the threshold applied.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#value\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.value = 0;\r\n\r\n        /**\r\n         * Movement tolerance threshold below which axis values are ignored in `getValue`.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#threshold\r\n         * @type {number}\r\n         * @default 0.1\r\n         * @since 3.0.0\r\n         */\r\n        this.threshold = 0.1;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler for this Axis.\r\n     * Called automatically by the Gamepad as part of its update.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Axis#update\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value of the axis movement.\r\n     */\r\n    update: function (value)\r\n    {\r\n        this.value = value;\r\n    },\r\n\r\n    /**\r\n     * Applies the `threshold` value to the axis and returns it.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Axis#getValue\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The axis value, adjusted for the movement threshold.\r\n     */\r\n    getValue: function ()\r\n    {\r\n        return (Math.abs(this.value) < this.threshold) ? 0 : this.value;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Axis instance and releases external references it holds.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Axis#destroy\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.pad = null;\r\n        this.events = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Axis;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Events = require('./events');\r\n\r\n/**\r\n * @classdesc\r\n * Contains information about a specific button on a Gamepad.\r\n * Button objects are created automatically by the Gamepad as they are needed.\r\n *\r\n * @class Button\r\n * @memberof Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Gamepad.Gamepad} pad - A reference to the Gamepad that this Button belongs to.\r\n * @param {number} index - The index of this Button.\r\n */\r\nvar Button = new Class({\r\n\r\n    initialize:\r\n\r\n    function Button (pad, index)\r\n    {\r\n        /**\r\n         * A reference to the Gamepad that this Button belongs to.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#pad\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @since 3.0.0\r\n         */\r\n        this.pad = pad;\r\n\r\n        /**\r\n         * An event emitter to use to emit the button events.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events = pad.manager;\r\n\r\n        /**\r\n         * The index of this Button.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = index;\r\n\r\n        /**\r\n         * Between 0 and 1.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#value\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.value = 0;\r\n\r\n        /**\r\n         * Can be set for analogue buttons to enable a 'pressure' threshold,\r\n         * before a button is considered as being 'pressed'.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#threshold\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.threshold = 1;\r\n\r\n        /**\r\n         * Is the Button being pressed down or not?\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#pressed\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.pressed = false;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler for this Button.\r\n     * Called automatically by the Gamepad as part of its update.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Button#update\r\n     * @fires Phaser.Input.Gamepad.Events#BUTTON_DOWN\r\n     * @fires Phaser.Input.Gamepad.Events#BUTTON_UP\r\n     * @fires Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_DOWN\r\n     * @fires Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_UP\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value of the button. Between 0 and 1.\r\n     */\r\n    update: function (value)\r\n    {\r\n        this.value = value;\r\n\r\n        var pad = this.pad;\r\n        var index = this.index;\r\n\r\n        if (value >= this.threshold)\r\n        {\r\n            if (!this.pressed)\r\n            {\r\n                this.pressed = true;\r\n                this.events.emit(Events.BUTTON_DOWN, pad, this, value);\r\n                this.pad.emit(Events.GAMEPAD_BUTTON_DOWN, index, value, this);\r\n            }\r\n        }\r\n        else if (this.pressed)\r\n        {\r\n            this.pressed = false;\r\n            this.events.emit(Events.BUTTON_UP, pad, this, value);\r\n            this.pad.emit(Events.GAMEPAD_BUTTON_UP, index, value, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Button instance and releases external references it holds.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Button#destroy\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.pad = null;\r\n        this.events = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Button;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Axis = require('./Axis');\r\nvar Button = require('./Button');\r\nvar Class = require('../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A single Gamepad.\r\n *\r\n * These are created, updated and managed by the Gamepad Plugin.\r\n *\r\n * @class Gamepad\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Gamepad.GamepadPlugin} manager - A reference to the Gamepad Plugin.\r\n * @param {Phaser.Types.Input.Gamepad.Pad} pad - The Gamepad object, as extracted from GamepadEvent.\r\n */\r\nvar Gamepad = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function Gamepad (manager, pad)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Gamepad Plugin.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#manager\r\n         * @type {Phaser.Input.Gamepad.GamepadPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = manager;\r\n\r\n        /**\r\n         * A reference to the native Gamepad object that is connected to the browser.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#pad\r\n         * @type {any}\r\n         * @since 3.10.0\r\n         */\r\n        this.pad = pad;\r\n\r\n        /**\r\n         * A string containing some information about the controller.\r\n         *\r\n         * This is not strictly specified, but in Firefox it will contain three pieces of information\r\n         * separated by dashes (-): two 4-digit hexadecimal strings containing the USB vendor and\r\n         * product id of the controller, and the name of the controller as provided by the driver.\r\n         * In Chrome it will contain the name of the controller as provided by the driver,\r\n         * followed by vendor and product 4-digit hexadecimal strings.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#id\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.id = pad.id;\r\n\r\n        /**\r\n         * An integer that is unique for each Gamepad currently connected to the system.\r\n         * This can be used to distinguish multiple controllers.\r\n         * Note that disconnecting a device and then connecting a new device may reuse the previous index.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = pad.index;\r\n\r\n        var buttons = [];\r\n\r\n        for (var i = 0; i < pad.buttons.length; i++)\r\n        {\r\n            buttons.push(new Button(this, i));\r\n        }\r\n\r\n        /**\r\n         * An array of Gamepad Button objects, corresponding to the different buttons available on the Gamepad.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#buttons\r\n         * @type {Phaser.Input.Gamepad.Button[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.buttons = buttons;\r\n\r\n        var axes = [];\r\n\r\n        for (i = 0; i < pad.axes.length; i++)\r\n        {\r\n            axes.push(new Axis(this, i));\r\n        }\r\n\r\n        /**\r\n         * An array of Gamepad Axis objects, corresponding to the different axes available on the Gamepad, if any.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#axes\r\n         * @type {Phaser.Input.Gamepad.Axis[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.axes = axes;\r\n\r\n        /**\r\n         * The Gamepad's Haptic Actuator (Vibration / Rumble support).\r\n         * This is highly experimental and only set if both present on the device,\r\n         * and exposed by both the hardware and browser.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#vibration\r\n         * @type {GamepadHapticActuator}\r\n         * @since 3.10.0\r\n         */\r\n        this.vibration = pad.vibrationActuator;\r\n\r\n        // https://w3c.github.io/gamepad/#remapping\r\n\r\n        var _noButton = { value: 0, pressed: false };\r\n\r\n        /**\r\n         * A reference to the Left Button in the Left Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_LCLeft\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._LCLeft = (buttons[14]) ? buttons[14] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Right Button in the Left Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_LCRight\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._LCRight = (buttons[15]) ? buttons[15] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Top Button in the Left Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_LCTop\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._LCTop = (buttons[12]) ? buttons[12] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Bottom Button in the Left Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_LCBottom\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._LCBottom = (buttons[13]) ? buttons[13] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Left Button in the Right Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_RCLeft\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._RCLeft = (buttons[2]) ? buttons[2] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Right Button in the Right Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_RCRight\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._RCRight = (buttons[1]) ? buttons[1] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Top Button in the Right Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_RCTop\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._RCTop = (buttons[3]) ? buttons[3] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Bottom Button in the Right Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_RCBottom\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._RCBottom = (buttons[0]) ? buttons[0] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Top Left Front Button (L1 Shoulder Button)\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_FBLeftTop\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._FBLeftTop = (buttons[4]) ? buttons[4] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Bottom Left Front Button (L2 Shoulder Button)\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_FBLeftBottom\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._FBLeftBottom = (buttons[6]) ? buttons[6] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Top Right Front Button (R1 Shoulder Button)\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_FBRightTop\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._FBRightTop = (buttons[5]) ? buttons[5] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Bottom Right Front Button (R2 Shoulder Button)\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_FBRightBottom\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._FBRightBottom = (buttons[7]) ? buttons[7] : _noButton;\r\n\r\n        var _noAxis = { value: 0 };\r\n\r\n        /**\r\n         * A reference to the Horizontal Axis for the Left Stick.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_HAxisLeft\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._HAxisLeft = (axes[0]) ? axes[0] : _noAxis;\r\n\r\n        /**\r\n         * A reference to the Vertical Axis for the Left Stick.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_VAxisLeft\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._VAxisLeft = (axes[1]) ? axes[1] : _noAxis;\r\n\r\n        /**\r\n         * A reference to the Horizontal Axis for the Right Stick.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_HAxisRight\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._HAxisRight = (axes[2]) ? axes[2] : _noAxis;\r\n\r\n        /**\r\n         * A reference to the Vertical Axis for the Right Stick.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_VAxisRight\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._VAxisRight = (axes[3]) ? axes[3] : _noAxis;\r\n\r\n        /**\r\n         * A Vector2 containing the most recent values from the Gamepad's left axis stick.\r\n         * This is updated automatically as part of the Gamepad.update cycle.\r\n         * The H Axis is mapped to the `Vector2.x` property, and the V Axis to the `Vector2.y` property.\r\n         * The values are based on the Axis thresholds.\r\n         * If the Gamepad does not have a left axis stick, the values will always be zero.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#leftStick\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.10.0\r\n         */\r\n        this.leftStick = new Vector2();\r\n\r\n        /**\r\n         * A Vector2 containing the most recent values from the Gamepad's right axis stick.\r\n         * This is updated automatically as part of the Gamepad.update cycle.\r\n         * The H Axis is mapped to the `Vector2.x` property, and the V Axis to the `Vector2.y` property.\r\n         * The values are based on the Axis thresholds.\r\n         * If the Gamepad does not have a right axis stick, the values will always be zero.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#rightStick\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.10.0\r\n         */\r\n        this.rightStick = new Vector2();\r\n\r\n        /**\r\n         * When was this Gamepad created? Used to avoid duplicate event spamming in the update loop.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_created\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this._created = performance.now();\r\n    },\r\n\r\n    /**\r\n     * Gets the total number of axis this Gamepad claims to support.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#getAxisTotal\r\n     * @since 3.10.0\r\n     *\r\n     * @return {number} The total number of axes this Gamepad claims to support.\r\n     */\r\n    getAxisTotal: function ()\r\n    {\r\n        return this.axes.length;\r\n    },\r\n\r\n    /**\r\n     * Gets the value of an axis based on the given index.\r\n     * The index must be valid within the range of axes supported by this Gamepad.\r\n     * The return value will be a float between 0 and 1.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#getAxisValue\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} index - The index of the axes to get the value for.\r\n     *\r\n     * @return {number} The value of the axis, between 0 and 1.\r\n     */\r\n    getAxisValue: function (index)\r\n    {\r\n        return this.axes[index].getValue();\r\n    },\r\n\r\n    /**\r\n     * Sets the threshold value of all axis on this Gamepad.\r\n     * The value is a float between 0 and 1 and is the amount below which the axis is considered as not having been moved.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#setAxisThreshold\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} value - A value between 0 and 1.\r\n     */\r\n    setAxisThreshold: function (value)\r\n    {\r\n        for (var i = 0; i < this.axes.length; i++)\r\n        {\r\n            this.axes[i].threshold = value;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Gets the total number of buttons this Gamepad claims to have.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#getButtonTotal\r\n     * @since 3.10.0\r\n     *\r\n     * @return {number} The total number of buttons this Gamepad claims to have.\r\n     */\r\n    getButtonTotal: function ()\r\n    {\r\n        return this.buttons.length;\r\n    },\r\n\r\n    /**\r\n     * Gets the value of a button based on the given index.\r\n     * The index must be valid within the range of buttons supported by this Gamepad.\r\n     *\r\n     * The return value will be either 0 or 1 for an analogue button, or a float between 0 and 1\r\n     * for a pressure-sensitive digital button, such as the shoulder buttons on a Dual Shock.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#getButtonValue\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} index - The index of the button to get the value for.\r\n     *\r\n     * @return {number} The value of the button, between 0 and 1.\r\n     */\r\n    getButtonValue: function (index)\r\n    {\r\n        return this.buttons[index].value;\r\n    },\r\n\r\n    /**\r\n     * Returns if the button is pressed down or not.\r\n     * The index must be valid within the range of buttons supported by this Gamepad.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#isButtonDown\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} index - The index of the button to get the value for.\r\n     *\r\n     * @return {boolean} `true` if the button is considered as being pressed down, otherwise `false`.\r\n     */\r\n    isButtonDown: function (index)\r\n    {\r\n        return this.buttons[index].pressed;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler for this Gamepad.\r\n     * Called automatically by the Gamepad Manager as part of its update.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#update\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    update: function (pad)\r\n    {\r\n        if (pad.timestamp < this._created)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n\r\n        //  Sync the button values\r\n\r\n        var localButtons = this.buttons;\r\n        var gamepadButtons = pad.buttons;\r\n\r\n        var len = localButtons.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            localButtons[i].update(gamepadButtons[i].value);\r\n        }\r\n\r\n        //  Sync the axis values\r\n\r\n        var localAxes = this.axes;\r\n        var gamepadAxes = pad.axes;\r\n\r\n        len = localAxes.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            localAxes[i].update(gamepadAxes[i]);\r\n        }\r\n\r\n        if (len >= 2)\r\n        {\r\n            this.leftStick.set(localAxes[0].getValue(), localAxes[1].getValue());\r\n\r\n            if (len >= 4)\r\n            {\r\n                this.rightStick.set(localAxes[2].getValue(), localAxes[3].getValue());\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Gamepad instance, its buttons and axes, and releases external references it holds.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#destroy\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.manager = null;\r\n        this.pad = null;\r\n\r\n        var i;\r\n\r\n        for (i = 0; i < this.buttons.length; i++)\r\n        {\r\n            this.buttons[i].destroy();\r\n        }\r\n\r\n        for (i = 0; i < this.axes.length; i++)\r\n        {\r\n            this.axes[i].destroy();\r\n        }\r\n\r\n        this.buttons = [];\r\n        this.axes = [];\r\n    },\r\n\r\n    /**\r\n     * Is this Gamepad currently connected or not?\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#connected\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\r\n    connected: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.pad.connected;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A timestamp containing the most recent time this Gamepad was updated.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#timestamp\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    timestamp: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.pad.timestamp;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's Left button being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * This is the d-pad left button under standard Gamepad mapping.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#left\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    left: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._LCLeft.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's Right button being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * This is the d-pad right button under standard Gamepad mapping.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#right\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    right: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._LCRight.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's Up button being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * This is the d-pad up button under standard Gamepad mapping.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#up\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    up: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._LCTop.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's Down button being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * This is the d-pad down button under standard Gamepad mapping.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#down\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    down: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._LCBottom.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's bottom button in the right button cluster being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * On a Dual Shock controller it's the X button.\r\n     * On an XBox controller it's the A button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#A\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    A: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._RCBottom.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's top button in the right button cluster being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * On a Dual Shock controller it's the Triangle button.\r\n     * On an XBox controller it's the Y button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#Y\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    Y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._RCTop.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's left button in the right button cluster being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * On a Dual Shock controller it's the Square button.\r\n     * On an XBox controller it's the X button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#X\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    X: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._RCLeft.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's right button in the right button cluster being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * On a Dual Shock controller it's the Circle button.\r\n     * On an XBox controller it's the B button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#B\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    B: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._RCRight.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of the Gamepad's top left shoulder button.\r\n     * If the Gamepad doesn't have this button it will always return zero.\r\n     * The value is a float between 0 and 1, corresponding to how depressed the button is.\r\n     * On a Dual Shock controller it's the L1 button.\r\n     * On an XBox controller it's the LB button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#L1\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    L1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._FBLeftTop.value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of the Gamepad's bottom left shoulder button.\r\n     * If the Gamepad doesn't have this button it will always return zero.\r\n     * The value is a float between 0 and 1, corresponding to how depressed the button is.\r\n     * On a Dual Shock controller it's the L2 button.\r\n     * On an XBox controller it's the LT button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#L2\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    L2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._FBLeftBottom.value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of the Gamepad's top right shoulder button.\r\n     * If the Gamepad doesn't have this button it will always return zero.\r\n     * The value is a float between 0 and 1, corresponding to how depressed the button is.\r\n     * On a Dual Shock controller it's the R1 button.\r\n     * On an XBox controller it's the RB button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#R1\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    R1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._FBRightTop.value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of the Gamepad's bottom right shoulder button.\r\n     * If the Gamepad doesn't have this button it will always return zero.\r\n     * The value is a float between 0 and 1, corresponding to how depressed the button is.\r\n     * On a Dual Shock controller it's the R2 button.\r\n     * On an XBox controller it's the RT button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#R2\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    R2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._FBRightBottom.value;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Gamepad;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('../events');\r\n\r\n/**\r\n * @classdesc\r\n * A generic Key object which can be passed to the Process functions (and so on)\r\n * keycode must be an integer\r\n *\r\n * @class Key\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyboardPlugin} plugin - The Keyboard Plugin instance that owns this Key object.\r\n * @param {number} keyCode - The keycode of this key.\r\n */\r\nvar Key = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function Key (plugin, keyCode)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Keyboard Plugin instance that owns this Key object.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#plugin\r\n         * @type {Phaser.Input.Keyboard.KeyboardPlugin}\r\n         * @since 3.17.0\r\n         */\r\n        this.plugin = plugin;\r\n\r\n        /**\r\n         * The keycode of this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#keyCode\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.keyCode = keyCode;\r\n\r\n        /**\r\n         * The original DOM event.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#originalEvent\r\n         * @type {KeyboardEvent}\r\n         * @since 3.0.0\r\n         */\r\n        this.originalEvent = undefined;\r\n\r\n        /**\r\n         * Can this Key be processed?\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * The \"down\" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#isDown\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.isDown = false;\r\n\r\n        /**\r\n         * The \"up\" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#isUp\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.isUp = true;\r\n\r\n        /**\r\n         * The down state of the ALT key, if pressed at the same time as this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#altKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.altKey = false;\r\n\r\n        /**\r\n         * The down state of the CTRL key, if pressed at the same time as this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#ctrlKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.ctrlKey = false;\r\n\r\n        /**\r\n         * The down state of the SHIFT key, if pressed at the same time as this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#shiftKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.shiftKey = false;\r\n\r\n        /**\r\n         * The down state of the Meta key, if pressed at the same time as this key.\r\n         * On a Mac the Meta Key is the Command key. On Windows keyboards, it's the Windows key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#metaKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.16.0\r\n         */\r\n        this.metaKey = false;\r\n\r\n        /**\r\n         * The location of the modifier key. 0 for standard (or unknown), 1 for left, 2 for right, 3 for numpad.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#location\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.location = 0;\r\n\r\n        /**\r\n         * The timestamp when the key was last pressed down.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#timeDown\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeDown = 0;\r\n\r\n        /**\r\n         * The number of milliseconds this key was held down for in the previous down - up sequence.\r\n         * This value isn't updated every game step, only when the Key changes state.\r\n         * To get the current duration use the `getDuration` method.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#duration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.duration = 0;\r\n\r\n        /**\r\n         * The timestamp when the key was last released.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#timeUp\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeUp = 0;\r\n\r\n        /**\r\n         * When a key is held down should it continuously fire the `down` event each time it repeats?\r\n         * \r\n         * By default it will emit the `down` event just once, but if you wish to receive the event\r\n         * for each repeat as well, enable this property.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#emitOnRepeat\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.16.0\r\n         */\r\n        this.emitOnRepeat = false;\r\n\r\n        /**\r\n         * If a key is held down this holds down the number of times the key has 'repeated'.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#repeats\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.repeats = 0;\r\n\r\n        /**\r\n         * True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#_justDown\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this._justDown = false;\r\n\r\n        /**\r\n         * True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#_justUp\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this._justUp = false;\r\n\r\n        /**\r\n         * Internal tick counter.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#_tick\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._tick = -1;\r\n    },\r\n\r\n    /**\r\n     * Controls if this Key will continuously emit a `down` event while being held down (true),\r\n     * or emit the event just once, on first press, and then skip future events (false).\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#setEmitOnRepeat\r\n     * @since 3.16.0\r\n     * \r\n     * @param {boolean} value - Emit `down` events on repeated key down actions, or just once?\r\n     * \r\n     * @return {this} This Key instance.\r\n     */\r\n    setEmitOnRepeat: function (value)\r\n    {\r\n        this.emitOnRepeat = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Processes the Key Down action for this Key.\r\n     * Called automatically by the Keyboard Plugin.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#onDown\r\n     * @fires Phaser.Input.Keyboard.Events#DOWN\r\n     * @since 3.16.0\r\n     * \r\n     * @param {KeyboardEvent} event - The native DOM Keyboard event.\r\n     */\r\n    onDown: function (event)\r\n    {\r\n        this.originalEvent = event;\r\n\r\n        if (!this.enabled)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.altKey = event.altKey;\r\n        this.ctrlKey = event.ctrlKey;\r\n        this.shiftKey = event.shiftKey;\r\n        this.metaKey = event.metaKey;\r\n        this.location = event.location;\r\n    \r\n        this.repeats++;\r\n\r\n        if (!this.isDown)\r\n        {\r\n            this.isDown = true;\r\n            this.isUp = false;\r\n            this.timeDown = event.timeStamp;\r\n            this.duration = 0;\r\n            this._justDown = true;\r\n            this._justUp = false;\r\n\r\n            this.emit(Events.DOWN, this, event);\r\n        }\r\n        else if (this.emitOnRepeat)\r\n        {\r\n            this.emit(Events.DOWN, this, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Processes the Key Up action for this Key.\r\n     * Called automatically by the Keyboard Plugin.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#onUp\r\n     * @fires Phaser.Input.Keyboard.Events#UP\r\n     * @since 3.16.0\r\n     * \r\n     * @param {KeyboardEvent} event - The native DOM Keyboard event.\r\n     */\r\n    onUp: function (event)\r\n    {\r\n        this.originalEvent = event;\r\n\r\n        if (!this.enabled)\r\n        {\r\n            return;\r\n        }\r\n    \r\n        this.isDown = false;\r\n        this.isUp = true;\r\n        this.timeUp = event.timeStamp;\r\n        this.duration = this.timeUp - this.timeDown;\r\n        this.repeats = 0;\r\n    \r\n        this._justDown = false;\r\n        this._justUp = true;\r\n        this._tick = -1;\r\n        \r\n        this.emit(Events.UP, this, event);\r\n    },\r\n\r\n    /**\r\n     * Resets this Key object back to its default un-pressed state.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#reset\r\n     * @since 3.6.0\r\n     * \r\n     * @return {this} This Key instance.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.preventDefault = true;\r\n        this.enabled = true;\r\n        this.isDown = false;\r\n        this.isUp = true;\r\n        this.altKey = false;\r\n        this.ctrlKey = false;\r\n        this.shiftKey = false;\r\n        this.metaKey = false;\r\n        this.timeDown = 0;\r\n        this.duration = 0;\r\n        this.timeUp = 0;\r\n        this.repeats = 0;\r\n        this._justDown = false;\r\n        this._justUp = false;\r\n        this._tick = -1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the duration, in ms, that the Key has been held down for.\r\n     * \r\n     * If the key is not currently down it will return zero.\r\n     * \r\n     * The get the duration the Key was held down for in the previous up-down cycle,\r\n     * use the `Key.duration` property value instead.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#getDuration\r\n     * @since 3.17.0\r\n     * \r\n     * @return {number} The duration, in ms, that the Key has been held down for if currently down.\r\n     */\r\n    getDuration: function ()\r\n    {\r\n        if (this.isDown)\r\n        {\r\n            return (this.plugin.game.loop.time - this.timeDown);\r\n        }\r\n        else\r\n        {\r\n            return 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes any bound event handlers and removes local references.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#destroy\r\n     * @since 3.16.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.originalEvent = null;\r\n\r\n        this.plugin = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Key;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Events = require('../events');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar ProcessKeyCombo = require('./ProcessKeyCombo');\r\nvar ResetKeyCombo = require('./ResetKeyCombo');\r\n\r\n/**\r\n * @classdesc\r\n * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them\r\n * it will emit a `keycombomatch` event from the Keyboard Manager.\r\n *\r\n * The keys to be listened for can be defined as:\r\n *\r\n * A string (i.e. 'ATARI')\r\n * An array of either integers (key codes) or strings, or a mixture of both\r\n * An array of objects (such as Key objects) with a public 'keyCode' property\r\n *\r\n * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)\r\n * you could pass the following array of key codes:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n *\r\n * this.input.keyboard.on('keycombomatch', function (event) {\r\n *     console.log('Konami Code entered!');\r\n * });\r\n * ```\r\n *\r\n * Or, to listen for the user entering the word PHASER:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.createCombo('PHASER');\r\n * ```\r\n *\r\n * @class KeyCombo\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @listens Phaser.Input.Keyboard.Events#ANY_KEY_DOWN\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyboardPlugin} keyboardPlugin - A reference to the Keyboard Plugin.\r\n * @param {(string|number[]|object[])} keys - The keys that comprise this combo.\r\n * @param {Phaser.Types.Input.Keyboard.KeyComboConfig} [config] - A Key Combo configuration object.\r\n */\r\nvar KeyCombo = new Class({\r\n\r\n    initialize:\r\n\r\n    function KeyCombo (keyboardPlugin, keys, config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        //  Can't have a zero or single length combo (string or array based)\r\n        if (keys.length < 2)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * A reference to the Keyboard Manager\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#manager\r\n         * @type {Phaser.Input.Keyboard.KeyboardPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = keyboardPlugin;\r\n\r\n        /**\r\n         * A flag that controls if this Key Combo is actively processing keys or not.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * An array of the keycodes that comprise this combo.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#keyCodes\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.keyCodes = [];\r\n\r\n        //  if 'keys' is a string we need to get the keycode of each character in it\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            var char = keys[i];\r\n\r\n            if (typeof char === 'string')\r\n            {\r\n                this.keyCodes.push(char.toUpperCase().charCodeAt(0));\r\n            }\r\n            else if (typeof char === 'number')\r\n            {\r\n                this.keyCodes.push(char);\r\n            }\r\n            else if (char.hasOwnProperty('keyCode'))\r\n            {\r\n                this.keyCodes.push(char.keyCode);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The current keyCode the combo is waiting for.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#current\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.current = this.keyCodes[0];\r\n\r\n        /**\r\n         * The current index of the key being waited for in the 'keys' string.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#index\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.index = 0;\r\n\r\n        /**\r\n         * The length of this combo (in keycodes)\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#size\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.size = this.keyCodes.length;\r\n\r\n        /**\r\n         * The time the previous key in the combo was matched.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#timeLastMatched\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeLastMatched = 0;\r\n\r\n        /**\r\n         * Has this Key Combo been matched yet?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#matched\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.matched = false;\r\n\r\n        /**\r\n         * The time the entire combo was matched.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#timeMatched\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeMatched = 0;\r\n\r\n        /**\r\n         * If they press the wrong key do we reset the combo?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#resetOnWrongKey\r\n         * @type {boolean}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.resetOnWrongKey = GetFastValue(config, 'resetOnWrongKey', true);\r\n\r\n        /**\r\n         * The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#maxKeyDelay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.maxKeyDelay = GetFastValue(config, 'maxKeyDelay', 0);\r\n\r\n        /**\r\n         * If previously matched and they press the first key of the combo again, will it reset?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#resetOnMatch\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.resetOnMatch = GetFastValue(config, 'resetOnMatch', false);\r\n\r\n        /**\r\n         * If the combo matches, will it delete itself?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#deleteOnMatch\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.deleteOnMatch = GetFastValue(config, 'deleteOnMatch', false);\r\n\r\n        var _this = this;\r\n\r\n        var onKeyDownHandler = function (event)\r\n        {\r\n            if (_this.matched || !_this.enabled)\r\n            {\r\n                return;\r\n            }\r\n\r\n            var matched = ProcessKeyCombo(event, _this);\r\n\r\n            if (matched)\r\n            {\r\n                _this.manager.emit(Events.COMBO_MATCH, _this, event);\r\n\r\n                if (_this.resetOnMatch)\r\n                {\r\n                    ResetKeyCombo(_this);\r\n                }\r\n                else if (_this.deleteOnMatch)\r\n                {\r\n                    _this.destroy();\r\n                }\r\n            }\r\n        };\r\n\r\n        /**\r\n         * The internal Key Down handler.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#onKeyDown\r\n         * @private\r\n         * @type {KeyboardKeydownCallback}\r\n         * @fires Phaser.Input.Keyboard.Events#COMBO_MATCH\r\n         * @since 3.0.0\r\n         */\r\n        this.onKeyDown = onKeyDownHandler;\r\n\r\n        this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);\r\n    },\r\n\r\n    /**\r\n     * How far complete is this combo? A value between 0 and 1.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#progress\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    progress: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.index / this.size;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Destroys this Key Combo and all of its references.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyCombo#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.enabled = false;\r\n        this.keyCodes = [];\r\n\r\n        this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown);\r\n\r\n        this.manager = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = KeyCombo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AdvanceKeyCombo = require('./AdvanceKeyCombo');\r\n\r\n/**\r\n * Used internally by the KeyCombo class.\r\n *\r\n * @function Phaser.Input.Keyboard.ProcessKeyCombo\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {KeyboardEvent} event - The native Keyboard Event.\r\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - The KeyCombo object to be processed.\r\n *\r\n * @return {boolean} `true` if the combo was matched, otherwise `false`.\r\n */\r\nvar ProcessKeyCombo = function (event, combo)\r\n{\r\n    if (combo.matched)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    var comboMatched = false;\r\n    var keyMatched = false;\r\n\r\n    if (event.keyCode === combo.current)\r\n    {\r\n        //  Key was correct\r\n\r\n        if (combo.index > 0 && combo.maxKeyDelay > 0)\r\n        {\r\n            //  We have to check to see if the delay between\r\n            //  the new key and the old one was too long (if enabled)\r\n\r\n            var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;\r\n\r\n            //  Check if they pressed it in time or not\r\n            if (event.timeStamp <= timeLimit)\r\n            {\r\n                keyMatched = true;\r\n                comboMatched = AdvanceKeyCombo(event, combo);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            keyMatched = true;\r\n\r\n            //  We don't check the time for the first key pressed, so just advance it\r\n            comboMatched = AdvanceKeyCombo(event, combo);\r\n        }\r\n    }\r\n\r\n    if (!keyMatched && combo.resetOnWrongKey)\r\n    {\r\n        //  Wrong key was pressed\r\n        combo.index = 0;\r\n        combo.current = combo.keyCodes[0];\r\n    }\r\n\r\n    if (comboMatched)\r\n    {\r\n        combo.timeLastMatched = event.timeStamp;\r\n        combo.matched = true;\r\n        combo.timeMatched = event.timeStamp;\r\n    }\r\n\r\n    return comboMatched;\r\n};\r\n\r\nmodule.exports = ProcessKeyCombo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Used internally by the KeyCombo class.\r\n * Return `true` if it reached the end of the combo, `false` if not.\r\n *\r\n * @function Phaser.Input.Keyboard.AdvanceKeyCombo\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {KeyboardEvent} event - The native Keyboard Event.\r\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - The KeyCombo object to advance.\r\n *\r\n * @return {boolean} `true` if it reached the end of the combo, `false` if not.\r\n */\r\nvar AdvanceKeyCombo = function (event, combo)\r\n{\r\n    combo.timeLastMatched = event.timeStamp;\r\n    combo.index++;\r\n\r\n    if (combo.index === combo.size)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        combo.current = combo.keyCodes[combo.index];\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = AdvanceKeyCombo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Used internally by the KeyCombo class.\r\n *\r\n * @function Phaser.Input.Keyboard.ResetKeyCombo\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - The KeyCombo to reset.\r\n *\r\n * @return {Phaser.Input.Keyboard.KeyCombo} The KeyCombo.\r\n */\r\nvar ResetKeyCombo = function (combo)\r\n{\r\n    combo.current = combo.keyCodes[0];\r\n    combo.index = 0;\r\n    combo.timeLastMatched = 0;\r\n    combo.matched = false;\r\n    combo.timeMatched = 0;\r\n\r\n    return combo;\r\n};\r\n\r\nmodule.exports = ResetKeyCombo;\r\n"],"sourceRoot":""}