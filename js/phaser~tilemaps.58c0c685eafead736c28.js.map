{"version":3,"file":"js/phaser~tilemaps.58c0c685eafead736c28.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/Formats.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/ImageCollection.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/ParseToTilemap.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/Tile.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/Tilemap.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/TilemapCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/TilemapFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/TilemapLayer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/TilemapLayerCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/TilemapLayerRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/TilemapLayerWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/Tileset.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/CalculateFacesAt.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/CalculateFacesWithin.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/CheckIsoBounds.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/Copy.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/CreateFromTiles.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/CullBounds.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/CullTiles.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/Fill.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/FilterTiles.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/FindByIndex.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/FindTile.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/ForEachTile.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/GetCullTilesFunction.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/GetTileAt.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/GetTileAtWorldXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/GetTileToWorldXFunction.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/GetTileToWorldXYFunction.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/GetTileToWorldYFunction.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/GetTilesWithin.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/GetTilesWithinShape.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/GetTilesWithinWorldXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/GetWorldToTileXFunction.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/GetWorldToTileXYFunction.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/GetWorldToTileYFunction.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/HasTileAt.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/HasTileAtWorldXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/HexagonalCullBounds.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/HexagonalCullTiles.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/HexagonalTileToWorldXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/HexagonalTileToWorldY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/HexagonalWorldToTileXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/HexagonalWorldToTileY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/IsInLayerBounds.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/IsometricCullTiles.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/IsometricTileToWorldXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/IsometricWorldToTileXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/PutTileAt.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/PutTileAtWorldXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/PutTilesAt.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/Randomize.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/RemoveTileAt.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/RemoveTileAtWorldXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/RenderDebug.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/ReplaceByIndex.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/RunCull.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/SetCollision.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/SetCollisionBetween.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/SetCollisionByExclusion.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/SetCollisionByProperty.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/SetCollisionFromCollisionGroup.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/SetLayerCollisionIndex.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/SetTileCollision.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/SetTileIndexCallback.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/SetTileLocationCallback.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/Shuffle.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/StaggeredCullBounds.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/StaggeredCullTiles.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/StaggeredTileToWorldXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/StaggeredTileToWorldY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/StaggeredWorldToTileXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/StaggeredWorldToTileY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/SwapByIndex.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/TileToWorldX.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/TileToWorldXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/TileToWorldY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/WeightedRandomize.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/WorldToTileX.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/WorldToTileXY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/WorldToTileY.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/components/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/const/ORIENTATION_CONST.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/const/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/mapdata/LayerData.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/mapdata/MapData.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/mapdata/ObjectLayer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/FromOrientationString.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/Parse.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/Parse2DArray.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/ParseCSV.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/impact/ParseTileLayers.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/impact/ParseTilesets.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/impact/ParseWeltmeister.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/impact/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/AssignTileProperties.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/Base64Decode.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/BuildTilesetIndex.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/CreateGroupLayer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseGID.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseImageLayers.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseJSONTiled.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseObject.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseObjectLayers.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseTileLayers.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseTilesets.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/ParseWangsets.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/tilemaps/parsers/tiled/index.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Formats\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * CSV Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.CSV\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    CSV: 0,\r\n\r\n    /**\r\n     * Tiled JSON Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.TILED_JSON\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    TILED_JSON: 1,\r\n\r\n    /**\r\n     * 2D Array Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.ARRAY_2D\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    ARRAY_2D: 2,\r\n\r\n    /**\r\n     * Weltmeister (Impact.js) Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.WELTMEISTER\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    WELTMEISTER: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * An Image Collection is a special Tile Set containing multiple images, with no slicing into each image.\r\n *\r\n * Image Collections are normally created automatically when Tiled data is loaded.\r\n *\r\n * @class ImageCollection\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n * \r\n * @param {string} name - The name of the image collection in the map data.\r\n * @param {number} firstgid - The first image index this image collection contains.\r\n * @param {number} [width=32] - Width of widest image (in pixels).\r\n * @param {number} [height=32] - Height of tallest image (in pixels).\r\n * @param {number} [margin=0] - The margin around all images in the collection (in pixels).\r\n * @param {number} [spacing=0] - The spacing between each image in the collection (in pixels).\r\n * @param {object} [properties={}] - Custom Image Collection properties.\r\n */\r\nvar ImageCollection = new Class({\r\n\r\n    initialize:\r\n\r\n    function ImageCollection (name, firstgid, width, height, margin, spacing, properties)\r\n    {\r\n        if (width === undefined || width <= 0) { width = 32; }\r\n        if (height === undefined || height <= 0) { height = 32; }\r\n        if (margin === undefined) { margin = 0; }\r\n        if (spacing === undefined) { spacing = 0; }\r\n\r\n        /**\r\n         * The name of the Image Collection.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n        */\r\n        this.name = name;\r\n\r\n        /**\r\n         * The Tiled firstgid value.\r\n         * This is the starting index of the first image index this Image Collection contains.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#firstgid\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.firstgid = firstgid | 0;\r\n\r\n        /**\r\n         * The width of the widest image (in pixels).\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageWidth\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.imageWidth = width | 0;\r\n\r\n        /**\r\n         * The height of the tallest image (in pixels).\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageHeight\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.imageHeight = height | 0;\r\n\r\n        /**\r\n         * The margin around the images in the collection (in pixels).\r\n         * Use `setSpacing` to change.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageMarge\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.imageMargin = margin | 0;\r\n\r\n        /**\r\n         * The spacing between each image in the collection (in pixels).\r\n         * Use `setSpacing` to change.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageSpacing\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.imageSpacing = spacing | 0;\r\n\r\n        /**\r\n         * Image Collection-specific properties that are typically defined in the Tiled editor.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = properties || {};\r\n\r\n        /**\r\n         * The cached images that are a part of this collection.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#images\r\n         * @type {array}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.images = [];\r\n\r\n        /**\r\n         * The total number of images in the image collection.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#total\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.total = 0;\r\n    },\r\n\r\n    /**\r\n     * Returns true if and only if this image collection contains the given image index.\r\n     *\r\n     * @method Phaser.Tilemaps.ImageCollection#containsImageIndex\r\n     * @since 3.0.0\r\n     * \r\n     * @param {number} imageIndex - The image index to search for.\r\n     * \r\n     * @return {boolean} True if this Image Collection contains the given index.\r\n     */\r\n    containsImageIndex: function (imageIndex)\r\n    {\r\n        return (imageIndex >= this.firstgid && imageIndex < (this.firstgid + this.total));\r\n    },\r\n\r\n    /**\r\n     * Add an image to this Image Collection.\r\n     *\r\n     * @method Phaser.Tilemaps.ImageCollection#addImage\r\n     * @since 3.0.0\r\n     * \r\n     * @param {number} gid - The gid of the image in the Image Collection.\r\n     * @param {string} image - The the key of the image in the Image Collection and in the cache.\r\n     *\r\n     * @return {Phaser.Tilemaps.ImageCollection} This ImageCollection object.\r\n     */\r\n    addImage: function (gid, image)\r\n    {\r\n        this.images.push({ gid: gid, image: image });\r\n        this.total++;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ImageCollection;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('./Formats');\r\nvar MapData = require('./mapdata/MapData');\r\nvar Parse = require('./parsers/Parse');\r\nvar Tilemap = require('./Tilemap');\r\n\r\n/**\r\n * Create a Tilemap from the given key or data. If neither is given, make a blank Tilemap. When\r\n * loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing from\r\n * a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map data. For\r\n * an empty map, you should specify tileWidth, tileHeight, width & height.\r\n *\r\n * @function Phaser.Tilemaps.ParseToTilemap\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Tilemap belongs.\r\n * @param {string} [key] - The key in the Phaser cache that corresponds to the loaded tilemap data.\r\n * @param {number} [tileWidth=32] - The width of a tile in pixels.\r\n * @param {number} [tileHeight=32] - The height of a tile in pixels.\r\n * @param {number} [width=10] - The width of the map in tiles.\r\n * @param {number} [height=10] - The height of the map in tiles.\r\n * @param {number[][]} [data] - Instead of loading from the cache, you can also load directly from\r\n * a 2D array of tile indexes.\r\n * @param {boolean} [insertNull=false] - Controls how empty tiles, tiles with an index of -1, in the\r\n * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.Tilemap}\r\n */\r\nvar ParseToTilemap = function (scene, key, tileWidth, tileHeight, width, height, data, insertNull)\r\n{\r\n    if (tileWidth === undefined) { tileWidth = 32; }\r\n    if (tileHeight === undefined) { tileHeight = 32; }\r\n    if (width === undefined) { width = 10; }\r\n    if (height === undefined) { height = 10; }\r\n    if (insertNull === undefined) { insertNull = false; }\r\n\r\n    var mapData = null;\r\n\r\n    if (Array.isArray(data))\r\n    {\r\n        var name = key !== undefined ? key : 'map';\r\n        mapData = Parse(name, Formats.ARRAY_2D, data, tileWidth, tileHeight, insertNull);\r\n    }\r\n    else if (key !== undefined)\r\n    {\r\n        var tilemapData = scene.cache.tilemap.get(key);\r\n\r\n        if (!tilemapData)\r\n        {\r\n            console.warn('No map data found for key ' + key);\r\n        }\r\n        else\r\n        {\r\n            mapData = Parse(key, tilemapData.format, tilemapData.data, tileWidth, tileHeight, insertNull);\r\n        }\r\n    }\r\n\r\n    if (mapData === null)\r\n    {\r\n        mapData = new MapData({\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height\r\n        });\r\n    }\r\n\r\n    return new Tilemap(scene, mapData);\r\n};\r\n\r\nmodule.exports = ParseToTilemap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const/ORIENTATION_CONST');\r\nvar Class = require('../utils/Class');\r\nvar Components = require('../gameobjects/components');\r\nvar Rectangle = require('../geom/rectangle');\r\n\r\n/**\r\n * @classdesc\r\n * A Tile is a representation of a single tile within the Tilemap. This is a lightweight data\r\n * representation, so its position information is stored without factoring in scroll, layer\r\n * scale or layer position.\r\n *\r\n * @class Tile\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The LayerData object in the Tilemap that this tile belongs to.\r\n * @param {number} index - The unique index of this tile within the map.\r\n * @param {number} x - The x coordinate of this tile in tile coordinates.\r\n * @param {number} y - The y coordinate of this tile in tile coordinates.\r\n * @param {number} width - Width of the tile in pixels.\r\n * @param {number} height - Height of the tile in pixels.\r\n * @param {number} baseWidth - The base width a tile in the map (in pixels). Tiled maps support\r\n * multiple tileset sizes within one map, but they are still placed at intervals of the base\r\n * tile width.\r\n * @param {number} baseHeight - The base height of the tile in pixels (in pixels). Tiled maps\r\n * support multiple tileset sizes within one map, but they are still placed at intervals of the\r\n * base tile height.\r\n */\r\nvar Tile = new Class({\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.Flip,\r\n        Components.Visible\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Tile (layer, index, x, y, width, height, baseWidth, baseHeight)\r\n    {\r\n        /**\r\n         * The LayerData in the Tilemap data that this tile belongs to.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#layer\r\n         * @type {Phaser.Tilemaps.LayerData}\r\n         * @since 3.0.0\r\n         */\r\n        this.layer = layer;\r\n\r\n        /**\r\n         * The index of this tile within the map data corresponding to the tileset, or -1 if this\r\n         * represents a blank tile.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = index;\r\n\r\n        /**\r\n         * The x map coordinate of this tile in tile units.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.x = x;\r\n\r\n        /**\r\n         * The y map coordinate of this tile in tile units.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.y = y;\r\n\r\n        /**\r\n         * The width of the tile in pixels.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the tile in pixels.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * The right of the tile in pixels.\r\n         *\r\n         * Set in the `updatePixelXY` method.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#right\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.right;\r\n\r\n        /**\r\n         * The bottom of the tile in pixels.\r\n         *\r\n         * Set in the `updatePixelXY` method.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#bottom\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.bottom;\r\n\r\n        /**\r\n         * The maps base width of a tile in pixels. Tiled maps support multiple tileset sizes\r\n         * within one map, but they are still placed at intervals of the base tile size.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#baseWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseWidth = (baseWidth !== undefined) ? baseWidth : width;\r\n\r\n        /**\r\n         * The maps base height of a tile in pixels. Tiled maps support multiple tileset sizes\r\n         * within one map, but they are still placed at intervals of the base tile size.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#baseHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseHeight = (baseHeight !== undefined) ? baseHeight : height;\r\n\r\n        /**\r\n         * The x coordinate of the top left of this tile in pixels. This is relative to the top left\r\n         * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n         * scroll, layer scale or layer position.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#pixelX\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.pixelX = 0;\r\n\r\n        /**\r\n         * The y coordinate of the top left of this tile in pixels. This is relative to the top left\r\n         * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n         * scroll, layer scale or layer position.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#pixelY\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.pixelY = 0;\r\n\r\n        this.updatePixelXY();\r\n\r\n        /**\r\n         * Tile specific properties. These usually come from Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#properties\r\n         * @type {any}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = {};\r\n\r\n        /**\r\n         * The rotation angle of this tile.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#rotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.rotation = 0;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the left side.\r\n         *\r\n         * This property is used by Arcade Physics only, however, you can also use it\r\n         * in your own checks.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideLeft\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideLeft = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the right side.\r\n         *\r\n         * This property is used by Arcade Physics only, however, you can also use it\r\n         * in your own checks.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideRight\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideRight = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the top side.\r\n         *\r\n         * This property is used by Arcade Physics only, however, you can also use it\r\n         * in your own checks.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideUp\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideUp = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the bottom side.\r\n         *\r\n         * This property is used by Arcade Physics only, however, you can also use it\r\n         * in your own checks.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideDown\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideDown = false;\r\n\r\n        /**\r\n         * Whether the tiles left edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceLeft\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceLeft = false;\r\n\r\n        /**\r\n         * Whether the tiles right edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceRight\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceRight = false;\r\n\r\n        /**\r\n         * Whether the tiles top edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceTop\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceTop = false;\r\n\r\n        /**\r\n         * Whether the tiles bottom edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceBottom\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceBottom = false;\r\n\r\n        /**\r\n         * Tile collision callback.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collisionCallback\r\n         * @type {function}\r\n         * @since 3.0.0\r\n         */\r\n        this.collisionCallback = undefined;\r\n\r\n        /**\r\n         * The context in which the collision callback will be called.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collisionCallbackContext\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.collisionCallbackContext = this;\r\n\r\n        /**\r\n         * The tint to apply to this tile. Note: tint is currently a single color value instead of\r\n         * the 4 corner tint component on other GameObjects.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#tint\r\n         * @type {number}\r\n         * @default\r\n         * @since 3.0.0\r\n         */\r\n        this.tint = 0xffffff;\r\n\r\n        /**\r\n         * An empty object where physics-engine specific information (e.g. bodies) may be stored.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#physics\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.physics = {};\r\n    },\r\n\r\n    /**\r\n     * Check if the given x and y world coordinates are within this Tile. This does not factor in\r\n     * camera scroll, layer scale or layer position.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#containsPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to test.\r\n     * @param {number} y - The y coordinate to test.\r\n     *\r\n     * @return {boolean} True if the coordinates are within this Tile, otherwise false.\r\n     */\r\n    containsPoint: function (x, y)\r\n    {\r\n        return !(x < this.pixelX || y < this.pixelY || x > this.right || y > this.bottom);\r\n    },\r\n\r\n    /**\r\n     * Copies the tile data & properties from the given tile to this tile. This copies everything\r\n     * except for position and interesting faces.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.Tile} tile - The tile to copy from.\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    copy: function (tile)\r\n    {\r\n        this.index = tile.index;\r\n        this.alpha = tile.alpha;\r\n        this.properties = tile.properties;\r\n        this.visible = tile.visible;\r\n        this.setFlip(tile.flipX, tile.flipY);\r\n        this.tint = tile.tint;\r\n        this.rotation = tile.rotation;\r\n        this.collideUp = tile.collideUp;\r\n        this.collideDown = tile.collideDown;\r\n        this.collideLeft = tile.collideLeft;\r\n        this.collideRight = tile.collideRight;\r\n        this.collisionCallback = tile.collisionCallback;\r\n        this.collisionCallbackContext = tile.collisionCallbackContext;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The collision group for this Tile, defined within the Tileset. This returns a reference to\r\n     * the collision group stored within the Tileset, so any modification of the returned object\r\n     * will impact all tiles that have the same index as this tile.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?object} The collision group for this Tile, as defined in the Tileset, or `null` if no group was defined.\r\n     */\r\n    getCollisionGroup: function ()\r\n    {\r\n        return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;\r\n    },\r\n\r\n    /**\r\n     * The tile data for this Tile, defined within the Tileset. This typically contains Tiled\r\n     * collision data, tile animations and terrain information. This returns a reference to the tile\r\n     * data stored within the Tileset, so any modification of the returned object will impact all\r\n     * tiles that have the same index as this tile.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?object} The tile data for this Tile, as defined in the Tileset, or `null` if no data was defined.\r\n     */\r\n    getTileData: function ()\r\n    {\r\n        return this.tileset ? this.tileset.getTileData(this.index) : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the left side of the tile, factoring in the layers position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The left (x) value of this tile.\r\n     */\r\n    getLeft: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        return (tilemapLayer) ? tilemapLayer.tileToWorldX(this.x, camera) : this.x * this.baseWidth;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the right side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getRight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The right (x) value of this tile.\r\n     */\r\n    getRight: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        return (tilemapLayer) ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the top side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The top (y) value of this tile.\r\n     */\r\n    getTop: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        // Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile in grid\r\n        // units is the bottom left, so the y coordinate needs to be adjusted by the difference\r\n        // between the base size and this tile's size.\r\n        return tilemapLayer\r\n            ? tilemapLayer.tileToWorldY(this.y, camera) - (this.height - this.baseHeight) * tilemapLayer.scaleY\r\n            : this.y * this.baseHeight - (this.height - this.baseHeight);\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the bottom side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n\r\n     * @method Phaser.Tilemaps.Tile#getBottom\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The bottom (y) value of this tile.\r\n     */\r\n    getBottom: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        return tilemapLayer\r\n            ? this.getTop(camera) + this.height * tilemapLayer.scaleY\r\n            : this.getTop(camera) + this.height;\r\n    },\r\n\r\n\r\n    /**\r\n     * Gets the world rectangle bounding box for the tile, factoring in the layers position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     * @param {Phaser.Geom.Rectangle} [output] - Optional Rectangle object to store the results in.\r\n     *\r\n     * @return {(Phaser.Geom.Rectangle|object)} The bounds of this Tile.\r\n     */\r\n    getBounds: function (camera, output)\r\n    {\r\n        if (output === undefined) { output = new Rectangle(); }\r\n\r\n        output.x = this.getLeft();\r\n        output.y = this.getTop();\r\n        output.width = this.getRight() - output.x;\r\n        output.height = this.getBottom() - output.y;\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the center of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCenterX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The center x position of this Tile.\r\n     */\r\n    getCenterX: function (camera)\r\n    {\r\n        return (this.getLeft(camera) + this.getRight(camera)) / 2;\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the center of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCenterY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The center y position of this Tile.\r\n     */\r\n    getCenterY: function (camera)\r\n    {\r\n        return (this.getTop(camera) + this.getBottom(camera)) / 2;\r\n    },\r\n\r\n    /**\r\n     * Check for intersection with this tile. This does not factor in camera scroll, layer scale or\r\n     * layer position.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#intersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x axis in pixels.\r\n     * @param {number} y - The y axis in pixels.\r\n     * @param {number} right - The right point.\r\n     * @param {number} bottom - The bottom point.\r\n     *\r\n     * @return {boolean} `true` if the Tile intersects with the given dimensions, otherwise `false`.\r\n     */\r\n    intersects: function (x, y, right, bottom)\r\n    {\r\n        return !(\r\n            right <= this.pixelX || bottom <= this.pixelY ||\r\n            x >= this.right || y >= this.bottom\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Checks if the tile is interesting.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#isInteresting\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} collides - If true, will consider the tile interesting if it collides on any side.\r\n     * @param {boolean} faces - If true, will consider the tile interesting if it has an interesting face.\r\n     *\r\n     * @return {boolean} True if the Tile is interesting, otherwise false.\r\n     */\r\n    isInteresting: function (collides, faces)\r\n    {\r\n        if (collides && faces)\r\n        {\r\n            return (this.canCollide || this.hasInterestingFace);\r\n        }\r\n        else if (collides)\r\n        {\r\n            return this.collides;\r\n        }\r\n        else if (faces)\r\n        {\r\n            return this.hasInterestingFace;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Reset collision status flags.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#resetCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces for this tile and its neighbors.\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    resetCollision: function (recalculateFaces)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        this.collideLeft = false;\r\n        this.collideRight = false;\r\n        this.collideUp = false;\r\n        this.collideDown = false;\r\n\r\n        this.faceTop = false;\r\n        this.faceBottom = false;\r\n        this.faceLeft = false;\r\n        this.faceRight = false;\r\n\r\n        if (recalculateFaces)\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                this.tilemapLayer.calculateFacesAt(this.x, this.y);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset faces.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#resetFaces\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    resetFaces: function ()\r\n    {\r\n        this.faceTop = false;\r\n        this.faceBottom = false;\r\n        this.faceLeft = false;\r\n        this.faceRight = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision flags for each side of this tile and updates the interesting faces list.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} left - Indicating collide with any object on the left.\r\n     * @param {boolean} [right] - Indicating collide with any object on the right.\r\n     * @param {boolean} [up] - Indicating collide with any object on the top.\r\n     * @param {boolean} [down] - Indicating collide with any object on the bottom.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces for this tile and its neighbors.\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    setCollision: function (left, right, up, down, recalculateFaces)\r\n    {\r\n        if (right === undefined) { right = left; }\r\n        if (up === undefined) { up = left; }\r\n        if (down === undefined) { down = left; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        this.collideLeft = left;\r\n        this.collideRight = right;\r\n        this.collideUp = up;\r\n        this.collideDown = down;\r\n\r\n        this.faceLeft = left;\r\n        this.faceRight = right;\r\n        this.faceTop = up;\r\n        this.faceBottom = down;\r\n\r\n        if (recalculateFaces)\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                this.tilemapLayer.calculateFacesAt(this.x, this.y);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set a callback to be called when this tile is hit by an object. The callback must true for\r\n     * collision processing to take place.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setCollisionCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - Callback function.\r\n     * @param {object} context - Callback will be called within this context.\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    setCollisionCallback: function (callback, context)\r\n    {\r\n        if (callback === null)\r\n        {\r\n            this.collisionCallback = undefined;\r\n            this.collisionCallbackContext = undefined;\r\n        }\r\n        else\r\n        {\r\n            this.collisionCallback = callback;\r\n            this.collisionCallbackContext = context;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the size of the tile and updates its pixelX and pixelY.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileWidth - The width of the tile in pixels.\r\n     * @param {number} tileHeight - The height of the tile in pixels.\r\n     * @param {number} baseWidth - The base width a tile in the map (in pixels).\r\n     * @param {number} baseHeight - The base height of the tile in pixels (in pixels).\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    setSize: function (tileWidth, tileHeight, baseWidth, baseHeight)\r\n    {\r\n        if (tileWidth !== undefined) { this.width = tileWidth; }\r\n        if (tileHeight !== undefined) { this.height = tileHeight; }\r\n        if (baseWidth !== undefined) { this.baseWidth = baseWidth; }\r\n        if (baseHeight !== undefined) { this.baseHeight = baseHeight; }\r\n\r\n        this.updatePixelXY();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Used internally. Updates the tiles world XY position based on the current tile size.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#updatePixelXY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    updatePixelXY: function ()\r\n    {\r\n        var orientation = this.layer.orientation;\r\n\r\n        if (orientation === CONST.ORTHOGONAL)\r\n        {\r\n            //  In orthogonal mode, Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile is the\r\n            //  bottom left, while the Phaser renderer assumes the origin is the top left. The y\r\n            //  coordinate needs to be adjusted by the difference.\r\n\r\n            this.pixelX = this.x * this.baseWidth;\r\n            this.pixelY = this.y * this.baseHeight;\r\n        }\r\n        else if (orientation === CONST.ISOMETRIC)\r\n        {\r\n            //  Reminder: For the tilemap to be centered we have to move the image to the right with the camera!\r\n            //  This is crucial for wordtotile, tiletoworld to work.\r\n\r\n            this.pixelX = (this.x - this.y) * this.baseWidth * 0.5;\r\n            this.pixelY = (this.x + this.y) * this.baseHeight * 0.5;\r\n        }\r\n        else if (orientation === CONST.STAGGERED)\r\n        {\r\n            this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);\r\n            this.pixelY = this.y * (this.baseHeight / 2);\r\n        }\r\n        else if (orientation === CONST.HEXAGONAL)\r\n        {\r\n            var len = this.layer.hexSideLength;\r\n            var rowHeight = ((this.baseHeight - len) / 2 + len);\r\n\r\n            this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);\r\n            this.pixelY = this.y * rowHeight;\r\n        }\r\n\r\n        this.right = this.pixelX + this.baseWidth;\r\n        this.bottom = this.pixelY + this.baseHeight;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clean up memory.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.collisionCallback = undefined;\r\n        this.collisionCallbackContext = undefined;\r\n        this.properties = undefined;\r\n    },\r\n\r\n    /**\r\n     * True if this tile can collide on any of its faces or has a collision callback set.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#canCollide\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    canCollide: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown || (this.collisionCallback !== undefined));\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * True if this tile can collide on any of its faces.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#collides\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    collides: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * True if this tile has any interesting faces.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#hasInterestingFace\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    hasInterestingFace: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The tileset that contains this Tile. This is null if accessed from a LayerData instance\r\n     * before the tile is placed in a TilemapLayer, or if the tile has an index that doesn't correspond\r\n     * to any of the maps tilesets.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tileset\r\n     * @type {?Phaser.Tilemaps.Tileset}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    tileset: {\r\n\r\n        get: function ()\r\n        {\r\n            var tilemapLayer = this.layer.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                var tileset = tilemapLayer.gidMap[this.index];\r\n\r\n                if (tileset)\r\n                {\r\n                    return tileset;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The tilemap layer that contains this Tile. This will only return null if accessed from a\r\n     * LayerData instance before the tile is placed within a TilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tilemapLayer\r\n     * @type {?Phaser.Tilemaps.TilemapLayer}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    tilemapLayer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.layer.tilemapLayer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The tilemap that contains this Tile. This will only return null if accessed from a LayerData\r\n     * instance before the tile is placed within a TilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tilemap\r\n     * @type {?Phaser.Tilemaps.Tilemap}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    tilemap: {\r\n\r\n        get: function ()\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            return tilemapLayer ? tilemapLayer.tilemap : null;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Tile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar DegToRad = require('../math/DegToRad');\r\nvar Formats = require('./Formats');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar LayerData = require('./mapdata/LayerData');\r\nvar ORIENTATION = require('./const/ORIENTATION_CONST');\r\nvar Rotate = require('../math/Rotate');\r\nvar SpliceOne = require('../utils/array/SpliceOne');\r\nvar Sprite = require('../gameobjects/sprite/Sprite');\r\nvar Tile = require('./Tile');\r\nvar TilemapComponents = require('./components');\r\nvar TilemapLayer = require('./TilemapLayer');\r\nvar Tileset = require('./Tileset');\r\n\r\n/**\r\n * @callback TilemapFilterCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} value - An object found in the filtered area.\r\n * @param {number} index - The index of the object within the array.\r\n * @param {Phaser.GameObjects.GameObject[]} array - An array of all the objects found.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The object.\r\n */\r\n\r\n/**\r\n * @callback TilemapFindCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} value - An object found.\r\n * @param {number} index - The index of the object within the array.\r\n * @param {Phaser.GameObjects.GameObject[]} array - An array of all the objects found.\r\n *\r\n * @return {boolean} `true` if the callback should be invoked, otherwise `false`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Tilemap is a container for Tilemap data. This isn't a display object, rather, it holds data\r\n * about the map and allows you to add tilesets and tilemap layers to it. A map can have one or\r\n * more tilemap layers, which are the display objects that actually render the tiles.\r\n *\r\n * The Tilemap data can be parsed from a Tiled JSON file, a CSV file or a 2D array. Tiled is a free\r\n * software package specifically for creating tile maps, and is available from:\r\n * http://www.mapeditor.org\r\n *\r\n * As of Phaser 3.50.0 the Tilemap API now supports the following types of map:\r\n *\r\n * 1) Orthogonal\r\n * 2) Isometric\r\n * 3) Hexagonal\r\n * 4) Staggered\r\n *\r\n * Prior to this release, only orthogonal maps were supported.\r\n *\r\n * Another large change in 3.50 was the consolidation of Tilemap Layers. Previously, you created\r\n * either a Static or Dynamic Tilemap Layer. However, as of 3.50 the features of both have been\r\n * merged and the API simplified, so now there is just the single `TilemapLayer` class.\r\n *\r\n * A Tilemap has handy methods for getting and manipulating the tiles within a layer, allowing\r\n * you to build or modify the tilemap data at runtime.\r\n *\r\n * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a\r\n * TilemapLayer may have its own unique tile size that overrides this.\r\n *\r\n * As of Phaser 3.21.0, if your tilemap includes layer groups (a feature of Tiled 1.2.0+) these\r\n * will be traversed and the following properties will impact children:\r\n *\r\n * - Opacity (blended with parent) and visibility (parent overrides child)\r\n * - Vertical and horizontal offset\r\n *\r\n * The grouping hierarchy is not preserved and all layers will be flattened into a single array.\r\n *\r\n * Group layers are parsed during Tilemap construction but are discarded after parsing so dynamic\r\n * layers will NOT continue to be affected by a parent.\r\n *\r\n * To avoid duplicate layer names, a layer that is a child of a group layer will have its parent\r\n * group name prepended with a '/'.  For example, consider a group called 'ParentGroup' with a\r\n * child called 'Layer 1'. In the Tilemap object, 'Layer 1' will have the name\r\n * 'ParentGroup/Layer 1'.\r\n *\r\n * @class Tilemap\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Tilemap belongs.\r\n * @param {Phaser.Tilemaps.MapData} mapData - A MapData instance containing Tilemap data.\r\n */\r\nvar Tilemap = new Class({\r\n\r\n    initialize:\r\n\r\n    function Tilemap (scene, mapData)\r\n    {\r\n        /**\r\n         * @name Phaser.Tilemaps.Tilemap#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The base width of a tile in pixels. Note that individual layers may have a different tile\r\n         * width.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = mapData.tileWidth;\r\n\r\n        /**\r\n         * The base height of a tile in pixels. Note that individual layers may have a different\r\n         * tile height.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = mapData.tileHeight;\r\n\r\n        /**\r\n         * The width of the map (in tiles).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = mapData.width;\r\n\r\n        /**\r\n         * The height of the map (in tiles).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = mapData.height;\r\n\r\n        /**\r\n         * The orientation of the map data (as specified in Tiled), usually 'orthogonal'.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#orientation\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.orientation = mapData.orientation;\r\n\r\n        /**\r\n         * The render (draw) order of the map data (as specified in Tiled), usually 'right-down'.\r\n         *\r\n         * The draw orders are:\r\n         *\r\n         * right-down\r\n         * left-down\r\n         * right-up\r\n         * left-up\r\n         *\r\n         * This can be changed via the `setRenderOrder` method.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#renderOrder\r\n         * @type {string}\r\n         * @since 3.12.0\r\n         */\r\n        this.renderOrder = mapData.renderOrder;\r\n\r\n        /**\r\n         * The format of the map data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#format\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.format = mapData.format;\r\n\r\n        /**\r\n         * The version of the map data (as specified in Tiled, usually 1).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#version\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.version = mapData.version;\r\n\r\n        /**\r\n         * Map specific properties as specified in Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = mapData.properties;\r\n\r\n        /**\r\n         * The width of the map in pixels based on width * tileWidth.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.widthInPixels = mapData.widthInPixels;\r\n\r\n        /**\r\n         * The height of the map in pixels based on height * tileHeight.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.heightInPixels = mapData.heightInPixels;\r\n\r\n        /**\r\n         * A collection of Images, as parsed from Tiled map data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#imageCollections\r\n         * @type {Phaser.Tilemaps.ImageCollection[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.imageCollections = mapData.imageCollections;\r\n\r\n        /**\r\n         * An array of Tiled Image Layers.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#images\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.images = mapData.images;\r\n\r\n        /**\r\n         * An array of Tilemap layer data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#layers\r\n         * @type {Phaser.Tilemaps.LayerData[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.layers = mapData.layers;\r\n\r\n        /**\r\n         * An array of Tilesets used in the map.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tilesets\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.tilesets = mapData.tilesets;\r\n\r\n        /**\r\n         * An array of ObjectLayer instances parsed from Tiled object layers.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#objects\r\n         * @type {Phaser.Tilemaps.ObjectLayer[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.objects = mapData.objects;\r\n\r\n        /**\r\n         * The index of the currently selected LayerData object.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#currentLayerIndex\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentLayerIndex = 0;\r\n\r\n        /**\r\n         * The length of the horizontal sides of the hexagon.\r\n         * Only used for hexagonal orientation Tilemaps.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#hexSideLength\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.hexSideLength = mapData.hexSideLength;\r\n\r\n        var orientation = this.orientation;\r\n\r\n        /**\r\n         * Functions used to handle world to tile, and tile to world, conversion.\r\n         * Cached here for internal use by public methods such as `worldToTileXY`, etc.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#_convert\r\n         * @private\r\n         * @type {object}\r\n         * @since 3.50.0\r\n         */\r\n        this._convert = {\r\n            WorldToTileXY: TilemapComponents.GetWorldToTileXYFunction(orientation),\r\n            WorldToTileX: TilemapComponents.GetWorldToTileXFunction(orientation),\r\n            WorldToTileY: TilemapComponents.GetWorldToTileYFunction(orientation),\r\n            TileToWorldXY: TilemapComponents.GetTileToWorldXYFunction(orientation),\r\n            TileToWorldX: TilemapComponents.GetTileToWorldXFunction(orientation),\r\n            TileToWorldY: TilemapComponents.GetTileToWorldYFunction(orientation)\r\n        };\r\n    },\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    createBlankDynamicLayer: function (name, tileset, x, y, width, height, tileWidth, tileHeight)\r\n    {\r\n        console.warn('createBlankDynamicLayer is deprecated. Use createBlankLayer');\r\n\r\n        return this.createBlankLayer(name, tileset, x, y, width, height, tileWidth, tileHeight);\r\n    },\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    createDynamicLayer: function (layerID, tileset, x, y)\r\n    {\r\n        console.warn('createDynamicLayer is deprecated. Use createLayer');\r\n\r\n        return this.createLayer(layerID, tileset, x, y);\r\n    },\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    createStaticLayer: function (layerID, tileset, x, y)\r\n    {\r\n        console.warn('createStaticLayer is deprecated. Use createLayer');\r\n\r\n        return this.createLayer(layerID, tileset, x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets the rendering (draw) order of the tiles in this map.\r\n     *\r\n     * The default is 'right-down', meaning it will order the tiles starting from the top-left,\r\n     * drawing to the right and then moving down to the next row.\r\n     *\r\n     * The draw orders are:\r\n     *\r\n     * 0 = right-down\r\n     * 1 = left-down\r\n     * 2 = right-up\r\n     * 3 = left-up\r\n     *\r\n     * Setting the render order does not change the tiles or how they are stored in the layer,\r\n     * it purely impacts the order in which they are rendered.\r\n     *\r\n     * You can provide either an integer (0 to 3), or the string version of the order.\r\n     *\r\n     * Calling this method _after_ creating Tilemap Layers will **not** automatically\r\n     * update them to use the new render order. If you call this method after creating layers, use their\r\n     * own `setRenderOrder` methods to change them as needed.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setRenderOrder\r\n     * @since 3.12.0\r\n     *\r\n     * @param {(number|string)} renderOrder - The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setRenderOrder: function (renderOrder)\r\n    {\r\n        var orders = [ 'right-down', 'left-down', 'right-up', 'left-up' ];\r\n\r\n        if (typeof renderOrder === 'number')\r\n        {\r\n            renderOrder = orders[renderOrder];\r\n        }\r\n\r\n        if (orders.indexOf(renderOrder) > -1)\r\n        {\r\n            this.renderOrder = renderOrder;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.\r\n     * Note that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled\r\n     * editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#addTilesetImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} tilesetName - The name of the tileset as specified in the map data.\r\n     * @param {string} [key] - The key of the Phaser.Cache image used for this tileset. If\r\n     * `undefined` or `null` it will look for an image with a key matching the tilesetName parameter.\r\n     * @param {number} [tileWidth] - The width of the tile (in pixels) in the Tileset Image. If not\r\n     * given it will default to the map's tileWidth value, or the tileWidth specified in the Tiled\r\n     * JSON file.\r\n     * @param {number} [tileHeight] - The height of the tiles (in pixels) in the Tileset Image. If\r\n     * not given it will default to the map's tileHeight value, or the tileHeight specified in the\r\n     * Tiled JSON file.\r\n     * @param {number} [tileMargin] - The margin around the tiles in the sheet (in pixels). If not\r\n     * specified, it will default to 0 or the value specified in the Tiled JSON file.\r\n     * @param {number} [tileSpacing] - The spacing between each the tile in the sheet (in pixels).\r\n     * If not specified, it will default to 0 or the value specified in the Tiled JSON file.\r\n     * @param {number} [gid=0] - If adding multiple tilesets to a blank map, specify the starting\r\n     * GID this set will use here.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tileset} Returns the Tileset object that was created or updated, or null if it\r\n     * failed.\r\n     */\r\n    addTilesetImage: function (tilesetName, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid)\r\n    {\r\n        if (tilesetName === undefined) { return null; }\r\n        if (key === undefined || key === null) { key = tilesetName; }\r\n\r\n        if (!this.scene.sys.textures.exists(key))\r\n        {\r\n            console.warn('Invalid Tileset Image: ' + key);\r\n            return null;\r\n        }\r\n\r\n        var texture = this.scene.sys.textures.get(key);\r\n\r\n        var index = this.getTilesetIndex(tilesetName);\r\n\r\n        if (index === null && this.format === Formats.TILED_JSON)\r\n        {\r\n            console.warn('No data found for Tileset: ' + tilesetName);\r\n            return null;\r\n        }\r\n\r\n        var tileset = this.tilesets[index];\r\n\r\n        if (tileset)\r\n        {\r\n            tileset.setTileSize(tileWidth, tileHeight);\r\n            tileset.setSpacing(tileMargin, tileSpacing);\r\n            tileset.setImage(texture);\r\n\r\n            return tileset;\r\n        }\r\n\r\n        if (tileWidth === undefined) { tileWidth = this.tileWidth; }\r\n        if (tileHeight === undefined) { tileHeight = this.tileHeight; }\r\n        if (tileMargin === undefined) { tileMargin = 0; }\r\n        if (tileSpacing === undefined) { tileSpacing = 0; }\r\n        if (gid === undefined) { gid = 0; }\r\n\r\n        tileset = new Tileset(tilesetName, gid, tileWidth, tileHeight, tileMargin, tileSpacing);\r\n\r\n        tileset.setImage(texture);\r\n\r\n        this.tilesets.push(tileset);\r\n\r\n        return tileset;\r\n    },\r\n\r\n    /**\r\n     * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n     * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n     * information in the destination region.\r\n     *\r\n     * If no layer specified, the map's current layer is used. This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {number} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {number} width - The width of the area to copy, in tiles, not pixels.\r\n     * @param {number} height - The height of the area to copy, in tiles, not pixels.\r\n     * @param {number} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {number} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    copy: function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer !== null)\r\n        {\r\n            TilemapComponents.Copy(\r\n                srcTileX, srcTileY,\r\n                width, height,\r\n                destTileX, destTileY,\r\n                recalculateFaces, layer\r\n            );\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new and empty Tilemap Layer. The currently selected layer in the map is set to this new layer.\r\n     *\r\n     * Prior to v3.50.0 this method was called `createBlankDynamicLayer`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createBlankLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of this layer. Must be unique within the map.\r\n     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n     * @param {number} [x=0] - The world x position where the top left of this layer will be placed.\r\n     * @param {number} [y=0] - The world y position where the top left of this layer will be placed.\r\n     * @param {number} [width] - The width of the layer in tiles. If not specified, it will default to the map's width.\r\n     * @param {number} [height] - The height of the layer in tiles. If not specified, it will default to the map's height.\r\n     * @param {number} [tileWidth] - The width of the tiles the layer uses for calculations. If not specified, it will default to the map's tileWidth.\r\n     * @param {number} [tileHeight] - The height of the tiles the layer uses for calculations. If not specified, it will default to the map's tileHeight.\r\n     *\r\n     * @return {?Phaser.Tilemaps.TilemapLayer} Returns the new layer that was created, or `null` if it failed.\r\n     */\r\n    createBlankLayer: function (name, tileset, x, y, width, height, tileWidth, tileHeight)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.width; }\r\n        if (height === undefined) { height = this.height; }\r\n        if (tileWidth === undefined) { tileWidth = this.tileWidth; }\r\n        if (tileHeight === undefined) { tileHeight = this.tileHeight; }\r\n\r\n        var index = this.getLayerIndex(name);\r\n\r\n        if (index !== null)\r\n        {\r\n            console.warn('Invalid Tilemap Layer ID: ' + name);\r\n            return null;\r\n        }\r\n\r\n        var layerData = new LayerData({\r\n            name: name,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height,\r\n            orientation: this.orientation\r\n        });\r\n\r\n        var row;\r\n\r\n        for (var tileY = 0; tileY < height; tileY++)\r\n        {\r\n            row = [];\r\n\r\n            for (var tileX = 0; tileX < width; tileX++)\r\n            {\r\n                row.push(new Tile(layerData, -1, tileX, tileY, tileWidth, tileHeight, this.tileWidth, this.tileHeight));\r\n            }\r\n\r\n            layerData.data.push(row);\r\n        }\r\n\r\n        this.layers.push(layerData);\r\n\r\n        this.currentLayerIndex = this.layers.length - 1;\r\n\r\n        var layer = new TilemapLayer(this.scene, this, this.currentLayerIndex, tileset, x, y);\r\n\r\n        layer.setRenderOrder(this.renderOrder);\r\n\r\n        this.scene.sys.displayList.add(layer);\r\n\r\n        return layer;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Tilemap Layer that renders the LayerData associated with the given\r\n     * `layerID`. The currently selected layer in the map is set to this new layer.\r\n     *\r\n     * The `layerID` is important. If you've created your map in Tiled then you can get this by\r\n     * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and\r\n     * look at the layers[].name value. Either way it must match.\r\n     *\r\n     * Prior to v3.50.0 this method was called `createDynamicLayer`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|string)} layerID - The layer array index value, or if a string is given, the layer name from Tiled.\r\n     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n     * @param {number} [x=0] - The x position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n     * @param {number} [y=0] - The y position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n     *\r\n     * @return {?Phaser.Tilemaps.TilemapLayer} Returns the new layer was created, or null if it failed.\r\n     */\r\n    createLayer: function (layerID, tileset, x, y)\r\n    {\r\n        var index = this.getLayerIndex(layerID);\r\n\r\n        if (index === null)\r\n        {\r\n            console.warn('Invalid Tilemap Layer ID: ' + layerID);\r\n\r\n            if (typeof layerID === 'string')\r\n            {\r\n                console.warn('Valid tilelayer names:\\n\\t' + this.getTileLayerNames().join(',\\n\\t'));\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        var layerData = this.layers[index];\r\n\r\n        // Check for an associated static or dynamic tilemap layer\r\n        if (layerData.tilemapLayer)\r\n        {\r\n            console.warn('Tilemap Layer ID already exists:' + layerID);\r\n            return null;\r\n        }\r\n\r\n        this.currentLayerIndex = index;\r\n\r\n        //  Default the x/y position to match Tiled layer offset, if it exists.\r\n\r\n        if (x === undefined)\r\n        {\r\n            x = layerData.x;\r\n        }\r\n\r\n        if (y === undefined)\r\n        {\r\n            y = layerData.y;\r\n        }\r\n\r\n        var layer = new TilemapLayer(this.scene, this, index, tileset, x, y);\r\n\r\n        layer.setRenderOrder(this.renderOrder);\r\n\r\n        this.scene.sys.displayList.add(layer);\r\n\r\n        return layer;\r\n    },\r\n\r\n    /**\r\n     * This method will iterate through all of the objects defined in a Tiled Object Layer and then\r\n     * convert the matching results into Phaser Game Objects (by default, Sprites)\r\n     *\r\n     * Objects are matched on one of 3 criteria: The Object ID, the Object GID or the Object Name.\r\n     *\r\n     * Within Tiled, Object IDs are unique per Object. Object GIDs, however, are shared by all objects\r\n     * using the same image. Finally, Object Names are strings and the same name can be used on multiple\r\n     * Objects in Tiled, they do not have to be unique.\r\n     *\r\n     * You set the configuration parameter accordingly, based on which type of criteria you wish\r\n     * to match against. For example, to convert all items on an Object Layer with a `gid` of 26:\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, {\r\n     *   gid: 26\r\n     * });\r\n     * ```\r\n     *\r\n     * Or, to convert objects with the name 'bonus':\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, {\r\n     *   name: 'bonus'\r\n     * });\r\n     * ```\r\n     *\r\n     * Or, to convert an object with a specific id:\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, {\r\n     *   id: 9\r\n     * });\r\n     * ```\r\n     *\r\n     * You should only specify either `id`, `gid`, `name`, or none of them. Do not add more than\r\n     * one criteria to your config. If you do not specify any criteria, then _all_ objects in the\r\n     * Object Layer will be converted.\r\n     *\r\n     * By default this method will convert objects into `Sprite` instances, but you can override\r\n     * this by providing your own class type:\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, {\r\n     *   gid: 26,\r\n     *   classType: Coin\r\n     * });\r\n     * ```\r\n     *\r\n     * This will convert all Objects with a gid of 26 into your custom `Coin` class. You can pass\r\n     * any class type here, but it _must_ extend `Phaser.GameObjects.GameObject` as its base class.\r\n     * Your class will always be passed 1 parameter: `scene`, which is a reference to either the Scene\r\n     * specified in the config object or, if not given, the Scene to which this Tilemap belongs.\r\n     *\r\n     * All properties from object are copied into the Game Object, so you can use this as an easy\r\n     * way to configure properties from within the map editor. For example giving an object a\r\n     * property of `alpha: 0.5` in Tiled will be reflected in the Game Object that is created.\r\n     *\r\n     * Custom object properties that do not exist as a Game Object property are set in the\r\n     * Game Objects {@link Phaser.GameObjects.GameObject#data data store}.\r\n     *\r\n     * You can use set a `container` property in the config. If given, the class will be added to\r\n     * the Container instance instead of the Scene.\r\n     *\r\n     * Finally, you can provide an array of config objects, to convert multiple types of object in\r\n     * a single call:\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, [\r\n     *   {\r\n     *     gid: 26,\r\n     *     classType: Coin\r\n     *   },\r\n     *   {\r\n     *     id: 9,\r\n     *     classType: BossMonster\r\n     *   },\r\n     *   {\r\n     *     name: 'lava',\r\n     *     classType: LavaTile\r\n     *   }\r\n     * ]);\r\n     * ```\r\n     *\r\n     * The signature of this method changed significantly in v3.50.0. Prior to this, it did not take config objects.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createFromObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} objectLayerName - The name of the Tiled object layer to create the Game Objects from.\r\n     * @param {Phaser.Types.Tilemaps.CreateFromObjectLayerConfig|Phaser.Types.Tilemaps.CreateFromObjectLayerConfig[]} config - A CreateFromObjects configuration object, or an array of them.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array containing the Game Objects that were created. Empty if invalid object layer, or no matching id/gid/name was found.\r\n     */\r\n    createFromObjects: function (objectLayerName, config)\r\n    {\r\n        var results = [];\r\n\r\n        var objectLayer = this.getObjectLayer(objectLayerName);\r\n\r\n        if (!objectLayer)\r\n        {\r\n            console.warn('createFromObjects: Invalid objectLayerName given: ' + objectLayerName);\r\n\r\n            return results;\r\n        }\r\n\r\n        if (!Array.isArray(config))\r\n        {\r\n            config = [ config ];\r\n        }\r\n\r\n        var objects = objectLayer.objects;\r\n\r\n        for (var c = 0; c < config.length; c++)\r\n        {\r\n            var singleConfig = config[c];\r\n\r\n            var id = GetFastValue(singleConfig, 'id', null);\r\n            var gid = GetFastValue(singleConfig, 'gid', null);\r\n            var name = GetFastValue(singleConfig, 'name', null);\r\n\r\n            var obj;\r\n            var toConvert = [];\r\n\r\n            //  Sweep to get all the objects we want to convert in this pass\r\n            for (var s = 0; s < objects.length; s++)\r\n            {\r\n                obj = objects[s];\r\n\r\n                if (\r\n                    (id === null && gid === null && name === null) ||\r\n                    (id !== null && obj.id === id) ||\r\n                    (gid !== null && obj.gid === gid) ||\r\n                    (name !== null && obj.name === name)\r\n                )\r\n                {\r\n                    toConvert.push(obj);\r\n                }\r\n            }\r\n\r\n            //  Now let's convert them ...\r\n\r\n            var classType = GetFastValue(singleConfig, 'classType', Sprite);\r\n            var scene = GetFastValue(singleConfig, 'scene', this.scene);\r\n            var container = GetFastValue(singleConfig, 'container', null);\r\n            var texture = GetFastValue(singleConfig, 'key', null);\r\n            var frame = GetFastValue(singleConfig, 'frame', null);\r\n\r\n            for (var i = 0; i < toConvert.length; i++)\r\n            {\r\n                obj = toConvert[i];\r\n\r\n                var sprite = new classType(scene);\r\n\r\n                sprite.setName(obj.name);\r\n                sprite.setPosition(obj.x, obj.y);\r\n                sprite.setTexture(texture, frame);\r\n\r\n                if (obj.width)\r\n                {\r\n                    sprite.displayWidth = obj.width;\r\n                }\r\n\r\n                if (obj.height)\r\n                {\r\n                    sprite.displayHeight = obj.height;\r\n                }\r\n\r\n                //  Origin is (0, 1) in Tiled, so find the offset that matches the Sprites origin.\r\n                //  Do not offset objects with zero dimensions (e.g. points).\r\n                var offset = {\r\n                    x: sprite.originX * obj.width,\r\n                    y: (sprite.originY - 1) * obj.height\r\n                };\r\n\r\n                //  If the object is rotated, then the origin offset also needs to be rotated.\r\n                if (obj.rotation)\r\n                {\r\n                    var angle = DegToRad(obj.rotation);\r\n\r\n                    Rotate(offset, angle);\r\n\r\n                    sprite.rotation = angle;\r\n                }\r\n\r\n                sprite.x += offset.x;\r\n                sprite.y += offset.y;\r\n\r\n                if (obj.flippedHorizontal !== undefined || obj.flippedVertical !== undefined)\r\n                {\r\n                    sprite.setFlip(obj.flippedHorizontal, obj.flippedVertical);\r\n                }\r\n\r\n                if (!obj.visible)\r\n                {\r\n                    sprite.visible = false;\r\n                }\r\n\r\n                //  Set properties the class may have, or setData those it doesn't\r\n                if (Array.isArray(obj.properties))\r\n                {\r\n                    // Tiled objects custom properties format\r\n                    obj.properties.forEach(function (propData)\r\n                    {\r\n                        var key = propData['name'];\r\n                        if (sprite[key] !== undefined)\r\n                        {\r\n                            sprite[key] = propData['value'];\r\n                        }\r\n                        else\r\n                        {\r\n                            sprite.setData(key, propData['value']);\r\n                        }\r\n                    });\r\n                }\r\n                else\r\n                {\r\n                    for (var key in obj.properties)\r\n                    {\r\n                        if (sprite[key] !== undefined)\r\n                        {\r\n                            sprite[key] = obj.properties[key];\r\n                        }\r\n                        else\r\n                        {\r\n                            sprite.setData(key, obj.properties[key]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (container)\r\n                {\r\n                    container.add(sprite);\r\n                }\r\n                else\r\n                {\r\n                    scene.add.existing(sprite);\r\n                }\r\n\r\n                results.push(sprite);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n     * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n     * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createFromTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n     * @param {(number|array)} replacements - The tile index, or array of indexes, to change a converted\r\n     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a\r\n     * one-to-one mapping with the indexes array.\r\n     * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e. scene.make.sprite).\r\n     * @param {Phaser.Scene} [scene] - The Scene to create the Sprites within.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.GameObjects.Sprite[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    createFromTiles: function (indexes, replacements, spriteConfig, scene, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n     * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n     * Collision information in the region will be recalculated.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#fill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} index - The tile index to fill the area with.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    fill: function (index, tileX, tileY, width, height, recalculateFaces, layer)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * For each object in the given object layer, run the given filter callback function. Any\r\n     * objects that pass the filter test (i.e. where the callback returns true) will returned as a\r\n     * new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#filterObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.ObjectLayer|string)} objectLayer - The name of an object layer (from Tiled) or an ObjectLayer instance.\r\n     * @param {TilemapFilterCallback} callback - The callback. Each object in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     *\r\n     * @return {?Phaser.Types.Tilemaps.TiledObject[]} An array of object that match the search, or null if the objectLayer given was invalid.\r\n     */\r\n    filterObjects: function (objectLayer, callback, context)\r\n    {\r\n        if (typeof objectLayer === 'string')\r\n        {\r\n            var name = objectLayer;\r\n\r\n            objectLayer = this.getObjectLayer(objectLayer);\r\n\r\n            if (!objectLayer)\r\n            {\r\n                console.warn('No object layer found with the name: ' + name);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return objectLayer.objects.filter(callback, context);\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#filterTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n     * filter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    filterTiles: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer);\r\n    },\r\n\r\n    /**\r\n     * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n     * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n     * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n     * the top-left.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} index - The tile index value to search for.\r\n     * @param {number} [skip=0] - The number of times to skip a matching tile before returning.\r\n     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.\r\n     */\r\n    findByIndex: function (findIndex, skip, reverse, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.FindByIndex(findIndex, skip, reverse, layer);\r\n    },\r\n\r\n    /**\r\n     * Find the first object in the given object layer that satisfies the provided testing function.\r\n     * I.e. finds the first object for which `callback` returns true. Similar to\r\n     * Array.prototype.find in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.ObjectLayer|string)} objectLayer - The name of an object layer (from Tiled) or an ObjectLayer instance.\r\n     * @param {TilemapFindCallback} callback - The callback. Each object in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     *\r\n     * @return {?Phaser.Types.Tilemaps.TiledObject} An object that matches the search, or null if no object found.\r\n     */\r\n    findObject: function (objectLayer, callback, context)\r\n    {\r\n        if (typeof objectLayer === 'string')\r\n        {\r\n            var name = objectLayer;\r\n\r\n            objectLayer = this.getObjectLayer(objectLayer);\r\n\r\n            if (!objectLayer)\r\n            {\r\n                console.warn('No object layer found with the name: ' + name);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return objectLayer.objects.find(callback, context) || null;\r\n    },\r\n\r\n    /**\r\n     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n     * true. Similar to Array.prototype.find in vanilla JS.\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The Tile layer to run the search on. If not provided will use the current layer.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.\r\n     */\r\n    findTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#forEachTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The Tile layer to run the search on. If not provided will use the current layer.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    forEachTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the image layer index based on its name.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getImageIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the image to get.\r\n     *\r\n     * @return {number} The index of the image in this tilemap, or null if not found.\r\n     */\r\n    getImageIndex: function (name)\r\n    {\r\n        return this.getIndex(this.images, name);\r\n    },\r\n\r\n    /**\r\n     * Return a list of all valid imagelayer names loaded in this Tilemap.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getImageLayerNames\r\n     * @since 3.21.0\r\n     *\r\n     * @return {string[]} Array of valid imagelayer names / IDs loaded into this Tilemap.\r\n     */\r\n    getImageLayerNames: function ()\r\n    {\r\n        if (!this.images || !Array.isArray(this.images))\r\n        {\r\n            return [];\r\n        }\r\n\r\n        return this.images.map(function (image)\r\n        {\r\n            return image.name;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Internally used. Returns the index of the object in one of the Tilemaps arrays whose name\r\n     * property matches the given `name`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} location - The Tilemap array to search.\r\n     * @param {string} name - The name of the array element to get.\r\n     *\r\n     * @return {number} The index of the element in the array, or null if not found.\r\n     */\r\n    getIndex: function (location, name)\r\n    {\r\n        for (var i = 0; i < location.length; i++)\r\n        {\r\n            if (location[i].name === name)\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Gets the LayerData from `this.layers` that is associated with the given `layer`, or null if the layer is invalid.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The name of the layer from Tiled, the index of the layer in the map or Tilemap Layer. If not given will default to the maps current layer index.\r\n     *\r\n     * @return {Phaser.Tilemaps.LayerData} The corresponding LayerData within this.layers.\r\n     */\r\n    getLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        return (index !== null) ? this.layers[index] : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the ObjectLayer from `this.objects` that has the given `name`, or null if no ObjectLayer is found with that name.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getObjectLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [name] - The name of the object layer from Tiled.\r\n     *\r\n     * @return {?Phaser.Tilemaps.ObjectLayer} The corresponding `ObjectLayer` within `this.objects`, or null.\r\n     */\r\n    getObjectLayer: function (name)\r\n    {\r\n        var index = this.getIndex(this.objects, name);\r\n\r\n        return (index !== null) ? this.objects[index] : null;\r\n    },\r\n\r\n    /**\r\n     * Return a list of all valid objectgroup names loaded in this Tilemap.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getObjectLayerNames\r\n     * @since 3.21.0\r\n     *\r\n     * @return {string[]} Array of valid objectgroup names / IDs loaded into this Tilemap.\r\n     */\r\n    getObjectLayerNames: function ()\r\n    {\r\n        if (!this.objects || !Array.isArray(this.objects))\r\n        {\r\n            return [];\r\n        }\r\n\r\n        return this.objects.map(function (object)\r\n        {\r\n            return object.name;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Gets the LayerData index of the given `layer` within this.layers, or null if an invalid\r\n     * `layer` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayerIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The name of the layer from Tiled, the index of the layer in the map or a Tilemap Layer. If not given will default to the map's current layer index.\r\n     *\r\n     * @return {number} The LayerData index within this.layers.\r\n     */\r\n    getLayerIndex: function (layer)\r\n    {\r\n        if (layer === undefined)\r\n        {\r\n            return this.currentLayerIndex;\r\n        }\r\n        else if (typeof layer === 'string')\r\n        {\r\n            return this.getLayerIndexByName(layer);\r\n        }\r\n        else if (typeof layer === 'number' && layer < this.layers.length)\r\n        {\r\n            return layer;\r\n        }\r\n        else if (layer instanceof TilemapLayer)\r\n        {\r\n            return layer.layerIndex;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Gets the index of the LayerData within this.layers that has the given `name`, or null if an\r\n     * invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayerIndexByName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the layer to get.\r\n     *\r\n     * @return {number} The LayerData index within this.layers.\r\n     */\r\n    getLayerIndexByName: function (name)\r\n    {\r\n        return this.getIndex(this.layers, name);\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given tile coordinates from the given layer.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - X position to get the tile from (given in tile units, not pixels).\r\n     * @param {number} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n     * @param {boolean} [nonNull] - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    getTileAt: function (tileX, tileY, nonNull, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTileAt(tileX, tileY, nonNull, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given world coordinates from the given layer.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - X position to get the tile from (given in pixels)\r\n     * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n     * @param {boolean} [nonNull] - If true, function won't return null for empty tiles, but a Tile object with an index of -1.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    getTileAtWorldXY: function (worldX, worldY, nonNull, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Return a list of all valid tilelayer names loaded in this Tilemap.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileLayerNames\r\n     * @since 3.21.0\r\n     *\r\n     * @return {string[]} Array of valid tilelayer names / IDs loaded into this Tilemap.\r\n     */\r\n    getTileLayerNames: function ()\r\n    {\r\n        if (!this.layers || !Array.isArray(this.layers))\r\n        {\r\n            return [];\r\n        }\r\n\r\n        return this.layers.map(function (layer)\r\n        {\r\n            return layer.name;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    getTilesWithin: function (tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n     * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithinShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    getTilesWithinShape: function (shape, filteringOptions, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithinWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The world x coordinate for the top-left of the area.\r\n     * @param {number} worldY - The world y coordinate for the top-left of the area.\r\n     * @param {number} width - The width of the area.\r\n     * @param {number} height - The height of the area.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    getTilesWithinWorldXY: function (worldX, worldY, width, height, filteringOptions, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the Tileset that has the given `name`, or null if an invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileset\r\n     * @since 3.14.0\r\n     *\r\n     * @param {string} name - The name of the Tileset to get.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tileset} The Tileset, or `null` if no matching named tileset was found.\r\n     */\r\n    getTileset: function (name)\r\n    {\r\n        var index = this.getIndex(this.tilesets, name);\r\n\r\n        return (index !== null) ? this.tilesets[index] : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the index of the Tileset within this.tilesets that has the given `name`, or null if an\r\n     * invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesetIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the Tileset to get.\r\n     *\r\n     * @return {number} The Tileset index within this.tilesets.\r\n     */\r\n    getTilesetIndex: function (name)\r\n    {\r\n        return this.getIndex(this.tilesets, name);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#hasTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n     */\r\n    hasTileAt: function (tileX, tileY, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.HasTileAt(tileX, tileY, layer);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#hasTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n     */\r\n    hasTileAtWorldXY: function (worldX, worldY, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * The LayerData object that is currently selected in the map. You can set this property using\r\n     * any type supported by setLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#layer\r\n     * @type {Phaser.Tilemaps.LayerData}\r\n     * @since 3.0.0\r\n     */\r\n    layer: {\r\n        get: function ()\r\n        {\r\n            return this.layers[this.currentLayerIndex];\r\n        },\r\n\r\n        set: function (layer)\r\n        {\r\n            this.setLayer(layer);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n     * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n     * location. If you pass in an index, only the index at the specified location will be changed.\r\n     * Collision information will be recalculated at the specified location.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces] - `true` if the faces data should be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid or the coordinates were out of bounds.\r\n     */\r\n    putTileAt: function (tile, tileX, tileY, recalculateFaces, layer)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, layer);\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n     * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n     * specified location. If you pass in an index, only the index at the specified location will be\r\n     * changed. Collision information will be recalculated at the specified location.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [recalculateFaces] - `true` if the faces data should be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    putTileAtWorldXY: function (tile, worldX, worldY, recalculateFaces, camera, layer)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n     * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n     * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n     * index at the specified location will be changed. Collision information will be recalculated\r\n     * within the region tiles were changed.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTilesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number[]|number[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces] - `true` if the faces data should be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    putTilesAt: function (tilesArray, tileX, tileY, recalculateFaces, layer)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n     * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n     * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n     * indexes. This method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#randomize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {number[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    randomize: function (tileX, tileY, width, height, indexes, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.Randomize(tileX, tileY, width, height, indexes, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n     * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n     * internally to optimize recalculating faces when only one tile has been changed.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#calculateFacesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    calculateFacesAt: function (tileX, tileY, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.CalculateFacesAt(tileX, tileY, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n     * is mostly used internally.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#calculateFacesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    calculateFacesWithin: function (tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the given TilemapLayer from this Tilemap without destroying it.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeLayer\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to be removed.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    removeLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        if (index !== null)\r\n        {\r\n            SpliceOne(this.layers, index);\r\n\r\n            for (var i = index; i < this.layers.length; i++)\r\n            {\r\n                if (this.layers[i].tilemapLayer)\r\n                {\r\n                    this.layers[i].tilemapLayer.layerIndex--;\r\n                }\r\n            }\r\n\r\n            if (this.currentLayerIndex === index)\r\n            {\r\n                this.currentLayerIndex = 0;\r\n            }\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys the given TilemapLayer and removes it from this Tilemap.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#destroyLayer\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to be destroyed.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    destroyLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        if (index !== null)\r\n        {\r\n            layer = this.layers[index];\r\n\r\n            layer.destroy();\r\n\r\n            SpliceOne(this.layers, index);\r\n\r\n            if (this.currentLayerIndex === index)\r\n            {\r\n                this.currentLayerIndex = 0;\r\n            }\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes all Tilemap Layers from this Tilemap and calls `destroy` on each of them.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeAllLayers\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    removeAllLayers: function ()\r\n    {\r\n        var layers = this.layers;\r\n\r\n        for (var i = 0; i < layers.length; i++)\r\n        {\r\n            if (layers[i].tilemapLayer)\r\n            {\r\n                layers[i].tilemapLayer.destroy(false);\r\n            }\r\n        }\r\n\r\n        layers.length = 0;\r\n\r\n        this.currentLayerIndex = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the given Tile, or an array of Tiles, from the layer to which they belong,\r\n     * and optionally recalculates the collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTile\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.Tile|Phaser.Tilemaps.Tile[])} tiles - The Tile to remove, or an array of Tiles.\r\n     * @param {number} [replaceIndex=-1] - After removing the Tile, insert a brand new Tile into its location with the given index. Leave as -1 to just remove the tile.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} Returns an array of Tiles that were removed.\r\n     */\r\n    removeTile: function (tiles, replaceIndex, recalculateFaces)\r\n    {\r\n        if (replaceIndex === undefined) { replaceIndex = -1; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        var removed = [];\r\n\r\n        if (!Array.isArray(tiles))\r\n        {\r\n            tiles = [ tiles ];\r\n        }\r\n\r\n        for (var i = 0; i < tiles.length; i++)\r\n        {\r\n            var tile = tiles[i];\r\n\r\n            removed.push(this.removeTileAt(tile.x, tile.y, true, recalculateFaces, tile.tilemapLayer));\r\n\r\n            if (replaceIndex > -1)\r\n            {\r\n                this.putTileAt(replaceIndex, tile.x, tile.y, recalculateFaces, tile.tilemapLayer);\r\n            }\r\n        }\r\n\r\n        return removed;\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given tile coordinates in the specified layer and updates the layers collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [replaceWithNull] - If `true` (the default), this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces] - If `true` (the default), the faces data will be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns the Tile that was removed, or null if the layer given was invalid.\r\n     */\r\n    removeTileAt: function (tileX, tileY, replaceWithNull, recalculateFaces, layer)\r\n    {\r\n        if (replaceWithNull === undefined) { replaceWithNull = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer);\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given world coordinates in the specified layer and updates the layers collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [replaceWithNull] - If `true` (the default), this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces] - If `true` (the default), the faces data will be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    removeTileAtWorldXY: function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer)\r\n    {\r\n        if (replaceWithNull === undefined) { replaceWithNull = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Draws a debug representation of the layer to the given Graphics object. This is helpful when you want to\r\n     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n     * wherever you want on the screen.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * **Note:** This method currently only works with orthogonal tilemap layers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#renderDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {Phaser.Types.Tilemaps.StyleConfig} [styleConfig] - An object specifying the colors to use for the debug drawing.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    renderDebug: function (graphics, styleConfig, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        if (this.orientation === ORIENTATION.ORTHOGONAL)\r\n        {\r\n            TilemapComponents.RenderDebug(graphics, styleConfig, layer);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws a debug representation of all layers within this Tilemap to the given Graphics object.\r\n     *\r\n     * This is helpful when you want to get a quick idea of which of your tiles are colliding and which\r\n     * have interesting faces. The tiles are drawn starting at (0, 0) in the Graphics, allowing you to\r\n     * place the debug representation wherever you want on the screen.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#renderDebugFull\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {Phaser.Types.Tilemaps.StyleConfig} [styleConfig] - An object specifying the colors to use for the debug drawing.\r\n     *\r\n     * @return {this} This Tilemap instance.\r\n     */\r\n    renderDebugFull: function (graphics, styleConfig)\r\n    {\r\n        var layers = this.layers;\r\n\r\n        for (var i = 0; i < layers.length; i++)\r\n        {\r\n            TilemapComponents.RenderDebug(graphics, styleConfig, layers[i]);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n     * not change collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#replaceByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} findIndex - The index of the tile to search for.\r\n     * @param {number} newIndex - The index of the tile to replace it with.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    replaceByIndex: function (findIndex, newIndex, tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n     * collision will be enabled (true) or disabled (false).\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollision: function (indexes, collides, recalculateFaces, layer, updateLayer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n        if (updateLayer === undefined) { updateLayer = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollision(indexes, collides, recalculateFaces, layer, updateLayer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n     * enabled (true) or disabled (false).\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionBetween\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} start - The first index of the tile to be set for collision.\r\n     * @param {number} stop - The last index of the tile to be set for collision.\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionBetween: function (start, stop, collides, recalculateFaces, layer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n     * that matches the given properties object, its collision flag will be set. The `collides`\r\n     * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n     * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n     * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n     * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n     * \"types\" property that matches any of those values, its collision flag will be updated.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionByProperty\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} properties - An object with tile properties and corresponding values that should be checked.\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionByProperty: function (properties, collides, recalculateFaces, layer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n     * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n     * disabled (false). Tile indexes not currently in the layer are not affected.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionByExclusion\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number[]} indexes - An array of the tile indexes to not be counted for collision.\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionByExclusion: function (indexes, collides, recalculateFaces, layer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking each tiles collision group data\r\n     * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n     * a tiles collision group, the tiles colliding information will be set. The `collides` parameter\r\n     * controls if collision will be enabled (true) or disabled (false).\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionFromCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionFromCollisionGroup: function (collides, recalculateFaces, layer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n     * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n     * at a specific location on the map then see `setTileLocationCallback`.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setTileIndexCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|number[])} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for. All values should be integers.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setTileIndexCallback: function (indexes, callback, callbackContext, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n     * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n     * remove it.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setTileLocationCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} [callbackContext] - The context under which the callback is called.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setTileLocationCallback: function (tileX, tileY, width, height, callback, callbackContext, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current layer to the LayerData associated with `layer`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The name of the layer from Tiled, the index of the layer in the map or a TilemapLayer. If not given will default to the maps current layer index.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        if (index !== null)\r\n        {\r\n            this.currentLayerIndex = index;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the base tile size for the map. Note: this does not necessarily match the tileWidth and\r\n     * tileHeight for all layers. This also updates the base size on all tiles across all layers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setBaseTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileWidth - The width of the tiles the map uses for calculations.\r\n     * @param {number} tileHeight - The height of the tiles the map uses for calculations.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setBaseTileSize: function (tileWidth, tileHeight)\r\n    {\r\n        this.tileWidth = tileWidth;\r\n        this.tileHeight = tileHeight;\r\n        this.widthInPixels = this.width * tileWidth;\r\n        this.heightInPixels = this.height * tileHeight;\r\n\r\n        //  Update the base tile size on all layers & tiles\r\n        for (var i = 0; i < this.layers.length; i++)\r\n        {\r\n            this.layers[i].baseTileWidth = tileWidth;\r\n            this.layers[i].baseTileHeight = tileHeight;\r\n\r\n            var mapData = this.layers[i].data;\r\n            var mapWidth = this.layers[i].width;\r\n            var mapHeight = this.layers[i].height;\r\n\r\n            for (var row = 0; row < mapHeight; row++)\r\n            {\r\n                for (var col = 0; col < mapWidth; col++)\r\n                {\r\n                    var tile = mapData[row][col];\r\n\r\n                    if (tile !== null)\r\n                    {\r\n                        tile.setSize(undefined, undefined, tileWidth, tileHeight);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tile size for a specific `layer`. Note: this does not necessarily match the maps\r\n     * tileWidth and tileHeight for all layers. This will set the tile size for the layer and any\r\n     * tiles the layer has.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setLayerTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileWidth - The width of the tiles (in pixels) in the layer.\r\n     * @param {number} tileHeight - The height of the tiles (in pixels) in the layer.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The name of the layer from Tiled, the index of the layer in the map or a TilemapLayer. If not given will default to the maps current layer index.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setLayerTileSize: function (tileWidth, tileHeight, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return this; }\r\n\r\n        layer.tileWidth = tileWidth;\r\n        layer.tileHeight = tileHeight;\r\n\r\n        var mapData = layer.data;\r\n        var mapWidth = layer.width;\r\n        var mapHeight = layer.height;\r\n\r\n        for (var row = 0; row < mapHeight; row++)\r\n        {\r\n            for (var col = 0; col < mapWidth; col++)\r\n            {\r\n                var tile = mapData[row][col];\r\n\r\n                if (tile !== null)\r\n                {\r\n                    tile.setSize(tileWidth, tileHeight);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n     * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n     * appear to have changed! This method only modifies tile indexes and does not change collision\r\n     * information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#shuffle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    shuffle: function (tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.Shuffle(tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n     * information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#swapByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileA - First tile index.\r\n     * @param {number} tileB - Second tile index.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    swapByIndex: function (indexA, indexB, tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    tileToWorldX: function (tileX, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.TileToWorldX(tileX, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    tileToWorldY: function (tileX, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.TileToWorldY(tileX, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Math.Vector2} [vec2] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Math.Vector2} Returns a Vector2, or null if the layer given was invalid.\r\n     */\r\n    tileToWorldXY: function (tileX, tileY, vec2, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.TileToWorldXY(tileX, tileY, vec2, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n     * weightedIndexes array. An example weighted array:\r\n     *\r\n     * [\r\n     *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n     *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n     *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n     *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n     * ]\r\n     *\r\n     * The probability of any index being picked is (the indexs weight) / (sum of all weights). This\r\n     * method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#weightedRandomize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object[]} weightedIndexes - An array of objects to randomly draw from during randomization. They should be in the form: { index: 0, weight: 4 } or { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    weightedRandomize: function (weightedIndexes, tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    worldToTileX: function (worldX, snapToFloor, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.WorldToTileX(worldX, snapToFloor, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    worldToTileY: function (worldY, snapToFloor, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.WorldToTileY(worldY, snapToFloor, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Math.Vector2} [vec2] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Math.Vector2} Returns a vec2, or null if the layer given was invalid.\r\n     */\r\n    worldToTileXY: function (worldX, worldY, snapToFloor, vec2, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.WorldToTileXY(worldX, worldY, snapToFloor, vec2, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Removes all layer data from this Tilemap and nulls the scene reference. This will destroy any\r\n     * TilemapLayers that have been created.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllLayers();\r\n\r\n        this.tilesets.length = 0;\r\n        this.objects.length = 0;\r\n\r\n        this.scene = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Tilemap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectCreator = require('../gameobjects/GameObjectCreator');\r\nvar ParseToTilemap = require('./ParseToTilemap');\r\n\r\n/**\r\n * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.\r\n * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing\r\n * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map\r\n * data. For an empty map, you should specify tileWidth, tileHeight, width & height.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#tilemap\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Types.Tilemaps.TilemapConfig} [config] - The config options for the Tilemap.\r\n * \r\n * @return {Phaser.Tilemaps.Tilemap}\r\n */\r\nGameObjectCreator.register('tilemap', function (config)\r\n{\r\n    // Defaults are applied in ParseToTilemap\r\n    var c = (config !== undefined) ? config : {};\r\n\r\n    return ParseToTilemap(\r\n        this.scene,\r\n        c.key,\r\n        c.tileWidth,\r\n        c.tileHeight,\r\n        c.width,\r\n        c.height,\r\n        c.data,\r\n        c.insertNull\r\n    );\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../gameobjects/GameObjectFactory');\r\nvar ParseToTilemap = require('./ParseToTilemap');\r\n\r\n/**\r\n * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.\r\n * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing\r\n * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map\r\n * data. For an empty map, you should specify tileWidth, tileHeight, width & height.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#tilemap\r\n * @since 3.0.0\r\n *\r\n * @param {string} [key] - The key in the Phaser cache that corresponds to the loaded tilemap data.\r\n * @param {number} [tileWidth=32] - The width of a tile in pixels. Pass in `null` to leave as the\r\n * default.\r\n * @param {number} [tileHeight=32] - The height of a tile in pixels. Pass in `null` to leave as the\r\n * default.\r\n * @param {number} [width=10] - The width of the map in tiles. Pass in `null` to leave as the\r\n * default.\r\n * @param {number} [height=10] - The height of the map in tiles. Pass in `null` to leave as the\r\n * default.\r\n * @param {number[][]} [data] - Instead of loading from the cache, you can also load directly from\r\n * a 2D array of tile indexes. Pass in `null` for no data.\r\n * @param {boolean} [insertNull=false] - Controls how empty tiles, tiles with an index of -1, in the\r\n * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n * \r\n * @return {Phaser.Tilemaps.Tilemap}\r\n */\r\nGameObjectFactory.register('tilemap', function (key, tileWidth, tileHeight, width, height, data, insertNull)\r\n{\r\n    // Allow users to specify null to indicate that they want the default value, since null is\r\n    // shorter & more legible than undefined. Convert null to undefined to allow ParseToTilemap\r\n    // defaults to take effect.\r\n\r\n    if (key === null) { key = undefined; }\r\n    if (tileWidth === null) { tileWidth = undefined; }\r\n    if (tileHeight === null) { tileHeight = undefined; }\r\n    if (width === null) { width = undefined; }\r\n    if (height === null) { height = undefined; }\r\n\r\n    return ParseToTilemap(this.scene, key, tileWidth, tileHeight, width, height, data, insertNull);\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Components = require('../gameobjects/components');\r\nvar GameObject = require('../gameobjects/GameObject');\r\nvar TilemapComponents = require('./components');\r\nvar TilemapLayerRender = require('./TilemapLayerRender');\r\n\r\n/**\r\n * @classdesc\r\n * A Tilemap Layer is a Game Object that renders LayerData from a Tilemap when used in combination\r\n * with one, or more, Tilesets.\r\n *\r\n * @class TilemapLayer\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\r\n * @param {Phaser.Tilemaps.Tilemap} tilemap - The Tilemap this layer is a part of.\r\n * @param {number} layerIndex - The index of the LayerData associated with this layer.\r\n * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n * @param {number} [x=0] - The world x position where the top left of this layer will be placed.\r\n * @param {number} [y=0] - The world y position where the top left of this layer will be placed.\r\n */\r\nvar TilemapLayer = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Components.ScrollFactor,\r\n        TilemapLayerRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function TilemapLayer (scene, tilemap, layerIndex, tileset, x, y)\r\n    {\r\n        GameObject.call(this, scene, 'TilemapLayer');\r\n\r\n        /**\r\n         * Used internally by physics system to perform fast type checks.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#isTilemap\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.isTilemap = true;\r\n\r\n        /**\r\n         * The Tilemap that this layer is a part of.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#tilemap\r\n         * @type {Phaser.Tilemaps.Tilemap}\r\n         * @since 3.50.0\r\n         */\r\n        this.tilemap = tilemap;\r\n\r\n        /**\r\n         * The index of the LayerData associated with this layer.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#layerIndex\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.layerIndex = layerIndex;\r\n\r\n        /**\r\n         * The LayerData associated with this layer. LayerData can only be associated with one\r\n         * tilemap layer.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#layer\r\n         * @type {Phaser.Tilemaps.LayerData}\r\n         * @since 3.50.0\r\n         */\r\n        this.layer = tilemap.layers[layerIndex];\r\n\r\n        // Link the LayerData with this static tilemap layer\r\n        this.layer.tilemapLayer = this;\r\n\r\n        /**\r\n         * An array of `Tileset` objects associated with this layer.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#tileset\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.tileset = [];\r\n\r\n        /**\r\n         * The total number of tiles drawn by the renderer in the last frame.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#tilesDrawn\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.tilesDrawn = 0;\r\n\r\n        /**\r\n         * The total number of tiles in this layer. Updated every frame.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#tilesTotal\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.tilesTotal = this.layer.width * this.layer.height;\r\n\r\n        /**\r\n         * Used internally during rendering. This holds the tiles that are visible within the Camera.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#culledTiles\r\n         * @type {Phaser.Tilemaps.Tile[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.culledTiles = [];\r\n\r\n        /**\r\n         * You can control if the camera should cull tiles on this layer before rendering them or not.\r\n         *\r\n         * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.\r\n         *\r\n         * However, there are some instances when you may wish to disable this, and toggling this flag allows\r\n         * you to do so. Also see `setSkipCull` for a chainable method that does the same thing.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#skipCull\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.skipCull = false;\r\n\r\n        /**\r\n         * The amount of extra tiles to add into the cull rectangle when calculating its horizontal size.\r\n         *\r\n         * See the method `setCullPadding` for more details.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#cullPaddingX\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.50.0\r\n         */\r\n        this.cullPaddingX = 1;\r\n\r\n        /**\r\n         * The amount of extra tiles to add into the cull rectangle when calculating its vertical size.\r\n         *\r\n         * See the method `setCullPadding` for more details.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#cullPaddingY\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.50.0\r\n         */\r\n        this.cullPaddingY = 1;\r\n\r\n        /**\r\n         * The callback that is invoked when the tiles are culled.\r\n         *\r\n         * It will call a different function based on the map orientation:\r\n         *\r\n         * Orthogonal (the default) is `TilemapComponents.CullTiles`\r\n         * Isometric is `TilemapComponents.IsometricCullTiles`\r\n         * Hexagonal is `TilemapComponents.HexagonalCullTiles`\r\n         * Staggered is `TilemapComponents.StaggeredCullTiles`\r\n         *\r\n         * However, you can override this to call any function you like.\r\n         *\r\n         * It will be sent 4 arguments:\r\n         *\r\n         * 1. The Phaser.Tilemaps.LayerData object for this Layer\r\n         * 2. The Camera that is culling the layer. You can check its `dirty` property to see if it has changed since the last cull.\r\n         * 3. A reference to the `culledTiles` array, which should be used to store the tiles you want rendered.\r\n         * 4. The Render Order constant.\r\n         *\r\n         * See the `TilemapComponents.CullTiles` source code for details on implementing your own culling system.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#cullCallback\r\n         * @type {function}\r\n         * @since 3.50.0\r\n         */\r\n        this.cullCallback = TilemapComponents.GetCullTilesFunction(this.layer.orientation);\r\n\r\n        /**\r\n         * The rendering (draw) order of the tiles in this layer.\r\n         *\r\n         * The default is 0 which is 'right-down', meaning it will draw the tiles starting from the top-left,\r\n         * drawing to the right and then moving down to the next row.\r\n         *\r\n         * The draw orders are:\r\n         *\r\n         * 0 = right-down\r\n         * 1 = left-down\r\n         * 2 = right-up\r\n         * 3 = left-up\r\n         *\r\n         * This can be changed via the `setRenderOrder` method.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#_renderOrder\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this._renderOrder = 0;\r\n\r\n        /**\r\n         * An array holding the mapping between the tile indexes and the tileset they belong to.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#gidMap\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.gidMap = [];\r\n\r\n        this.setTilesets(tileset);\r\n        this.setAlpha(this.layer.alpha);\r\n        this.setPosition(x, y);\r\n        this.setOrigin();\r\n        this.setSize(tilemap.tileWidth * this.layer.width, tilemap.tileHeight * this.layer.height);\r\n\r\n        this.initPipeline();\r\n    },\r\n\r\n    /**\r\n     * Populates the internal `tileset` array with the Tileset references this Layer requires for rendering.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setTilesets\r\n     * @private\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n     */\r\n    setTilesets: function (tilesets)\r\n    {\r\n        var gidMap = [];\r\n        var setList = [];\r\n        var map = this.tilemap;\r\n\r\n        if (!Array.isArray(tilesets))\r\n        {\r\n            tilesets = [ tilesets ];\r\n        }\r\n\r\n        for (var i = 0; i < tilesets.length; i++)\r\n        {\r\n            var tileset = tilesets[i];\r\n\r\n            if (typeof tileset === 'string')\r\n            {\r\n                tileset = map.getTileset(tileset);\r\n            }\r\n\r\n            if (tileset)\r\n            {\r\n                setList.push(tileset);\r\n\r\n                var s = tileset.firstgid;\r\n\r\n                for (var t = 0; t < tileset.total; t++)\r\n                {\r\n                    gidMap[s + t] = tileset;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.gidMap = gidMap;\r\n        this.tileset = setList;\r\n    },\r\n\r\n    /**\r\n     * Sets the rendering (draw) order of the tiles in this layer.\r\n     *\r\n     * The default is 'right-down', meaning it will order the tiles starting from the top-left,\r\n     * drawing to the right and then moving down to the next row.\r\n     *\r\n     * The draw orders are:\r\n     *\r\n     * 0 = right-down\r\n     * 1 = left-down\r\n     * 2 = right-up\r\n     * 3 = left-up\r\n     *\r\n     * Setting the render order does not change the tiles or how they are stored in the layer,\r\n     * it purely impacts the order in which they are rendered.\r\n     *\r\n     * You can provide either an integer (0 to 3), or the string version of the order.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setRenderOrder\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|string)} renderOrder - The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setRenderOrder: function (renderOrder)\r\n    {\r\n        var orders = [ 'right-down', 'left-down', 'right-up', 'left-up' ];\r\n\r\n        if (typeof renderOrder === 'string')\r\n        {\r\n            renderOrder = orders.indexOf(renderOrder);\r\n        }\r\n\r\n        if (renderOrder >= 0 && renderOrder < 4)\r\n        {\r\n            this._renderOrder = renderOrder;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n     * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n     * internally to optimize recalculating faces when only one tile has been changed.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#calculateFacesAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate.\r\n     * @param {number} tileY - The y coordinate.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    calculateFacesAt: function (tileX, tileY)\r\n    {\r\n        TilemapComponents.CalculateFacesAt(tileX, tileY, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n     * is mostly used internally.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#calculateFacesWithin\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    calculateFacesWithin: function (tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n     * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n     * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#createFromTiles\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n     * @param {(number|array)} replacements - The tile index, or array of indexes, to change a converted\r\n     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a\r\n     * one-to-one mapping with the indexes array.\r\n     * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} [spriteConfig] - The config object to pass into the Sprite creator (i.e.\r\n     * scene.make.sprite).\r\n     * @param {Phaser.Scene} [scene] - The Scene to create the Sprites within.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when determining the world XY\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n     */\r\n    createFromTiles: function (indexes, replacements, spriteConfig, scene, camera)\r\n    {\r\n        return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Returns the tiles in the given layer that are within the cameras viewport.\r\n     * This is used internally during rendering.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#cull\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects to render.\r\n     */\r\n    cull: function (camera)\r\n    {\r\n        return this.cullCallback(this.layer, camera, this.culledTiles, this._renderOrder);\r\n    },\r\n\r\n    /**\r\n     * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n     * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n     * information in the destination region.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#copy\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {number} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {number} width - The width of the area to copy, in tiles, not pixels.\r\n     * @param {number} height - The height of the area to copy, in tiles, not pixels.\r\n     * @param {number} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {number} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    copy: function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces)\r\n    {\r\n        TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n     * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n     * Collision information in the region will be recalculated.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#fill\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} index - The tile index to fill the area with.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    fill: function (index, tileX, tileY, width, height, recalculateFaces)\r\n    {\r\n        TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#filterTiles\r\n     * @since 3.50.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n     * filter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */\r\n    filterTiles: function (callback, context, tileX, tileY, width, height, filteringOptions)\r\n    {\r\n        return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n     * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n     * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n     * the top-left.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#findByIndex\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} index - The tile index value to search for.\r\n     * @param {number} [skip=0] - The number of times to skip a matching tile before returning.\r\n     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The first matching Tile object.\r\n     */\r\n    findByIndex: function (findIndex, skip, reverse)\r\n    {\r\n        return TilemapComponents.FindByIndex(findIndex, skip, reverse, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n     * true. Similar to Array.prototype.find in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#findTile\r\n     * @since 3.50.0\r\n     *\r\n     * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} The first Tile found at the given location.\r\n     */\r\n    findTile: function (callback, context, tileX, tileY, width, height, filteringOptions)\r\n    {\r\n        return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#forEachTile\r\n     * @since 3.50.0\r\n     *\r\n     * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context, or scope, under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    forEachTile: function (callback, context, tileX, tileY, width, height, filteringOptions)\r\n    {\r\n        TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given tile coordinates from the given layer.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTileAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - X position to get the tile from (given in tile units, not pixels).\r\n     * @param {number} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n     * @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The Tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n     */\r\n    getTileAt: function (tileX, tileY, nonNull)\r\n    {\r\n        return TilemapComponents.GetTileAt(tileX, tileY, nonNull, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given world coordinates from the given layer.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTileAtWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - X position to get the tile from (given in pixels)\r\n     * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n     * @param {boolean} [nonNull=false] - If true, function won't return null for empty tiles, but a Tile object with an index of -1.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n     */\r\n    getTileAtWorldXY: function (worldX, worldY, nonNull, camera)\r\n    {\r\n        return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTilesWithin\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects found within the area.\r\n     */\r\n    getTilesWithin: function (tileX, tileY, width, height, filteringOptions)\r\n    {\r\n        return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n     * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTilesWithinShape\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects found within the shape.\r\n     */\r\n    getTilesWithinShape: function (shape, filteringOptions, camera)\r\n    {\r\n        return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTilesWithinWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The world x coordinate for the top-left of the area.\r\n     * @param {number} worldY - The world y coordinate for the top-left of the area.\r\n     * @param {number} width - The width of the area.\r\n     * @param {number} height - The height of the area.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects found within the area.\r\n     */\r\n    getTilesWithinWorldXY: function (worldX, worldY, width, height, filteringOptions, camera)\r\n    {\r\n        return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#hasTileAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     *\r\n     * @return {boolean} `true` if a tile was found at the given location, otherwise `false`.\r\n     */\r\n    hasTileAt: function (tileX, tileY)\r\n    {\r\n        return TilemapComponents.HasTileAt(tileX, tileY, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#hasTileAtWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     *\r\n     * @return {boolean} `true` if a tile was found at the given location, otherwise `false`.\r\n     */\r\n    hasTileAtWorldXY: function (worldX, worldY, camera)\r\n    {\r\n        return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n     * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n     * location. If you pass in an index, only the index at the specified location will be changed.\r\n     * Collision information will be recalculated at the specified location.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#putTileAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The Tile object that was inserted at the given coordinates.\r\n     */\r\n    putTileAt: function (tile, tileX, tileY, recalculateFaces)\r\n    {\r\n        return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n     * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n     * specified location. If you pass in an index, only the index at the specified location will be\r\n     * changed. Collision information will be recalculated at the specified location.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#putTileAtWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [recalculateFaces] - `true` if the faces data should be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The Tile object that was inserted at the given coordinates.\r\n     */\r\n    putTileAtWorldXY: function (tile, worldX, worldY, recalculateFaces, camera)\r\n    {\r\n        return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n     * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n     * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n     * index at the specified location will be changed. Collision information will be recalculated\r\n     * within the region tiles were changed.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#putTilesAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number[]|number[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    putTilesAt: function (tilesArray, tileX, tileY, recalculateFaces)\r\n    {\r\n        TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n     * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n     * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n     * indexes. This method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#randomize\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {number[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    randomize: function (tileX, tileY, width, height, indexes)\r\n    {\r\n        TilemapComponents.Randomize(tileX, tileY, width, height, indexes, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given tile coordinates in the specified layer and updates the layers\r\n     * collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#removeTileAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} A Tile object.\r\n     */\r\n    removeTileAt: function (tileX, tileY, replaceWithNull, recalculateFaces)\r\n    {\r\n        return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given world coordinates in the specified layer and updates the layers\r\n     * collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#removeTileAtWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The Tile object that was removed from the given location.\r\n     */\r\n    removeTileAtWorldXY: function (worldX, worldY, replaceWithNull, recalculateFaces, camera)\r\n    {\r\n        return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to\r\n     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n     * wherever you want on the screen.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#renderDebug\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {Phaser.Types.Tilemaps.StyleConfig} [styleConfig] - An object specifying the colors to use for the debug drawing.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    renderDebug: function (graphics, styleConfig)\r\n    {\r\n        TilemapComponents.RenderDebug(graphics, styleConfig, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n     * not change collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#replaceByIndex\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} findIndex - The index of the tile to search for.\r\n     * @param {number} newIndex - The index of the tile to replace it with.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    replaceByIndex: function (findIndex, newIndex, tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * You can control if the Cameras should cull tiles before rendering them or not.\r\n     *\r\n     * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.\r\n     *\r\n     * However, there are some instances when you may wish to disable this.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setSkipCull\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [value=true] - Set to `true` to stop culling tiles. Set to `false` to enable culling again.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setSkipCull: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skipCull = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When a Camera culls the tiles in this layer it does so using its view into the world, building up a\r\n     * rectangle inside which the tiles must exist or they will be culled. Sometimes you may need to expand the size\r\n     * of this 'cull rectangle', especially if you plan on rotating the Camera viewing the layer. Do so\r\n     * by providing the padding values. The values given are in tiles, not pixels. So if the tile width was 32px\r\n     * and you set `paddingX` to be 4, it would add 32px x 4 to the cull rectangle (adjusted for scale)\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCullPadding\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [paddingX=1] - The amount of extra horizontal tiles to add to the cull check padding.\r\n     * @param {number} [paddingY=1] - The amount of extra vertical tiles to add to the cull check padding.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCullPadding: function (paddingX, paddingY)\r\n    {\r\n        if (paddingX === undefined) { paddingX = 1; }\r\n        if (paddingY === undefined) { paddingY = 1; }\r\n\r\n        this.cullPaddingX = paddingX;\r\n        this.cullPaddingY = paddingY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n     * collision will be enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollision\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollision: function (indexes, collides, recalculateFaces, updateLayer)\r\n    {\r\n        TilemapComponents.SetCollision(indexes, collides, recalculateFaces, this.layer, updateLayer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n     * enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollisionBetween\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} start - The first index of the tile to be set for collision.\r\n     * @param {number} stop - The last index of the tile to be set for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollisionBetween: function (start, stop, collides, recalculateFaces)\r\n    {\r\n        TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n     * that matches the given properties object, its collision flag will be set. The `collides`\r\n     * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n     * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n     * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n     * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n     * \"types\" property that matches any of those values, its collision flag will be updated.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollisionByProperty\r\n     * @since 3.50.0\r\n     *\r\n     * @param {object} properties - An object with tile properties and corresponding values that should be checked.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollisionByProperty: function (properties, collides, recalculateFaces)\r\n    {\r\n        TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n     * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n     * disabled (false). Tile indexes not currently in the layer are not affected.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollisionByExclusion\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number[]} indexes - An array of the tile indexes to not be counted for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollisionByExclusion: function (indexes, collides, recalculateFaces)\r\n    {\r\n        TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking each tiles collision group data\r\n     * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n     * a tiles collision group, the tile's colliding information will be set. The `collides` parameter\r\n     * controls if collision will be enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollisionFromCollisionGroup\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollisionFromCollisionGroup: function (collides, recalculateFaces)\r\n    {\r\n        TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n     * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n     * at a specific location on the map then see setTileLocationCallback.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setTileIndexCallback\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|number[])} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setTileIndexCallback: function (indexes, callback, callbackContext)\r\n    {\r\n        TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n     * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n     * remove it.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setTileLocationCallback\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {function} [callback] - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} [callbackContext] - The context, or scope, under which the callback is invoked.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setTileLocationCallback: function (tileX, tileY, width, height, callback, callbackContext)\r\n    {\r\n        TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n     * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n     * appear to have changed! This method only modifies tile indexes and does not change collision\r\n     * information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#shuffle\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    shuffle: function (tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.Shuffle(tileX, tileY, width, height, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n     * information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#swapByIndex\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileA - First tile index.\r\n     * @param {number} tileB - Second tile index.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    swapByIndex: function (indexA, indexB, tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#tileToWorldX\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {number} The Tile X coordinate converted to pixels.\r\n     */\r\n    tileToWorldX: function (tileX, camera)\r\n    {\r\n        return this.tilemap.tileToWorldX(tileX, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#tileToWorldY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {number} The Tile Y coordinate converted to pixels.\r\n     */\r\n    tileToWorldY: function (tileY, camera)\r\n    {\r\n        return this.tilemap.tileToWorldY(tileY, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#tileToWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Math.Vector2} A Vector2 containing the world coordinates of the Tile.\r\n     */\r\n    tileToWorldXY: function (tileX, tileY, point, camera)\r\n    {\r\n        return this.tilemap.tileToWorldXY(tileX, tileY, point, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n     * weightedIndexes array. An example weighted array:\r\n     *\r\n     * [\r\n     *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n     *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n     *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n     *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n     * ]\r\n     *\r\n     * The probability of any index being choose is (the index's weight) / (sum of all weights). This\r\n     * method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#weightedRandomize\r\n     * @since 3.50.0\r\n     *\r\n     * @param {object[]} weightedIndexes - An array of objects to randomly draw from during randomization. They should be in the form: { index: 0, weight: 4 } or { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    weightedRandomize: function (weightedIndexes, tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#worldToTileX\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {number} The tile X coordinate based on the world value.\r\n     */\r\n    worldToTileX: function (worldX, snapToFloor, camera)\r\n    {\r\n        return this.tilemap.worldToTileX(worldX, snapToFloor, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#worldToTileY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {number} The tile Y coordinate based on the world value.\r\n     */\r\n    worldToTileY: function (worldY, snapToFloor, camera)\r\n    {\r\n        return this.tilemap.worldToTileY(worldY, snapToFloor, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#worldToTileXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Math.Vector2} A Vector2 containing the tile coordinates of the world values.\r\n     */\r\n    worldToTileXY: function (worldX, worldY, snapToFloor, point, camera)\r\n    {\r\n        return this.tilemap.worldToTileXY(worldX, worldY, snapToFloor, point, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Destroys this TilemapLayer and removes its link to the associated LayerData.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#destroy\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [removeFromTilemap=true] - Remove this layer from the parent Tilemap?\r\n     */\r\n    destroy: function (removeFromTilemap)\r\n    {\r\n        if (removeFromTilemap === undefined) { removeFromTilemap = true; }\r\n\r\n        if (!this.tilemap)\r\n        {\r\n            //  Abort, we've already been destroyed\r\n            return;\r\n        }\r\n\r\n        //  Uninstall this layer only if it is still installed on the LayerData object\r\n        if (this.layer.tilemapLayer === this)\r\n        {\r\n            this.layer.tilemapLayer = undefined;\r\n        }\r\n\r\n        if (removeFromTilemap)\r\n        {\r\n            this.tilemap.removeLayer(this);\r\n        }\r\n\r\n        this.tilemap = undefined;\r\n        this.layer = undefined;\r\n        this.culledTiles.length = 0;\r\n        this.cullCallback = null;\r\n\r\n        this.gidMap = [];\r\n        this.tileset = [];\r\n\r\n        GameObject.prototype.destroy.call(this);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = TilemapLayer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TransformMatrix = require('../gameobjects/components/TransformMatrix');\r\n\r\nvar tempMatrix1 = new TransformMatrix();\r\nvar tempMatrix2 = new TransformMatrix();\r\nvar tempMatrix3 = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.Tilemaps.TilemapLayer#renderCanvas\r\n * @since 3.50.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.Tilemaps.TilemapLayer} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TilemapLayerCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var renderTiles = src.cull(camera);\r\n\r\n    var tileCount = renderTiles.length;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (tileCount === 0 || alpha <= 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var camMatrix = tempMatrix1;\r\n    var layerMatrix = tempMatrix2;\r\n    var calcMatrix = tempMatrix3;\r\n\r\n    layerMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    var ctx = renderer.currentContext;\r\n    var gidMap = src.gidMap;\r\n\r\n    ctx.save();\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        layerMatrix.e = src.x;\r\n        layerMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(layerMatrix, calcMatrix);\r\n\r\n        calcMatrix.copyToContext(ctx);\r\n    }\r\n    else\r\n    {\r\n        layerMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        layerMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        layerMatrix.copyToContext(ctx);\r\n    }\r\n\r\n    if (!renderer.antialias || src.scaleX > 1 || src.scaleY > 1)\r\n    {\r\n        ctx.imageSmoothingEnabled = false;\r\n    }\r\n\r\n    for (var i = 0; i < tileCount; i++)\r\n    {\r\n        var tile = renderTiles[i];\r\n\r\n        var tileset = gidMap[tile.index];\r\n\r\n        if (!tileset)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var image = tileset.image.getSourceImage();\r\n\r\n        var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);\r\n\r\n        if (tileTexCoords === null)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var tileWidth = tileset.tileWidth;\r\n        var tileHeight = tileset.tileHeight;\r\n\r\n        var halfWidth = tileWidth * 0.5;\r\n        var halfHeight = tileHeight * 0.5;\r\n\r\n        ctx.save();\r\n\r\n        ctx.translate(tile.pixelX + halfWidth, tile.pixelY + halfHeight);\r\n\r\n        if (tile.rotation !== 0)\r\n        {\r\n            ctx.rotate(tile.rotation);\r\n        }\r\n\r\n        if (tile.flipX || tile.flipY)\r\n        {\r\n            ctx.scale((tile.flipX) ? -1 : 1, (tile.flipY) ? -1 : 1);\r\n        }\r\n\r\n        ctx.globalAlpha = alpha * tile.alpha;\r\n\r\n        ctx.drawImage(\r\n            image,\r\n            tileTexCoords.x, tileTexCoords.y,\r\n            tileWidth , tileHeight,\r\n            -halfWidth, -halfHeight,\r\n            tileWidth, tileHeight\r\n        );\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = TilemapLayerCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../utils/NOOP');\r\nvar renderCanvas = require('../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./TilemapLayerWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./TilemapLayerCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.Tilemaps.TilemapLayer#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.Tilemaps.TilemapLayer} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */\r\nvar TilemapLayerWebGLRenderer = function (renderer, src, camera)\r\n{\r\n    var renderTiles = src.cull(camera);\r\n\r\n    var tileCount = renderTiles.length;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (tileCount === 0 || alpha <= 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var gidMap = src.gidMap;\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    var scrollFactorX = src.scrollFactorX;\r\n    var scrollFactorY = src.scrollFactorY;\r\n\r\n    var x = src.x;\r\n    var y = src.y;\r\n\r\n    var sx = src.scaleX;\r\n    var sy = src.scaleY;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    for (var i = 0; i < tileCount; i++)\r\n    {\r\n        var tile = renderTiles[i];\r\n\r\n        var tileset = gidMap[tile.index];\r\n\r\n        if (!tileset)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);\r\n\r\n        if (tileTexCoords === null)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var texture = tileset.glTexture;\r\n\r\n        var textureUnit = pipeline.setTexture2D(texture, src);\r\n\r\n        var frameWidth = tileset.tileWidth;\r\n        var frameHeight = tileset.tileHeight;\r\n\r\n        var frameX = tileTexCoords.x;\r\n        var frameY = tileTexCoords.y;\r\n\r\n        var tw = tileset.tileWidth * 0.5;\r\n        var th = tileset.tileHeight * 0.5;\r\n\r\n        var tint = getTint(tile.tint, alpha * tile.alpha);\r\n\r\n        pipeline.batchTexture(\r\n            src,\r\n            texture,\r\n            texture.width, texture.height,\r\n            x + ((tw + tile.pixelX) * sx), y + ((th + tile.pixelY) * sy),\r\n            tile.width, tile.height,\r\n            sx, sy,\r\n            tile.rotation,\r\n            tile.flipX, tile.flipY,\r\n            scrollFactorX, scrollFactorY,\r\n            tw, th,\r\n            frameX, frameY, frameWidth, frameHeight,\r\n            tint, tint, tint, tint, false,\r\n            0, 0,\r\n            camera,\r\n            null,\r\n            true,\r\n            textureUnit\r\n        );\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = TilemapLayerWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A Tileset is a combination of an image containing the tiles and a container for data about\r\n * each tile.\r\n *\r\n * @class Tileset\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tileset in the map data.\r\n * @param {number} firstgid - The first tile index this tileset contains.\r\n * @param {number} [tileWidth=32] - Width of each tile (in pixels).\r\n * @param {number} [tileHeight=32] - Height of each tile (in pixels).\r\n * @param {number} [tileMargin=0] - The margin around all tiles in the sheet (in pixels).\r\n * @param {number} [tileSpacing=0] - The spacing between each tile in the sheet (in pixels).\r\n * @param {object} [tileProperties={}] - Custom properties defined per tile in the Tileset.\r\n * These typically are custom properties created in Tiled when editing a tileset.\r\n * @param {object} [tileData={}] - Data stored per tile. These typically are created in Tiled\r\n * when editing a tileset, e.g. from Tiled's tile collision editor or terrain editor.\r\n */\r\nvar Tileset = new Class({\r\n\r\n    initialize:\r\n\r\n    function Tileset (name, firstgid, tileWidth, tileHeight, tileMargin, tileSpacing, tileProperties, tileData)\r\n    {\r\n        if (tileWidth === undefined || tileWidth <= 0) { tileWidth = 32; }\r\n        if (tileHeight === undefined || tileHeight <= 0) { tileHeight = 32; }\r\n        if (tileMargin === undefined) { tileMargin = 0; }\r\n        if (tileSpacing === undefined) { tileSpacing = 0; }\r\n        if (tileProperties === undefined) { tileProperties = {}; }\r\n        if (tileData === undefined) { tileData = {}; }\r\n\r\n        /**\r\n         * The name of the Tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = name;\r\n\r\n        /**\r\n         * The starting index of the first tile index this Tileset contains.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#firstgid\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.firstgid = firstgid;\r\n\r\n        /**\r\n         * The width of each tile (in pixels). Use setTileSize to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileWidth\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = tileWidth;\r\n\r\n        /**\r\n         * The height of each tile (in pixels). Use setTileSize to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileHeight\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = tileHeight;\r\n\r\n        /**\r\n         * The margin around the tiles in the sheet (in pixels). Use `setSpacing` to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileMargin\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.tileMargin = tileMargin;\r\n\r\n        /**\r\n         * The spacing between each the tile in the sheet (in pixels). Use `setSpacing` to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileSpacing\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.tileSpacing = tileSpacing;\r\n\r\n        /**\r\n         * Tileset-specific properties per tile that are typically defined in the Tiled editor in the\r\n         * Tileset editor.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileProperties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileProperties = tileProperties;\r\n\r\n        /**\r\n         * Tileset-specific data per tile that are typically defined in the Tiled editor, e.g. within\r\n         * the Tileset collision editor. This is where collision objects and terrain are stored.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileData\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileData = tileData;\r\n\r\n        /**\r\n         * The cached image that contains the individual tiles. Use setImage to set.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#image\r\n         * @type {?Phaser.Textures.Texture}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.image = null;\r\n\r\n        /**\r\n         * The gl texture used by the WebGL renderer.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#glTexture\r\n         * @type {?WebGLTexture}\r\n         * @readonly\r\n         * @since 3.11.0\r\n         */\r\n        this.glTexture = null;\r\n\r\n        /**\r\n         * The number of tile rows in the the tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#rows\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.rows = 0;\r\n\r\n        /**\r\n         * The number of tile columns in the tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#columns\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.columns = 0;\r\n\r\n        /**\r\n         * The total number of tiles in the tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#total\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.total = 0;\r\n\r\n        /**\r\n         * The look-up table to specific tile image texture coordinates (UV in pixels). Each element\r\n         * contains the coordinates for a tile in an object of the form {x, y}.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#texCoordinates\r\n         * @type {object[]}\r\n         * @readonly\r\n         * @since 3.0.0\r\n        */\r\n        this.texCoordinates = [];\r\n    },\r\n\r\n    /**\r\n     * Get a tiles properties that are stored in the Tileset. Returns null if tile index is not\r\n     * contained in this Tileset. This is typically defined in Tiled under the Tileset editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileProperties\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?(object|undefined)}\r\n     */\r\n    getTileProperties: function (tileIndex)\r\n    {\r\n        if (!this.containsTileIndex(tileIndex)) { return null; }\r\n\r\n        return this.tileProperties[tileIndex - this.firstgid];\r\n    },\r\n\r\n    /**\r\n     * Get a tile's data that is stored in the Tileset. Returns null if tile index is not contained\r\n     * in this Tileset. This is typically defined in Tiled and will contain both Tileset collision\r\n     * info and terrain mapping.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?object|undefined}\r\n     */\r\n    getTileData: function (tileIndex)\r\n    {\r\n        if (!this.containsTileIndex(tileIndex)) { return null; }\r\n\r\n        return this.tileData[tileIndex - this.firstgid];\r\n    },\r\n\r\n    /**\r\n     * Get a tile's collision group that is stored in the Tileset. Returns null if tile index is not\r\n     * contained in this Tileset. This is typically defined within Tiled's tileset collision editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?object}\r\n     */\r\n    getTileCollisionGroup: function (tileIndex)\r\n    {\r\n        var data = this.getTileData(tileIndex);\r\n\r\n        return (data && data.objectgroup) ? data.objectgroup : null;\r\n    },\r\n\r\n    /**\r\n     * Returns true if and only if this Tileset contains the given tile index.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#containsTileIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    containsTileIndex: function (tileIndex)\r\n    {\r\n        return (\r\n            tileIndex >= this.firstgid &&\r\n            tileIndex < (this.firstgid + this.total)\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Returns the texture coordinates (UV in pixels) in the Tileset image for the given tile index.\r\n     * Returns null if tile index is not contained in this Tileset.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileTextureCoordinates\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?object} Object in the form { x, y } representing the top-left UV coordinate\r\n     * within the Tileset image.\r\n     */\r\n    getTileTextureCoordinates: function (tileIndex)\r\n    {\r\n        if (!this.containsTileIndex(tileIndex)) { return null; }\r\n\r\n        return this.texCoordinates[tileIndex - this.firstgid];\r\n    },\r\n\r\n    /**\r\n     * Sets the image associated with this Tileset and updates the tile data (rows, columns, etc.).\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#setImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.Texture} texture - The image that contains the tiles.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */\r\n    setImage: function (texture)\r\n    {\r\n        this.image = texture;\r\n\r\n        this.glTexture = texture.get().source.glTexture;\r\n\r\n        this.updateTileData(this.image.source[0].width, this.image.source[0].height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tile width & height and updates the tile data (rows, columns, etc.).\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#setTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileWidth] - The width of a tile in pixels.\r\n     * @param {number} [tileHeight] - The height of a tile in pixels.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */\r\n    setTileSize: function (tileWidth, tileHeight)\r\n    {\r\n        if (tileWidth !== undefined) { this.tileWidth = tileWidth; }\r\n        if (tileHeight !== undefined) { this.tileHeight = tileHeight; }\r\n\r\n        if (this.image)\r\n        {\r\n            this.updateTileData(this.image.source[0].width, this.image.source[0].height);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tile margin & spacing and updates the tile data (rows, columns, etc.).\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#setSpacing\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [margin] - The margin around the tiles in the sheet (in pixels).\r\n     * @param {number} [spacing] - The spacing between the tiles in the sheet (in pixels).\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */\r\n    setSpacing: function (margin, spacing)\r\n    {\r\n        if (margin !== undefined) { this.tileMargin = margin; }\r\n        if (spacing !== undefined) { this.tileSpacing = spacing; }\r\n\r\n        if (this.image)\r\n        {\r\n            this.updateTileData(this.image.source[0].width, this.image.source[0].height);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates tile texture coordinates and tileset data.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#updateTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} imageWidth - The (expected) width of the image to slice.\r\n     * @param {number} imageHeight - The (expected) height of the image to slice.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */\r\n    updateTileData: function (imageWidth, imageHeight)\r\n    {\r\n        var rowCount = (imageHeight - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing);\r\n        var colCount = (imageWidth - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing);\r\n\r\n        if (rowCount % 1 !== 0 || colCount % 1 !== 0)\r\n        {\r\n            console.warn('Image tile area not tile size multiple in: ' + this.name);\r\n        }\r\n\r\n        // In Tiled a tileset image that is not an even multiple of the tile dimensions is truncated\r\n        // - hence the floor when calculating the rows/columns.\r\n        rowCount = Math.floor(rowCount);\r\n        colCount = Math.floor(colCount);\r\n\r\n        this.rows = rowCount;\r\n        this.columns = colCount;\r\n\r\n        // In Tiled, \"empty\" spaces in a tileset count as tiles and hence count towards the gid\r\n        this.total = rowCount * colCount;\r\n\r\n        this.texCoordinates.length = 0;\r\n\r\n        var tx = this.tileMargin;\r\n        var ty = this.tileMargin;\r\n\r\n        for (var y = 0; y < this.rows; y++)\r\n        {\r\n            for (var x = 0; x < this.columns; x++)\r\n            {\r\n                this.texCoordinates.push({ x: tx, y: ty });\r\n                tx += this.tileWidth + this.tileSpacing;\r\n            }\r\n\r\n            tx = this.tileMargin;\r\n            ty += this.tileHeight + this.tileSpacing;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Tileset;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTileAt = require('./GetTileAt');\r\n\r\n/**\r\n * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n * internally to optimize recalculating faces when only one tile has been changed.\r\n *\r\n * @function Phaser.Tilemaps.Components.CalculateFacesAt\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate.\r\n * @param {number} tileY - The y coordinate.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar CalculateFacesAt = function (tileX, tileY, layer)\r\n{\r\n    var tile = GetTileAt(tileX, tileY, true, layer);\r\n    var above = GetTileAt(tileX, tileY - 1, true, layer);\r\n    var below = GetTileAt(tileX, tileY + 1, true, layer);\r\n    var left = GetTileAt(tileX - 1, tileY, true, layer);\r\n    var right = GetTileAt(tileX + 1, tileY, true, layer);\r\n    var tileCollides = tile && tile.collides;\r\n\r\n    // Assume the changed tile has all interesting edges\r\n    if (tileCollides)\r\n    {\r\n        tile.faceTop = true;\r\n        tile.faceBottom = true;\r\n        tile.faceLeft = true;\r\n        tile.faceRight = true;\r\n    }\r\n\r\n    // Reset edges that are shared between tile and its neighbors\r\n    if (above && above.collides)\r\n    {\r\n        if (tileCollides)\r\n        {\r\n            tile.faceTop = false;\r\n        }\r\n\r\n        above.faceBottom = !tileCollides;\r\n    }\r\n\r\n    if (below && below.collides)\r\n    {\r\n        if (tileCollides)\r\n        {\r\n            tile.faceBottom = false;\r\n        }\r\n\r\n        below.faceTop = !tileCollides;\r\n    }\r\n\r\n    if (left && left.collides)\r\n    {\r\n        if (tileCollides)\r\n        {\r\n            tile.faceLeft = false;\r\n        }\r\n\r\n        left.faceRight = !tileCollides;\r\n    }\r\n\r\n    if (right && right.collides)\r\n    {\r\n        if (tileCollides)\r\n        {\r\n            tile.faceRight = false;\r\n        }\r\n\r\n        right.faceLeft = !tileCollides;\r\n    }\r\n\r\n    if (tile && !tile.collides)\r\n    {\r\n        tile.resetFaces();\r\n    }\r\n\r\n    return tile;\r\n};\r\n\r\nmodule.exports = CalculateFacesAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTileAt = require('./GetTileAt');\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n * is mostly used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.CalculateFacesWithin\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar CalculateFacesWithin = function (tileX, tileY, width, height, layer)\r\n{\r\n    var above = null;\r\n    var below = null;\r\n    var left = null;\r\n    var right = null;\r\n\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        if (tile)\r\n        {\r\n            if (tile.collides)\r\n            {\r\n                above = GetTileAt(tile.x, tile.y - 1, true, layer);\r\n                below = GetTileAt(tile.x, tile.y + 1, true, layer);\r\n                left = GetTileAt(tile.x - 1, tile.y, true, layer);\r\n                right = GetTileAt(tile.x + 1, tile.y, true, layer);\r\n\r\n                tile.faceTop = (above && above.collides) ? false : true;\r\n                tile.faceBottom = (below && below.collides) ? false : true;\r\n                tile.faceLeft = (left && left.collides) ? false : true;\r\n                tile.faceRight = (right && right.collides) ? false : true;\r\n            }\r\n            else\r\n            {\r\n                tile.resetFaces();\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = CalculateFacesWithin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Checks if the given tile coordinate is within the isometric layer bounds, or not.\r\n *\r\n * @function Phaser.Tilemaps.Components.CheckIsoBounds\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to check against.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.\r\n *\r\n * @return {boolean} Returns `true` if the coordinates are within the iso bounds.\r\n */\r\nvar CheckIsoBounds = function (tileX, tileY, layer, camera)\r\n{\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var cullPaddingX = tilemapLayer.cullPaddingX;\r\n    var cullPaddingY = tilemapLayer.cullPaddingY;\r\n\r\n    var pos = tilemapLayer.tilemap.tileToWorldXY(tileX, tileY, point, camera, tilemapLayer);\r\n\r\n    // we always subtract 1/2 of the tile's height/width to make the culling distance start from the center of the tiles.\r\n    return pos.x > camera.worldView.x + tilemapLayer.scaleX * layer.tileWidth * (-cullPaddingX - 0.5)\r\n        && pos.x < camera.worldView.right + tilemapLayer.scaleX * layer.tileWidth * (cullPaddingX - 0.5)\r\n        && pos.y > camera.worldView.y + tilemapLayer.scaleY * layer.tileHeight * (-cullPaddingY - 1.0)\r\n        && pos.y < camera.worldView.bottom + tilemapLayer.scaleY * layer.tileHeight * (cullPaddingY - 0.5);\r\n};\r\n\r\nmodule.exports = CheckIsoBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\n\r\n/**\r\n * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n * information in the destination region.\r\n *\r\n * @function Phaser.Tilemaps.Components.Copy\r\n * @since 3.0.0\r\n *\r\n * @param {number} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.\r\n * @param {number} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.\r\n * @param {number} width - The width of the area to copy, in tiles, not pixels.\r\n * @param {number} height - The height of the area to copy, in tiles, not pixels.\r\n * @param {number} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.\r\n * @param {number} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar Copy = function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer)\r\n{\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (srcTileX < 0) { srcTileX = 0; }\r\n    if (srcTileY < 0) { srcTileY = 0; }\r\n\r\n    var srcTiles = GetTilesWithin(srcTileX, srcTileY, width, height, null, layer);\r\n\r\n    var offsetX = destTileX - srcTileX;\r\n    var offsetY = destTileY - srcTileY;\r\n\r\n    for (var i = 0; i < srcTiles.length; i++)\r\n    {\r\n        var tileX = srcTiles[i].x + offsetX;\r\n        var tileY = srcTiles[i].y + offsetY;\r\n\r\n        if (tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height)\r\n        {\r\n            if (layer.data[tileY][tileX])\r\n            {\r\n                layer.data[tileY][tileX].copy(srcTiles[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        // Recalculate the faces within the destination area and neighboring tiles\r\n        CalculateFacesWithin(destTileX - 1, destTileY - 1, width + 2, height + 2, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = Copy;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar ReplaceByIndex = require('./ReplaceByIndex');\r\n\r\n/**\r\n * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n *\r\n * @function Phaser.Tilemaps.Components.CreateFromTiles\r\n * @since 3.0.0\r\n *\r\n * @param {(number|number[])} indexes - The tile index, or array of indexes, to create Sprites from.\r\n * @param {(number|number[])} replacements - The tile index, or array of indexes, to change a converted tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a one-to-one mapping with the indexes array.\r\n * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e. scene.make.sprite).\r\n * @param {Phaser.Scene} scene - The Scene to create the Sprites within.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when determining the world XY\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n */\r\nvar CreateFromTiles = function (indexes, replacements, spriteConfig, scene, camera, layer)\r\n{\r\n    if (!spriteConfig) { spriteConfig = {}; }\r\n\r\n    if (!Array.isArray(indexes))\r\n    {\r\n        indexes = [ indexes ];\r\n    }\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (!scene) { scene = tilemapLayer.scene; }\r\n    if (!camera) { camera = scene.cameras.main; }\r\n\r\n    var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);\r\n    var sprites = [];\r\n    var i;\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        if (indexes.indexOf(tile.index) !== -1)\r\n        {\r\n            var point = tilemapLayer.tileToWorldXY(tile.x, tile.y, undefined, camera,layer);\r\n\r\n            spriteConfig.x = point.x;\r\n            spriteConfig.y = point.y;\r\n\r\n            sprites.push(scene.make.sprite(spriteConfig));\r\n        }\r\n    }\r\n\r\n    if (typeof replacements === 'number')\r\n    {\r\n        //  Assume 1 replacement for all types of tile given\r\n        for (i = 0; i < indexes.length; i++)\r\n        {\r\n            ReplaceByIndex(indexes[i], replacements, 0, 0, layer.width, layer.height, layer);\r\n        }\r\n    }\r\n    else if (Array.isArray(replacements))\r\n    {\r\n        //  Assume 1 to 1 mapping with indexes array\r\n        for (i = 0; i < indexes.length; i++)\r\n        {\r\n            ReplaceByIndex(indexes[i], replacements[i], 0, 0, layer.width, layer.height, layer);\r\n        }\r\n    }\r\n\r\n    return sprites;\r\n};\r\n\r\nmodule.exports = CreateFromTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar SnapCeil = require('../../math/snap/SnapCeil');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\nvar bounds = new Rectangle();\r\n\r\n/**\r\n * Returns the bounds in the given orthogonal layer that are within the cameras viewport.\r\n * This is used internally by the cull tiles function.\r\n *\r\n * @function Phaser.Tilemaps.Components.CullBounds\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n *\r\n * @return {Phaser.Geom.Rectangle} A rectangle containing the culled bounds. If you wish to retain this object, clone it, as it's recycled internally.\r\n */\r\nvar CullBounds = function (layer, camera)\r\n{\r\n    var tilemap = layer.tilemapLayer.tilemap;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    //  We need to use the tile sizes defined for the map as a whole, not the layer,\r\n    //  in order to calculate the bounds correctly. As different sized tiles may be\r\n    //  placed on the grid and we cannot trust layer.baseTileWidth to give us the true size.\r\n    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);\r\n    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);\r\n\r\n    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;\r\n    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;\r\n\r\n    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;\r\n    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;\r\n\r\n    return bounds.setTo(\r\n        boundsLeft,\r\n        boundsTop,\r\n        (boundsRight - boundsLeft),\r\n        (boundsBottom - boundsTop)\r\n    );\r\n};\r\n\r\nmodule.exports = CullBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CullBounds = require('./CullBounds');\r\nvar RunCull = require('./RunCull');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.CullTiles\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n * @param {number} [renderOrder=0] - The rendering order constant.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar CullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    //  Camera world view bounds, snapped for scaled tile size\r\n    //  Cull Padding values are given in tiles, not pixels\r\n    var bounds = CullBounds(layer, camera);\r\n\r\n    if (tilemapLayer.skipCull || tilemapLayer.scrollFactorX !== 1 || tilemapLayer.scrollFactorY !== 1)\r\n    {\r\n        bounds.left = 0;\r\n        bounds.right = layer.width;\r\n        bounds.top = 0;\r\n        bounds.bottom = layer.height;\r\n    }\r\n\r\n    RunCull(layer, bounds, renderOrder, outputArray);\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = CullTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar SetTileCollision = require('./SetTileCollision');\r\n\r\n/**\r\n * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n * Collision information in the region will be recalculated.\r\n *\r\n * @function Phaser.Tilemaps.Components.Fill\r\n * @since 3.0.0\r\n *\r\n * @param {number} index - The tile index to fill the area with.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The tile layer to use. If not given the current layer is used.\r\n */\r\nvar Fill = function (index, tileX, tileY, width, height, recalculateFaces, layer)\r\n{\r\n    var doesIndexCollide = (layer.collideIndexes.indexOf(index) !== -1);\r\n\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].index = index;\r\n\r\n        SetTileCollision(tiles[i], doesIndexCollide);\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        // Recalculate the faces within the area and neighboring tiles\r\n        CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = Fill;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n *\r\n * @function Phaser.Tilemaps.Components.FilterTiles\r\n * @since 3.0.0\r\n *\r\n * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n * filter.\r\n * @param {object} context - The context under which the callback should be run.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} The filtered array of Tiles.\r\n */\r\nvar FilterTiles = function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n    return tiles.filter(callback, context);\r\n};\r\n\r\nmodule.exports = FilterTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n * the top-left.\r\n *\r\n * @function Phaser.Tilemaps.Components.FindByIndex\r\n * @since 3.0.0\r\n *\r\n * @param {number} index - The tile index value to search for.\r\n * @param {number} skip - The number of times to skip a matching tile before returning.\r\n * @param {boolean} reverse - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?Phaser.Tilemaps.Tile} The first (or n skipped) tile with the matching index.\r\n */\r\nvar FindByIndex = function (findIndex, skip, reverse, layer)\r\n{\r\n    if (skip === undefined) { skip = 0; }\r\n    if (reverse === undefined) { reverse = false; }\r\n\r\n    var count = 0;\r\n    var tx;\r\n    var ty;\r\n    var tile;\r\n\r\n    if (reverse)\r\n    {\r\n        for (ty = layer.height - 1; ty >= 0; ty--)\r\n        {\r\n            for (tx = layer.width - 1; tx >= 0; tx--)\r\n            {\r\n                tile = layer.data[ty][tx];\r\n                if (tile && tile.index === findIndex)\r\n                {\r\n                    if (count === skip)\r\n                    {\r\n                        return tile;\r\n                    }\r\n                    else\r\n                    {\r\n                        count += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (ty = 0; ty < layer.height; ty++)\r\n        {\r\n            for (tx = 0; tx < layer.width; tx++)\r\n            {\r\n                tile = layer.data[ty][tx];\r\n                if (tile && tile.index === findIndex)\r\n                {\r\n                    if (count === skip)\r\n                    {\r\n                        return tile;\r\n                    }\r\n                    else\r\n                    {\r\n                        count += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nmodule.exports = FindByIndex;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * @callback FindTileCallback\r\n *\r\n * @param {Phaser.Tilemaps.Tile} value - The Tile.\r\n * @param {number} index - The index of the tile.\r\n * @param {Phaser.Tilemaps.Tile[]} array - An array of Tile objects.\r\n *\r\n * @return {boolean} Return `true` if the callback should run, otherwise `false`.\r\n */\r\n\r\n/**\r\n * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n * true. Similar to Array.prototype.find in vanilla JS.\r\n *\r\n * @function Phaser.Tilemaps.Components.FindTile\r\n * @since 3.0.0\r\n *\r\n * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n * @param {object} context - The context under which the callback should be run.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?Phaser.Tilemaps.Tile} A Tile that matches the search, or null if no Tile found\r\n */\r\nvar FindTile = function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n    return tiles.find(callback, context) || null;\r\n};\r\n\r\nmodule.exports = FindTile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * @callback EachTileCallback\r\n *\r\n * @param {Phaser.Tilemaps.Tile} value - The Tile.\r\n * @param {number} index - The index of the tile.\r\n * @param {Phaser.Tilemaps.Tile[]} array - An array of Tile objects.\r\n */\r\n\r\n/**\r\n * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n *\r\n * @function Phaser.Tilemaps.Components.ForEachTile\r\n * @since 3.0.0\r\n *\r\n * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n * @param {object} context - The context under which the callback should be run.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar ForEachTile = function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n    tiles.forEach(callback, context);\r\n};\r\n\r\nmodule.exports = ForEachTile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar CullTiles = require('./CullTiles');\r\nvar HexagonalCullTiles = require('./HexagonalCullTiles');\r\nvar IsometricCullTiles = require('./IsometricCullTiles');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredCullTiles = require('./StaggeredCullTiles');\r\n\r\n/**\r\n * Gets the correct function to use to cull tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetCullTilesFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to cull tiles for the given map type.\r\n */\r\nvar GetCullTilesFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return CullTiles;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalCullTiles;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredCullTiles;\r\n    }\r\n    else if (orientation === CONST.ISOMETRIC)\r\n    {\r\n        return IsometricCullTiles;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetCullTilesFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\n\r\n/**\r\n * Gets a tile at the given tile coordinates from the given layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - X position to get the tile from (given in tile units, not pixels).\r\n * @param {number} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n * @param {boolean} nonNull - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n */\r\nvar GetTileAt = function (tileX, tileY, nonNull, layer)\r\n{\r\n    if (nonNull === undefined) { nonNull = false; }\r\n\r\n    if (IsInLayerBounds(tileX, tileY, layer))\r\n    {\r\n        var tile = layer.data[tileY][tileX] || null;\r\n\r\n        if (!tile)\r\n        {\r\n            return null;\r\n        }\r\n        else if (tile.index === -1)\r\n        {\r\n            return nonNull ? tile : null;\r\n        }\r\n        else\r\n        {\r\n            return tile;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        return null;\r\n    }\r\n};\r\n\r\nmodule.exports = GetTileAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTileAt = require('./GetTileAt');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Gets a tile at the given world coordinates from the given layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - X position to get the tile from (given in pixels)\r\n * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n * @param {boolean} nonNull - If true, function won't return null for empty tiles, but a Tile object with an index of -1.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n */\r\nvar GetTileAtWorldXY = function (worldX, worldY, nonNull, camera, layer)\r\n{\r\n    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);\r\n\r\n    return GetTileAt(point.x, point.y, nonNull, layer);\r\n};\r\n\r\nmodule.exports = GetTileAtWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar TileToWorldX = require('./TileToWorldX');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileToWorldXFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetTileToWorldXFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return TileToWorldX;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetTileToWorldXFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar HexagonalTileToWorldXY = require('./HexagonalTileToWorldXY');\r\nvar IsometricTileToWorldXY = require('./IsometricTileToWorldXY');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredTileToWorldXY = require('./StaggeredTileToWorldXY');\r\nvar TileToWorldXY = require('./TileToWorldXY');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileToWorldXYFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetTileToWorldXYFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return TileToWorldXY;\r\n    }\r\n    else if (orientation === CONST.ISOMETRIC)\r\n    {\r\n        return IsometricTileToWorldXY;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalTileToWorldXY;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredTileToWorldXY;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetTileToWorldXYFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar HexagonalTileToWorldY = require('./HexagonalTileToWorldY');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredTileToWorldY = require('./StaggeredTileToWorldY');\r\nvar TileToWorldY = require('./TileToWorldY');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileToWorldYFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetTileToWorldYFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return TileToWorldY;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalTileToWorldY;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredTileToWorldY;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetTileToWorldYFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithin\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithin = function (tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    if (tileX === undefined) { tileX = 0; }\r\n    if (tileY === undefined) { tileY = 0; }\r\n    if (width === undefined) { width = layer.width; }\r\n    if (height === undefined) { height = layer.height; }\r\n    if (!filteringOptions) { filteringOptions = {}; }\r\n\r\n    var isNotEmpty = GetFastValue(filteringOptions, 'isNotEmpty', false);\r\n    var isColliding = GetFastValue(filteringOptions, 'isColliding', false);\r\n    var hasInterestingFace = GetFastValue(filteringOptions, 'hasInterestingFace', false);\r\n\r\n    // Clip x, y to top left of map, while shrinking width/height to match.\r\n    if (tileX < 0)\r\n    {\r\n        width += tileX;\r\n        tileX = 0;\r\n    }\r\n\r\n    if (tileY < 0)\r\n    {\r\n        height += tileY;\r\n        tileY = 0;\r\n    }\r\n\r\n    // Clip width and height to bottom right of map.\r\n    if (tileX + width > layer.width)\r\n    {\r\n        width = Math.max(layer.width - tileX, 0);\r\n    }\r\n\r\n    if (tileY + height > layer.height)\r\n    {\r\n        height = Math.max(layer.height - tileY, 0);\r\n    }\r\n\r\n    var results = [];\r\n\r\n    for (var ty = tileY; ty < tileY + height; ty++)\r\n    {\r\n        for (var tx = tileX; tx < tileX + width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (tile !== null)\r\n            {\r\n                if (isNotEmpty && tile.index === -1)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (isColliding && !tile.collides)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (hasInterestingFace && !tile.hasInterestingFace)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                results.push(tile);\r\n            }\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n\r\nmodule.exports = GetTilesWithin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Geom = require('../../geom/');\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar Intersects = require('../../geom/intersects/');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar TriangleToRectangle = function (triangle, rect)\r\n{\r\n    return Intersects.RectangleToTriangle(rect, triangle);\r\n};\r\n\r\nvar point = new Vector2();\r\nvar pointStart = new Vector2();\r\nvar pointEnd = new Vector2();\r\n\r\n/**\r\n * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithinShape\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithinShape = function (shape, filteringOptions, camera, layer)\r\n{\r\n    if (shape === undefined) { return []; }\r\n\r\n    // intersectTest is a function with parameters: shape, rect\r\n    var intersectTest = NOOP;\r\n\r\n    if (shape instanceof Geom.Circle)\r\n    {\r\n        intersectTest = Intersects.CircleToRectangle;\r\n    }\r\n    else if (shape instanceof Geom.Rectangle)\r\n    {\r\n        intersectTest = Intersects.RectangleToRectangle;\r\n    }\r\n    else if (shape instanceof Geom.Triangle)\r\n    {\r\n        intersectTest = TriangleToRectangle;\r\n    }\r\n    else if (shape instanceof Geom.Line)\r\n    {\r\n        intersectTest = Intersects.LineToRectangle;\r\n    }\r\n\r\n    // Top left corner of the shapes's bounding box, rounded down to include partial tiles\r\n    layer.tilemapLayer.worldToTileXY(shape.left, shape.top, true, pointStart, camera);\r\n\r\n    var xStart = pointStart.x;\r\n    var yStart = pointStart.y;\r\n\r\n    // Bottom right corner of the shapes's bounding box, rounded up to include partial tiles\r\n    layer.tilemapLayer.worldToTileXY(shape.right, shape.bottom, true, pointEnd, camera);\r\n\r\n    var xEnd = Math.ceil(pointEnd.x);\r\n    var yEnd = Math.ceil(pointEnd.y);\r\n\r\n    // Tiles within bounding rectangle of shape. Bounds are forced to be at least 1 x 1 tile in size\r\n    // to grab tiles for shapes that don't have a height or width (e.g. a horizontal line).\r\n    var width = Math.max(xEnd - xStart, 1);\r\n    var height = Math.max(yEnd - yStart, 1);\r\n\r\n    var tiles = GetTilesWithin(xStart, yStart, width, height, filteringOptions, layer);\r\n\r\n    var tileWidth = layer.tileWidth;\r\n    var tileHeight = layer.tileHeight;\r\n\r\n    if (layer.tilemapLayer)\r\n    {\r\n        tileWidth *= layer.tilemapLayer.scaleX;\r\n        tileHeight *= layer.tilemapLayer.scaleY;\r\n    }\r\n\r\n    var results = [];\r\n    var tileRect = new Geom.Rectangle(0, 0, tileWidth, tileHeight);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        layer.tilemapLayer.tileToWorldXY(tile.x, tile.y, point, camera);\r\n\r\n        tileRect.x = point.x;\r\n        tileRect.y = point.y;\r\n\r\n        if (intersectTest(shape, tileRect))\r\n        {\r\n            results.push(tile);\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n\r\nmodule.exports = GetTilesWithinShape;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar pointStart = new Vector2();\r\nvar pointEnd = new Vector2();\r\n\r\n/**\r\n * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithinWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The world x coordinate for the top-left of the area.\r\n * @param {number} worldY - The world y coordinate for the top-left of the area.\r\n * @param {number} width - The width of the area.\r\n * @param {number} height - The height of the area.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when factoring in which tiles to return.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithinWorldXY = function (worldX, worldY, width, height, filteringOptions, camera, layer)\r\n{\r\n    var worldToTileXY = layer.tilemapLayer.tilemap._convert.WorldToTileXY;\r\n\r\n    //  Top left corner of the rect, rounded down to include partial tiles\r\n    worldToTileXY(worldX, worldY, true, pointStart, camera, layer);\r\n\r\n    var xStart = pointStart.x;\r\n    var yStart = pointStart.y;\r\n\r\n    //  Bottom right corner of the rect, rounded up to include partial tiles\r\n    worldToTileXY(worldX + width, worldY + height, false, pointEnd, camera, layer);\r\n\r\n    var xEnd = Math.ceil(pointEnd.x);\r\n    var yEnd = Math.ceil(pointEnd.y);\r\n\r\n    return GetTilesWithin(xStart, yStart, xEnd - xStart, yEnd - yStart, filteringOptions, layer);\r\n};\r\n\r\nmodule.exports = GetTilesWithinWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar WorldToTileX = require('./WorldToTileX');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetWorldToTileXFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetWorldToTileXFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return WorldToTileX;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetWorldToTileXFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar HexagonalWorldToTileXY = require('./HexagonalWorldToTileXY');\r\nvar IsometricWorldToTileXY = require('./IsometricWorldToTileXY');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredWorldToTileXY = require('./StaggeredWorldToTileXY');\r\nvar WorldToTileXY = require('./WorldToTileXY');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetWorldToTileXYFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetWorldToTileXYFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return WorldToTileXY;\r\n    }\r\n    else if (orientation === CONST.ISOMETRIC)\r\n    {\r\n        return IsometricWorldToTileXY;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalWorldToTileXY;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredWorldToTileXY;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetWorldToTileXYFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar HexagonalWorldToTileY = require('./HexagonalWorldToTileY');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredWorldToTileY = require('./StaggeredWorldToTileY');\r\nvar WorldToTileY = require('./WorldToTileY');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetWorldToTileYFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetWorldToTileYFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return WorldToTileY;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalWorldToTileY;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredWorldToTileY;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetWorldToTileYFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\n\r\n/**\r\n * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n * false if there is no tile or if the tile at that location has an index of -1.\r\n *\r\n * @function Phaser.Tilemaps.Components.HasTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - X position to get the tile from (given in tile units, not pixels).\r\n * @param {number} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n */\r\nvar HasTileAt = function (tileX, tileY, layer)\r\n{\r\n    if (IsInLayerBounds(tileX, tileY, layer))\r\n    {\r\n        var tile = layer.data[tileY][tileX];\r\n\r\n        return (tile !== null && tile.index > -1);\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = HasTileAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar HasTileAt = require('./HasTileAt');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n * false if there is no tile or if the tile at that location has an index of -1.\r\n *\r\n * @function Phaser.Tilemaps.Components.HasTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The X coordinate of the world position.\r\n * @param {number} worldY - The Y coordinate of the world position.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when factoring in which tiles to return.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n */\r\nvar HasTileAtWorldXY = function (worldX, worldY, camera, layer)\r\n{\r\n    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);\r\n\r\n    var tileX = point.x;\r\n    var tileY = point.y;\r\n\r\n    return HasTileAt(tileX, tileY, layer);\r\n};\r\n\r\nmodule.exports = HasTileAtWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SnapCeil = require('../../math/snap/SnapCeil');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\n/**\r\n * Returns the bounds in the given layer that are within the camera's viewport.\r\n * This is used internally by the cull tiles function.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalCullBounds\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n *\r\n * @return {object} An object containing the `left`, `right`, `top` and `bottom` bounds.\r\n */\r\nvar HexagonalCullBounds = function (layer, camera)\r\n{\r\n    var tilemap = layer.tilemapLayer.tilemap;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    //  We need to use the tile sizes defined for the map as a whole, not the layer,\r\n    //  in order to calculate the bounds correctly. As different sized tiles may be\r\n    //  placed on the grid and we cannot trust layer.baseTileWidth to give us the true size.\r\n    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);\r\n    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);\r\n\r\n    var len = layer.hexSideLength;\r\n    var rowH = ((tileH - len) / 2 + len);\r\n\r\n    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;\r\n    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;\r\n\r\n    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, rowH, 0, true) - tilemapLayer.cullPaddingY;\r\n    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, rowH, 0, true) + tilemapLayer.cullPaddingY;\r\n\r\n    return {\r\n        left: boundsLeft,\r\n        right: boundsRight,\r\n        top: boundsTop,\r\n        bottom: boundsBottom\r\n    };\r\n};\r\n\r\nmodule.exports = HexagonalCullBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CullBounds = require('./HexagonalCullBounds');\r\nvar RunCull = require('./RunCull');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalCullTiles\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n * @param {number} [renderOrder=0] - The rendering order constant.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar HexagonalCullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1)\r\n    {\r\n        //  Camera world view bounds, snapped for scaled tile size\r\n        //  Cull Padding values are given in tiles, not pixels\r\n\r\n        var bounds = CullBounds(layer, camera);\r\n\r\n        RunCull(layer, bounds, renderOrder, outputArray);\r\n    }\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = HexagonalCullTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from hexagonal tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalTileToWorldXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */\r\nvar HexagonalTileToWorldXY = function (tileX, tileY, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var layerWorldX = 0;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var len = layer.hexSideLength;\r\n    var rowHeight = ((tileHeight - len) / 2 + len);\r\n\r\n    // similar to staggered, because Tiled uses the oddr representation.\r\n    var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);\r\n    var y = layerWorldY + tileY * rowHeight;\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = HexagonalTileToWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from hexagonal tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalTileToWorldY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in world coordinates.\r\n */\r\nvar HexagonalTileToWorldY = function (tileY, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (camera === undefined) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var len = tilemapLayer.tilemap.hexSideLength;\r\n\r\n    var rowHeight = ((tileHeight - len) / 2 + len);\r\n\r\n    return layerWorldY + tileY * rowHeight;\r\n};\r\n\r\nmodule.exports = HexagonalTileToWorldY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from world XY coordinates (pixels) to hexagonal tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalWorldToTileXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinates down to the nearest integer.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */\r\nvar HexagonalWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's horizontal scroll\r\n\r\n        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    var len = layer.hexSideLength;\r\n    var rowHeight = ((tileHeight - len) / 2 + len);\r\n\r\n    // similar to staggered, because Tiled uses the oddr representation.\r\n    var y = (snapToFloor) ? Math.floor((worldY / rowHeight)) : (worldY / rowHeight);\r\n    var x = (snapToFloor) ? Math.floor((worldX - (y % 2) * 0.5 * tileWidth) / tileWidth) : (worldX - (y % 2) * 0.5 * tileWidth) / tileWidth;\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = HexagonalWorldToTileXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from world Y coordinates (pixels) to hexagonal tile Y coordinates (tile units), factoring in the\r\n * layers position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalWorldToTileY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in tile units.\r\n */\r\nvar HexagonalWorldToTileY = function (worldY, snapToFloor, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        //  Find the world position relative to the static or dynamic layer's top left origin,\r\n        //  factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var len = layer.hexSideLength;\r\n\r\n    var rowHeight = ((tileHeight - len) / 2 + len);\r\n\r\n    return (snapToFloor) ? Math.floor(worldY / rowHeight) : worldY / rowHeight;\r\n};\r\n\r\nmodule.exports = HexagonalWorldToTileY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if the given tile coordinates are within the bounds of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsInLayerBounds\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {boolean} `true` if the tile coordinates are within the bounds of the layer, otherwise `false`.\r\n */\r\nvar IsInLayerBounds = function (tileX, tileY, layer)\r\n{\r\n    return (tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height);\r\n};\r\n\r\nmodule.exports = IsInLayerBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CheckIsoBounds = require('./CheckIsoBounds');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsometricCullTiles\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n * @param {number} [renderOrder=0] - The rendering order constant.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar IsometricCullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var mapData = layer.data;\r\n    var mapWidth = layer.width;\r\n    var mapHeight = layer.height;\r\n\r\n    var drawLeft = 0;\r\n    var drawRight = mapWidth;\r\n    var drawTop = 0;\r\n    var drawBottom = mapHeight;\r\n\r\n    if (!tilemapLayer.skipCull)\r\n    {\r\n        var x;\r\n        var y;\r\n        var tile;\r\n\r\n        if (renderOrder === 0)\r\n        {\r\n            //  right-down\r\n\r\n            for (y = drawTop; y < drawBottom; y++)\r\n            {\r\n                for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n                {\r\n                    if (CheckIsoBounds(x, y, layer, camera))\r\n                    {\r\n                        tile = mapData[y][x];\r\n\r\n                        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        outputArray.push(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (renderOrder === 1)\r\n        {\r\n            //  left-down\r\n\r\n            for (y = drawTop; y < drawBottom; y++)\r\n            {\r\n                for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n                {\r\n                    if (CheckIsoBounds(x, y, layer, camera))\r\n                    {\r\n                        tile = mapData[y][x];\r\n\r\n                        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        outputArray.push(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (renderOrder === 2)\r\n        {\r\n            //  right-up\r\n\r\n            for (y = drawBottom; y >= drawTop; y--)\r\n            {\r\n                for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n                {\r\n                    if (CheckIsoBounds(x, y, layer, camera))\r\n                    {\r\n                        tile = mapData[y][x];\r\n\r\n                        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        outputArray.push(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (renderOrder === 3)\r\n        {\r\n            //  left-up\r\n\r\n            for (y = drawBottom; y >= drawTop; y--)\r\n            {\r\n                for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n                {\r\n                    if (CheckIsoBounds(x, y, layer, camera))\r\n                    {\r\n                        tile = mapData[y][x];\r\n\r\n                        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        outputArray.push(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    tilemapLayer.tilesDrawn = outputArray.length;\r\n    tilemapLayer.tilesTotal = mapWidth * mapHeight;\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = IsometricCullTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from isometric tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsometricTileToWorldXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */\r\nvar IsometricTileToWorldXY = function (tileX, tileY, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var layerWorldX = 0;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var x = layerWorldX + (tileX - tileY) * (tileWidth / 2);\r\n    var y = layerWorldY + (tileX + tileY) * (tileHeight / 2);\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = IsometricTileToWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from world XY coordinates (pixels) to isometric tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsometricWorldToTileXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */\r\nvar IsometricWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's horizontal scroll\r\n\r\n        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    var x = (snapToFloor) ? Math.floor((worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2) : ((worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2);\r\n    var y = (snapToFloor) ? Math.floor((worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2) : ((worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2);\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = IsometricWorldToTileXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tile = require('../Tile');\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\nvar CalculateFacesAt = require('./CalculateFacesAt');\r\nvar SetTileCollision = require('./SetTileCollision');\r\n\r\n/**\r\n * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n * location. If you pass in an index, only the index at the specified location will be changed.\r\n * Collision information will be recalculated at the specified location.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was created or added to this map.\r\n */\r\nvar PutTileAt = function (tile, tileX, tileY, recalculateFaces, layer)\r\n{\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (!IsInLayerBounds(tileX, tileY, layer))\r\n    {\r\n        return null;\r\n    }\r\n\r\n    var oldTile = layer.data[tileY][tileX];\r\n    var oldTileCollides = oldTile && oldTile.collides;\r\n\r\n    if (tile instanceof Tile)\r\n    {\r\n        if (layer.data[tileY][tileX] === null)\r\n        {\r\n            layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, layer.tileWidth, layer.tileHeight);\r\n        }\r\n\r\n        layer.data[tileY][tileX].copy(tile);\r\n    }\r\n    else\r\n    {\r\n        var index = tile;\r\n\r\n        if (layer.data[tileY][tileX] === null)\r\n        {\r\n            layer.data[tileY][tileX] = new Tile(layer, index, tileX, tileY, layer.tileWidth, layer.tileHeight);\r\n        }\r\n        else\r\n        {\r\n            layer.data[tileY][tileX].index = index;\r\n        }\r\n    }\r\n\r\n    // Updating colliding flag on the new tile\r\n    var newTile = layer.data[tileY][tileX];\r\n    var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;\r\n\r\n    SetTileCollision(newTile, collides);\r\n\r\n    // Recalculate faces only if the colliding flag at (tileX, tileY) has changed\r\n    if (recalculateFaces && (oldTileCollides !== newTile.collides))\r\n    {\r\n        CalculateFacesAt(tileX, tileY, layer);\r\n    }\r\n\r\n    return newTile;\r\n};\r\n\r\nmodule.exports = PutTileAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PutTileAt = require('./PutTileAt');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n * specified location. If you pass in an index, only the index at the specified location will be\r\n * changed. Collision information will be recalculated at the specified location.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {number} worldX - The x coordinate, in pixels.\r\n * @param {number} worldY - The y coordinate, in pixels.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was created or added to this map.\r\n */\r\nvar PutTileAtWorldXY = function (tile, worldX, worldY, recalculateFaces, camera, layer)\r\n{\r\n    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);\r\n\r\n    return PutTileAt(tile, point.x, point.y, recalculateFaces, layer);\r\n};\r\n\r\nmodule.exports = PutTileAtWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar PutTileAt = require('./PutTileAt');\r\n\r\n/**\r\n * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n * index at the specified location will be changed. Collision information will be recalculated\r\n * within the region tiles were changed.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTilesAt\r\n * @since 3.0.0\r\n *\r\n * @param {(number[]|number[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar PutTilesAt = function (tilesArray, tileX, tileY, recalculateFaces, layer)\r\n{\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (!Array.isArray(tilesArray))\r\n    {\r\n        return null;\r\n    }\r\n\r\n    // Force the input array to be a 2D array\r\n    if (!Array.isArray(tilesArray[0]))\r\n    {\r\n        tilesArray = [ tilesArray ];\r\n    }\r\n\r\n    var height = tilesArray.length;\r\n    var width = tilesArray[0].length;\r\n\r\n    for (var ty = 0; ty < height; ty++)\r\n    {\r\n        for (var tx = 0; tx < width; tx++)\r\n        {\r\n            var tile = tilesArray[ty][tx];\r\n\r\n            PutTileAt(tile, tileX + tx, tileY + ty, false, layer);\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        // Recalculate the faces within the destination area and neighboring tiles\r\n        CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = PutTilesAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar GetRandom = require('../../utils/array/GetRandom');\r\n\r\n/**\r\n * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n * indexes. This method only modifies tile indexes and does not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.Randomize\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {number[]} indexes - An array of indexes to randomly draw from during randomization.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar Randomize = function (tileX, tileY, width, height, indexes, layer)\r\n{\r\n    var i;\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, {}, layer);\r\n\r\n    // If no indices are given, then find all the unique indexes within the specified region\r\n    if (!indexes)\r\n    {\r\n        indexes = [];\r\n\r\n        for (i = 0; i < tiles.length; i++)\r\n        {\r\n            if (indexes.indexOf(tiles[i].index) === -1)\r\n            {\r\n                indexes.push(tiles[i].index);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].index = GetRandom(indexes);\r\n    }\r\n};\r\n\r\nmodule.exports = Randomize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tile = require('../Tile');\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\nvar CalculateFacesAt = require('./CalculateFacesAt');\r\n\r\n/**\r\n * Removes the tile at the given tile coordinates in the specified layer and updates the layer's\r\n * collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.RemoveTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate.\r\n * @param {number} tileY - The y coordinate.\r\n * @param {boolean} replaceWithNull - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was removed.\r\n */\r\nvar RemoveTileAt = function (tileX, tileY, replaceWithNull, recalculateFaces, layer)\r\n{\r\n    if (replaceWithNull === undefined) { replaceWithNull = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (!IsInLayerBounds(tileX, tileY, layer))\r\n    {\r\n        return null;\r\n    }\r\n\r\n    var tile = layer.data[tileY][tileX];\r\n\r\n    if (!tile)\r\n    {\r\n        return null;\r\n    }\r\n    else\r\n    {\r\n        layer.data[tileY][tileX] = (replaceWithNull) ? null : new Tile(layer, -1, tileX, tileY, layer.tileWidth, layer.tileHeight);\r\n    }\r\n\r\n    //  Recalculate faces only if the removed tile was a colliding tile\r\n    if (recalculateFaces && tile && tile.collides)\r\n    {\r\n        CalculateFacesAt(tileX, tileY, layer);\r\n    }\r\n\r\n    return tile;\r\n};\r\n\r\nmodule.exports = RemoveTileAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RemoveTileAt = require('./RemoveTileAt');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Removes the tile at the given world coordinates in the specified layer and updates the layer's\r\n * collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.RemoveTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The x coordinate, in pixels.\r\n * @param {number} worldY - The y coordinate, in pixels.\r\n * @param {boolean} replaceWithNull - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was removed.\r\n */\r\nvar RemoveTileAtWorldXY = function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer)\r\n{\r\n    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);\r\n\r\n    return RemoveTileAt(point.x, point.y, replaceWithNull, recalculateFaces, layer);\r\n};\r\n\r\nmodule.exports = RemoveTileAtWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar Color = require('../../display/color');\r\n\r\nvar defaultTileColor = new Color(105, 210, 231, 150);\r\nvar defaultCollidingTileColor = new Color(243, 134, 48, 200);\r\nvar defaultFaceColor = new Color(40, 39, 37, 150);\r\n\r\n/**\r\n * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to\r\n * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n * wherever you want on the screen.\r\n *\r\n * @function Phaser.Tilemaps.Components.RenderDebug\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n * @param {Phaser.Types.Tilemaps.DebugStyleOptions} styleConfig - An object specifying the colors to use for the debug drawing.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar RenderDebug = function (graphics, styleConfig, layer)\r\n{\r\n    if (styleConfig === undefined) { styleConfig = {}; }\r\n\r\n    // Default colors without needlessly creating Color objects\r\n    var tileColor = (styleConfig.tileColor !== undefined) ? styleConfig.tileColor : defaultTileColor;\r\n    var collidingTileColor = (styleConfig.collidingTileColor !== undefined) ? styleConfig.collidingTileColor : defaultCollidingTileColor;\r\n    var faceColor = (styleConfig.faceColor !== undefined) ? styleConfig.faceColor : defaultFaceColor;\r\n\r\n    var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);\r\n\r\n    graphics.translateCanvas(layer.tilemapLayer.x, layer.tilemapLayer.y);\r\n    graphics.scaleCanvas(layer.tilemapLayer.scaleX, layer.tilemapLayer.scaleY);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        var tw = tile.width;\r\n        var th = tile.height;\r\n        var x = tile.pixelX;\r\n        var y = tile.pixelY;\r\n\r\n        var color = tile.collides ? collidingTileColor : tileColor;\r\n\r\n        if (color !== null)\r\n        {\r\n            graphics.fillStyle(color.color, color.alpha / 255);\r\n            graphics.fillRect(x, y, tw, th);\r\n        }\r\n\r\n        // Inset the face line to prevent neighboring tile's lines from overlapping\r\n        x += 1;\r\n        y += 1;\r\n        tw -= 2;\r\n        th -= 2;\r\n\r\n        if (faceColor !== null)\r\n        {\r\n            graphics.lineStyle(1, faceColor.color, faceColor.alpha / 255);\r\n\r\n            if (tile.faceTop) { graphics.lineBetween(x, y, x + tw, y); }\r\n            if (tile.faceRight) { graphics.lineBetween(x + tw, y, x + tw, y + th); }\r\n            if (tile.faceBottom) { graphics.lineBetween(x, y + th, x + tw, y + th); }\r\n            if (tile.faceLeft) { graphics.lineBetween(x, y, x, y + th); }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = RenderDebug;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n * not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.ReplaceByIndex\r\n * @since 3.0.0\r\n *\r\n * @param {number} findIndex - The index of the tile to search for.\r\n * @param {number} newIndex - The index of the tile to replace it with.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar ReplaceByIndex = function (findIndex, newIndex, tileX, tileY, width, height, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        if (tiles[i] && tiles[i].index === findIndex)\r\n        {\r\n            tiles[i].index = newIndex;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = ReplaceByIndex;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.RunCull\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {object} bounds - An object containing the `left`, `right`, `top` and `bottom` bounds.\r\n * @param {number} renderOrder - The rendering order constant.\r\n * @param {array} outputArray - The array to store the Tile objects within.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar RunCull = function (layer, bounds, renderOrder, outputArray)\r\n{\r\n    var mapData = layer.data;\r\n    var mapWidth = layer.width;\r\n    var mapHeight = layer.height;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var drawLeft = Math.max(0, bounds.left);\r\n    var drawRight = Math.min(mapWidth, bounds.right);\r\n    var drawTop = Math.max(0, bounds.top);\r\n    var drawBottom = Math.min(mapHeight, bounds.bottom);\r\n\r\n    var x;\r\n    var y;\r\n    var tile;\r\n\r\n    if (renderOrder === 0)\r\n    {\r\n        //  right-down\r\n\r\n        for (y = drawTop; y < drawBottom; y++)\r\n        {\r\n            for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n    else if (renderOrder === 1)\r\n    {\r\n        //  left-down\r\n\r\n        for (y = drawTop; y < drawBottom; y++)\r\n        {\r\n            for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n    else if (renderOrder === 2)\r\n    {\r\n        //  right-up\r\n\r\n        for (y = drawBottom; y >= drawTop; y--)\r\n        {\r\n            for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n    else if (renderOrder === 3)\r\n    {\r\n        //  left-up\r\n\r\n        for (y = drawBottom; y >= drawTop; y--)\r\n        {\r\n            for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n\r\n    tilemapLayer.tilesDrawn = outputArray.length;\r\n    tilemapLayer.tilesTotal = mapWidth * mapHeight;\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = RunCull;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar SetLayerCollisionIndex = require('./SetLayerCollisionIndex');\r\n\r\n/**\r\n * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n * collision will be enabled (true) or disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollision\r\n * @since 3.0.0\r\n *\r\n * @param {(number|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n */\r\nvar SetCollision = function (indexes, collides, recalculateFaces, layer, updateLayer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n    if (updateLayer === undefined) { updateLayer = true; }\r\n\r\n    if (!Array.isArray(indexes))\r\n    {\r\n        indexes = [ indexes ];\r\n    }\r\n\r\n    // Update the array of colliding indexes\r\n    for (var i = 0; i < indexes.length; i++)\r\n    {\r\n        SetLayerCollisionIndex(indexes[i], collides, layer);\r\n    }\r\n\r\n    // Update the tiles\r\n    if (updateLayer)\r\n    {\r\n        for (var ty = 0; ty < layer.height; ty++)\r\n        {\r\n            for (var tx = 0; tx < layer.width; tx++)\r\n            {\r\n                var tile = layer.data[ty][tx];\r\n\r\n                if (tile && indexes.indexOf(tile.index) !== -1)\r\n                {\r\n                    SetTileCollision(tile, collides);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollision;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar SetLayerCollisionIndex = require('./SetLayerCollisionIndex');\r\n\r\n/**\r\n * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n * enabled (true) or disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionBetween\r\n * @since 3.0.0\r\n *\r\n * @param {number} start - The first index of the tile to be set for collision.\r\n * @param {number} stop - The last index of the tile to be set for collision.\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n */\r\nvar SetCollisionBetween = function (start, stop, collides, recalculateFaces, layer, updateLayer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n    if (updateLayer === undefined) { updateLayer = true; }\r\n\r\n    if (start > stop)\r\n    {\r\n        return;\r\n    }\r\n\r\n    //  Update the array of colliding indexes\r\n    for (var index = start; index <= stop; index++)\r\n    {\r\n        SetLayerCollisionIndex(index, collides, layer);\r\n    }\r\n\r\n    //  Update the tiles\r\n    if (updateLayer)\r\n    {\r\n        for (var ty = 0; ty < layer.height; ty++)\r\n        {\r\n            for (var tx = 0; tx < layer.width; tx++)\r\n            {\r\n                var tile = layer.data[ty][tx];\r\n\r\n                if (tile)\r\n                {\r\n                    if (tile.index >= start && tile.index <= stop)\r\n                    {\r\n                        SetTileCollision(tile, collides);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollisionBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar SetLayerCollisionIndex = require('./SetLayerCollisionIndex');\r\n\r\n/**\r\n * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n * disabled (false). Tile indexes not currently in the layer are not affected.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionByExclusion\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} indexes - An array of the tile indexes to not be counted for collision.\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetCollisionByExclusion = function (indexes, collides, recalculateFaces, layer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (!Array.isArray(indexes))\r\n    {\r\n        indexes = [ indexes ];\r\n    }\r\n\r\n    // Note: this only updates layer.collideIndexes for tile indexes found currently in the layer\r\n    for (var ty = 0; ty < layer.height; ty++)\r\n    {\r\n        for (var tx = 0; tx < layer.width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (tile && indexes.indexOf(tile.index) === -1)\r\n            {\r\n                SetTileCollision(tile, collides);\r\n                SetLayerCollisionIndex(tile.index, collides, layer);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollisionByExclusion;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar HasValue = require('../../utils/object/HasValue');\r\n\r\n/**\r\n * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n * that matches the given properties object, its collision flag will be set. The `collides`\r\n * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n * \"types\" property that matches any of those values, its collision flag will be updated.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionByProperty\r\n * @since 3.0.0\r\n *\r\n * @param {object} properties - An object with tile properties and corresponding values that should be checked.\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetCollisionByProperty = function (properties, collides, recalculateFaces, layer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    for (var ty = 0; ty < layer.height; ty++)\r\n    {\r\n        for (var tx = 0; tx < layer.width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (!tile) { continue; }\r\n\r\n            for (var property in properties)\r\n            {\r\n                if (!HasValue(tile.properties, property)) { continue; }\r\n\r\n                var values = properties[property];\r\n\r\n                if (!Array.isArray(values))\r\n                {\r\n                    values = [ values ];\r\n                }\r\n\r\n                for (var i = 0; i < values.length; i++)\r\n                {\r\n                    if (tile.properties[property] === values[i])\r\n                    {\r\n                        SetTileCollision(tile, collides);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollisionByProperty;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\n\r\n/**\r\n * Sets collision on the tiles within a layer by checking each tile's collision group data\r\n * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n * a tile's collision group, the tile's colliding information will be set. The `collides` parameter\r\n * controls if collision will be enabled (true) or disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionFromCollisionGroup\r\n * @since 3.0.0\r\n *\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetCollisionFromCollisionGroup = function (collides, recalculateFaces, layer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    for (var ty = 0; ty < layer.height; ty++)\r\n    {\r\n        for (var tx = 0; tx < layer.width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (!tile) { continue; }\r\n\r\n            var collisionGroup = tile.getCollisionGroup();\r\n\r\n            // It's possible in Tiled to have a collision group without any shapes, e.g. create a\r\n            // shape and then delete the shape.\r\n            if (collisionGroup && collisionGroup.objects && collisionGroup.objects.length > 0)\r\n            {\r\n                SetTileCollision(tile, collides);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollisionFromCollisionGroup;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Internally used method to keep track of the tile indexes that collide within a layer. This\r\n * updates LayerData.collideIndexes to either contain or not contain the given `tileIndex`.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetLayerCollisionIndex\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileIndex - The tile index to set the collision boolean for.\r\n * @param {boolean} collides - Should the tile index collide or not?\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetLayerCollisionIndex = function (tileIndex, collides, layer)\r\n{\r\n    var loc = layer.collideIndexes.indexOf(tileIndex);\r\n\r\n    if (collides && loc === -1)\r\n    {\r\n        layer.collideIndexes.push(tileIndex);\r\n    }\r\n    else if (!collides && loc !== -1)\r\n    {\r\n        layer.collideIndexes.splice(loc, 1);\r\n    }\r\n};\r\n\r\nmodule.exports = SetLayerCollisionIndex;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Internally used method to set the colliding state of a tile. This does not recalculate\r\n * interesting faces.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetTileCollision\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.Tile} tile - The Tile to set the collision on.\r\n * @param {boolean} [collides=true] - Should the tile index collide or not?\r\n */\r\nvar SetTileCollision = function (tile, collides)\r\n{\r\n    if (collides)\r\n    {\r\n        tile.setCollision(true, true, true, true, false);\r\n    }\r\n    else\r\n    {\r\n        tile.resetCollision(false);\r\n    }\r\n};\r\n\r\nmodule.exports = SetTileCollision;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n * at a specific location on the map then see setTileLocationCallback.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetTileIndexCallback\r\n * @since 3.0.0\r\n *\r\n * @param {(number|array)} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for.\r\n * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n * @param {object} callbackContext - The context under which the callback is called.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetTileIndexCallback = function (indexes, callback, callbackContext, layer)\r\n{\r\n    if (typeof indexes === 'number')\r\n    {\r\n        layer.callbacks[indexes] = (callback !== null)\r\n            ? { callback: callback, callbackContext: callbackContext }\r\n            : undefined;\r\n    }\r\n    else\r\n    {\r\n        for (var i = 0, len = indexes.length; i < len; i++)\r\n        {\r\n            layer.callbacks[indexes[i]] = (callback !== null)\r\n                ? { callback: callback, callbackContext: callbackContext }\r\n                : undefined;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = SetTileIndexCallback;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n * remove it.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetTileLocationCallback\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n * @param {object} callbackContext - The context under which the callback is called.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetTileLocationCallback = function (tileX, tileY, width, height, callback, callbackContext, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].setCollisionCallback(callback, callbackContext);\r\n    }\r\n};\r\n\r\nmodule.exports = SetTileLocationCallback;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar ShuffleArray = require('../../utils/array/Shuffle');\r\n\r\n/**\r\n * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n * appear to have changed! This method only modifies tile indexes and does not change collision\r\n * information.\r\n *\r\n * @function Phaser.Tilemaps.Components.Shuffle\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar Shuffle = function (tileX, tileY, width, height, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    var indexes = tiles.map(function (tile) { return tile.index; });\r\n\r\n    ShuffleArray(indexes);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].index = indexes[i];\r\n    }\r\n};\r\n\r\nmodule.exports = Shuffle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SnapCeil = require('../../math/snap/SnapCeil');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\n/**\r\n * Returns the bounds in the given layer that are within the camera's viewport.\r\n * This is used internally by the cull tiles function.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredCullBounds\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n *\r\n * @return {object} An object containing the `left`, `right`, `top` and `bottom` bounds.\r\n */\r\nvar StaggeredCullBounds = function (layer, camera)\r\n{\r\n    var tilemap = layer.tilemapLayer.tilemap;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    //  We need to use the tile sizes defined for the map as a whole, not the layer,\r\n    //  in order to calculate the bounds correctly. As different sized tiles may be\r\n    //  placed on the grid and we cannot trust layer.baseTileWidth to give us the true size.\r\n    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);\r\n    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);\r\n\r\n    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;\r\n    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;\r\n\r\n    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH / 2, 0, true) - tilemapLayer.cullPaddingY;\r\n    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH / 2, 0, true) + tilemapLayer.cullPaddingY;\r\n\r\n    return {\r\n        left: boundsLeft,\r\n        right: boundsRight,\r\n        top: boundsTop,\r\n        bottom: boundsBottom\r\n    };\r\n};\r\n\r\nmodule.exports = StaggeredCullBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CullBounds = require('./StaggeredCullBounds');\r\nvar RunCull = require('./RunCull');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredCullTiles\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n * @param {number} [renderOrder=0] - The rendering order constant.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar StaggeredCullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1)\r\n    {\r\n        //  Camera world view bounds, snapped for scaled tile size\r\n        //  Cull Padding values are given in tiles, not pixels\r\n\r\n        var bounds = CullBounds(layer, camera);\r\n\r\n        RunCull(layer, bounds, renderOrder, outputArray);\r\n    }\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = StaggeredCullTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from staggered tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredTileToWorldXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */\r\nvar StaggeredTileToWorldXY = function (tileX, tileY, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var layerWorldX = 0;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);\r\n    var y = layerWorldY + tileY * (tileHeight / 2);\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = StaggeredTileToWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from staggered tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n * layers position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredTileToWorldY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in world coordinates.\r\n */\r\nvar StaggeredTileToWorldY = function (tileY, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (camera === undefined) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    return layerWorldY + tileY * (tileHeight / 2);\r\n};\r\n\r\nmodule.exports = StaggeredTileToWorldY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from world XY coordinates (pixels) to staggered tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredWorldToTileXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */\r\nvar StaggeredWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's horizontal scroll\r\n\r\n        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    var y = (snapToFloor) ? Math.floor((worldY / (tileHeight / 2))) : (worldY / (tileHeight / 2));\r\n    var x = (snapToFloor) ? Math.floor((worldX + (y % 2) * 0.5 * tileWidth) / tileWidth) : (worldX + (y % 2) * 0.5 * tileWidth) / tileWidth;\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = StaggeredWorldToTileXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from world Y coordinates (pixels) to staggered tile Y coordinates (tile units), factoring in the\r\n * layers position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredWorldToTileY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in tile units.\r\n */\r\nvar StaggeredWorldToTileY = function (worldY, snapToFloor, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        //  Find the world position relative to the static or dynamic layer's top left origin,\r\n        //  factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    return (snapToFloor) ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);\r\n};\r\n\r\nmodule.exports = StaggeredWorldToTileY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n * information.\r\n *\r\n * @function Phaser.Tilemaps.Components.SwapByIndex\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileA - First tile index.\r\n * @param {number} tileB - Second tile index.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SwapByIndex = function (indexA, indexB, tileX, tileY, width, height, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        if (tiles[i])\r\n        {\r\n            if (tiles[i].index === indexA)\r\n            {\r\n                tiles[i].index = indexB;\r\n            }\r\n            else if (tiles[i].index === indexB)\r\n            {\r\n                tiles[i].index = indexA;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = SwapByIndex;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.TileToWorldX\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number}\r\n */\r\nvar TileToWorldX = function (tileX, camera, layer)\r\n{\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    var layerWorldX = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    return layerWorldX + tileX * tileWidth;\r\n};\r\n\r\nmodule.exports = TileToWorldX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TileToWorldX = require('./TileToWorldX');\r\nvar TileToWorldY = require('./TileToWorldY');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.TileToWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */\r\nvar TileToWorldXY = function (tileX, tileY, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(0, 0); }\r\n\r\n    point.x = TileToWorldX(tileX, camera, layer);\r\n    point.y = TileToWorldY(tileY, camera, layer);\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = TileToWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.TileToWorldY\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in world coordinates.\r\n */\r\nvar TileToWorldY = function (tileY, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    return layerWorldY + tileY * tileHeight;\r\n};\r\n\r\nmodule.exports = TileToWorldY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n * weightedIndexes array. An example weighted array:\r\n *\r\n * [\r\n *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n * ]\r\n *\r\n * The probability of any index being choose is (the index's weight) / (sum of all weights). This\r\n * method only modifies tile indexes and does not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.WeightedRandomize\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {object[]} weightedIndexes - An array of objects to randomly draw from during\r\n * randomization. They should be in the form: { index: 0, weight: 4 } or\r\n * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar WeightedRandomize = function (tileX, tileY, width, height, weightedIndexes, layer)\r\n{\r\n    if (!weightedIndexes) { return; }\r\n\r\n    var i;\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    var weightTotal = 0;\r\n\r\n    for (i = 0; i < weightedIndexes.length; i++)\r\n    {\r\n        weightTotal += weightedIndexes[i].weight;\r\n    }\r\n\r\n    if (weightTotal <= 0) { return; }\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        var rand = Math.random() * weightTotal;\r\n        var sum = 0;\r\n        var randomIndex = -1;\r\n\r\n        for (var j = 0; j < weightedIndexes.length; j++)\r\n        {\r\n            sum += weightedIndexes[j].weight;\r\n\r\n            if (rand <= sum)\r\n            {\r\n                var chosen = weightedIndexes[j].index;\r\n\r\n                randomIndex = Array.isArray(chosen)\r\n                    ? chosen[Math.floor(Math.random() * chosen.length)]\r\n                    : chosen;\r\n                break;\r\n            }\r\n        }\r\n\r\n        tiles[i].index = randomIndex;\r\n    }\r\n};\r\n\r\nmodule.exports = WeightedRandomize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.WorldToTileX\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {?Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The X location in tile units.\r\n */\r\nvar WorldToTileX = function (worldX, snapToFloor, camera, layer)\r\n{\r\n    if (snapToFloor === undefined) { snapToFloor = true; }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's horizontal scroll\r\n        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    return (snapToFloor) ? Math.floor(worldX / tileWidth) : worldX / tileWidth;\r\n};\r\n\r\nmodule.exports = WorldToTileX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar WorldToTileX = require('./WorldToTileX');\r\nvar WorldToTileY = require('./WorldToTileY');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.WorldToTileXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */\r\nvar WorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)\r\n{\r\n    if (snapToFloor === undefined) { snapToFloor = true; }\r\n    if (!point) { point = new Vector2(0, 0); }\r\n\r\n    point.x = WorldToTileX(worldX, snapToFloor, camera, layer);\r\n    point.y = WorldToTileY(worldY, snapToFloor, camera, layer);\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = WorldToTileXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.WorldToTileY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {?Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in tile units.\r\n */\r\nvar WorldToTileY = function (worldY, snapToFloor, camera, layer)\r\n{\r\n    if (snapToFloor === undefined) { snapToFloor = true; }\r\n\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's vertical scroll\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    return (snapToFloor) ? Math.floor(worldY / tileHeight) : worldY / tileHeight;\r\n};\r\n\r\nmodule.exports = WorldToTileY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Components\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    CalculateFacesAt: require('./CalculateFacesAt'),\r\n    CalculateFacesWithin: require('./CalculateFacesWithin'),\r\n    CheckIsoBounds: require('./CheckIsoBounds'),\r\n    Copy: require('./Copy'),\r\n    CreateFromTiles: require('./CreateFromTiles'),\r\n    CullBounds: require('./CullBounds'),\r\n    CullTiles: require('./CullTiles'),\r\n    Fill: require('./Fill'),\r\n    FilterTiles: require('./FilterTiles'),\r\n    FindByIndex: require('./FindByIndex'),\r\n    FindTile: require('./FindTile'),\r\n    ForEachTile: require('./ForEachTile'),\r\n    GetCullTilesFunction: require('./GetCullTilesFunction'),\r\n    GetTileAt: require('./GetTileAt'),\r\n    GetTileAtWorldXY: require('./GetTileAtWorldXY'),\r\n    GetTilesWithin: require('./GetTilesWithin'),\r\n    GetTilesWithinShape: require('./GetTilesWithinShape'),\r\n    GetTilesWithinWorldXY: require('./GetTilesWithinWorldXY'),\r\n    GetTileToWorldXFunction: require('./GetTileToWorldXFunction'),\r\n    GetTileToWorldXYFunction: require('./GetTileToWorldXYFunction'),\r\n    GetTileToWorldYFunction: require('./GetTileToWorldYFunction'),\r\n    GetWorldToTileXFunction: require('./GetWorldToTileXFunction'),\r\n    GetWorldToTileXYFunction: require('./GetWorldToTileXYFunction'),\r\n    GetWorldToTileYFunction: require('./GetWorldToTileYFunction'),\r\n    HasTileAt: require('./HasTileAt'),\r\n    HasTileAtWorldXY: require('./HasTileAtWorldXY'),\r\n    HexagonalCullBounds: require('./HexagonalCullBounds'),\r\n    HexagonalCullTiles: require('./HexagonalCullTiles'),\r\n    HexagonalTileToWorldXY: require('./HexagonalTileToWorldXY'),\r\n    HexagonalTileToWorldY: require('./HexagonalTileToWorldY'),\r\n    HexagonalWorldToTileXY: require('./HexagonalWorldToTileXY'),\r\n    HexagonalWorldToTileY: require('./HexagonalWorldToTileY'),\r\n    IsInLayerBounds: require('./IsInLayerBounds'),\r\n    IsometricCullTiles: require('./IsometricCullTiles'),\r\n    IsometricTileToWorldXY: require('./IsometricTileToWorldXY'),\r\n    IsometricWorldToTileXY: require('./IsometricWorldToTileXY'),\r\n    PutTileAt: require('./PutTileAt'),\r\n    PutTileAtWorldXY: require('./PutTileAtWorldXY'),\r\n    PutTilesAt: require('./PutTilesAt'),\r\n    Randomize: require('./Randomize'),\r\n    RemoveTileAt: require('./RemoveTileAt'),\r\n    RemoveTileAtWorldXY: require('./RemoveTileAtWorldXY'),\r\n    RenderDebug: require('./RenderDebug'),\r\n    ReplaceByIndex: require('./ReplaceByIndex'),\r\n    RunCull: require('./RunCull'),\r\n    SetCollision: require('./SetCollision'),\r\n    SetCollisionBetween: require('./SetCollisionBetween'),\r\n    SetCollisionByExclusion: require('./SetCollisionByExclusion'),\r\n    SetCollisionByProperty: require('./SetCollisionByProperty'),\r\n    SetCollisionFromCollisionGroup: require('./SetCollisionFromCollisionGroup'),\r\n    SetLayerCollisionIndex: require('./SetLayerCollisionIndex'),\r\n    SetTileCollision: require('./SetTileCollision'),\r\n    SetTileIndexCallback: require('./SetTileIndexCallback'),\r\n    SetTileLocationCallback: require('./SetTileLocationCallback'),\r\n    Shuffle: require('./Shuffle'),\r\n    StaggeredCullBounds: require('./StaggeredCullBounds'),\r\n    StaggeredCullTiles: require('./StaggeredCullTiles'),\r\n    StaggeredTileToWorldXY: require('./StaggeredTileToWorldXY'),\r\n    StaggeredTileToWorldY: require('./StaggeredTileToWorldY'),\r\n    StaggeredWorldToTileXY: require('./StaggeredWorldToTileXY'),\r\n    StaggeredWorldToTileY: require('./StaggeredWorldToTileY'),\r\n    SwapByIndex: require('./SwapByIndex'),\r\n    TileToWorldX: require('./TileToWorldX'),\r\n    TileToWorldXY: require('./TileToWorldXY'),\r\n    TileToWorldY: require('./TileToWorldY'),\r\n    WeightedRandomize: require('./WeightedRandomize'),\r\n    WorldToTileX: require('./WorldToTileX'),\r\n    WorldToTileXY: require('./WorldToTileXY'),\r\n    WorldToTileY: require('./WorldToTileY')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Tilemap constants for orientation.\r\n * \r\n * @namespace Phaser.Tilemaps.Orientation\r\n * @memberof Phaser.Tilemaps\r\n * @since 3.50.0\r\n */\r\n\r\n/**\r\n * Phaser Tilemap constants for orientation.\r\n * \r\n * To find out what each mode does please see [Phaser.Tilemaps.Orientation]{@link Phaser.Tilemaps.Orientation}.\r\n * \r\n * @typedef {Phaser.Tilemaps.Orientation} Phaser.Tilemaps.OrientationType\r\n * @memberof Phaser.Tilemaps\r\n * @since 3.50.0\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * Orthogonal Tilemap orientation constant.\r\n     * \r\n     * @name Phaser.Tilemaps.Orientation.ORTHOGONAL\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    ORTHOGONAL: 0,\r\n\r\n    /**\r\n     * Isometric Tilemap orientation constant.\r\n     *\r\n     * @name Phaser.Tilemaps.Orientation.ISOMETRIC\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    ISOMETRIC: 1,\r\n\r\n    /**\r\n     * Staggered Tilemap orientation constant.\r\n     *\r\n     * @name Phaser.Tilemaps.Orientation.STAGGERED\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    STAGGERED: 2,\r\n\r\n    /**\r\n     * Hexagonal Tilemap orientation constant.\r\n     *\r\n     * @name Phaser.Tilemaps.Orientation.HEXAGONAL\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    HEXAGONAL: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = {\r\n\r\n    ORIENTATION: require('./ORIENTATION_CONST')\r\n\r\n};\r\n\r\nmodule.exports = CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Extend = require('../utils/object/Extend');\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps\r\n *\r\n * @borrows Phaser.Tilemaps.Orientation.ORTHOGONAL as ORTHOGONAL\r\n * @borrows Phaser.Tilemaps.Orientation.ISOMETRIC as ISOMETRIC\r\n * @borrows Phaser.Tilemaps.Orientation.STAGGERED as STAGGERED\r\n * @borrows Phaser.Tilemaps.Orientation.HEXAGONAL as HEXAGONAL\r\n */\r\n\r\nvar Tilemaps = {\r\n\r\n    Components: require('./components'),\r\n    Parsers: require('./parsers'),\r\n\r\n    Formats: require('./Formats'),\r\n    ImageCollection: require('./ImageCollection'),\r\n    ParseToTilemap: require('./ParseToTilemap'),\r\n    Tile: require('./Tile'),\r\n    Tilemap: require('./Tilemap'),\r\n    TilemapCreator: require('./TilemapCreator'),\r\n    TilemapFactory: require('./TilemapFactory'),\r\n    Tileset: require('./Tileset'),\r\n    TilemapLayer: require('./TilemapLayer'),\r\n    Orientation: require('./const/ORIENTATION_CONST'),\r\n\r\n    LayerData: require('./mapdata/LayerData'),\r\n    MapData: require('./mapdata/MapData'),\r\n    ObjectLayer: require('./mapdata/ObjectLayer')\r\n\r\n};\r\n\r\nTilemaps = Extend(false, Tilemaps, CONST.ORIENTATION);\r\n\r\nmodule.exports = Tilemaps;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * @classdesc\r\n * A class for representing data about about a layer in a map. Maps are parsed from CSV, Tiled,\r\n * etc. into this format. Tilemap and TilemapLayer objects have a reference\r\n * to this data and use it to look up and perform operations on tiles.\r\n *\r\n * @class LayerData\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Tilemaps.LayerDataConfig} [config] - The Layer Data configuration object.\r\n */\r\nvar LayerData = new Class({\r\n\r\n    initialize:\r\n\r\n    function LayerData (config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        /**\r\n         * The name of the layer, if specified in Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', 'layer');\r\n\r\n        /**\r\n         * The x offset of where to draw from the top left.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.x = GetFastValue(config, 'x', 0);\r\n\r\n        /**\r\n         * The y offset of where to draw from the top left.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.y = GetFastValue(config, 'y', 0);\r\n\r\n        /**\r\n         * The width of the layer in tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = GetFastValue(config, 'width', 0);\r\n\r\n        /**\r\n         * The height of the layer in tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = GetFastValue(config, 'height', 0);\r\n\r\n        /**\r\n         * The pixel width of the tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#tileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = GetFastValue(config, 'tileWidth', 0);\r\n\r\n        /**\r\n         * The pixel height of the tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#tileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = GetFastValue(config, 'tileHeight', 0);\r\n\r\n        /**\r\n         * The base tile width.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#baseTileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseTileWidth = GetFastValue(config, 'baseTileWidth', this.tileWidth);\r\n\r\n        /**\r\n         * The base tile height.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#baseTileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseTileHeight = GetFastValue(config, 'baseTileHeight', this.tileHeight);\r\n\r\n        /**\r\n         * The layers orientation, necessary to be able to determine a tiles pixelX and pixelY as well as the layers width and height.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#orientation\r\n         * @type {Phaser.Tilemaps.OrientationType}\r\n         * @since 3.50.0\r\n         */\r\n        this.orientation = GetFastValue(config, 'orientation', CONST.ORTHOGONAL);\r\n\r\n        /**\r\n         * The width in pixels of the entire layer.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.widthInPixels = GetFastValue(config, 'widthInPixels', this.width * this.baseTileWidth);\r\n\r\n        /**\r\n         * The height in pixels of the entire layer.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.heightInPixels = GetFastValue(config, 'heightInPixels', this.height * this.baseTileHeight);\r\n\r\n        /**\r\n         * The alpha value of the layer.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#alpha\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.alpha = GetFastValue(config, 'alpha', 1);\r\n\r\n        /**\r\n         * Is the layer visible or not?\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#visible\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.visible = GetFastValue(config, 'visible', true);\r\n\r\n        /**\r\n         * Layer specific properties (can be specified in Tiled)\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#properties\r\n         * @type {object[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = GetFastValue(config, 'properties', []);\r\n\r\n        /**\r\n         * Tile ID index map.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#indexes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.indexes = GetFastValue(config, 'indexes', []);\r\n\r\n        /**\r\n         * Tile Collision ID index map.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#collideIndexes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideIndexes = GetFastValue(config, 'collideIndexes', []);\r\n\r\n        /**\r\n         * An array of callbacks.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#callbacks\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.callbacks = GetFastValue(config, 'callbacks', []);\r\n\r\n        /**\r\n         * An array of physics bodies.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#bodies\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.bodies = GetFastValue(config, 'bodies', []);\r\n\r\n        /**\r\n         * An array of the tile data indexes.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#data\r\n         * @type {Phaser.Tilemaps.Tile[][]}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = GetFastValue(config, 'data', []);\r\n\r\n        /**\r\n         * A reference to the Tilemap layer that owns this data.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#tilemapLayer\r\n         * @type {Phaser.Tilemaps.TilemapLayer}\r\n         * @since 3.0.0\r\n         */\r\n        this.tilemapLayer = GetFastValue(config, 'tilemapLayer', null);\r\n\r\n        /**\r\n         * The length of the horizontal sides of the hexagon.\r\n         * Only used for hexagonal orientation Tilemaps.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#hexSideLength\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.hexSideLength = GetFastValue(config, 'hexSideLength', 0);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = LayerData;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * @classdesc\r\n * A class for representing data about a map. Maps are parsed from CSV, Tiled, etc. into this\r\n * format. A Tilemap object get a copy of this data and then unpacks the needed properties into\r\n * itself.\r\n *\r\n * @class MapData\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Tilemaps.MapDataConfig} [config] - The Map configuration object.\r\n */\r\nvar MapData = new Class({\r\n\r\n    initialize:\r\n\r\n    function MapData (config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        /**\r\n         * The key in the Phaser cache that corresponds to the loaded tilemap data.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', 'map');\r\n\r\n        /**\r\n         * The width of the entire tilemap.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = GetFastValue(config, 'width', 0);\r\n\r\n        /**\r\n         * The height of the entire tilemap.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = GetFastValue(config, 'height', 0);\r\n\r\n        /**\r\n         * If the map is infinite or not.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#infinite\r\n         * @type {boolean}\r\n         * @since 3.17.0\r\n         */\r\n        this.infinite = GetFastValue(config, 'infinite', false);\r\n\r\n        /**\r\n         * The width of the tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#tileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = GetFastValue(config, 'tileWidth', 0);\r\n\r\n        /**\r\n         * The height of the tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#tileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = GetFastValue(config, 'tileHeight', 0);\r\n\r\n        /**\r\n         * The width in pixels of the entire tilemap.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.widthInPixels = GetFastValue(config, 'widthInPixels', this.width * this.tileWidth);\r\n\r\n        /**\r\n         * The height in pixels of the entire tilemap.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.heightInPixels = GetFastValue(config, 'heightInPixels', this.height * this.tileHeight);\r\n\r\n        /**\r\n         * The format of the map data.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#format\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.format = GetFastValue(config, 'format', null);\r\n\r\n        /**\r\n         * The orientation of the map data (i.e. orthogonal, isometric, hexagonal), default 'orthogonal'.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#orientation\r\n         * @type {Phaser.Tilemaps.OrientationType}\r\n         * @since 3.50.0\r\n         */\r\n        this.orientation = GetFastValue(config, 'orientation', CONST.ORTHOGONAL);\r\n\r\n        /**\r\n         * Determines the draw order of tilemap. Default is right-down\r\n         *\r\n         * 0, or 'right-down'\r\n         * 1, or 'left-down'\r\n         * 2, or 'right-up'\r\n         * 3, or 'left-up'\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#renderOrder\r\n         * @type {string}\r\n         * @since 3.12.0\r\n         */\r\n        this.renderOrder = GetFastValue(config, 'renderOrder', 'right-down');\r\n\r\n        /**\r\n         * The version of the map data (as specified in Tiled).\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#version\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.version = GetFastValue(config, 'version', '1');\r\n\r\n        /**\r\n         * Map specific properties (can be specified in Tiled)\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = GetFastValue(config, 'properties', {});\r\n\r\n        /**\r\n         * An array with all the layers configured to the MapData.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#layers\r\n         * @type {(Phaser.Tilemaps.LayerData[]|Phaser.Tilemaps.ObjectLayer)}\r\n         * @since 3.0.0\r\n         */\r\n        this.layers = GetFastValue(config, 'layers', []);\r\n\r\n        /**\r\n         * An array of Tiled Image Layers.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#images\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.images = GetFastValue(config, 'images', []);\r\n\r\n        /**\r\n         * An object of Tiled Object Layers.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#objects\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.objects = GetFastValue(config, 'objects', {});\r\n\r\n        /**\r\n          * An object of collision data. Must be created as physics object or will return undefined.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#collision\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.collision = GetFastValue(config, 'collision', {});\r\n\r\n        /**\r\n         * An array of Tilesets.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#tilesets\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.tilesets = GetFastValue(config, 'tilesets', []);\r\n\r\n        /**\r\n         * The collection of images the map uses(specified in Tiled)\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#imageCollections\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.imageCollections = GetFastValue(config, 'imageCollections', []);\r\n\r\n        /**\r\n         * An array of tile instances.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#tiles\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.tiles = GetFastValue(config, 'tiles', []);\r\n\r\n        /**\r\n         * The length of the horizontal sides of the hexagon.\r\n         * Only used for hexagonal orientation Tilemaps.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#hexSideLength\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.hexSideLength = GetFastValue(config, 'hexSideLength', 0);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MapData;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * @classdesc\r\n * A class for representing a Tiled object layer in a map. This mirrors the structure of a Tiled\r\n * object layer, except:\r\n *  - \"x\" & \"y\" properties are ignored since these cannot be changed in Tiled.\r\n *  - \"offsetx\" & \"offsety\" are applied to the individual object coordinates directly, so they\r\n *    are ignored as well.\r\n *  - \"draworder\" is ignored.\r\n *\r\n * @class ObjectLayer\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Tilemaps.ObjectLayerConfig} [config] - The data for the layer from the Tiled JSON object.\r\n */\r\nvar ObjectLayer = new Class({\r\n\r\n    initialize:\r\n\r\n    function ObjectLayer (config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        /**\r\n         * The name of the Object Layer.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', 'object layer');\r\n\r\n        /**\r\n         * The opacity of the layer, between 0 and 1.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#opacity\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.opacity = GetFastValue(config, 'opacity', 1);\r\n\r\n        /**\r\n         * The custom properties defined on the Object Layer, keyed by their name.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = GetFastValue(config, 'properties', {});\r\n\r\n        /**\r\n         * The type of each custom property defined on the Object Layer, keyed by its name.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#propertyTypes\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.propertyTypes = GetFastValue(config, 'propertytypes', {});\r\n\r\n        /**\r\n         * The type of the layer, which should be `objectgroup`.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = GetFastValue(config, 'type', 'objectgroup');\r\n\r\n        /**\r\n         * Whether the layer is shown (`true`) or hidden (`false`).\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#visible\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.visible = GetFastValue(config, 'visible', true);\r\n\r\n        /**\r\n         * An array of all objects on this Object Layer.\r\n         *\r\n         * Each Tiled object corresponds to a JavaScript object in this array. It has an `id` (unique),\r\n         * `name` (as assigned in Tiled), `type` (as assigned in Tiled), `rotation` (in clockwise degrees),\r\n         * `properties` (if any), `visible` state (`true` if visible, `false` otherwise),\r\n         * `x` and `y` coordinates (in pixels, relative to the tilemap), and a `width` and `height` (in pixels).\r\n         *\r\n         * An object tile has a `gid` property (GID of the represented tile), a `flippedHorizontal` property,\r\n         * a `flippedVertical` property, and `flippedAntiDiagonal` property.\r\n         * The {@link http://docs.mapeditor.org/en/latest/reference/tmx-map-format/|Tiled documentation} contains\r\n         * information on flipping and rotation.\r\n         *\r\n         * Polylines have a `polyline` property, which is an array of objects corresponding to points,\r\n         * where each point has an `x` property and a `y` property. Polygons have an identically structured\r\n         * array in their `polygon` property. Text objects have a `text` property with the text's properties.\r\n         *\r\n         * Rectangles and ellipses have a `rectangle` or `ellipse` property set to `true`.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#objects\r\n         * @type {Phaser.Types.Tilemaps.TiledObject[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.objects = GetFastValue(config, 'objects', []);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ObjectLayer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\n\r\n/**\r\n * Get the Tilemap orientation from the given string.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.FromOrientationString\r\n * @since 3.50.0\r\n *\r\n * @param {string} [orientation] - The orientation type as a string.\r\n *\r\n * @return {Phaser.Tilemaps.OrientationType} The Tilemap Orientation type.\r\n */\r\nvar FromOrientationString = function (orientation)\r\n{\r\n    orientation = orientation.toLowerCase();\r\n\r\n    if (orientation === 'isometric')\r\n    {\r\n        return CONST.ISOMETRIC;\r\n    }\r\n    else if (orientation === 'staggered')\r\n    {\r\n        return CONST.STAGGERED;\r\n    }\r\n    else if (orientation === 'hexagonal')\r\n    {\r\n        return CONST.HEXAGONAL;\r\n    }\r\n    else\r\n    {\r\n        return CONST.ORTHOGONAL;\r\n    }\r\n};\r\n\r\nmodule.exports = FromOrientationString;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('../Formats');\r\nvar Parse2DArray = require('./Parse2DArray');\r\nvar ParseCSV = require('./ParseCSV');\r\nvar ParseJSONTiled = require('./tiled/ParseJSONTiled');\r\nvar ParseWeltmeister = require('./impact/ParseWeltmeister');\r\n\r\n/**\r\n * Parses raw data of a given Tilemap format into a new MapData object. If no recognized data format\r\n * is found, returns `null`. When loading from CSV or a 2D array, you should specify the tileWidth &\r\n * tileHeight. When parsing from a map from Tiled, the tileWidth & tileHeight will be pulled from\r\n * the map data.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Parse\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {number} mapFormat - See ../Formats.js.\r\n * @param {(number[][]|string|object)} data - 2D array, CSV string or Tiled JSON object.\r\n * @param {number} tileWidth - The width of a tile in pixels. Required for 2D array and CSV, but\r\n * ignored for Tiled JSON.\r\n * @param {number} tileHeight - The height of a tile in pixels. Required for 2D array and CSV, but\r\n * ignored for Tiled JSON.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} The created `MapData` object.\r\n */\r\nvar Parse = function (name, mapFormat, data, tileWidth, tileHeight, insertNull)\r\n{\r\n    var newMap;\r\n\r\n    switch (mapFormat)\r\n    {\r\n        case (Formats.ARRAY_2D):\r\n            newMap = Parse2DArray(name, data, tileWidth, tileHeight, insertNull);\r\n            break;\r\n        case (Formats.CSV):\r\n            newMap = ParseCSV(name, data, tileWidth, tileHeight, insertNull);\r\n            break;\r\n        case (Formats.TILED_JSON):\r\n            newMap = ParseJSONTiled(name, data, insertNull);\r\n            break;\r\n        case (Formats.WELTMEISTER):\r\n            newMap = ParseWeltmeister(name, data, insertNull);\r\n            break;\r\n        default:\r\n            console.warn('Unrecognized tilemap data format: ' + mapFormat);\r\n            newMap = null;\r\n    }\r\n\r\n    return newMap;\r\n};\r\n\r\nmodule.exports = Parse;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('../Formats');\r\nvar LayerData = require('../mapdata/LayerData');\r\nvar MapData = require('../mapdata/MapData');\r\nvar Tile = require('../Tile');\r\n\r\n/**\r\n * Parses a 2D array of tile indexes into a new MapData object with a single layer.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Parse2DArray\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {number[][]} data - 2D array, CSV string or Tiled JSON object.\r\n * @param {number} tileWidth - The width of a tile in pixels.\r\n * @param {number} tileHeight - The height of a tile in pixels.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} The MapData object.\r\n */\r\nvar Parse2DArray = function (name, data, tileWidth, tileHeight, insertNull)\r\n{\r\n    var layerData = new LayerData({\r\n        tileWidth: tileWidth,\r\n        tileHeight: tileHeight\r\n    });\r\n    \r\n    var mapData = new MapData({\r\n        name: name,\r\n        tileWidth: tileWidth,\r\n        tileHeight: tileHeight,\r\n        format: Formats.ARRAY_2D,\r\n        layers: [ layerData ]\r\n    });\r\n\r\n    var tiles = [];\r\n    var height = data.length;\r\n    var width = 0;\r\n\r\n    for (var y = 0; y < data.length; y++)\r\n    {\r\n        tiles[y] = [];\r\n        var row = data[y];\r\n\r\n        for (var x = 0; x < row.length; x++)\r\n        {\r\n            var tileIndex = parseInt(row[x], 10);\r\n\r\n            if (isNaN(tileIndex) || tileIndex === -1)\r\n            {\r\n                tiles[y][x] = insertNull\r\n                    ? null\r\n                    : new Tile(layerData, -1, x, y, tileWidth, tileHeight);\r\n            }\r\n            else\r\n            {\r\n                tiles[y][x] = new Tile(layerData, tileIndex, x, y, tileWidth, tileHeight);\r\n            }\r\n        }\r\n\r\n        if (width === 0)\r\n        {\r\n            width = row.length;\r\n        }\r\n    }\r\n\r\n    mapData.width = layerData.width = width;\r\n    mapData.height = layerData.height = height;\r\n    mapData.widthInPixels = layerData.widthInPixels = width * tileWidth;\r\n    mapData.heightInPixels = layerData.heightInPixels = height * tileHeight;\r\n    layerData.data = tiles;\r\n\r\n    return mapData;\r\n};\r\n\r\nmodule.exports = Parse2DArray;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('../Formats');\r\nvar Parse2DArray = require('./Parse2DArray');\r\n\r\n/**\r\n * Parses a CSV string of tile indexes into a new MapData object with a single layer.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.ParseCSV\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {string} data - CSV string of tile indexes.\r\n * @param {number} tileWidth - The width of a tile in pixels.\r\n * @param {number} tileHeight - The height of a tile in pixels.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} The resulting MapData object.\r\n */\r\nvar ParseCSV = function (name, data, tileWidth, tileHeight, insertNull)\r\n{\r\n    var array2D = data\r\n        .trim()\r\n        .split('\\n')\r\n        .map(function (row) { return row.split(','); });\r\n\r\n    var map = Parse2DArray(name, array2D, tileWidth, tileHeight, insertNull);\r\n    map.format = Formats.CSV;\r\n\r\n    return map;\r\n};\r\n\r\nmodule.exports = ParseCSV;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar LayerData = require('../../mapdata/LayerData');\r\nvar Tile = require('../../Tile');\r\n\r\n/**\r\n * Parses all tilemap layers in an Impact JSON object into new LayerData objects.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Impact.ParseTileLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Impact JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled (see {@link Phaser.Tilemaps.Parsers.Tiled.ParseJSONTiled}).\r\n *\r\n * @return {Phaser.Tilemaps.LayerData[]} - An array of LayerData objects, one for each entry in\r\n * json.layers with the type 'tilelayer'.\r\n */\r\nvar ParseTileLayers = function (json, insertNull)\r\n{\r\n    var tileLayers = [];\r\n\r\n    for (var i = 0; i < json.layer.length; i++)\r\n    {\r\n        var layer = json.layer[i];\r\n\r\n        var layerData = new LayerData({\r\n            name: layer.name,\r\n            width: layer.width,\r\n            height: layer.height,\r\n            tileWidth: layer.tilesize,\r\n            tileHeight: layer.tilesize,\r\n            visible: layer.visible === 1\r\n        });\r\n\r\n        var row = [];\r\n        var tileGrid = [];\r\n\r\n        //  Loop through the data field in the JSON. This is a 2D array containing the tile indexes,\r\n        //  one after the other. The indexes are relative to the tileset that contains the tile.\r\n        for (var y = 0; y < layer.data.length; y++)\r\n        {\r\n            for (var x = 0; x < layer.data[y].length; x++)\r\n            {\r\n                // In Weltmeister, 0 = no tile, but the Tilemap API expects -1 = no tile.\r\n                var index = layer.data[y][x] - 1;\r\n\r\n                var tile;\r\n\r\n                if (index > -1)\r\n                {\r\n                    tile = new Tile(layerData, index, x, y, layer.tilesize, layer.tilesize);\r\n                }\r\n                else\r\n                {\r\n                    tile = insertNull\r\n                        ? null\r\n                        : new Tile(layerData, -1, x, y, layer.tilesize, layer.tilesize);\r\n                }\r\n\r\n                row.push(tile);\r\n            }\r\n\r\n            tileGrid.push(row);\r\n            row = [];\r\n        }\r\n\r\n        layerData.data = tileGrid;\r\n\r\n        tileLayers.push(layerData);\r\n    }\r\n\r\n    return tileLayers;\r\n};\r\n\r\nmodule.exports = ParseTileLayers;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tileset = require('../../Tileset');\r\n\r\n/**\r\n * Tilesets and Image Collections\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Impact.ParseTilesets\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Impact JSON data.\r\n *\r\n * @return {array} An array of Tilesets.\r\n */\r\nvar ParseTilesets = function (json)\r\n{\r\n    var tilesets = [];\r\n    var tilesetsNames = [];\r\n\r\n    for (var i = 0; i < json.layer.length; i++)\r\n    {\r\n        var layer = json.layer[i];\r\n\r\n        // A relative filepath to the source image (within Weltmeister) is used for the name\r\n        var tilesetName = layer.tilesetName;\r\n\r\n        // Only add unique tilesets that have a valid name. Collision layers will have a blank name.\r\n        if (tilesetName !== '' && tilesetsNames.indexOf(tilesetName) === -1)\r\n        {\r\n            tilesetsNames.push(tilesetName);\r\n\r\n            // Tiles are stored with an ID relative to the tileset, rather than a globally unique ID\r\n            // across all tilesets. Also, tilesets in Weltmeister have no margin or padding.\r\n            tilesets.push(new Tileset(tilesetName, 0, layer.tilesize, layer.tilesize, 0, 0));\r\n        }\r\n    }\r\n\r\n    return tilesets;\r\n};\r\n\r\nmodule.exports = ParseTilesets;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('../../Formats');\r\nvar MapData = require('../../mapdata/MapData');\r\nvar ParseTileLayers = require('./ParseTileLayers');\r\nvar ParseTilesets = require('./ParseTilesets');\r\n\r\n/**\r\n * Parses a Weltmeister JSON object into a new MapData object.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Impact.ParseWeltmeister\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {object} json - The Weltmeister JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {?Phaser.Tilemaps.MapData} The created MapData object, or `null` if the data can't be parsed.\r\n */\r\nvar ParseWeltmeister = function (name, json, insertNull)\r\n{\r\n    if (json.layer.length === 0)\r\n    {\r\n        console.warn('No layers found in the Weltmeister map: ' + name);\r\n        return null;\r\n    }\r\n\r\n    var width = 0;\r\n    var height = 0;\r\n\r\n    for (var i = 0; i < json.layer.length; i++)\r\n    {\r\n        if (json.layer[i].width > width) { width = json.layer[i].width; }\r\n        if (json.layer[i].height > height) { height = json.layer[i].height; }\r\n    }\r\n\r\n    var mapData = new MapData({\r\n        width: width,\r\n        height: height,\r\n        name: name,\r\n        tileWidth: json.layer[0].tilesize,\r\n        tileHeight: json.layer[0].tilesize,\r\n        format: Formats.WELTMEISTER\r\n    });\r\n\r\n    mapData.layers = ParseTileLayers(json, insertNull);\r\n    mapData.tilesets = ParseTilesets(json);\r\n\r\n    return mapData;\r\n};\r\n\r\nmodule.exports = ParseWeltmeister;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Parsers.Impact\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ParseTileLayers: require('./ParseTileLayers'),\r\n    ParseTilesets: require('./ParseTilesets'),\r\n    ParseWeltmeister: require('./ParseWeltmeister')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Parsers\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    FromOrientationString: require('./FromOrientationString'),\r\n    Parse: require('./Parse'),\r\n    Parse2DArray: require('./Parse2DArray'),\r\n    ParseCSV: require('./ParseCSV'),\r\n\r\n    Impact: require('./impact/'),\r\n    Tiled: require('./tiled/')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Extend = require('../../../utils/object/Extend');\r\n\r\n/**\r\n * Copy properties from tileset to tiles.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.AssignTileProperties\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.MapData} mapData - The Map Data object.\r\n */\r\nvar AssignTileProperties = function (mapData)\r\n{\r\n    var layerData;\r\n    var tile;\r\n    var sid;\r\n    var set;\r\n    var row;\r\n\r\n    // go through each of the map data layers\r\n    for (var i = 0; i < mapData.layers.length; i++)\r\n    {\r\n        layerData = mapData.layers[i];\r\n\r\n        set = null;\r\n\r\n        // rows of tiles\r\n        for (var j = 0; j < layerData.data.length; j++)\r\n        {\r\n            row = layerData.data[j];\r\n\r\n            // individual tiles\r\n            for (var k = 0; k < row.length; k++)\r\n            {\r\n                tile = row[k];\r\n\r\n                if (tile === null || tile.index < 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                // find the relevant tileset\r\n                sid = mapData.tiles[tile.index][2];\r\n                set = mapData.tilesets[sid];\r\n\r\n                // Ensure that a tile's size matches its tileset\r\n                tile.width = set.tileWidth;\r\n                tile.height = set.tileHeight;\r\n\r\n                // if that tile type has any properties, add them to the tile object\r\n                if (set.tileProperties && set.tileProperties[tile.index - set.firstgid])\r\n                {\r\n                    tile.properties = Extend(\r\n                        tile.properties, set.tileProperties[tile.index - set.firstgid]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = AssignTileProperties;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Decode base-64 encoded data, for example as exported by Tiled.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.Base64Decode\r\n * @since 3.0.0\r\n *\r\n * @param {object} data - Base-64 encoded data to decode.\r\n *\r\n * @return {array} Array containing the decoded bytes.\r\n */\r\nvar Base64Decode = function (data)\r\n{\r\n    var binaryString = window.atob(data);\r\n    var len = binaryString.length;\r\n    var bytes = new Array(len / 4);\r\n\r\n    // Interpret binaryString as an array of bytes representing little-endian encoded uint32 values.\r\n    for (var i = 0; i < len; i += 4)\r\n    {\r\n        bytes[i / 4] = (\r\n            binaryString.charCodeAt(i) |\r\n            binaryString.charCodeAt(i + 1) << 8 |\r\n            binaryString.charCodeAt(i + 2) << 16 |\r\n            binaryString.charCodeAt(i + 3) << 24\r\n        ) >>> 0;\r\n    }\r\n\r\n    return bytes;\r\n};\r\n\r\nmodule.exports = Base64Decode;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tileset = require('../../Tileset');\r\n\r\n/**\r\n * Master list of tiles -> x, y, index in tileset.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.BuildTilesetIndex\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.MapData} mapData - The Map Data object.\r\n *\r\n * @return {array} An array of Tileset objects.\r\n */\r\nvar BuildTilesetIndex = function (mapData)\r\n{\r\n    var i;\r\n    var set;\r\n    var tiles = [];\r\n\r\n    for (i = 0; i < mapData.imageCollections.length; i++)\r\n    {\r\n        var collection = mapData.imageCollections[i];\r\n        var images = collection.images;\r\n\r\n        for (var j = 0; j < images.length; j++)\r\n        {\r\n            var image = images[j];\r\n\r\n            set = new Tileset(image.image, image.gid, collection.imageWidth, collection.imageHeight, 0, 0);\r\n\r\n            set.updateTileData(collection.imageWidth, collection.imageHeight);\r\n\r\n            mapData.tilesets.push(set);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < mapData.tilesets.length; i++)\r\n    {\r\n        set = mapData.tilesets[i];\r\n\r\n        var x = set.tileMargin;\r\n        var y = set.tileMargin;\r\n\r\n        var count = 0;\r\n        var countX = 0;\r\n        var countY = 0;\r\n\r\n        for (var t = set.firstgid; t < set.firstgid + set.total; t++)\r\n        {\r\n            //  Can add extra properties here as needed\r\n            tiles[t] = [ x, y, i ];\r\n\r\n            x += set.tileWidth + set.tileSpacing;\r\n\r\n            count++;\r\n\r\n            if (count === set.total)\r\n            {\r\n                break;\r\n            }\r\n\r\n            countX++;\r\n\r\n            if (countX === set.columns)\r\n            {\r\n                x = set.tileMargin;\r\n                y += set.tileHeight + set.tileSpacing;\r\n\r\n                countX = 0;\r\n                countY++;\r\n\r\n                if (countY === set.rows)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tiles;\r\n};\r\n\r\nmodule.exports = BuildTilesetIndex;\r\n","/**\r\n * @author       Seth Berrier <berriers@uwstout.edu>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\n\r\n/**\r\n * Parse a Tiled group layer and create a state object for inheriting.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.CreateGroupLayer\r\n * @since 3.21.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n * @param {object} [currentl] - The current group layer from the Tiled JSON file.\r\n * @param {object} [parentstate] - The state of the parent group (if any).\r\n *\r\n * @return {object} A group state object with proper values for updating children layers.\r\n */\r\nvar CreateGroupLayer = function (json, groupl, parentstate)\r\n{\r\n    if (!groupl)\r\n    {\r\n        // Return a default group state object\r\n        return {\r\n            i: 0, // Current layer array iterator\r\n            layers: json.layers, // Current array of layers\r\n\r\n            // Values inherited from parent group\r\n            name: '',\r\n            opacity: 1,\r\n            visible: true,\r\n            x: 0,\r\n            y: 0\r\n        };\r\n    }\r\n\r\n    // Compute group layer x, y\r\n    var layerX = groupl.x + GetFastValue(groupl, 'startx', 0) * json.tilewidth + GetFastValue(groupl, 'offsetx', 0);\r\n    var layerY = groupl.y + GetFastValue(groupl, 'starty', 0) * json.tileheight + GetFastValue(groupl, 'offsety', 0);\r\n\r\n    // Compute next state inherited from group\r\n    return {\r\n        i: 0,\r\n        layers: groupl.layers,\r\n        name: parentstate.name + groupl.name + '/',\r\n        opacity: parentstate.opacity * groupl.opacity,\r\n        visible: parentstate.visible && groupl.visible,\r\n        x: parentstate.x + layerX,\r\n        y: parentstate.y + layerY\r\n    };\r\n};\r\n\r\nmodule.exports = CreateGroupLayer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FLIPPED_HORIZONTAL = 0x80000000;\r\nvar FLIPPED_VERTICAL = 0x40000000;\r\nvar FLIPPED_ANTI_DIAGONAL = 0x20000000; // Top-right is swapped with bottom-left corners\r\n\r\n/**\r\n * See Tiled documentation on tile flipping:\r\n * http://docs.mapeditor.org/en/latest/reference/tmx-map-format/\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseGID\r\n * @since 3.0.0\r\n *\r\n * @param {number} gid - A Tiled GID.\r\n *\r\n * @return {Phaser.Types.Tilemaps.GIDData} The GID Data.\r\n */\r\nvar ParseGID = function (gid)\r\n{\r\n    var flippedHorizontal = Boolean(gid & FLIPPED_HORIZONTAL);\r\n    var flippedVertical = Boolean(gid & FLIPPED_VERTICAL);\r\n    var flippedAntiDiagonal = Boolean(gid & FLIPPED_ANTI_DIAGONAL);\r\n    gid = gid & ~(FLIPPED_HORIZONTAL | FLIPPED_VERTICAL | FLIPPED_ANTI_DIAGONAL);\r\n\r\n    // Parse the flip flags into something Phaser can use\r\n    var rotation = 0;\r\n    var flipped = false;\r\n\r\n    if (flippedHorizontal && flippedVertical && flippedAntiDiagonal)\r\n    {\r\n        rotation = Math.PI / 2;\r\n        flipped = true;\r\n    }\r\n    else if (flippedHorizontal && flippedVertical && !flippedAntiDiagonal)\r\n    {\r\n        rotation = Math.PI;\r\n        flipped = false;\r\n    }\r\n    else if (flippedHorizontal && !flippedVertical && flippedAntiDiagonal)\r\n    {\r\n        rotation = Math.PI / 2;\r\n        flipped = false;\r\n    }\r\n    else if (flippedHorizontal && !flippedVertical && !flippedAntiDiagonal)\r\n    {\r\n        rotation = 0;\r\n        flipped = true;\r\n    }\r\n    else if (!flippedHorizontal && flippedVertical && flippedAntiDiagonal)\r\n    {\r\n        rotation = 3 * Math.PI / 2;\r\n        flipped = false;\r\n    }\r\n    else if (!flippedHorizontal && flippedVertical && !flippedAntiDiagonal)\r\n    {\r\n        rotation = Math.PI;\r\n        flipped = true;\r\n    }\r\n    else if (!flippedHorizontal && !flippedVertical && flippedAntiDiagonal)\r\n    {\r\n        rotation = 3 * Math.PI / 2;\r\n        flipped = true;\r\n    }\r\n    else if (!flippedHorizontal && !flippedVertical && !flippedAntiDiagonal)\r\n    {\r\n        rotation = 0;\r\n        flipped = false;\r\n    }\r\n\r\n    return {\r\n        gid: gid,\r\n        flippedHorizontal: flippedHorizontal,\r\n        flippedVertical: flippedVertical,\r\n        flippedAntiDiagonal: flippedAntiDiagonal,\r\n        rotation: rotation,\r\n        flipped: flipped\r\n    };\r\n};\r\n\r\nmodule.exports = ParseGID;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar CreateGroupLayer = require('./CreateGroupLayer');\r\n\r\n/**\r\n * Parses a Tiled JSON object into an array of objects with details about the image layers.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseImageLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n *\r\n * @return {array} Array of objects that include critical info about the map's image layers\r\n */\r\nvar ParseImageLayers = function (json)\r\n{\r\n    var images = [];\r\n\r\n    // State inherited from a parent group\r\n    var groupStack = [];\r\n    var curGroupState = CreateGroupLayer(json);\r\n\r\n    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)\r\n    {\r\n        if (curGroupState.i >= curGroupState.layers.length)\r\n        {\r\n            // Ensure recursion stack is not empty first\r\n            if (groupStack.length < 1)\r\n            {\r\n                console.warn(\r\n                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'\r\n                );\r\n                break;\r\n            }\r\n\r\n            // Return to previous recursive state\r\n            curGroupState = groupStack.pop();\r\n            continue;\r\n        }\r\n\r\n        // Get current layer and advance iterator\r\n        var curi = curGroupState.layers[curGroupState.i];\r\n        curGroupState.i++;\r\n\r\n        if (curi.type !== 'imagelayer')\r\n        {\r\n            if (curi.type === 'group')\r\n            {\r\n                // Compute next state inherited from group\r\n                var nextGroupState = CreateGroupLayer(json, curi, curGroupState);\r\n\r\n                // Preserve current state before recursing\r\n                groupStack.push(curGroupState);\r\n                curGroupState = nextGroupState;\r\n            }\r\n\r\n            // Skip this layer OR 'recurse' (iterative style) into the group\r\n            continue;\r\n        }\r\n\r\n        var layerOffsetX = GetFastValue(curi, 'offsetx', 0) + GetFastValue(curi, 'startx', 0);\r\n        var layerOffsetY = GetFastValue(curi, 'offsety', 0) + GetFastValue(curi, 'starty', 0);\r\n        images.push({\r\n            name: (curGroupState.name + curi.name),\r\n            image: curi.image,\r\n            x: (curGroupState.x + layerOffsetX + curi.x),\r\n            y: (curGroupState.y + layerOffsetY + curi.y),\r\n            alpha: (curGroupState.opacity * curi.opacity),\r\n            visible: (curGroupState.visible && curi.visible),\r\n            properties: GetFastValue(curi, 'properties', {})\r\n        });\r\n    }\r\n\r\n    return images;\r\n};\r\n\r\nmodule.exports = ParseImageLayers;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AssignTileProperties = require('./AssignTileProperties');\r\nvar BuildTilesetIndex = require('./BuildTilesetIndex');\r\nvar CONST = require('../../const/ORIENTATION_CONST');\r\nvar Formats = require('../../Formats');\r\nvar FromOrientationString = require('../FromOrientationString');\r\nvar MapData = require('../../mapdata/MapData');\r\nvar ParseImageLayers = require('./ParseImageLayers');\r\nvar ParseObjectLayers = require('./ParseObjectLayers');\r\nvar ParseTileLayers = require('./ParseTileLayers');\r\nvar ParseTilesets = require('./ParseTilesets');\r\n\r\n/**\r\n * Parses a Tiled JSON object into a new MapData object.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseJSONTiled\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {object} json - The Tiled JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {?Phaser.Tilemaps.MapData} The created MapData object, or `null` if the data can't be parsed.\r\n */\r\nvar ParseJSONTiled = function (name, json, insertNull)\r\n{\r\n    //  Map data will consist of: layers, objects, images, tilesets, sizes\r\n    var mapData = new MapData({\r\n        width: json.width,\r\n        height: json.height,\r\n        name: name,\r\n        tileWidth: json.tilewidth,\r\n        tileHeight: json.tileheight,\r\n        orientation: FromOrientationString(json.orientation),\r\n        format: Formats.TILED_JSON,\r\n        version: json.version,\r\n        properties: json.properties,\r\n        renderOrder: json.renderorder,\r\n        infinite: json.infinite\r\n    });\r\n\r\n    if (mapData.orientation === CONST.HEXAGONAL)\r\n    {\r\n        mapData.hexSideLength = json.hexsidelength;\r\n    }\r\n\r\n    mapData.layers = ParseTileLayers(json, insertNull);\r\n    mapData.images = ParseImageLayers(json);\r\n\r\n    var sets = ParseTilesets(json);\r\n\r\n    mapData.tilesets = sets.tilesets;\r\n    mapData.imageCollections = sets.imageCollections;\r\n\r\n    mapData.objects = ParseObjectLayers(json);\r\n\r\n    mapData.tiles = BuildTilesetIndex(mapData);\r\n\r\n    AssignTileProperties(mapData);\r\n\r\n    return mapData;\r\n};\r\n\r\nmodule.exports = ParseJSONTiled;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Pick = require('../../../utils/object/Pick');\r\nvar ParseGID = require('./ParseGID');\r\n\r\nvar copyPoints = function (p) { return { x: p.x, y: p.y }; };\r\n\r\nvar commonObjectProps = [ 'id', 'name', 'type', 'rotation', 'properties', 'visible', 'x', 'y', 'width', 'height' ];\r\n\r\n/**\r\n * Convert a Tiled object to an internal parsed object normalising and copying properties over, while applying optional x and y offsets. The parsed object will always have the properties `id`, `name`, `type`, `rotation`, `properties`, `visible`, `x`, `y`, `width` and `height`. Other properties will be added according to the object type (such as text, polyline, gid etc.)\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseObject\r\n * @since 3.0.0\r\n *\r\n * @param {object} tiledObject - Tiled object to convert to an internal parsed object normalising and copying properties over.\r\n * @param {number} [offsetX=0] - Optional additional offset to apply to the object's x property. Defaults to 0.\r\n * @param {number} [offsetY=0] - Optional additional offset to apply to the object's y property. Defaults to 0.\r\n *\r\n * @return {object} The parsed object containing properties read from the Tiled object according to it's type with x and y values updated according to the given offsets.\r\n */\r\nvar ParseObject = function (tiledObject, offsetX, offsetY)\r\n{\r\n    if (offsetX === undefined) { offsetX = 0; }\r\n    if (offsetY === undefined) { offsetY = 0; }\r\n\r\n    var parsedObject = Pick(tiledObject, commonObjectProps);\r\n\r\n    parsedObject.x += offsetX;\r\n    parsedObject.y += offsetY;\r\n\r\n    if (tiledObject.gid)\r\n    {\r\n        //  Object tiles\r\n        var gidInfo = ParseGID(tiledObject.gid);\r\n        parsedObject.gid = gidInfo.gid;\r\n        parsedObject.flippedHorizontal = gidInfo.flippedHorizontal;\r\n        parsedObject.flippedVertical = gidInfo.flippedVertical;\r\n        parsedObject.flippedAntiDiagonal = gidInfo.flippedAntiDiagonal;\r\n    }\r\n    else if (tiledObject.polyline)\r\n    {\r\n        parsedObject.polyline = tiledObject.polyline.map(copyPoints);\r\n    }\r\n    else if (tiledObject.polygon)\r\n    {\r\n        parsedObject.polygon = tiledObject.polygon.map(copyPoints);\r\n    }\r\n    else if (tiledObject.ellipse)\r\n    {\r\n        parsedObject.ellipse = tiledObject.ellipse;\r\n    }\r\n    else if (tiledObject.text)\r\n    {\r\n        parsedObject.text = tiledObject.text;\r\n    }\r\n    else if (tiledObject.point)\r\n    {\r\n        parsedObject.point = true;\r\n    }\r\n    else\r\n    {\r\n        // Otherwise, assume it is a rectangle\r\n        parsedObject.rectangle = true;\r\n    }\r\n\r\n    return parsedObject;\r\n};\r\n\r\nmodule.exports = ParseObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar ParseObject = require('./ParseObject');\r\nvar ObjectLayer = require('../../mapdata/ObjectLayer');\r\nvar CreateGroupLayer = require('./CreateGroupLayer');\r\n\r\n/**\r\n * Parses a Tiled JSON object into an array of ObjectLayer objects.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseObjectLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n *\r\n * @return {array} An array of all object layers in the tilemap as `ObjectLayer`s.\r\n */\r\nvar ParseObjectLayers = function (json)\r\n{\r\n    var objectLayers = [];\r\n\r\n    // State inherited from a parent group\r\n    var groupStack = [];\r\n    var curGroupState = CreateGroupLayer(json);\r\n\r\n    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)\r\n    {\r\n        if (curGroupState.i >= curGroupState.layers.length)\r\n        {\r\n            // Ensure recursion stack is not empty first\r\n            if (groupStack.length < 1)\r\n            {\r\n                console.warn(\r\n                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'\r\n                );\r\n                break;\r\n            }\r\n\r\n            // Return to previous recursive state\r\n            curGroupState = groupStack.pop();\r\n            continue;\r\n        }\r\n\r\n        // Get current layer and advance iterator\r\n        var curo = curGroupState.layers[curGroupState.i];\r\n        curGroupState.i++;\r\n\r\n        // Modify inherited properties\r\n        curo.opacity *= curGroupState.opacity;\r\n        curo.visible = curGroupState.visible && curo.visible;\r\n\r\n        if (curo.type !== 'objectgroup')\r\n        {\r\n            if (curo.type === 'group')\r\n            {\r\n                // Compute next state inherited from group\r\n                var nextGroupState = CreateGroupLayer(json, curo, curGroupState);\r\n\r\n                // Preserve current state before recursing\r\n                groupStack.push(curGroupState);\r\n                curGroupState = nextGroupState;\r\n            }\r\n\r\n            // Skip this layer OR 'recurse' (iterative style) into the group\r\n            continue;\r\n        }\r\n\r\n        curo.name = curGroupState.name + curo.name;\r\n        var offsetX = curGroupState.x + GetFastValue(curo, 'startx', 0) + GetFastValue(curo, 'offsetx', 0);\r\n        var offsetY = curGroupState.y + GetFastValue(curo, 'starty', 0) + GetFastValue(curo, 'offsety', 0);\r\n\r\n        var objects = [];\r\n        for (var j = 0; j < curo.objects.length; j++)\r\n        {\r\n            var parsedObject = ParseObject(curo.objects[j], offsetX, offsetY);\r\n\r\n            objects.push(parsedObject);\r\n        }\r\n\r\n        var objectLayer = new ObjectLayer(curo);\r\n        objectLayer.objects = objects;\r\n\r\n        objectLayers.push(objectLayer);\r\n    }\r\n\r\n    return objectLayers;\r\n};\r\n\r\nmodule.exports = ParseObjectLayers;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Base64Decode = require('./Base64Decode');\r\nvar CONST = require('../../const/ORIENTATION_CONST');\r\nvar CreateGroupLayer = require('./CreateGroupLayer');\r\nvar FromOrientationString = require('../FromOrientationString');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar LayerData = require('../../mapdata/LayerData');\r\nvar ParseGID = require('./ParseGID');\r\nvar Tile = require('../../Tile');\r\n\r\n/**\r\n * Parses all tilemap layers in a Tiled JSON object into new LayerData objects.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseTileLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled (see {@link Phaser.Tilemaps.Parsers.Tiled.ParseJSONTiled}).\r\n *\r\n * @return {Phaser.Tilemaps.LayerData[]} - An array of LayerData objects, one for each entry in\r\n * json.layers with the type 'tilelayer'.\r\n */\r\nvar ParseTileLayers = function (json, insertNull)\r\n{\r\n    var infiniteMap = GetFastValue(json, 'infinite', false);\r\n    var tileLayers = [];\r\n\r\n    // State inherited from a parent group\r\n    var groupStack = [];\r\n    var curGroupState = CreateGroupLayer(json);\r\n\r\n    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)\r\n    {\r\n        if (curGroupState.i >= curGroupState.layers.length)\r\n        {\r\n            // Ensure recursion stack is not empty first\r\n            if (groupStack.length < 1)\r\n            {\r\n                console.warn(\r\n                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'\r\n                );\r\n                break;\r\n            }\r\n\r\n            // Return to previous recursive state\r\n            curGroupState = groupStack.pop();\r\n            continue;\r\n        }\r\n\r\n        var curl = curGroupState.layers[curGroupState.i];\r\n        curGroupState.i++;\r\n\r\n        if (curl.type !== 'tilelayer')\r\n        {\r\n            if (curl.type === 'group')\r\n            {\r\n                // Compute next state inherited from group\r\n                var nextGroupState = CreateGroupLayer(json, curl, curGroupState);\r\n\r\n                // Preserve current state before recursing\r\n                groupStack.push(curGroupState);\r\n                curGroupState = nextGroupState;\r\n            }\r\n\r\n            // Skip this layer OR 'recurse' (iterative style) into the group\r\n            continue;\r\n        }\r\n\r\n        // Base64 decode data if necessary. NOTE: uncompressed base64 only.\r\n        if (curl.compression)\r\n        {\r\n            console.warn(\r\n                'TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer \\''\r\n                + curl.name + '\\''\r\n            );\r\n            continue;\r\n        }\r\n        else if (curl.encoding && curl.encoding === 'base64')\r\n        {\r\n            // Chunks for an infinite map\r\n            if (curl.chunks)\r\n            {\r\n                for (var i = 0; i < curl.chunks.length; i++)\r\n                {\r\n                    curl.chunks[i].data = Base64Decode(curl.chunks[i].data);\r\n                }\r\n            }\r\n\r\n            // Non-infinite map data\r\n            if (curl.data)\r\n            {\r\n                curl.data = Base64Decode(curl.data);\r\n            }\r\n\r\n            delete curl.encoding; // Allow the same map to be parsed multiple times\r\n        }\r\n\r\n        //  This is an array containing the tile indexes, one after the other. -1 = no tile,\r\n        //  everything else = the tile index (starting at 1 for Tiled, 0 for CSV) If the map\r\n        //  contains multiple tilesets then the indexes are relative to that which the set starts\r\n        //  from. Need to set which tileset in the cache = which tileset in the JSON, if you do this\r\n        //  manually it means you can use the same map data but a new tileset.\r\n\r\n        var layerData;\r\n        var gidInfo;\r\n        var tile;\r\n        var blankTile;\r\n\r\n        var output = [];\r\n        var x = 0;\r\n\r\n        if (infiniteMap)\r\n        {\r\n            var layerOffsetX = (GetFastValue(curl, 'startx', 0) + curl.x);\r\n            var layerOffsetY = (GetFastValue(curl, 'starty', 0) + curl.y);\r\n\r\n            layerData = new LayerData({\r\n                name: (curGroupState.name + curl.name),\r\n                x: (curGroupState.x + GetFastValue(curl, 'offsetx', 0) + layerOffsetX * json.tilewidth),\r\n                y: (curGroupState.y + GetFastValue(curl, 'offsety', 0) + layerOffsetY * json.tileheight),\r\n                width: curl.width,\r\n                height: curl.height,\r\n                tileWidth: json.tilewidth,\r\n                tileHeight: json.tileheight,\r\n                alpha: (curGroupState.opacity * curl.opacity),\r\n                visible: (curGroupState.visible && curl.visible),\r\n                properties: GetFastValue(curl, 'properties', []),\r\n                orientation: FromOrientationString(json.orientation)\r\n            });\r\n\r\n            if (layerData.orientation === CONST.HEXAGONAL)\r\n            {\r\n                layerData.hexSideLength = json.hexsidelength;\r\n            }\r\n\r\n            for (var c = 0; c < curl.height; c++)\r\n            {\r\n                output.push([ null ]);\r\n\r\n                for (var j = 0; j < curl.width; j++)\r\n                {\r\n                    output[c][j] = null;\r\n                }\r\n            }\r\n\r\n            for (c = 0, len = curl.chunks.length; c < len; c++)\r\n            {\r\n                var chunk = curl.chunks[c];\r\n\r\n                var offsetX = (chunk.x - layerOffsetX);\r\n                var offsetY = (chunk.y - layerOffsetY);\r\n\r\n                var y = 0;\r\n\r\n                for (var t = 0, len2 = chunk.data.length; t < len2; t++)\r\n                {\r\n                    var newOffsetX = x + offsetX;\r\n                    var newOffsetY = y + offsetY;\r\n\r\n                    gidInfo = ParseGID(chunk.data[t]);\r\n\r\n                    //  index, x, y, width, height\r\n                    if (gidInfo.gid > 0)\r\n                    {\r\n                        tile = new Tile(layerData, gidInfo.gid, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);\r\n\r\n                        // Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal\r\n                        // propeties into flipX, flipY and rotation\r\n                        tile.rotation = gidInfo.rotation;\r\n                        tile.flipX = gidInfo.flipped;\r\n\r\n                        output[newOffsetY][newOffsetX] = tile;\r\n                    }\r\n                    else\r\n                    {\r\n                        blankTile = insertNull\r\n                            ? null\r\n                            : new Tile(layerData, -1, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);\r\n\r\n                        output[newOffsetY][newOffsetX] = blankTile;\r\n                    }\r\n\r\n                    x++;\r\n\r\n                    if (x === chunk.width)\r\n                    {\r\n                        y++;\r\n                        x = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            layerData = new LayerData({\r\n                name: (curGroupState.name + curl.name),\r\n                x: (curGroupState.x + GetFastValue(curl, 'offsetx', 0) + curl.x),\r\n                y: (curGroupState.y + GetFastValue(curl, 'offsety', 0) + curl.y),\r\n                width: curl.width,\r\n                height: curl.height,\r\n                tileWidth: json.tilewidth,\r\n                tileHeight: json.tileheight,\r\n                alpha: (curGroupState.opacity * curl.opacity),\r\n                visible: (curGroupState.visible && curl.visible),\r\n                properties: GetFastValue(curl, 'properties', []),\r\n                orientation: FromOrientationString(json.orientation)\r\n            });\r\n\r\n            if (layerData.orientation === CONST.HEXAGONAL)\r\n            {\r\n                layerData.hexSideLength = json.hexsidelength;\r\n            }\r\n            var row = [];\r\n\r\n            //  Loop through the data field in the JSON.\r\n            for (var k = 0, len = curl.data.length; k < len; k++)\r\n            {\r\n                gidInfo = ParseGID(curl.data[k]);\r\n\r\n                //  index, x, y, width, height\r\n                if (gidInfo.gid > 0)\r\n                {\r\n                    tile = new Tile(layerData, gidInfo.gid, x, output.length, json.tilewidth, json.tileheight);\r\n\r\n                    // Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal\r\n                    // propeties into flipX, flipY and rotation\r\n                    tile.rotation = gidInfo.rotation;\r\n                    tile.flipX = gidInfo.flipped;\r\n\r\n                    row.push(tile);\r\n                }\r\n                else\r\n                {\r\n                    blankTile = insertNull\r\n                        ? null\r\n                        : new Tile(layerData, -1, x, output.length, json.tilewidth, json.tileheight);\r\n                    row.push(blankTile);\r\n                }\r\n\r\n                x++;\r\n\r\n                if (x === curl.width)\r\n                {\r\n                    output.push(row);\r\n                    x = 0;\r\n                    row = [];\r\n                }\r\n            }\r\n        }\r\n\r\n        layerData.data = output;\r\n        tileLayers.push(layerData);\r\n    }\r\n\r\n    return tileLayers;\r\n};\r\n\r\nmodule.exports = ParseTileLayers;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tileset = require('../../Tileset');\r\nvar ImageCollection = require('../../ImageCollection');\r\nvar ParseObject = require('./ParseObject');\r\nvar ParseWangsets = require('./ParseWangsets');\r\n\r\n/**\r\n * Tilesets and Image Collections.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseTilesets\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON data.\r\n *\r\n * @return {object} An object containing the tileset and image collection data.\r\n */\r\nvar ParseTilesets = function (json)\r\n{\r\n    var tilesets = [];\r\n    var imageCollections = [];\r\n    var lastSet = null;\r\n    var stringID;\r\n\r\n    for (var i = 0; i < json.tilesets.length; i++)\r\n    {\r\n        //  name, firstgid, width, height, margin, spacing, properties\r\n        var set = json.tilesets[i];\r\n\r\n        if (set.source)\r\n        {\r\n            console.warn('External tilesets unsupported. Use Embed Tileset and re-export');\r\n        }\r\n        else if (set.image)\r\n        {\r\n            var newSet = new Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing);\r\n\r\n            if (json.version > 1)\r\n            {\r\n                var datas = undefined;\r\n                var props = undefined;\r\n\r\n                if (Array.isArray(set.tiles))\r\n                {\r\n                    datas = datas || {};\r\n                    props = props || {};\r\n\r\n                    // Tiled 1.2+\r\n                    for (var t = 0; t < set.tiles.length; t++)\r\n                    {\r\n                        var tile = set.tiles[t];\r\n\r\n                        //  Convert tileproperties.\r\n                        if (tile.properties)\r\n                        {\r\n                            var newPropData = {};\r\n\r\n                            tile.properties.forEach(function (propData)\r\n                            {\r\n                                newPropData[propData['name']] = propData['value'];\r\n                            });\r\n\r\n                            props[tile.id] = newPropData;\r\n                        }\r\n\r\n                        //  Convert objectgroup\r\n                        if (tile.objectgroup)\r\n                        {\r\n                            (datas[tile.id] || (datas[tile.id] = {})).objectgroup = tile.objectgroup;\r\n\r\n                            if (tile.objectgroup.objects)\r\n                            {\r\n                                var parsedObjects2 = tile.objectgroup.objects.map(function (obj)\r\n                                {\r\n                                    return ParseObject(obj);\r\n                                });\r\n\r\n                                datas[tile.id].objectgroup.objects = parsedObjects2;\r\n                            }\r\n                        }\r\n\r\n                        // Copy animation data\r\n                        if (tile.animation)\r\n                        {\r\n                            (datas[tile.id] || (datas[tile.id] = {})).animation = tile.animation;\r\n                        }\r\n\r\n                        // Copy tile `type` field\r\n                        // (see https://doc.mapeditor.org/en/latest/manual/custom-properties/#typed-tiles).\r\n                        if (tile.type)\r\n                        {\r\n                            (datas[tile.id] || (datas[tile.id] = {})).type = tile.type;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (Array.isArray(set.wangsets))\r\n                {\r\n                    datas = datas || {};\r\n                    props = props || {};\r\n\r\n                    ParseWangsets(set.wangsets, datas);\r\n                }\r\n\r\n                if (datas) // Implies also props is set.\r\n                {\r\n                    newSet.tileData = datas;\r\n                    newSet.tileProperties = props;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // Tiled 1\r\n\r\n                // Properties stored per-tile in object with string indexes starting at \"0\"\r\n                if (set.tileproperties)\r\n                {\r\n                    newSet.tileProperties = set.tileproperties;\r\n                }\r\n\r\n                // Object & terrain shapes stored per-tile in object with string indexes starting at \"0\"\r\n                if (set.tiles)\r\n                {\r\n                    newSet.tileData = set.tiles;\r\n\r\n                    // Parse the objects into Phaser format to match handling of other Tiled objects\r\n                    for (stringID in newSet.tileData)\r\n                    {\r\n                        var objectGroup = newSet.tileData[stringID].objectgroup;\r\n\r\n                        if (objectGroup && objectGroup.objects)\r\n                        {\r\n                            var parsedObjects1 = objectGroup.objects.map(function (obj)\r\n                            {\r\n                                return ParseObject(obj);\r\n                            });\r\n\r\n                            newSet.tileData[stringID].objectgroup.objects = parsedObjects1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // For a normal sliced tileset the row/count/size information is computed when updated.\r\n            // This is done (again) after the image is set.\r\n            newSet.updateTileData(set.imagewidth, set.imageheight);\r\n\r\n            tilesets.push(newSet);\r\n        }\r\n        else\r\n        {\r\n            var newCollection = new ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);\r\n\r\n            var maxId = 0;\r\n\r\n            for (t = 0; t < set.tiles.length; t++)\r\n            {\r\n                tile = set.tiles[t];\r\n\r\n                var image = tile.image;\r\n                var tileId = parseInt(tile.id, 10);\r\n                var gid = set.firstgid + tileId;\r\n                newCollection.addImage(gid, image);\r\n\r\n                maxId = Math.max(tileId, maxId);\r\n            }\r\n\r\n            newCollection.maxId = maxId;\r\n\r\n            imageCollections.push(newCollection);\r\n        }\r\n\r\n        //  We've got a new Tileset, so set the lastgid into the previous one\r\n        if (lastSet)\r\n        {\r\n            lastSet.lastgid = set.firstgid - 1;\r\n        }\r\n\r\n        lastSet = set;\r\n    }\r\n\r\n    return { tilesets: tilesets, imageCollections: imageCollections };\r\n};\r\n\r\nmodule.exports = ParseTilesets;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Parses out the Wangset information from Tiled 1.1.5+ map data, if present.\r\n *\r\n * Since a given tile can be in more than one wangset, the resulting properties\r\n * are nested. `tile.data.wangid[someWangsetName]` will return the array-based wang id in\r\n * this implementation.\r\n *\r\n * Note that we're not guaranteed that there will be any 'normal' tiles if the only\r\n * thing in the tilset are wangtile definitions, so this has to be parsed separately.\r\n *\r\n * See https://doc.mapeditor.org/en/latest/manual/using-wang-tiles/ for more information.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseWangsets\r\n * @since 3.53.0\r\n *\r\n * @param {Array.<object>} wangsets - The array of wangset objects (parsed from JSON)\r\n * @param {object} datas - The field into which to put wangset data from Tiled.\r\n *\r\n * @return {object} An object containing the tileset and image collection data.\r\n */\r\nvar ParseWangsets = function (wangsets, datas)\r\n{\r\n    for (var w = 0; w < wangsets.length; w++)\r\n    {\r\n        var wangset = wangsets[w];\r\n        var identifier = w;\r\n\r\n        if (wangset.name && wangset.name !== '')\r\n        {\r\n            identifier = wangset.name;\r\n        }\r\n\r\n        if (Array.isArray(wangset.wangtiles) && wangset.wangtiles.length > 0)\r\n        {\r\n            var edgeColors = {};\r\n            var cornerColors = {};\r\n\r\n            var c;\r\n            var color;\r\n            var colorIndex;\r\n\r\n            // Tiled before v2020.09.09\r\n            if (Array.isArray(wangset.edgecolors))\r\n            {\r\n                for (c = 0; c < wangset.edgecolors.length; c++)\r\n                {\r\n                    colorIndex = 1 + c;\r\n                    color = wangset.edgecolors[c];\r\n\r\n                    if (color.name !== '')\r\n                    {\r\n                        edgeColors[colorIndex] = color.name;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (Array.isArray(wangset.cornercolors))\r\n            {\r\n                for (c = 0; c < wangset.cornercolors.length; c++)\r\n                {\r\n                    colorIndex = 1 + c;\r\n                    color = wangset.cornercolors[c];\r\n\r\n                    if (color.name !== '')\r\n                    {\r\n                        cornerColors[colorIndex] = color.name;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Tiled after v2020.09.09\r\n            if (Array.isArray(wangset.colors))\r\n            {\r\n                for (c = 0; c < wangset.colors.length; c++)\r\n                {\r\n                    color = wangset.colors[c];\r\n                    colorIndex = 1 + c;\r\n\r\n                    if (color.name !== '')\r\n                    {\r\n                        edgeColors[colorIndex] = cornerColors[colorIndex] = color.name;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // The wangid layout is north, northeast, east, southeast, etc.\r\n            var idLayout = [\r\n                edgeColors, cornerColors, edgeColors, cornerColors,\r\n                edgeColors, cornerColors, edgeColors, cornerColors\r\n            ];\r\n\r\n            for (var t = 0; t < wangset.wangtiles.length; t++)\r\n            {\r\n                var wangtile = wangset.wangtiles[t];\r\n\r\n                var obj = (datas[wangtile.tileid] || (datas[wangtile.tileid] = {}));\r\n\r\n                obj = (obj.wangid || (obj.wangid = {}));\r\n\r\n                var wangid = [];\r\n\r\n                for (var i = 0; i < Math.min(idLayout.length, wangtile.wangid.length); i++)\r\n                {\r\n                    color = wangtile.wangid[i];\r\n\r\n                    if (color === 0)\r\n                    {\r\n                        wangid.push(undefined);\r\n                        continue;\r\n                    }\r\n\r\n                    var renamed = idLayout[i][color];\r\n\r\n                    if (renamed !== undefined)\r\n                    {\r\n                        wangid.push(renamed);\r\n                        continue;\r\n                    }\r\n\r\n                    wangid.push(color);\r\n                }\r\n\r\n                obj[identifier] = wangid;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = ParseWangsets;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Parsers.Tiled\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    AssignTileProperties: require('./AssignTileProperties'),\r\n    Base64Decode: require('./Base64Decode'),\r\n    BuildTilesetIndex: require('./BuildTilesetIndex'),\r\n    CreateGroupLayer: require('./CreateGroupLayer'),\r\n    ParseGID: require('./ParseGID'),\r\n    ParseImageLayers: require('./ParseImageLayers'),\r\n    ParseJSONTiled: require('./ParseJSONTiled'),\r\n    ParseObject: require('./ParseObject'),\r\n    ParseObjectLayers: require('./ParseObjectLayers'),\r\n    ParseTileLayers: require('./ParseTileLayers'),\r\n    ParseTilesets: require('./ParseTilesets')\r\n\r\n};\r\n"],"names":["module","exports","CSV","TILED_JSON","ARRAY_2D","WELTMEISTER","ImageCollection","initialize","name","firstgid","width","height","margin","spacing","properties","undefined","this","imageWidth","imageHeight","imageMargin","imageSpacing","images","total","containsImageIndex","imageIndex","addImage","gid","image","push","Formats","MapData","Parse","Tilemap","scene","key","tileWidth","tileHeight","data","insertNull","mapData","Array","isArray","tilemapData","cache","tilemap","get","format","console","warn","CONST","Class","Components","Rectangle","Tile","Mixins","Alpha","Flip","Visible","layer","index","x","y","baseWidth","baseHeight","right","bottom","pixelX","pixelY","updatePixelXY","rotation","collideLeft","collideRight","collideUp","collideDown","faceLeft","faceRight","faceTop","faceBottom","collisionCallback","collisionCallbackContext","tint","physics","containsPoint","copy","tile","alpha","visible","setFlip","flipX","flipY","getCollisionGroup","tileset","getTileCollisionGroup","getTileData","getLeft","camera","tilemapLayer","tileToWorldX","getRight","scaleX","getTop","tileToWorldY","scaleY","getBottom","getBounds","output","getCenterX","getCenterY","intersects","isInteresting","collides","faces","canCollide","hasInterestingFace","resetCollision","recalculateFaces","calculateFacesAt","resetFaces","setCollision","left","up","down","setCollisionCallback","callback","context","setSize","orientation","ORTHOGONAL","ISOMETRIC","STAGGERED","HEXAGONAL","len","hexSideLength","rowHeight","destroy","gidMap","DegToRad","GetFastValue","LayerData","ORIENTATION","Rotate","SpliceOne","Sprite","TilemapComponents","TilemapLayer","Tileset","renderOrder","version","widthInPixels","heightInPixels","imageCollections","layers","tilesets","objects","currentLayerIndex","_convert","WorldToTileXY","GetWorldToTileXYFunction","WorldToTileX","GetWorldToTileXFunction","WorldToTileY","GetWorldToTileYFunction","TileToWorldXY","GetTileToWorldXYFunction","TileToWorldX","GetTileToWorldXFunction","TileToWorldY","GetTileToWorldYFunction","createBlankDynamicLayer","createBlankLayer","createDynamicLayer","layerID","createLayer","createStaticLayer","setRenderOrder","orders","indexOf","addTilesetImage","tilesetName","tileMargin","tileSpacing","sys","textures","exists","texture","getTilesetIndex","setTileSize","setSpacing","setImage","srcTileX","srcTileY","destTileX","destTileY","getLayer","Copy","getLayerIndex","row","layerData","tileY","tileX","length","displayList","add","getTileLayerNames","join","createFromObjects","objectLayerName","config","results","objectLayer","getObjectLayer","c","obj","singleConfig","id","toConvert","s","classType","container","frame","i","sprite","setName","setPosition","setTexture","displayWidth","displayHeight","offset","originX","originY","angle","flippedHorizontal","flippedVertical","forEach","propData","setData","existing","createFromTiles","indexes","replacements","spriteConfig","CreateFromTiles","fill","Fill","filterObjects","filter","filterTiles","filteringOptions","FilterTiles","findByIndex","findIndex","skip","reverse","FindByIndex","findObject","find","findTile","FindTile","forEachTile","ForEachTile","getImageIndex","getIndex","getImageLayerNames","map","location","getObjectLayerNames","object","getLayerIndexByName","layerIndex","getTileAt","nonNull","GetTileAt","getTileAtWorldXY","worldX","worldY","GetTileAtWorldXY","getTilesWithin","GetTilesWithin","getTilesWithinShape","shape","GetTilesWithinShape","getTilesWithinWorldXY","GetTilesWithinWorldXY","getTileset","hasTileAt","HasTileAt","hasTileAtWorldXY","HasTileAtWorldXY","set","setLayer","putTileAt","PutTileAt","putTileAtWorldXY","PutTileAtWorldXY","putTilesAt","tilesArray","PutTilesAt","randomize","Randomize","CalculateFacesAt","calculateFacesWithin","CalculateFacesWithin","removeLayer","destroyLayer","removeAllLayers","removeTile","tiles","replaceIndex","removed","removeTileAt","replaceWithNull","RemoveTileAt","removeTileAtWorldXY","RemoveTileAtWorldXY","renderDebug","graphics","styleConfig","RenderDebug","renderDebugFull","replaceByIndex","newIndex","ReplaceByIndex","updateLayer","SetCollision","setCollisionBetween","start","stop","SetCollisionBetween","setCollisionByProperty","SetCollisionByProperty","setCollisionByExclusion","SetCollisionByExclusion","setCollisionFromCollisionGroup","SetCollisionFromCollisionGroup","setTileIndexCallback","callbackContext","SetTileIndexCallback","setTileLocationCallback","SetTileLocationCallback","setBaseTileSize","baseTileWidth","baseTileHeight","mapWidth","mapHeight","col","setLayerTileSize","shuffle","Shuffle","swapByIndex","indexA","indexB","SwapByIndex","tileToWorldXY","vec2","weightedRandomize","weightedIndexes","WeightedRandomize","worldToTileX","snapToFloor","worldToTileY","worldToTileXY","GameObjectCreator","ParseToTilemap","register","GameObjectFactory","GameObject","TilemapLayerRender","Extends","BlendMode","ComputedSize","Depth","GetBounds","Origin","Pipeline","Transform","ScrollFactor","call","isTilemap","tilesDrawn","tilesTotal","culledTiles","skipCull","cullPaddingX","cullPaddingY","cullCallback","GetCullTilesFunction","_renderOrder","setTilesets","setAlpha","setOrigin","initPipeline","setList","t","cull","setSkipCull","value","setCullPadding","paddingX","paddingY","point","removeFromTilemap","prototype","TransformMatrix","tempMatrix1","tempMatrix2","tempMatrix3","renderer","src","parentMatrix","renderTiles","tileCount","camMatrix","layerMatrix","calcMatrix","applyITRS","copyFrom","matrix","ctx","currentContext","save","multiplyWithOffset","scrollX","scrollFactorX","scrollY","scrollFactorY","e","f","multiply","copyToContext","antialias","imageSmoothingEnabled","getSourceImage","tileTexCoords","getTileTextureCoordinates","halfWidth","halfHeight","translate","rotate","scale","globalAlpha","drawImage","restore","renderWebGL","renderCanvas","Utils","pipeline","pipelines","getTint","getTintAppendFloatAlpha","sx","sy","preBatch","glTexture","textureUnit","setTexture2D","frameWidth","frameHeight","frameX","frameY","tw","th","batchTexture","postBatch","tileProperties","tileData","rows","columns","texCoordinates","getTileProperties","tileIndex","containsTileIndex","objectgroup","source","updateTileData","rowCount","colCount","Math","floor","tx","ty","above","below","tileCollides","pos","worldView","srcTiles","offsetX","offsetY","cameras","main","sprites","make","SnapCeil","SnapFloor","bounds","tileW","tileH","boundsLeft","boundsRight","boundsTop","boundsBottom","setTo","CullBounds","RunCull","outputArray","top","SetTileCollision","doesIndexCollide","collideIndexes","count","CullTiles","HexagonalCullTiles","IsometricCullTiles","NOOP","StaggeredCullTiles","IsInLayerBounds","HexagonalTileToWorldXY","IsometricTileToWorldXY","StaggeredTileToWorldXY","HexagonalTileToWorldY","StaggeredTileToWorldY","isNotEmpty","isColliding","max","Geom","Intersects","Vector2","TriangleToRectangle","triangle","rect","RectangleToTriangle","pointStart","pointEnd","intersectTest","Circle","CircleToRectangle","RectangleToRectangle","Triangle","Line","LineToRectangle","xStart","yStart","xEnd","ceil","yEnd","tileRect","HexagonalWorldToTileXY","IsometricWorldToTileXY","StaggeredWorldToTileXY","HexagonalWorldToTileY","StaggeredWorldToTileY","rowH","layerWorldX","layerWorldY","CheckIsoBounds","drawRight","drawBottom","oldTile","oldTileCollides","newTile","GetRandom","Color","defaultTileColor","defaultCollidingTileColor","defaultFaceColor","tileColor","collidingTileColor","faceColor","translateCanvas","scaleCanvas","color","fillStyle","fillRect","lineStyle","lineBetween","drawLeft","min","drawTop","SetLayerCollisionIndex","HasValue","property","values","collisionGroup","loc","splice","callbacks","ShuffleArray","weightTotal","weight","rand","random","sum","randomIndex","j","chosen","HexagonalCullBounds","StaggeredCullBounds","Extend","Tilemaps","Parsers","TilemapCreator","TilemapFactory","Orientation","ObjectLayer","bodies","infinite","collision","opacity","propertyTypes","type","toLowerCase","Parse2DArray","ParseCSV","ParseJSONTiled","ParseWeltmeister","mapFormat","newMap","parseInt","isNaN","array2D","trim","split","json","tileLayers","tilesize","tileGrid","tilesetsNames","ParseTileLayers","ParseTilesets","FromOrientationString","Impact","Tiled","sid","k","binaryString","window","atob","bytes","charCodeAt","collection","countX","countY","groupl","parentstate","layerX","tilewidth","layerY","tileheight","Boolean","flippedAntiDiagonal","flipped","PI","CreateGroupLayer","groupStack","curGroupState","pop","curi","layerOffsetX","layerOffsetY","nextGroupState","AssignTileProperties","BuildTilesetIndex","ParseImageLayers","ParseObjectLayers","renderorder","hexsidelength","sets","Pick","ParseGID","copyPoints","p","commonObjectProps","tiledObject","parsedObject","gidInfo","polyline","polygon","ellipse","text","rectangle","ParseObject","objectLayers","curo","Base64Decode","infiniteMap","curl","compression","encoding","chunks","blankTile","chunk","len2","newOffsetX","newOffsetY","ParseWangsets","stringID","lastSet","newSet","datas","props","newPropData","parsedObjects2","animation","wangsets","tileproperties","objectGroup","parsedObjects1","imagewidth","imageheight","newCollection","maxId","tileId","lastgid","w","wangset","identifier","wangtiles","colorIndex","edgeColors","cornerColors","edgecolors","cornercolors","colors","idLayout","wangtile","tileid","wangid","renamed"],"sourceRoot":""}