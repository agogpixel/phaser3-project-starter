{"version":3,"sources":["webpack:///./node_modules/phaser/src/tilemaps/components/IsInLayerBounds.js","webpack:///./node_modules/phaser/src/tilemaps/mapdata/LayerData.js","webpack:///./node_modules/phaser/src/tilemaps/mapdata/MapData.js","webpack:///./node_modules/phaser/src/tilemaps/Tileset.js","webpack:///./node_modules/phaser/src/tilemaps/index.js","webpack:///./node_modules/phaser/src/tilemaps/const/index.js","webpack:///./node_modules/phaser/src/tilemaps/components/Copy.js","webpack:///./node_modules/phaser/src/tilemaps/components/CreateFromTiles.js","webpack:///./node_modules/phaser/src/tilemaps/components/Fill.js","webpack:///./node_modules/phaser/src/tilemaps/components/FilterTiles.js","webpack:///./node_modules/phaser/src/tilemaps/components/FindByIndex.js","webpack:///./node_modules/phaser/src/tilemaps/components/FindTile.js","webpack:///./node_modules/phaser/src/tilemaps/components/ForEachTile.js","webpack:///./node_modules/phaser/src/tilemaps/components/GetCullTilesFunction.js","webpack:///./node_modules/phaser/src/tilemaps/components/GetTileAtWorldXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/GetTilesWithinShape.js","webpack:///./node_modules/phaser/src/tilemaps/components/GetTileToWorldXFunction.js","webpack:///./node_modules/phaser/src/tilemaps/components/GetTileToWorldXYFunction.js","webpack:///./node_modules/phaser/src/tilemaps/components/GetTileToWorldYFunction.js","webpack:///./node_modules/phaser/src/tilemaps/components/GetWorldToTileXFunction.js","webpack:///./node_modules/phaser/src/tilemaps/components/GetWorldToTileXYFunction.js","webpack:///./node_modules/phaser/src/tilemaps/components/GetWorldToTileYFunction.js","webpack:///./node_modules/phaser/src/tilemaps/components/HasTileAtWorldXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/PutTileAtWorldXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/PutTilesAt.js","webpack:///./node_modules/phaser/src/tilemaps/components/Randomize.js","webpack:///./node_modules/phaser/src/tilemaps/components/RemoveTileAtWorldXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/RenderDebug.js","webpack:///./node_modules/phaser/src/tilemaps/components/SetCollision.js","webpack:///./node_modules/phaser/src/tilemaps/components/SetCollisionBetween.js","webpack:///./node_modules/phaser/src/tilemaps/components/SetCollisionByExclusion.js","webpack:///./node_modules/phaser/src/tilemaps/components/SetCollisionByProperty.js","webpack:///./node_modules/phaser/src/tilemaps/components/SetCollisionFromCollisionGroup.js","webpack:///./node_modules/phaser/src/tilemaps/components/SetTileIndexCallback.js","webpack:///./node_modules/phaser/src/tilemaps/components/SetTileLocationCallback.js","webpack:///./node_modules/phaser/src/tilemaps/components/Shuffle.js","webpack:///./node_modules/phaser/src/tilemaps/components/SwapByIndex.js","webpack:///./node_modules/phaser/src/tilemaps/components/WeightedRandomize.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/index.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/ParseWangsets.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/impact/index.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/index.js","webpack:///./node_modules/phaser/src/tilemaps/TilemapLayerRender.js","webpack:///./node_modules/phaser/src/tilemaps/TilemapLayerWebGLRenderer.js","webpack:///./node_modules/phaser/src/tilemaps/TilemapLayerCanvasRenderer.js","webpack:///./node_modules/phaser/src/tilemaps/TilemapCreator.js","webpack:///./node_modules/phaser/src/tilemaps/TilemapFactory.js","webpack:///./node_modules/phaser/src/tilemaps/components/GetTileAt.js","webpack:///./node_modules/phaser/src/tilemaps/components/RunCull.js","webpack:///./node_modules/phaser/src/tilemaps/components/SetLayerCollisionIndex.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/CreateGroupLayer.js","webpack:///./node_modules/phaser/src/gameobjects/sprite/SpriteRender.js","webpack:///./node_modules/phaser/src/gameobjects/sprite/SpriteWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/sprite/SpriteCanvasRenderer.js","webpack:///./node_modules/phaser/src/tilemaps/components/GetTilesWithinWorldXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/GetTilesWithin.js","webpack:///./node_modules/phaser/src/tilemaps/components/index.js","webpack:///./node_modules/phaser/src/tilemaps/components/CalculateFacesAt.js","webpack:///./node_modules/phaser/src/tilemaps/components/TileToWorldX.js","webpack:///./node_modules/phaser/src/tilemaps/components/TileToWorldY.js","webpack:///./node_modules/phaser/src/tilemaps/components/WorldToTileX.js","webpack:///./node_modules/phaser/src/tilemaps/components/WorldToTileY.js","webpack:///./node_modules/phaser/src/tilemaps/components/PutTileAt.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/FromOrientationString.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/Parse2DArray.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/ParseObject.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/ParseGID.js","webpack:///./node_modules/phaser/src/tilemaps/ParseToTilemap.js","webpack:///./node_modules/phaser/src/tilemaps/const/ORIENTATION_CONST.js","webpack:///./node_modules/phaser/src/tilemaps/Formats.js","webpack:///./node_modules/phaser/src/tilemaps/components/CheckIsoBounds.js","webpack:///./node_modules/phaser/src/tilemaps/components/ReplaceByIndex.js","webpack:///./node_modules/phaser/src/tilemaps/components/CullBounds.js","webpack:///./node_modules/phaser/src/tilemaps/components/CullTiles.js","webpack:///./node_modules/phaser/src/tilemaps/components/HexagonalCullTiles.js","webpack:///./node_modules/phaser/src/tilemaps/components/HexagonalCullBounds.js","webpack:///./node_modules/phaser/src/tilemaps/components/IsometricCullTiles.js","webpack:///./node_modules/phaser/src/tilemaps/components/StaggeredCullTiles.js","webpack:///./node_modules/phaser/src/tilemaps/components/StaggeredCullBounds.js","webpack:///./node_modules/phaser/src/tilemaps/components/HexagonalTileToWorldXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/IsometricTileToWorldXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/StaggeredTileToWorldXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/TileToWorldXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/HexagonalTileToWorldY.js","webpack:///./node_modules/phaser/src/tilemaps/components/StaggeredTileToWorldY.js","webpack:///./node_modules/phaser/src/tilemaps/components/HexagonalWorldToTileXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/IsometricWorldToTileXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/StaggeredWorldToTileXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/WorldToTileXY.js","webpack:///./node_modules/phaser/src/tilemaps/components/HexagonalWorldToTileY.js","webpack:///./node_modules/phaser/src/tilemaps/components/StaggeredWorldToTileY.js","webpack:///./node_modules/phaser/src/tilemaps/components/HasTileAt.js","webpack:///./node_modules/phaser/src/tilemaps/components/RemoveTileAt.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/Parse.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/ParseCSV.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/ParseJSONTiled.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/AssignTileProperties.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/BuildTilesetIndex.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/ParseImageLayers.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/ParseObjectLayers.js","webpack:///./node_modules/phaser/src/tilemaps/mapdata/ObjectLayer.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/ParseTileLayers.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/Base64Decode.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/tiled/ParseTilesets.js","webpack:///./node_modules/phaser/src/tilemaps/ImageCollection.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/impact/ParseWeltmeister.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/impact/ParseTileLayers.js","webpack:///./node_modules/phaser/src/tilemaps/parsers/impact/ParseTilesets.js","webpack:///./node_modules/phaser/src/tilemaps/Tilemap.js","webpack:///./node_modules/phaser/src/tilemaps/TilemapLayer.js","webpack:///./node_modules/phaser/src/gameobjects/sprite/Sprite.js","webpack:///./node_modules/phaser/src/tilemaps/components/CalculateFacesWithin.js","webpack:///./node_modules/phaser/src/tilemaps/components/SetTileCollision.js","webpack:///./node_modules/phaser/src/tilemaps/Tile.js"],"names":["module","exports","tileX","tileY","layer","width","height","Class","CONST","GetFastValue","LayerData","initialize","config","undefined","this","name","x","y","tileWidth","tileHeight","baseTileWidth","baseTileHeight","orientation","ORTHOGONAL","widthInPixels","heightInPixels","alpha","visible","properties","indexes","collideIndexes","callbacks","bodies","data","tilemapLayer","hexSideLength","MapData","infinite","format","renderOrder","version","layers","images","objects","collision","tilesets","imageCollections","tiles","Tileset","firstgid","tileMargin","tileSpacing","tileProperties","tileData","image","glTexture","rows","columns","total","texCoordinates","getTileProperties","tileIndex","containsTileIndex","getTileData","getTileCollisionGroup","objectgroup","getTileTextureCoordinates","setImage","texture","get","source","updateTileData","setTileSize","setSpacing","margin","spacing","imageWidth","imageHeight","rowCount","colCount","console","warn","Math","floor","length","tx","ty","push","Extend","Tilemaps","Components","Parsers","Formats","ImageCollection","ParseToTilemap","Tile","Tilemap","TilemapCreator","TilemapFactory","TilemapLayer","Orientation","ObjectLayer","ORIENTATION","GetTilesWithin","CalculateFacesWithin","srcTileX","srcTileY","destTileX","destTileY","recalculateFaces","srcTiles","offsetX","offsetY","i","copy","ReplaceByIndex","replacements","spriteConfig","scene","camera","Array","isArray","cameras","main","sprites","tile","indexOf","index","point","tileToWorldXY","make","sprite","SetTileCollision","doesIndexCollide","callback","context","filteringOptions","filter","findIndex","skip","reverse","count","find","forEach","CullTiles","HexagonalCullTiles","IsometricCullTiles","NOOP","StaggeredCullTiles","HEXAGONAL","STAGGERED","ISOMETRIC","GetTileAt","worldX","worldY","nonNull","worldToTileXY","Geom","Intersects","Vector2","TriangleToRectangle","triangle","rect","RectangleToTriangle","pointStart","pointEnd","shape","intersectTest","Circle","CircleToRectangle","Rectangle","RectangleToRectangle","Triangle","Line","LineToRectangle","left","top","xStart","yStart","right","bottom","xEnd","ceil","yEnd","max","scaleX","scaleY","results","tileRect","TileToWorldX","HexagonalTileToWorldXY","IsometricTileToWorldXY","StaggeredTileToWorldXY","TileToWorldXY","HexagonalTileToWorldY","StaggeredTileToWorldY","TileToWorldY","WorldToTileX","HexagonalWorldToTileXY","IsometricWorldToTileXY","StaggeredWorldToTileXY","WorldToTileXY","HexagonalWorldToTileY","StaggeredWorldToTileY","WorldToTileY","HasTileAt","PutTileAt","tilesArray","GetRandom","RemoveTileAt","replaceWithNull","Color","defaultTileColor","defaultCollidingTileColor","defaultFaceColor","graphics","styleConfig","tileColor","collidingTileColor","faceColor","translateCanvas","scaleCanvas","tw","th","pixelX","pixelY","color","collides","fillStyle","fillRect","lineStyle","faceTop","lineBetween","faceRight","faceBottom","faceLeft","SetLayerCollisionIndex","updateLayer","start","stop","HasValue","property","values","collisionGroup","getCollisionGroup","callbackContext","len","setCollisionCallback","ShuffleArray","map","indexA","indexB","weightedIndexes","weightTotal","weight","rand","random","sum","randomIndex","j","chosen","FromOrientationString","Parse","Parse2DArray","ParseCSV","Impact","Tiled","wangsets","datas","w","wangset","identifier","wangtiles","c","colorIndex","edgeColors","cornerColors","edgecolors","cornercolors","colors","idLayout","t","wangtile","obj","tileid","wangid","min","renamed","ParseTileLayers","ParseTilesets","ParseWeltmeister","AssignTileProperties","Base64Decode","BuildTilesetIndex","CreateGroupLayer","ParseGID","ParseImageLayers","ParseJSONTiled","ParseObject","ParseObjectLayers","renderWebGL","renderCanvas","Utils","renderer","src","renderTiles","cull","tileCount","gidMap","pipeline","pipelines","set","getTint","getTintAppendFloatAlpha","scrollFactorX","scrollFactorY","sx","sy","preBatch","tileset","tileTexCoords","textureUnit","setTexture2D","frameWidth","frameHeight","frameX","frameY","tint","batchTexture","rotation","flipX","flipY","postBatch","TransformMatrix","tempMatrix1","tempMatrix2","tempMatrix3","parentMatrix","camMatrix","layerMatrix","calcMatrix","applyITRS","copyFrom","matrix","ctx","currentContext","save","multiplyWithOffset","scrollX","scrollY","e","f","multiply","copyToContext","antialias","imageSmoothingEnabled","getSourceImage","halfWidth","halfHeight","translate","rotate","scale","globalAlpha","drawImage","restore","GameObjectCreator","register","key","insertNull","GameObjectFactory","IsInLayerBounds","bounds","outputArray","mapData","mapWidth","mapHeight","drawLeft","drawRight","drawTop","drawBottom","tilesDrawn","tilesTotal","loc","splice","json","groupl","parentstate","opacity","layerX","tilewidth","layerY","tileheight","addToRenderList","batchSprite","frame","tilemap","_convert","isNotEmpty","isColliding","hasInterestingFace","CalculateFacesAt","CheckIsoBounds","Copy","CreateFromTiles","CullBounds","Fill","FilterTiles","FindByIndex","FindTile","ForEachTile","GetCullTilesFunction","GetTileAtWorldXY","GetTilesWithinShape","GetTilesWithinWorldXY","GetTileToWorldXFunction","GetTileToWorldXYFunction","GetTileToWorldYFunction","GetWorldToTileXFunction","GetWorldToTileXYFunction","GetWorldToTileYFunction","HasTileAtWorldXY","HexagonalCullBounds","PutTileAtWorldXY","PutTilesAt","Randomize","RemoveTileAtWorldXY","RenderDebug","RunCull","SetCollision","SetCollisionBetween","SetCollisionByExclusion","SetCollisionByProperty","SetCollisionFromCollisionGroup","SetTileIndexCallback","SetTileLocationCallback","Shuffle","StaggeredCullBounds","SwapByIndex","WeightedRandomize","above","below","tileCollides","resetFaces","layerWorldX","layerWorldY","snapToFloor","oldTile","oldTileCollides","newTile","toLowerCase","layerData","ARRAY_2D","row","parseInt","isNaN","Pick","copyPoints","p","commonObjectProps","tiledObject","parsedObject","gid","gidInfo","flippedHorizontal","flippedVertical","flippedAntiDiagonal","polyline","polygon","ellipse","text","rectangle","FLIPPED_HORIZONTAL","FLIPPED_VERTICAL","FLIPPED_ANTI_DIAGONAL","Boolean","flipped","PI","tilemapData","cache","CSV","TILED_JSON","WELTMEISTER","cullPaddingX","cullPaddingY","pos","worldView","newIndex","SnapCeil","SnapFloor","tileW","tileH","boundsLeft","boundsRight","boundsTop","boundsBottom","setTo","skipCull","rowH","rowHeight","mapFormat","newMap","array2D","trim","split","renderorder","hexsidelength","sets","sid","k","collection","countX","countY","groupStack","curGroupState","pop","curi","type","layerOffsetX","layerOffsetY","nextGroupState","objectLayers","curo","objectLayer","propertyTypes","infiniteMap","tileLayers","curl","compression","encoding","chunks","blankTile","output","chunk","len2","newOffsetX","newOffsetY","binaryString","window","atob","bytes","charCodeAt","ParseWangsets","stringID","lastSet","newSet","props","newPropData","propData","id","parsedObjects2","animation","tileproperties","objectGroup","parsedObjects1","imagewidth","imageheight","newCollection","maxId","tileId","addImage","lastgid","imageMargin","imageSpacing","containsImageIndex","imageIndex","tilesize","tileGrid","tilesetsNames","tilesetName","DegToRad","Rotate","SpliceOne","Sprite","TilemapComponents","currentLayerIndex","createBlankDynamicLayer","createBlankLayer","createDynamicLayer","layerID","createLayer","createStaticLayer","setRenderOrder","orders","addTilesetImage","sys","textures","exists","getTilesetIndex","getLayer","getLayerIndex","displayList","add","getTileLayerNames","join","createFromObjects","objectLayerName","getObjectLayer","singleConfig","toConvert","s","classType","container","setName","setPosition","setTexture","displayWidth","displayHeight","offset","originX","originY","angle","setFlip","setData","existing","createFromTiles","fill","filterObjects","filterTiles","findByIndex","findObject","findTile","forEachTile","getImageIndex","getIndex","getImageLayerNames","location","getObjectLayerNames","object","getLayerIndexByName","layerIndex","getTileAt","getTileAtWorldXY","getTilesWithin","getTilesWithinShape","getTilesWithinWorldXY","getTileset","hasTileAt","hasTileAtWorldXY","setLayer","putTileAt","putTileAtWorldXY","putTilesAt","randomize","calculateFacesAt","calculateFacesWithin","removeLayer","destroyLayer","destroy","removeAllLayers","removeTile","replaceIndex","removed","removeTileAt","removeTileAtWorldXY","renderDebug","renderDebugFull","replaceByIndex","setCollision","setCollisionBetween","setCollisionByProperty","setCollisionByExclusion","setCollisionFromCollisionGroup","setTileIndexCallback","setTileLocationCallback","setBaseTileSize","col","setSize","setLayerTileSize","shuffle","swapByIndex","tileToWorldX","tileToWorldY","vec2","weightedRandomize","worldToTileX","worldToTileY","GameObject","TilemapLayerRender","Extends","Mixins","Alpha","BlendMode","ComputedSize","Depth","Flip","GetBounds","Origin","Pipeline","Transform","Visible","ScrollFactor","call","isTilemap","culledTiles","cullCallback","_renderOrder","setTilesets","setAlpha","setOrigin","initPipeline","setList","setSkipCull","value","setCullPadding","paddingX","paddingY","removeFromTilemap","prototype","AnimationState","SpriteRender","Mask","Size","TextureCrop","Tint","_crop","resetCropObject","anims","setSizeToFrame","setOriginFromFrame","addedToScene","updateList","removedFromScene","remove","preUpdate","time","delta","update","play","ignoreIfPlaying","playReverse","playAfterDelay","delay","playAfterRepeat","repeatCount","chain","stopAfterDelay","stopAfterRepeat","stopOnFrame","toJSON","ToJSON","preDestroy","resetCollision","baseWidth","baseHeight","updatePixelXY","collideLeft","collideRight","collideUp","collideDown","collisionCallback","collisionCallbackContext","physics","containsPoint","getLeft","getRight","getTop","getBottom","getBounds","getCenterX","getCenterY","intersects","isInteresting","faces","canCollide","up","down"],"mappings":"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","file":"js/vendors~phaser~tilemaps.02dc9710c9609c88d15a.js","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Checks if the given tile coordinates are within the bounds of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsInLayerBounds\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {boolean} `true` if the tile coordinates are within the bounds of the layer, otherwise `false`.\r\n */\r\nvar IsInLayerBounds = function (tileX, tileY, layer)\r\n{\r\n    return (tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height);\r\n};\r\n\r\nmodule.exports = IsInLayerBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * @classdesc\r\n * A class for representing data about about a layer in a map. Maps are parsed from CSV, Tiled,\r\n * etc. into this format. Tilemap and TilemapLayer objects have a reference\r\n * to this data and use it to look up and perform operations on tiles.\r\n *\r\n * @class LayerData\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Tilemaps.LayerDataConfig} [config] - The Layer Data configuration object.\r\n */\r\nvar LayerData = new Class({\r\n\r\n    initialize:\r\n\r\n    function LayerData (config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        /**\r\n         * The name of the layer, if specified in Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', 'layer');\r\n\r\n        /**\r\n         * The x offset of where to draw from the top left.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.x = GetFastValue(config, 'x', 0);\r\n\r\n        /**\r\n         * The y offset of where to draw from the top left.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.y = GetFastValue(config, 'y', 0);\r\n\r\n        /**\r\n         * The width of the layer in tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = GetFastValue(config, 'width', 0);\r\n\r\n        /**\r\n         * The height of the layer in tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = GetFastValue(config, 'height', 0);\r\n\r\n        /**\r\n         * The pixel width of the tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#tileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = GetFastValue(config, 'tileWidth', 0);\r\n\r\n        /**\r\n         * The pixel height of the tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#tileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = GetFastValue(config, 'tileHeight', 0);\r\n\r\n        /**\r\n         * The base tile width.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#baseTileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseTileWidth = GetFastValue(config, 'baseTileWidth', this.tileWidth);\r\n\r\n        /**\r\n         * The base tile height.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#baseTileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseTileHeight = GetFastValue(config, 'baseTileHeight', this.tileHeight);\r\n\r\n        /**\r\n         * The layers orientation, necessary to be able to determine a tiles pixelX and pixelY as well as the layers width and height.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#orientation\r\n         * @type {Phaser.Tilemaps.OrientationType}\r\n         * @since 3.50.0\r\n         */\r\n        this.orientation = GetFastValue(config, 'orientation', CONST.ORTHOGONAL);\r\n\r\n        /**\r\n         * The width in pixels of the entire layer.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.widthInPixels = GetFastValue(config, 'widthInPixels', this.width * this.baseTileWidth);\r\n\r\n        /**\r\n         * The height in pixels of the entire layer.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.heightInPixels = GetFastValue(config, 'heightInPixels', this.height * this.baseTileHeight);\r\n\r\n        /**\r\n         * The alpha value of the layer.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#alpha\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.alpha = GetFastValue(config, 'alpha', 1);\r\n\r\n        /**\r\n         * Is the layer visible or not?\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#visible\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.visible = GetFastValue(config, 'visible', true);\r\n\r\n        /**\r\n         * Layer specific properties (can be specified in Tiled)\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#properties\r\n         * @type {object[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = GetFastValue(config, 'properties', []);\r\n\r\n        /**\r\n         * Tile ID index map.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#indexes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.indexes = GetFastValue(config, 'indexes', []);\r\n\r\n        /**\r\n         * Tile Collision ID index map.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#collideIndexes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideIndexes = GetFastValue(config, 'collideIndexes', []);\r\n\r\n        /**\r\n         * An array of callbacks.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#callbacks\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.callbacks = GetFastValue(config, 'callbacks', []);\r\n\r\n        /**\r\n         * An array of physics bodies.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#bodies\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.bodies = GetFastValue(config, 'bodies', []);\r\n\r\n        /**\r\n         * An array of the tile data indexes.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#data\r\n         * @type {Phaser.Tilemaps.Tile[][]}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = GetFastValue(config, 'data', []);\r\n\r\n        /**\r\n         * A reference to the Tilemap layer that owns this data.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#tilemapLayer\r\n         * @type {Phaser.Tilemaps.TilemapLayer}\r\n         * @since 3.0.0\r\n         */\r\n        this.tilemapLayer = GetFastValue(config, 'tilemapLayer', null);\r\n\r\n        /**\r\n         * The length of the horizontal sides of the hexagon.\r\n         * Only used for hexagonal orientation Tilemaps.\r\n         *\r\n         * @name Phaser.Tilemaps.LayerData#hexSideLength\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.hexSideLength = GetFastValue(config, 'hexSideLength', 0);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = LayerData;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * @classdesc\r\n * A class for representing data about a map. Maps are parsed from CSV, Tiled, etc. into this\r\n * format. A Tilemap object get a copy of this data and then unpacks the needed properties into\r\n * itself.\r\n *\r\n * @class MapData\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Tilemaps.MapDataConfig} [config] - The Map configuration object.\r\n */\r\nvar MapData = new Class({\r\n\r\n    initialize:\r\n\r\n    function MapData (config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        /**\r\n         * The key in the Phaser cache that corresponds to the loaded tilemap data.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', 'map');\r\n\r\n        /**\r\n         * The width of the entire tilemap.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = GetFastValue(config, 'width', 0);\r\n\r\n        /**\r\n         * The height of the entire tilemap.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = GetFastValue(config, 'height', 0);\r\n\r\n        /**\r\n         * If the map is infinite or not.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#infinite\r\n         * @type {boolean}\r\n         * @since 3.17.0\r\n         */\r\n        this.infinite = GetFastValue(config, 'infinite', false);\r\n\r\n        /**\r\n         * The width of the tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#tileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = GetFastValue(config, 'tileWidth', 0);\r\n\r\n        /**\r\n         * The height of the tiles.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#tileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = GetFastValue(config, 'tileHeight', 0);\r\n\r\n        /**\r\n         * The width in pixels of the entire tilemap.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.widthInPixels = GetFastValue(config, 'widthInPixels', this.width * this.tileWidth);\r\n\r\n        /**\r\n         * The height in pixels of the entire tilemap.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.heightInPixels = GetFastValue(config, 'heightInPixels', this.height * this.tileHeight);\r\n\r\n        /**\r\n         * The format of the map data.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#format\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.format = GetFastValue(config, 'format', null);\r\n\r\n        /**\r\n         * The orientation of the map data (i.e. orthogonal, isometric, hexagonal), default 'orthogonal'.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#orientation\r\n         * @type {Phaser.Tilemaps.OrientationType}\r\n         * @since 3.50.0\r\n         */\r\n        this.orientation = GetFastValue(config, 'orientation', CONST.ORTHOGONAL);\r\n\r\n        /**\r\n         * Determines the draw order of tilemap. Default is right-down\r\n         *\r\n         * 0, or 'right-down'\r\n         * 1, or 'left-down'\r\n         * 2, or 'right-up'\r\n         * 3, or 'left-up'\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#renderOrder\r\n         * @type {string}\r\n         * @since 3.12.0\r\n         */\r\n        this.renderOrder = GetFastValue(config, 'renderOrder', 'right-down');\r\n\r\n        /**\r\n         * The version of the map data (as specified in Tiled).\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#version\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.version = GetFastValue(config, 'version', '1');\r\n\r\n        /**\r\n         * Map specific properties (can be specified in Tiled)\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = GetFastValue(config, 'properties', {});\r\n\r\n        /**\r\n         * An array with all the layers configured to the MapData.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#layers\r\n         * @type {(Phaser.Tilemaps.LayerData[]|Phaser.Tilemaps.ObjectLayer)}\r\n         * @since 3.0.0\r\n         */\r\n        this.layers = GetFastValue(config, 'layers', []);\r\n\r\n        /**\r\n         * An array of Tiled Image Layers.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#images\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.images = GetFastValue(config, 'images', []);\r\n\r\n        /**\r\n         * An object of Tiled Object Layers.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#objects\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.objects = GetFastValue(config, 'objects', {});\r\n\r\n        /**\r\n          * An object of collision data. Must be created as physics object or will return undefined.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#collision\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.collision = GetFastValue(config, 'collision', {});\r\n\r\n        /**\r\n         * An array of Tilesets.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#tilesets\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.tilesets = GetFastValue(config, 'tilesets', []);\r\n\r\n        /**\r\n         * The collection of images the map uses(specified in Tiled)\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#imageCollections\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.imageCollections = GetFastValue(config, 'imageCollections', []);\r\n\r\n        /**\r\n         * An array of tile instances.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#tiles\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.tiles = GetFastValue(config, 'tiles', []);\r\n\r\n        /**\r\n         * The length of the horizontal sides of the hexagon.\r\n         * Only used for hexagonal orientation Tilemaps.\r\n         *\r\n         * @name Phaser.Tilemaps.MapData#hexSideLength\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.hexSideLength = GetFastValue(config, 'hexSideLength', 0);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MapData;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A Tileset is a combination of an image containing the tiles and a container for data about\r\n * each tile.\r\n *\r\n * @class Tileset\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tileset in the map data.\r\n * @param {number} firstgid - The first tile index this tileset contains.\r\n * @param {number} [tileWidth=32] - Width of each tile (in pixels).\r\n * @param {number} [tileHeight=32] - Height of each tile (in pixels).\r\n * @param {number} [tileMargin=0] - The margin around all tiles in the sheet (in pixels).\r\n * @param {number} [tileSpacing=0] - The spacing between each tile in the sheet (in pixels).\r\n * @param {object} [tileProperties={}] - Custom properties defined per tile in the Tileset.\r\n * These typically are custom properties created in Tiled when editing a tileset.\r\n * @param {object} [tileData={}] - Data stored per tile. These typically are created in Tiled\r\n * when editing a tileset, e.g. from Tiled's tile collision editor or terrain editor.\r\n */\r\nvar Tileset = new Class({\r\n\r\n    initialize:\r\n\r\n    function Tileset (name, firstgid, tileWidth, tileHeight, tileMargin, tileSpacing, tileProperties, tileData)\r\n    {\r\n        if (tileWidth === undefined || tileWidth <= 0) { tileWidth = 32; }\r\n        if (tileHeight === undefined || tileHeight <= 0) { tileHeight = 32; }\r\n        if (tileMargin === undefined) { tileMargin = 0; }\r\n        if (tileSpacing === undefined) { tileSpacing = 0; }\r\n        if (tileProperties === undefined) { tileProperties = {}; }\r\n        if (tileData === undefined) { tileData = {}; }\r\n\r\n        /**\r\n         * The name of the Tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = name;\r\n\r\n        /**\r\n         * The starting index of the first tile index this Tileset contains.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#firstgid\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.firstgid = firstgid;\r\n\r\n        /**\r\n         * The width of each tile (in pixels). Use setTileSize to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileWidth\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = tileWidth;\r\n\r\n        /**\r\n         * The height of each tile (in pixels). Use setTileSize to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileHeight\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = tileHeight;\r\n\r\n        /**\r\n         * The margin around the tiles in the sheet (in pixels). Use `setSpacing` to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileMargin\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.tileMargin = tileMargin;\r\n\r\n        /**\r\n         * The spacing between each the tile in the sheet (in pixels). Use `setSpacing` to change.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileSpacing\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.tileSpacing = tileSpacing;\r\n\r\n        /**\r\n         * Tileset-specific properties per tile that are typically defined in the Tiled editor in the\r\n         * Tileset editor.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileProperties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileProperties = tileProperties;\r\n\r\n        /**\r\n         * Tileset-specific data per tile that are typically defined in the Tiled editor, e.g. within\r\n         * the Tileset collision editor. This is where collision objects and terrain are stored.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#tileData\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileData = tileData;\r\n\r\n        /**\r\n         * The cached image that contains the individual tiles. Use setImage to set.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#image\r\n         * @type {?Phaser.Textures.Texture}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.image = null;\r\n\r\n        /**\r\n         * The gl texture used by the WebGL renderer.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#glTexture\r\n         * @type {?WebGLTexture}\r\n         * @readonly\r\n         * @since 3.11.0\r\n         */\r\n        this.glTexture = null;\r\n\r\n        /**\r\n         * The number of tile rows in the the tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#rows\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.rows = 0;\r\n\r\n        /**\r\n         * The number of tile columns in the tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#columns\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.columns = 0;\r\n\r\n        /**\r\n         * The total number of tiles in the tileset.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#total\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.total = 0;\r\n\r\n        /**\r\n         * The look-up table to specific tile image texture coordinates (UV in pixels). Each element\r\n         * contains the coordinates for a tile in an object of the form {x, y}.\r\n         *\r\n         * @name Phaser.Tilemaps.Tileset#texCoordinates\r\n         * @type {object[]}\r\n         * @readonly\r\n         * @since 3.0.0\r\n        */\r\n        this.texCoordinates = [];\r\n    },\r\n\r\n    /**\r\n     * Get a tiles properties that are stored in the Tileset. Returns null if tile index is not\r\n     * contained in this Tileset. This is typically defined in Tiled under the Tileset editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileProperties\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?(object|undefined)}\r\n     */\r\n    getTileProperties: function (tileIndex)\r\n    {\r\n        if (!this.containsTileIndex(tileIndex)) { return null; }\r\n\r\n        return this.tileProperties[tileIndex - this.firstgid];\r\n    },\r\n\r\n    /**\r\n     * Get a tile's data that is stored in the Tileset. Returns null if tile index is not contained\r\n     * in this Tileset. This is typically defined in Tiled and will contain both Tileset collision\r\n     * info and terrain mapping.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?object|undefined}\r\n     */\r\n    getTileData: function (tileIndex)\r\n    {\r\n        if (!this.containsTileIndex(tileIndex)) { return null; }\r\n\r\n        return this.tileData[tileIndex - this.firstgid];\r\n    },\r\n\r\n    /**\r\n     * Get a tile's collision group that is stored in the Tileset. Returns null if tile index is not\r\n     * contained in this Tileset. This is typically defined within Tiled's tileset collision editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?object}\r\n     */\r\n    getTileCollisionGroup: function (tileIndex)\r\n    {\r\n        var data = this.getTileData(tileIndex);\r\n\r\n        return (data && data.objectgroup) ? data.objectgroup : null;\r\n    },\r\n\r\n    /**\r\n     * Returns true if and only if this Tileset contains the given tile index.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#containsTileIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    containsTileIndex: function (tileIndex)\r\n    {\r\n        return (\r\n            tileIndex >= this.firstgid &&\r\n            tileIndex < (this.firstgid + this.total)\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Returns the texture coordinates (UV in pixels) in the Tileset image for the given tile index.\r\n     * Returns null if tile index is not contained in this Tileset.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#getTileTextureCoordinates\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileIndex - The unique id of the tile across all tilesets in the map.\r\n     *\r\n     * @return {?object} Object in the form { x, y } representing the top-left UV coordinate\r\n     * within the Tileset image.\r\n     */\r\n    getTileTextureCoordinates: function (tileIndex)\r\n    {\r\n        if (!this.containsTileIndex(tileIndex)) { return null; }\r\n\r\n        return this.texCoordinates[tileIndex - this.firstgid];\r\n    },\r\n\r\n    /**\r\n     * Sets the image associated with this Tileset and updates the tile data (rows, columns, etc.).\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#setImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Textures.Texture} texture - The image that contains the tiles.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */\r\n    setImage: function (texture)\r\n    {\r\n        this.image = texture;\r\n\r\n        this.glTexture = texture.get().source.glTexture;\r\n\r\n        this.updateTileData(this.image.source[0].width, this.image.source[0].height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tile width & height and updates the tile data (rows, columns, etc.).\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#setTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileWidth] - The width of a tile in pixels.\r\n     * @param {number} [tileHeight] - The height of a tile in pixels.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */\r\n    setTileSize: function (tileWidth, tileHeight)\r\n    {\r\n        if (tileWidth !== undefined) { this.tileWidth = tileWidth; }\r\n        if (tileHeight !== undefined) { this.tileHeight = tileHeight; }\r\n\r\n        if (this.image)\r\n        {\r\n            this.updateTileData(this.image.source[0].width, this.image.source[0].height);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tile margin & spacing and updates the tile data (rows, columns, etc.).\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#setSpacing\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [margin] - The margin around the tiles in the sheet (in pixels).\r\n     * @param {number} [spacing] - The spacing between the tiles in the sheet (in pixels).\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */\r\n    setSpacing: function (margin, spacing)\r\n    {\r\n        if (margin !== undefined) { this.tileMargin = margin; }\r\n        if (spacing !== undefined) { this.tileSpacing = spacing; }\r\n\r\n        if (this.image)\r\n        {\r\n            this.updateTileData(this.image.source[0].width, this.image.source[0].height);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates tile texture coordinates and tileset data.\r\n     *\r\n     * @method Phaser.Tilemaps.Tileset#updateTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} imageWidth - The (expected) width of the image to slice.\r\n     * @param {number} imageHeight - The (expected) height of the image to slice.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tileset} This Tileset object.\r\n     */\r\n    updateTileData: function (imageWidth, imageHeight)\r\n    {\r\n        var rowCount = (imageHeight - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing);\r\n        var colCount = (imageWidth - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing);\r\n\r\n        if (rowCount % 1 !== 0 || colCount % 1 !== 0)\r\n        {\r\n            console.warn('Image tile area not tile size multiple in: ' + this.name);\r\n        }\r\n\r\n        // In Tiled a tileset image that is not an even multiple of the tile dimensions is truncated\r\n        // - hence the floor when calculating the rows/columns.\r\n        rowCount = Math.floor(rowCount);\r\n        colCount = Math.floor(colCount);\r\n\r\n        this.rows = rowCount;\r\n        this.columns = colCount;\r\n\r\n        // In Tiled, \"empty\" spaces in a tileset count as tiles and hence count towards the gid\r\n        this.total = rowCount * colCount;\r\n\r\n        this.texCoordinates.length = 0;\r\n\r\n        var tx = this.tileMargin;\r\n        var ty = this.tileMargin;\r\n\r\n        for (var y = 0; y < this.rows; y++)\r\n        {\r\n            for (var x = 0; x < this.columns; x++)\r\n            {\r\n                this.texCoordinates.push({ x: tx, y: ty });\r\n                tx += this.tileWidth + this.tileSpacing;\r\n            }\r\n\r\n            tx = this.tileMargin;\r\n            ty += this.tileHeight + this.tileSpacing;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Tileset;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Extend = require('../utils/object/Extend');\r\nvar CONST = require('./const');\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps\r\n *\r\n * @borrows Phaser.Tilemaps.Orientation.ORTHOGONAL as ORTHOGONAL\r\n * @borrows Phaser.Tilemaps.Orientation.ISOMETRIC as ISOMETRIC\r\n * @borrows Phaser.Tilemaps.Orientation.STAGGERED as STAGGERED\r\n * @borrows Phaser.Tilemaps.Orientation.HEXAGONAL as HEXAGONAL\r\n */\r\n\r\nvar Tilemaps = {\r\n\r\n    Components: require('./components'),\r\n    Parsers: require('./parsers'),\r\n\r\n    Formats: require('./Formats'),\r\n    ImageCollection: require('./ImageCollection'),\r\n    ParseToTilemap: require('./ParseToTilemap'),\r\n    Tile: require('./Tile'),\r\n    Tilemap: require('./Tilemap'),\r\n    TilemapCreator: require('./TilemapCreator'),\r\n    TilemapFactory: require('./TilemapFactory'),\r\n    Tileset: require('./Tileset'),\r\n    TilemapLayer: require('./TilemapLayer'),\r\n    Orientation: require('./const/ORIENTATION_CONST'),\r\n\r\n    LayerData: require('./mapdata/LayerData'),\r\n    MapData: require('./mapdata/MapData'),\r\n    ObjectLayer: require('./mapdata/ObjectLayer')\r\n\r\n};\r\n\r\nTilemaps = Extend(false, Tilemaps, CONST.ORIENTATION);\r\n\r\nmodule.exports = Tilemaps;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = {\r\n\r\n    ORIENTATION: require('./ORIENTATION_CONST')\r\n\r\n};\r\n\r\nmodule.exports = CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\n\r\n/**\r\n * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n * information in the destination region.\r\n *\r\n * @function Phaser.Tilemaps.Components.Copy\r\n * @since 3.0.0\r\n *\r\n * @param {number} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.\r\n * @param {number} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.\r\n * @param {number} width - The width of the area to copy, in tiles, not pixels.\r\n * @param {number} height - The height of the area to copy, in tiles, not pixels.\r\n * @param {number} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.\r\n * @param {number} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar Copy = function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer)\r\n{\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (srcTileX < 0) { srcTileX = 0; }\r\n    if (srcTileY < 0) { srcTileY = 0; }\r\n\r\n    var srcTiles = GetTilesWithin(srcTileX, srcTileY, width, height, null, layer);\r\n\r\n    var offsetX = destTileX - srcTileX;\r\n    var offsetY = destTileY - srcTileY;\r\n\r\n    for (var i = 0; i < srcTiles.length; i++)\r\n    {\r\n        var tileX = srcTiles[i].x + offsetX;\r\n        var tileY = srcTiles[i].y + offsetY;\r\n\r\n        if (tileX >= 0 && tileX < layer.width && tileY >= 0 && tileY < layer.height)\r\n        {\r\n            if (layer.data[tileY][tileX])\r\n            {\r\n                layer.data[tileY][tileX].copy(srcTiles[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        // Recalculate the faces within the destination area and neighboring tiles\r\n        CalculateFacesWithin(destTileX - 1, destTileY - 1, width + 2, height + 2, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = Copy;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar ReplaceByIndex = require('./ReplaceByIndex');\r\n\r\n/**\r\n * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n *\r\n * @function Phaser.Tilemaps.Components.CreateFromTiles\r\n * @since 3.0.0\r\n *\r\n * @param {(number|number[])} indexes - The tile index, or array of indexes, to create Sprites from.\r\n * @param {(number|number[])} replacements - The tile index, or array of indexes, to change a converted tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a one-to-one mapping with the indexes array.\r\n * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e. scene.make.sprite).\r\n * @param {Phaser.Scene} scene - The Scene to create the Sprites within.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when determining the world XY\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n */\r\nvar CreateFromTiles = function (indexes, replacements, spriteConfig, scene, camera, layer)\r\n{\r\n    if (!spriteConfig) { spriteConfig = {}; }\r\n\r\n    if (!Array.isArray(indexes))\r\n    {\r\n        indexes = [ indexes ];\r\n    }\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (!scene) { scene = tilemapLayer.scene; }\r\n    if (!camera) { camera = scene.cameras.main; }\r\n\r\n    var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);\r\n    var sprites = [];\r\n    var i;\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        if (indexes.indexOf(tile.index) !== -1)\r\n        {\r\n            var point = tilemapLayer.tileToWorldXY(tile.x, tile.y, undefined, camera,layer);\r\n\r\n            spriteConfig.x = point.x;\r\n            spriteConfig.y = point.y;\r\n\r\n            sprites.push(scene.make.sprite(spriteConfig));\r\n        }\r\n    }\r\n\r\n    if (typeof replacements === 'number')\r\n    {\r\n        //  Assume 1 replacement for all types of tile given\r\n        for (i = 0; i < indexes.length; i++)\r\n        {\r\n            ReplaceByIndex(indexes[i], replacements, 0, 0, layer.width, layer.height, layer);\r\n        }\r\n    }\r\n    else if (Array.isArray(replacements))\r\n    {\r\n        //  Assume 1 to 1 mapping with indexes array\r\n        for (i = 0; i < indexes.length; i++)\r\n        {\r\n            ReplaceByIndex(indexes[i], replacements[i], 0, 0, layer.width, layer.height, layer);\r\n        }\r\n    }\r\n\r\n    return sprites;\r\n};\r\n\r\nmodule.exports = CreateFromTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar SetTileCollision = require('./SetTileCollision');\r\n\r\n/**\r\n * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n * Collision information in the region will be recalculated.\r\n *\r\n * @function Phaser.Tilemaps.Components.Fill\r\n * @since 3.0.0\r\n *\r\n * @param {number} index - The tile index to fill the area with.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The tile layer to use. If not given the current layer is used.\r\n */\r\nvar Fill = function (index, tileX, tileY, width, height, recalculateFaces, layer)\r\n{\r\n    var doesIndexCollide = (layer.collideIndexes.indexOf(index) !== -1);\r\n\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].index = index;\r\n\r\n        SetTileCollision(tiles[i], doesIndexCollide);\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        // Recalculate the faces within the area and neighboring tiles\r\n        CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = Fill;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n *\r\n * @function Phaser.Tilemaps.Components.FilterTiles\r\n * @since 3.0.0\r\n *\r\n * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n * filter.\r\n * @param {object} context - The context under which the callback should be run.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} The filtered array of Tiles.\r\n */\r\nvar FilterTiles = function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n    return tiles.filter(callback, context);\r\n};\r\n\r\nmodule.exports = FilterTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n * the top-left.\r\n *\r\n * @function Phaser.Tilemaps.Components.FindByIndex\r\n * @since 3.0.0\r\n *\r\n * @param {number} index - The tile index value to search for.\r\n * @param {number} skip - The number of times to skip a matching tile before returning.\r\n * @param {boolean} reverse - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?Phaser.Tilemaps.Tile} The first (or n skipped) tile with the matching index.\r\n */\r\nvar FindByIndex = function (findIndex, skip, reverse, layer)\r\n{\r\n    if (skip === undefined) { skip = 0; }\r\n    if (reverse === undefined) { reverse = false; }\r\n\r\n    var count = 0;\r\n    var tx;\r\n    var ty;\r\n    var tile;\r\n\r\n    if (reverse)\r\n    {\r\n        for (ty = layer.height - 1; ty >= 0; ty--)\r\n        {\r\n            for (tx = layer.width - 1; tx >= 0; tx--)\r\n            {\r\n                tile = layer.data[ty][tx];\r\n                if (tile && tile.index === findIndex)\r\n                {\r\n                    if (count === skip)\r\n                    {\r\n                        return tile;\r\n                    }\r\n                    else\r\n                    {\r\n                        count += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (ty = 0; ty < layer.height; ty++)\r\n        {\r\n            for (tx = 0; tx < layer.width; tx++)\r\n            {\r\n                tile = layer.data[ty][tx];\r\n                if (tile && tile.index === findIndex)\r\n                {\r\n                    if (count === skip)\r\n                    {\r\n                        return tile;\r\n                    }\r\n                    else\r\n                    {\r\n                        count += 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nmodule.exports = FindByIndex;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * @callback FindTileCallback\r\n *\r\n * @param {Phaser.Tilemaps.Tile} value - The Tile.\r\n * @param {number} index - The index of the tile.\r\n * @param {Phaser.Tilemaps.Tile[]} array - An array of Tile objects.\r\n *\r\n * @return {boolean} Return `true` if the callback should run, otherwise `false`.\r\n */\r\n\r\n/**\r\n * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n * true. Similar to Array.prototype.find in vanilla JS.\r\n *\r\n * @function Phaser.Tilemaps.Components.FindTile\r\n * @since 3.0.0\r\n *\r\n * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n * @param {object} context - The context under which the callback should be run.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?Phaser.Tilemaps.Tile} A Tile that matches the search, or null if no Tile found\r\n */\r\nvar FindTile = function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n    return tiles.find(callback, context) || null;\r\n};\r\n\r\nmodule.exports = FindTile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * @callback EachTileCallback\r\n *\r\n * @param {Phaser.Tilemaps.Tile} value - The Tile.\r\n * @param {number} index - The index of the tile.\r\n * @param {Phaser.Tilemaps.Tile[]} array - An array of Tile objects.\r\n */\r\n\r\n/**\r\n * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n *\r\n * @function Phaser.Tilemaps.Components.ForEachTile\r\n * @since 3.0.0\r\n *\r\n * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n * @param {object} context - The context under which the callback should be run.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar ForEachTile = function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n    tiles.forEach(callback, context);\r\n};\r\n\r\nmodule.exports = ForEachTile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar CullTiles = require('./CullTiles');\r\nvar HexagonalCullTiles = require('./HexagonalCullTiles');\r\nvar IsometricCullTiles = require('./IsometricCullTiles');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredCullTiles = require('./StaggeredCullTiles');\r\n\r\n/**\r\n * Gets the correct function to use to cull tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetCullTilesFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to cull tiles for the given map type.\r\n */\r\nvar GetCullTilesFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return CullTiles;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalCullTiles;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredCullTiles;\r\n    }\r\n    else if (orientation === CONST.ISOMETRIC)\r\n    {\r\n        return IsometricCullTiles;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetCullTilesFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTileAt = require('./GetTileAt');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Gets a tile at the given world coordinates from the given layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - X position to get the tile from (given in pixels)\r\n * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n * @param {boolean} nonNull - If true, function won't return null for empty tiles, but a Tile object with an index of -1.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n */\r\nvar GetTileAtWorldXY = function (worldX, worldY, nonNull, camera, layer)\r\n{\r\n    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);\r\n\r\n    return GetTileAt(point.x, point.y, nonNull, layer);\r\n};\r\n\r\nmodule.exports = GetTileAtWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Geom = require('../../geom/');\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar Intersects = require('../../geom/intersects/');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar TriangleToRectangle = function (triangle, rect)\r\n{\r\n    return Intersects.RectangleToTriangle(rect, triangle);\r\n};\r\n\r\nvar point = new Vector2();\r\nvar pointStart = new Vector2();\r\nvar pointEnd = new Vector2();\r\n\r\n/**\r\n * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithinShape\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithinShape = function (shape, filteringOptions, camera, layer)\r\n{\r\n    if (shape === undefined) { return []; }\r\n\r\n    // intersectTest is a function with parameters: shape, rect\r\n    var intersectTest = NOOP;\r\n\r\n    if (shape instanceof Geom.Circle)\r\n    {\r\n        intersectTest = Intersects.CircleToRectangle;\r\n    }\r\n    else if (shape instanceof Geom.Rectangle)\r\n    {\r\n        intersectTest = Intersects.RectangleToRectangle;\r\n    }\r\n    else if (shape instanceof Geom.Triangle)\r\n    {\r\n        intersectTest = TriangleToRectangle;\r\n    }\r\n    else if (shape instanceof Geom.Line)\r\n    {\r\n        intersectTest = Intersects.LineToRectangle;\r\n    }\r\n\r\n    // Top left corner of the shapes's bounding box, rounded down to include partial tiles\r\n    layer.tilemapLayer.worldToTileXY(shape.left, shape.top, true, pointStart, camera);\r\n\r\n    var xStart = pointStart.x;\r\n    var yStart = pointStart.y;\r\n\r\n    // Bottom right corner of the shapes's bounding box, rounded up to include partial tiles\r\n    layer.tilemapLayer.worldToTileXY(shape.right, shape.bottom, true, pointEnd, camera);\r\n\r\n    var xEnd = Math.ceil(pointEnd.x);\r\n    var yEnd = Math.ceil(pointEnd.y);\r\n\r\n    // Tiles within bounding rectangle of shape. Bounds are forced to be at least 1 x 1 tile in size\r\n    // to grab tiles for shapes that don't have a height or width (e.g. a horizontal line).\r\n    var width = Math.max(xEnd - xStart, 1);\r\n    var height = Math.max(yEnd - yStart, 1);\r\n\r\n    var tiles = GetTilesWithin(xStart, yStart, width, height, filteringOptions, layer);\r\n\r\n    var tileWidth = layer.tileWidth;\r\n    var tileHeight = layer.tileHeight;\r\n\r\n    if (layer.tilemapLayer)\r\n    {\r\n        tileWidth *= layer.tilemapLayer.scaleX;\r\n        tileHeight *= layer.tilemapLayer.scaleY;\r\n    }\r\n\r\n    var results = [];\r\n    var tileRect = new Geom.Rectangle(0, 0, tileWidth, tileHeight);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        layer.tilemapLayer.tileToWorldXY(tile.x, tile.y, point, camera);\r\n\r\n        tileRect.x = point.x;\r\n        tileRect.y = point.y;\r\n\r\n        if (intersectTest(shape, tileRect))\r\n        {\r\n            results.push(tile);\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n\r\nmodule.exports = GetTilesWithinShape;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar TileToWorldX = require('./TileToWorldX');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileToWorldXFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetTileToWorldXFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return TileToWorldX;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetTileToWorldXFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar HexagonalTileToWorldXY = require('./HexagonalTileToWorldXY');\r\nvar IsometricTileToWorldXY = require('./IsometricTileToWorldXY');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredTileToWorldXY = require('./StaggeredTileToWorldXY');\r\nvar TileToWorldXY = require('./TileToWorldXY');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileToWorldXYFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetTileToWorldXYFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return TileToWorldXY;\r\n    }\r\n    else if (orientation === CONST.ISOMETRIC)\r\n    {\r\n        return IsometricTileToWorldXY;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalTileToWorldXY;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredTileToWorldXY;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetTileToWorldXYFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar HexagonalTileToWorldY = require('./HexagonalTileToWorldY');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredTileToWorldY = require('./StaggeredTileToWorldY');\r\nvar TileToWorldY = require('./TileToWorldY');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileToWorldYFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetTileToWorldYFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return TileToWorldY;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalTileToWorldY;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredTileToWorldY;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetTileToWorldYFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar WorldToTileX = require('./WorldToTileX');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetWorldToTileXFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetWorldToTileXFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return WorldToTileX;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetWorldToTileXFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar HexagonalWorldToTileXY = require('./HexagonalWorldToTileXY');\r\nvar IsometricWorldToTileXY = require('./IsometricWorldToTileXY');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredWorldToTileXY = require('./StaggeredWorldToTileXY');\r\nvar WorldToTileXY = require('./WorldToTileXY');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetWorldToTileXYFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetWorldToTileXYFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return WorldToTileXY;\r\n    }\r\n    else if (orientation === CONST.ISOMETRIC)\r\n    {\r\n        return IsometricWorldToTileXY;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalWorldToTileXY;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredWorldToTileXY;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetWorldToTileXYFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\nvar HexagonalWorldToTileY = require('./HexagonalWorldToTileY');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar StaggeredWorldToTileY = require('./StaggeredWorldToTileY');\r\nvar WorldToTileY = require('./WorldToTileY');\r\n\r\n/**\r\n * Gets the correct function to use to translate tiles, based on the map orientation.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetWorldToTileYFunction\r\n * @since 3.50.0\r\n *\r\n * @param {number} orientation - The Tilemap orientation constant.\r\n *\r\n * @return {function} The function to use to translate tiles for the given map type.\r\n */\r\nvar GetWorldToTileYFunction = function (orientation)\r\n{\r\n    if (orientation === CONST.ORTHOGONAL)\r\n    {\r\n        return WorldToTileY;\r\n    }\r\n    else if (orientation === CONST.HEXAGONAL)\r\n    {\r\n        return HexagonalWorldToTileY;\r\n    }\r\n    else if (orientation === CONST.STAGGERED)\r\n    {\r\n        return StaggeredWorldToTileY;\r\n    }\r\n    else\r\n    {\r\n        return NOOP;\r\n    }\r\n};\r\n\r\nmodule.exports = GetWorldToTileYFunction;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar HasTileAt = require('./HasTileAt');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n * false if there is no tile or if the tile at that location has an index of -1.\r\n *\r\n * @function Phaser.Tilemaps.Components.HasTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The X coordinate of the world position.\r\n * @param {number} worldY - The Y coordinate of the world position.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when factoring in which tiles to return.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n */\r\nvar HasTileAtWorldXY = function (worldX, worldY, camera, layer)\r\n{\r\n    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera);\r\n\r\n    var tileX = point.x;\r\n    var tileY = point.y;\r\n\r\n    return HasTileAt(tileX, tileY, layer);\r\n};\r\n\r\nmodule.exports = HasTileAtWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PutTileAt = require('./PutTileAt');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n * specified location. If you pass in an index, only the index at the specified location will be\r\n * changed. Collision information will be recalculated at the specified location.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {number} worldX - The x coordinate, in pixels.\r\n * @param {number} worldY - The y coordinate, in pixels.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was created or added to this map.\r\n */\r\nvar PutTileAtWorldXY = function (tile, worldX, worldY, recalculateFaces, camera, layer)\r\n{\r\n    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);\r\n\r\n    return PutTileAt(tile, point.x, point.y, recalculateFaces, layer);\r\n};\r\n\r\nmodule.exports = PutTileAtWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar PutTileAt = require('./PutTileAt');\r\n\r\n/**\r\n * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n * index at the specified location will be changed. Collision information will be recalculated\r\n * within the region tiles were changed.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTilesAt\r\n * @since 3.0.0\r\n *\r\n * @param {(number[]|number[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar PutTilesAt = function (tilesArray, tileX, tileY, recalculateFaces, layer)\r\n{\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (!Array.isArray(tilesArray))\r\n    {\r\n        return null;\r\n    }\r\n\r\n    // Force the input array to be a 2D array\r\n    if (!Array.isArray(tilesArray[0]))\r\n    {\r\n        tilesArray = [ tilesArray ];\r\n    }\r\n\r\n    var height = tilesArray.length;\r\n    var width = tilesArray[0].length;\r\n\r\n    for (var ty = 0; ty < height; ty++)\r\n    {\r\n        for (var tx = 0; tx < width; tx++)\r\n        {\r\n            var tile = tilesArray[ty][tx];\r\n\r\n            PutTileAt(tile, tileX + tx, tileY + ty, false, layer);\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        // Recalculate the faces within the destination area and neighboring tiles\r\n        CalculateFacesWithin(tileX - 1, tileY - 1, width + 2, height + 2, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = PutTilesAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar GetRandom = require('../../utils/array/GetRandom');\r\n\r\n/**\r\n * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n * indexes. This method only modifies tile indexes and does not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.Randomize\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {number[]} indexes - An array of indexes to randomly draw from during randomization.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar Randomize = function (tileX, tileY, width, height, indexes, layer)\r\n{\r\n    var i;\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, {}, layer);\r\n\r\n    // If no indices are given, then find all the unique indexes within the specified region\r\n    if (!indexes)\r\n    {\r\n        indexes = [];\r\n\r\n        for (i = 0; i < tiles.length; i++)\r\n        {\r\n            if (indexes.indexOf(tiles[i].index) === -1)\r\n            {\r\n                indexes.push(tiles[i].index);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].index = GetRandom(indexes);\r\n    }\r\n};\r\n\r\nmodule.exports = Randomize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RemoveTileAt = require('./RemoveTileAt');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Removes the tile at the given world coordinates in the specified layer and updates the layer's\r\n * collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.RemoveTileAtWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The x coordinate, in pixels.\r\n * @param {number} worldY - The y coordinate, in pixels.\r\n * @param {boolean} replaceWithNull - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was removed.\r\n */\r\nvar RemoveTileAtWorldXY = function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer)\r\n{\r\n    layer.tilemapLayer.worldToTileXY(worldX, worldY, true, point, camera, layer);\r\n\r\n    return RemoveTileAt(point.x, point.y, replaceWithNull, recalculateFaces, layer);\r\n};\r\n\r\nmodule.exports = RemoveTileAtWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar Color = require('../../display/color');\r\n\r\nvar defaultTileColor = new Color(105, 210, 231, 150);\r\nvar defaultCollidingTileColor = new Color(243, 134, 48, 200);\r\nvar defaultFaceColor = new Color(40, 39, 37, 150);\r\n\r\n/**\r\n * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to\r\n * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n * wherever you want on the screen.\r\n *\r\n * @function Phaser.Tilemaps.Components.RenderDebug\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n * @param {Phaser.Types.Tilemaps.DebugStyleOptions} styleConfig - An object specifying the colors to use for the debug drawing.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar RenderDebug = function (graphics, styleConfig, layer)\r\n{\r\n    if (styleConfig === undefined) { styleConfig = {}; }\r\n\r\n    // Default colors without needlessly creating Color objects\r\n    var tileColor = (styleConfig.tileColor !== undefined) ? styleConfig.tileColor : defaultTileColor;\r\n    var collidingTileColor = (styleConfig.collidingTileColor !== undefined) ? styleConfig.collidingTileColor : defaultCollidingTileColor;\r\n    var faceColor = (styleConfig.faceColor !== undefined) ? styleConfig.faceColor : defaultFaceColor;\r\n\r\n    var tiles = GetTilesWithin(0, 0, layer.width, layer.height, null, layer);\r\n\r\n    graphics.translateCanvas(layer.tilemapLayer.x, layer.tilemapLayer.y);\r\n    graphics.scaleCanvas(layer.tilemapLayer.scaleX, layer.tilemapLayer.scaleY);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        var tw = tile.width;\r\n        var th = tile.height;\r\n        var x = tile.pixelX;\r\n        var y = tile.pixelY;\r\n\r\n        var color = tile.collides ? collidingTileColor : tileColor;\r\n\r\n        if (color !== null)\r\n        {\r\n            graphics.fillStyle(color.color, color.alpha / 255);\r\n            graphics.fillRect(x, y, tw, th);\r\n        }\r\n\r\n        // Inset the face line to prevent neighboring tile's lines from overlapping\r\n        x += 1;\r\n        y += 1;\r\n        tw -= 2;\r\n        th -= 2;\r\n\r\n        if (faceColor !== null)\r\n        {\r\n            graphics.lineStyle(1, faceColor.color, faceColor.alpha / 255);\r\n\r\n            if (tile.faceTop) { graphics.lineBetween(x, y, x + tw, y); }\r\n            if (tile.faceRight) { graphics.lineBetween(x + tw, y, x + tw, y + th); }\r\n            if (tile.faceBottom) { graphics.lineBetween(x, y + th, x + tw, y + th); }\r\n            if (tile.faceLeft) { graphics.lineBetween(x, y, x, y + th); }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = RenderDebug;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar SetLayerCollisionIndex = require('./SetLayerCollisionIndex');\r\n\r\n/**\r\n * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n * collision will be enabled (true) or disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollision\r\n * @since 3.0.0\r\n *\r\n * @param {(number|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n */\r\nvar SetCollision = function (indexes, collides, recalculateFaces, layer, updateLayer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n    if (updateLayer === undefined) { updateLayer = true; }\r\n\r\n    if (!Array.isArray(indexes))\r\n    {\r\n        indexes = [ indexes ];\r\n    }\r\n\r\n    // Update the array of colliding indexes\r\n    for (var i = 0; i < indexes.length; i++)\r\n    {\r\n        SetLayerCollisionIndex(indexes[i], collides, layer);\r\n    }\r\n\r\n    // Update the tiles\r\n    if (updateLayer)\r\n    {\r\n        for (var ty = 0; ty < layer.height; ty++)\r\n        {\r\n            for (var tx = 0; tx < layer.width; tx++)\r\n            {\r\n                var tile = layer.data[ty][tx];\r\n\r\n                if (tile && indexes.indexOf(tile.index) !== -1)\r\n                {\r\n                    SetTileCollision(tile, collides);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollision;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar SetLayerCollisionIndex = require('./SetLayerCollisionIndex');\r\n\r\n/**\r\n * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n * enabled (true) or disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionBetween\r\n * @since 3.0.0\r\n *\r\n * @param {number} start - The first index of the tile to be set for collision.\r\n * @param {number} stop - The last index of the tile to be set for collision.\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n */\r\nvar SetCollisionBetween = function (start, stop, collides, recalculateFaces, layer, updateLayer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n    if (updateLayer === undefined) { updateLayer = true; }\r\n\r\n    if (start > stop)\r\n    {\r\n        return;\r\n    }\r\n\r\n    //  Update the array of colliding indexes\r\n    for (var index = start; index <= stop; index++)\r\n    {\r\n        SetLayerCollisionIndex(index, collides, layer);\r\n    }\r\n\r\n    //  Update the tiles\r\n    if (updateLayer)\r\n    {\r\n        for (var ty = 0; ty < layer.height; ty++)\r\n        {\r\n            for (var tx = 0; tx < layer.width; tx++)\r\n            {\r\n                var tile = layer.data[ty][tx];\r\n\r\n                if (tile)\r\n                {\r\n                    if (tile.index >= start && tile.index <= stop)\r\n                    {\r\n                        SetTileCollision(tile, collides);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollisionBetween;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar SetLayerCollisionIndex = require('./SetLayerCollisionIndex');\r\n\r\n/**\r\n * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n * disabled (false). Tile indexes not currently in the layer are not affected.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionByExclusion\r\n * @since 3.0.0\r\n *\r\n * @param {number[]} indexes - An array of the tile indexes to not be counted for collision.\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetCollisionByExclusion = function (indexes, collides, recalculateFaces, layer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (!Array.isArray(indexes))\r\n    {\r\n        indexes = [ indexes ];\r\n    }\r\n\r\n    // Note: this only updates layer.collideIndexes for tile indexes found currently in the layer\r\n    for (var ty = 0; ty < layer.height; ty++)\r\n    {\r\n        for (var tx = 0; tx < layer.width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (tile && indexes.indexOf(tile.index) === -1)\r\n            {\r\n                SetTileCollision(tile, collides);\r\n                SetLayerCollisionIndex(tile.index, collides, layer);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollisionByExclusion;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\nvar HasValue = require('../../utils/object/HasValue');\r\n\r\n/**\r\n * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n * that matches the given properties object, its collision flag will be set. The `collides`\r\n * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n * \"types\" property that matches any of those values, its collision flag will be updated.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionByProperty\r\n * @since 3.0.0\r\n *\r\n * @param {object} properties - An object with tile properties and corresponding values that should be checked.\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetCollisionByProperty = function (properties, collides, recalculateFaces, layer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    for (var ty = 0; ty < layer.height; ty++)\r\n    {\r\n        for (var tx = 0; tx < layer.width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (!tile) { continue; }\r\n\r\n            for (var property in properties)\r\n            {\r\n                if (!HasValue(tile.properties, property)) { continue; }\r\n\r\n                var values = properties[property];\r\n\r\n                if (!Array.isArray(values))\r\n                {\r\n                    values = [ values ];\r\n                }\r\n\r\n                for (var i = 0; i < values.length; i++)\r\n                {\r\n                    if (tile.properties[property] === values[i])\r\n                    {\r\n                        SetTileCollision(tile, collides);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollisionByProperty;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTileCollision = require('./SetTileCollision');\r\nvar CalculateFacesWithin = require('./CalculateFacesWithin');\r\n\r\n/**\r\n * Sets collision on the tiles within a layer by checking each tile's collision group data\r\n * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n * a tile's collision group, the tile's colliding information will be set. The `collides` parameter\r\n * controls if collision will be enabled (true) or disabled (false).\r\n *\r\n * @function Phaser.Tilemaps.Components.SetCollisionFromCollisionGroup\r\n * @since 3.0.0\r\n *\r\n * @param {boolean} collides - If true it will enable collision. If false it will clear collision.\r\n * @param {boolean} recalculateFaces - Whether or not to recalculate the tile faces after the update.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetCollisionFromCollisionGroup = function (collides, recalculateFaces, layer)\r\n{\r\n    if (collides === undefined) { collides = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    for (var ty = 0; ty < layer.height; ty++)\r\n    {\r\n        for (var tx = 0; tx < layer.width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (!tile) { continue; }\r\n\r\n            var collisionGroup = tile.getCollisionGroup();\r\n\r\n            // It's possible in Tiled to have a collision group without any shapes, e.g. create a\r\n            // shape and then delete the shape.\r\n            if (collisionGroup && collisionGroup.objects && collisionGroup.objects.length > 0)\r\n            {\r\n                SetTileCollision(tile, collides);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (recalculateFaces)\r\n    {\r\n        CalculateFacesWithin(0, 0, layer.width, layer.height, layer);\r\n    }\r\n};\r\n\r\nmodule.exports = SetCollisionFromCollisionGroup;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n * at a specific location on the map then see setTileLocationCallback.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetTileIndexCallback\r\n * @since 3.0.0\r\n *\r\n * @param {(number|array)} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for.\r\n * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n * @param {object} callbackContext - The context under which the callback is called.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetTileIndexCallback = function (indexes, callback, callbackContext, layer)\r\n{\r\n    if (typeof indexes === 'number')\r\n    {\r\n        layer.callbacks[indexes] = (callback !== null)\r\n            ? { callback: callback, callbackContext: callbackContext }\r\n            : undefined;\r\n    }\r\n    else\r\n    {\r\n        for (var i = 0, len = indexes.length; i < len; i++)\r\n        {\r\n            layer.callbacks[indexes[i]] = (callback !== null)\r\n                ? { callback: callback, callbackContext: callbackContext }\r\n                : undefined;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = SetTileIndexCallback;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n * remove it.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetTileLocationCallback\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n * @param {object} callbackContext - The context under which the callback is called.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetTileLocationCallback = function (tileX, tileY, width, height, callback, callbackContext, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].setCollisionCallback(callback, callbackContext);\r\n    }\r\n};\r\n\r\nmodule.exports = SetTileLocationCallback;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar ShuffleArray = require('../../utils/array/Shuffle');\r\n\r\n/**\r\n * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n * appear to have changed! This method only modifies tile indexes and does not change collision\r\n * information.\r\n *\r\n * @function Phaser.Tilemaps.Components.Shuffle\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar Shuffle = function (tileX, tileY, width, height, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    var indexes = tiles.map(function (tile) { return tile.index; });\r\n\r\n    ShuffleArray(indexes);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        tiles[i].index = indexes[i];\r\n    }\r\n};\r\n\r\nmodule.exports = Shuffle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n * information.\r\n *\r\n * @function Phaser.Tilemaps.Components.SwapByIndex\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileA - First tile index.\r\n * @param {number} tileB - Second tile index.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SwapByIndex = function (indexA, indexB, tileX, tileY, width, height, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        if (tiles[i])\r\n        {\r\n            if (tiles[i].index === indexA)\r\n            {\r\n                tiles[i].index = indexB;\r\n            }\r\n            else if (tiles[i].index === indexB)\r\n            {\r\n                tiles[i].index = indexA;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = SwapByIndex;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n * weightedIndexes array. An example weighted array:\r\n *\r\n * [\r\n *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n * ]\r\n *\r\n * The probability of any index being choose is (the index's weight) / (sum of all weights). This\r\n * method only modifies tile indexes and does not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.WeightedRandomize\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {object[]} weightedIndexes - An array of objects to randomly draw from during\r\n * randomization. They should be in the form: { index: 0, weight: 4 } or\r\n * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar WeightedRandomize = function (tileX, tileY, width, height, weightedIndexes, layer)\r\n{\r\n    if (!weightedIndexes) { return; }\r\n\r\n    var i;\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    var weightTotal = 0;\r\n\r\n    for (i = 0; i < weightedIndexes.length; i++)\r\n    {\r\n        weightTotal += weightedIndexes[i].weight;\r\n    }\r\n\r\n    if (weightTotal <= 0) { return; }\r\n\r\n    for (i = 0; i < tiles.length; i++)\r\n    {\r\n        var rand = Math.random() * weightTotal;\r\n        var sum = 0;\r\n        var randomIndex = -1;\r\n\r\n        for (var j = 0; j < weightedIndexes.length; j++)\r\n        {\r\n            sum += weightedIndexes[j].weight;\r\n\r\n            if (rand <= sum)\r\n            {\r\n                var chosen = weightedIndexes[j].index;\r\n\r\n                randomIndex = Array.isArray(chosen)\r\n                    ? chosen[Math.floor(Math.random() * chosen.length)]\r\n                    : chosen;\r\n                break;\r\n            }\r\n        }\r\n\r\n        tiles[i].index = randomIndex;\r\n    }\r\n};\r\n\r\nmodule.exports = WeightedRandomize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Parsers\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    FromOrientationString: require('./FromOrientationString'),\r\n    Parse: require('./Parse'),\r\n    Parse2DArray: require('./Parse2DArray'),\r\n    ParseCSV: require('./ParseCSV'),\r\n\r\n    Impact: require('./impact/'),\r\n    Tiled: require('./tiled/')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Parses out the Wangset information from Tiled 1.1.5+ map data, if present.\r\n *\r\n * Since a given tile can be in more than one wangset, the resulting properties\r\n * are nested. `tile.data.wangid[someWangsetName]` will return the array-based wang id in\r\n * this implementation.\r\n *\r\n * Note that we're not guaranteed that there will be any 'normal' tiles if the only\r\n * thing in the tilset are wangtile definitions, so this has to be parsed separately.\r\n *\r\n * See https://doc.mapeditor.org/en/latest/manual/using-wang-tiles/ for more information.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseWangsets\r\n * @since 3.53.0\r\n *\r\n * @param {Array.<object>} wangsets - The array of wangset objects (parsed from JSON)\r\n * @param {object} datas - The field into which to put wangset data from Tiled.\r\n *\r\n * @return {object} An object containing the tileset and image collection data.\r\n */\r\nvar ParseWangsets = function (wangsets, datas)\r\n{\r\n    for (var w = 0; w < wangsets.length; w++)\r\n    {\r\n        var wangset = wangsets[w];\r\n        var identifier = w;\r\n\r\n        if (wangset.name && wangset.name !== '')\r\n        {\r\n            identifier = wangset.name;\r\n        }\r\n\r\n        if (Array.isArray(wangset.wangtiles) && wangset.wangtiles.length > 0)\r\n        {\r\n            var edgeColors = {};\r\n            var cornerColors = {};\r\n\r\n            var c;\r\n            var color;\r\n            var colorIndex;\r\n\r\n            // Tiled before v2020.09.09\r\n            if (Array.isArray(wangset.edgecolors))\r\n            {\r\n                for (c = 0; c < wangset.edgecolors.length; c++)\r\n                {\r\n                    colorIndex = 1 + c;\r\n                    color = wangset.edgecolors[c];\r\n\r\n                    if (color.name !== '')\r\n                    {\r\n                        edgeColors[colorIndex] = color.name;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (Array.isArray(wangset.cornercolors))\r\n            {\r\n                for (c = 0; c < wangset.cornercolors.length; c++)\r\n                {\r\n                    colorIndex = 1 + c;\r\n                    color = wangset.cornercolors[c];\r\n\r\n                    if (color.name !== '')\r\n                    {\r\n                        cornerColors[colorIndex] = color.name;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Tiled after v2020.09.09\r\n            if (Array.isArray(wangset.colors))\r\n            {\r\n                for (c = 0; c < wangset.colors.length; c++)\r\n                {\r\n                    color = wangset.colors[c];\r\n                    colorIndex = 1 + c;\r\n\r\n                    if (color.name !== '')\r\n                    {\r\n                        edgeColors[colorIndex] = cornerColors[colorIndex] = color.name;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // The wangid layout is north, northeast, east, southeast, etc.\r\n            var idLayout = [\r\n                edgeColors, cornerColors, edgeColors, cornerColors,\r\n                edgeColors, cornerColors, edgeColors, cornerColors\r\n            ];\r\n\r\n            for (var t = 0; t < wangset.wangtiles.length; t++)\r\n            {\r\n                var wangtile = wangset.wangtiles[t];\r\n\r\n                var obj = (datas[wangtile.tileid] || (datas[wangtile.tileid] = {}));\r\n\r\n                obj = (obj.wangid || (obj.wangid = {}));\r\n\r\n                var wangid = [];\r\n\r\n                for (var i = 0; i < Math.min(idLayout.length, wangtile.wangid.length); i++)\r\n                {\r\n                    color = wangtile.wangid[i];\r\n\r\n                    if (color === 0)\r\n                    {\r\n                        wangid.push(undefined);\r\n                        continue;\r\n                    }\r\n\r\n                    var renamed = idLayout[i][color];\r\n\r\n                    if (renamed !== undefined)\r\n                    {\r\n                        wangid.push(renamed);\r\n                        continue;\r\n                    }\r\n\r\n                    wangid.push(color);\r\n                }\r\n\r\n                obj[identifier] = wangid;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = ParseWangsets;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Parsers.Impact\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ParseTileLayers: require('./ParseTileLayers'),\r\n    ParseTilesets: require('./ParseTilesets'),\r\n    ParseWeltmeister: require('./ParseWeltmeister')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Parsers.Tiled\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    AssignTileProperties: require('./AssignTileProperties'),\r\n    Base64Decode: require('./Base64Decode'),\r\n    BuildTilesetIndex: require('./BuildTilesetIndex'),\r\n    CreateGroupLayer: require('./CreateGroupLayer'),\r\n    ParseGID: require('./ParseGID'),\r\n    ParseImageLayers: require('./ParseImageLayers'),\r\n    ParseJSONTiled: require('./ParseJSONTiled'),\r\n    ParseObject: require('./ParseObject'),\r\n    ParseObjectLayers: require('./ParseObjectLayers'),\r\n    ParseTileLayers: require('./ParseTileLayers'),\r\n    ParseTilesets: require('./ParseTilesets')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../utils/NOOP');\r\nvar renderCanvas = require('../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./TilemapLayerWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./TilemapLayerCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.Tilemaps.TilemapLayer#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.Tilemaps.TilemapLayer} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */\r\nvar TilemapLayerWebGLRenderer = function (renderer, src, camera)\r\n{\r\n    var renderTiles = src.cull(camera);\r\n\r\n    var tileCount = renderTiles.length;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (tileCount === 0 || alpha <= 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var gidMap = src.gidMap;\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    var scrollFactorX = src.scrollFactorX;\r\n    var scrollFactorY = src.scrollFactorY;\r\n\r\n    var x = src.x;\r\n    var y = src.y;\r\n\r\n    var sx = src.scaleX;\r\n    var sy = src.scaleY;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    for (var i = 0; i < tileCount; i++)\r\n    {\r\n        var tile = renderTiles[i];\r\n\r\n        var tileset = gidMap[tile.index];\r\n\r\n        if (!tileset)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);\r\n\r\n        if (tileTexCoords === null)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var texture = tileset.glTexture;\r\n\r\n        var textureUnit = pipeline.setTexture2D(texture, src);\r\n\r\n        var frameWidth = tileset.tileWidth;\r\n        var frameHeight = tileset.tileHeight;\r\n\r\n        var frameX = tileTexCoords.x;\r\n        var frameY = tileTexCoords.y;\r\n\r\n        var tw = tileset.tileWidth * 0.5;\r\n        var th = tileset.tileHeight * 0.5;\r\n\r\n        var tint = getTint(tile.tint, alpha * tile.alpha);\r\n\r\n        pipeline.batchTexture(\r\n            src,\r\n            texture,\r\n            texture.width, texture.height,\r\n            x + ((tw + tile.pixelX) * sx), y + ((th + tile.pixelY) * sy),\r\n            tile.width, tile.height,\r\n            sx, sy,\r\n            tile.rotation,\r\n            tile.flipX, tile.flipY,\r\n            scrollFactorX, scrollFactorY,\r\n            tw, th,\r\n            frameX, frameY, frameWidth, frameHeight,\r\n            tint, tint, tint, tint, false,\r\n            0, 0,\r\n            camera,\r\n            null,\r\n            true,\r\n            textureUnit\r\n        );\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = TilemapLayerWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TransformMatrix = require('../gameobjects/components/TransformMatrix');\r\n\r\nvar tempMatrix1 = new TransformMatrix();\r\nvar tempMatrix2 = new TransformMatrix();\r\nvar tempMatrix3 = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.Tilemaps.TilemapLayer#renderCanvas\r\n * @since 3.50.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.Tilemaps.TilemapLayer} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TilemapLayerCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var renderTiles = src.cull(camera);\r\n\r\n    var tileCount = renderTiles.length;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (tileCount === 0 || alpha <= 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var camMatrix = tempMatrix1;\r\n    var layerMatrix = tempMatrix2;\r\n    var calcMatrix = tempMatrix3;\r\n\r\n    layerMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);\r\n\r\n    camMatrix.copyFrom(camera.matrix);\r\n\r\n    var ctx = renderer.currentContext;\r\n    var gidMap = src.gidMap;\r\n\r\n    ctx.save();\r\n\r\n    if (parentMatrix)\r\n    {\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        layerMatrix.e = src.x;\r\n        layerMatrix.f = src.y;\r\n\r\n        //  Multiply by the Sprite matrix, store result in calcMatrix\r\n        camMatrix.multiply(layerMatrix, calcMatrix);\r\n\r\n        calcMatrix.copyToContext(ctx);\r\n    }\r\n    else\r\n    {\r\n        layerMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        layerMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        layerMatrix.copyToContext(ctx);\r\n    }\r\n\r\n    if (!renderer.antialias || src.scaleX > 1 || src.scaleY > 1)\r\n    {\r\n        ctx.imageSmoothingEnabled = false;\r\n    }\r\n\r\n    for (var i = 0; i < tileCount; i++)\r\n    {\r\n        var tile = renderTiles[i];\r\n\r\n        var tileset = gidMap[tile.index];\r\n\r\n        if (!tileset)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var image = tileset.image.getSourceImage();\r\n\r\n        var tileTexCoords = tileset.getTileTextureCoordinates(tile.index);\r\n\r\n        if (tileTexCoords === null)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var tileWidth = tileset.tileWidth;\r\n        var tileHeight = tileset.tileHeight;\r\n\r\n        var halfWidth = tileWidth * 0.5;\r\n        var halfHeight = tileHeight * 0.5;\r\n\r\n        ctx.save();\r\n\r\n        ctx.translate(tile.pixelX + halfWidth, tile.pixelY + halfHeight);\r\n\r\n        if (tile.rotation !== 0)\r\n        {\r\n            ctx.rotate(tile.rotation);\r\n        }\r\n\r\n        if (tile.flipX || tile.flipY)\r\n        {\r\n            ctx.scale((tile.flipX) ? -1 : 1, (tile.flipY) ? -1 : 1);\r\n        }\r\n\r\n        ctx.globalAlpha = alpha * tile.alpha;\r\n\r\n        ctx.drawImage(\r\n            image,\r\n            tileTexCoords.x, tileTexCoords.y,\r\n            tileWidth , tileHeight,\r\n            -halfWidth, -halfHeight,\r\n            tileWidth, tileHeight\r\n        );\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = TilemapLayerCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectCreator = require('../gameobjects/GameObjectCreator');\r\nvar ParseToTilemap = require('./ParseToTilemap');\r\n\r\n/**\r\n * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.\r\n * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing\r\n * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map\r\n * data. For an empty map, you should specify tileWidth, tileHeight, width & height.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#tilemap\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Types.Tilemaps.TilemapConfig} [config] - The config options for the Tilemap.\r\n * \r\n * @return {Phaser.Tilemaps.Tilemap}\r\n */\r\nGameObjectCreator.register('tilemap', function (config)\r\n{\r\n    // Defaults are applied in ParseToTilemap\r\n    var c = (config !== undefined) ? config : {};\r\n\r\n    return ParseToTilemap(\r\n        this.scene,\r\n        c.key,\r\n        c.tileWidth,\r\n        c.tileHeight,\r\n        c.width,\r\n        c.height,\r\n        c.data,\r\n        c.insertNull\r\n    );\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../gameobjects/GameObjectFactory');\r\nvar ParseToTilemap = require('./ParseToTilemap');\r\n\r\n/**\r\n * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.\r\n * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing\r\n * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map\r\n * data. For an empty map, you should specify tileWidth, tileHeight, width & height.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#tilemap\r\n * @since 3.0.0\r\n *\r\n * @param {string} [key] - The key in the Phaser cache that corresponds to the loaded tilemap data.\r\n * @param {number} [tileWidth=32] - The width of a tile in pixels. Pass in `null` to leave as the\r\n * default.\r\n * @param {number} [tileHeight=32] - The height of a tile in pixels. Pass in `null` to leave as the\r\n * default.\r\n * @param {number} [width=10] - The width of the map in tiles. Pass in `null` to leave as the\r\n * default.\r\n * @param {number} [height=10] - The height of the map in tiles. Pass in `null` to leave as the\r\n * default.\r\n * @param {number[][]} [data] - Instead of loading from the cache, you can also load directly from\r\n * a 2D array of tile indexes. Pass in `null` for no data.\r\n * @param {boolean} [insertNull=false] - Controls how empty tiles, tiles with an index of -1, in the\r\n * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n * \r\n * @return {Phaser.Tilemaps.Tilemap}\r\n */\r\nGameObjectFactory.register('tilemap', function (key, tileWidth, tileHeight, width, height, data, insertNull)\r\n{\r\n    // Allow users to specify null to indicate that they want the default value, since null is\r\n    // shorter & more legible than undefined. Convert null to undefined to allow ParseToTilemap\r\n    // defaults to take effect.\r\n\r\n    if (key === null) { key = undefined; }\r\n    if (tileWidth === null) { tileWidth = undefined; }\r\n    if (tileHeight === null) { tileHeight = undefined; }\r\n    if (width === null) { width = undefined; }\r\n    if (height === null) { height = undefined; }\r\n\r\n    return ParseToTilemap(this.scene, key, tileWidth, tileHeight, width, height, data, insertNull);\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\n\r\n/**\r\n * Gets a tile at the given tile coordinates from the given layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - X position to get the tile from (given in tile units, not pixels).\r\n * @param {number} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n * @param {boolean} nonNull - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n */\r\nvar GetTileAt = function (tileX, tileY, nonNull, layer)\r\n{\r\n    if (nonNull === undefined) { nonNull = false; }\r\n\r\n    if (IsInLayerBounds(tileX, tileY, layer))\r\n    {\r\n        var tile = layer.data[tileY][tileX] || null;\r\n\r\n        if (!tile)\r\n        {\r\n            return null;\r\n        }\r\n        else if (tile.index === -1)\r\n        {\r\n            return nonNull ? tile : null;\r\n        }\r\n        else\r\n        {\r\n            return tile;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        return null;\r\n    }\r\n};\r\n\r\nmodule.exports = GetTileAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.RunCull\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {object} bounds - An object containing the `left`, `right`, `top` and `bottom` bounds.\r\n * @param {number} renderOrder - The rendering order constant.\r\n * @param {array} outputArray - The array to store the Tile objects within.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar RunCull = function (layer, bounds, renderOrder, outputArray)\r\n{\r\n    var mapData = layer.data;\r\n    var mapWidth = layer.width;\r\n    var mapHeight = layer.height;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var drawLeft = Math.max(0, bounds.left);\r\n    var drawRight = Math.min(mapWidth, bounds.right);\r\n    var drawTop = Math.max(0, bounds.top);\r\n    var drawBottom = Math.min(mapHeight, bounds.bottom);\r\n\r\n    var x;\r\n    var y;\r\n    var tile;\r\n\r\n    if (renderOrder === 0)\r\n    {\r\n        //  right-down\r\n\r\n        for (y = drawTop; y < drawBottom; y++)\r\n        {\r\n            for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n    else if (renderOrder === 1)\r\n    {\r\n        //  left-down\r\n\r\n        for (y = drawTop; y < drawBottom; y++)\r\n        {\r\n            for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n    else if (renderOrder === 2)\r\n    {\r\n        //  right-up\r\n\r\n        for (y = drawBottom; y >= drawTop; y--)\r\n        {\r\n            for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n    else if (renderOrder === 3)\r\n    {\r\n        //  left-up\r\n\r\n        for (y = drawBottom; y >= drawTop; y--)\r\n        {\r\n            for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n            {\r\n                tile = mapData[y][x];\r\n\r\n                if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                outputArray.push(tile);\r\n            }\r\n        }\r\n    }\r\n\r\n    tilemapLayer.tilesDrawn = outputArray.length;\r\n    tilemapLayer.tilesTotal = mapWidth * mapHeight;\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = RunCull;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Internally used method to keep track of the tile indexes that collide within a layer. This\r\n * updates LayerData.collideIndexes to either contain or not contain the given `tileIndex`.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetLayerCollisionIndex\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileIndex - The tile index to set the collision boolean for.\r\n * @param {boolean} collides - Should the tile index collide or not?\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar SetLayerCollisionIndex = function (tileIndex, collides, layer)\r\n{\r\n    var loc = layer.collideIndexes.indexOf(tileIndex);\r\n\r\n    if (collides && loc === -1)\r\n    {\r\n        layer.collideIndexes.push(tileIndex);\r\n    }\r\n    else if (!collides && loc !== -1)\r\n    {\r\n        layer.collideIndexes.splice(loc, 1);\r\n    }\r\n};\r\n\r\nmodule.exports = SetLayerCollisionIndex;\r\n","/**\r\n * @author       Seth Berrier <berriers@uwstout.edu>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\n\r\n/**\r\n * Parse a Tiled group layer and create a state object for inheriting.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.CreateGroupLayer\r\n * @since 3.21.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n * @param {object} [currentl] - The current group layer from the Tiled JSON file.\r\n * @param {object} [parentstate] - The state of the parent group (if any).\r\n *\r\n * @return {object} A group state object with proper values for updating children layers.\r\n */\r\nvar CreateGroupLayer = function (json, groupl, parentstate)\r\n{\r\n    if (!groupl)\r\n    {\r\n        // Return a default group state object\r\n        return {\r\n            i: 0, // Current layer array iterator\r\n            layers: json.layers, // Current array of layers\r\n\r\n            // Values inherited from parent group\r\n            name: '',\r\n            opacity: 1,\r\n            visible: true,\r\n            x: 0,\r\n            y: 0\r\n        };\r\n    }\r\n\r\n    // Compute group layer x, y\r\n    var layerX = groupl.x + GetFastValue(groupl, 'startx', 0) * json.tilewidth + GetFastValue(groupl, 'offsetx', 0);\r\n    var layerY = groupl.y + GetFastValue(groupl, 'starty', 0) * json.tileheight + GetFastValue(groupl, 'offsety', 0);\r\n\r\n    // Compute next state inherited from group\r\n    return {\r\n        i: 0,\r\n        layers: groupl.layers,\r\n        name: parentstate.name + groupl.name + '/',\r\n        opacity: parentstate.opacity * groupl.opacity,\r\n        visible: parentstate.visible && groupl.visible,\r\n        x: parentstate.x + layerX,\r\n        y: parentstate.y + layerY\r\n    };\r\n};\r\n\r\nmodule.exports = CreateGroupLayer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./SpriteWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./SpriteCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Sprite#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Sprite} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar SpriteWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    src.pipeline.batchSprite(src, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = SpriteWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Sprite#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Sprite} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar SpriteCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = SpriteCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar pointStart = new Vector2();\r\nvar pointEnd = new Vector2();\r\n\r\n/**\r\n * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithinWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The world x coordinate for the top-left of the area.\r\n * @param {number} worldY - The world y coordinate for the top-left of the area.\r\n * @param {number} width - The width of the area.\r\n * @param {number} height - The height of the area.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when factoring in which tiles to return.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithinWorldXY = function (worldX, worldY, width, height, filteringOptions, camera, layer)\r\n{\r\n    var worldToTileXY = layer.tilemapLayer.tilemap._convert.WorldToTileXY;\r\n\r\n    //  Top left corner of the rect, rounded down to include partial tiles\r\n    worldToTileXY(worldX, worldY, true, pointStart, camera, layer);\r\n\r\n    var xStart = pointStart.x;\r\n    var yStart = pointStart.y;\r\n\r\n    //  Bottom right corner of the rect, rounded up to include partial tiles\r\n    worldToTileXY(worldX + width, worldY + height, false, pointEnd, camera, layer);\r\n\r\n    var xEnd = Math.ceil(pointEnd.x);\r\n    var yEnd = Math.ceil(pointEnd.y);\r\n\r\n    return GetTilesWithin(xStart, yStart, xEnd - xStart, yEnd - yStart, filteringOptions, layer);\r\n};\r\n\r\nmodule.exports = GetTilesWithinWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n *\r\n * @function Phaser.Tilemaps.Components.GetTilesWithin\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Types.Tilemaps.FilteringOptions} filteringOptions - Optional filters to apply when getting the tiles.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} Array of Tile objects.\r\n */\r\nvar GetTilesWithin = function (tileX, tileY, width, height, filteringOptions, layer)\r\n{\r\n    if (tileX === undefined) { tileX = 0; }\r\n    if (tileY === undefined) { tileY = 0; }\r\n    if (width === undefined) { width = layer.width; }\r\n    if (height === undefined) { height = layer.height; }\r\n    if (!filteringOptions) { filteringOptions = {}; }\r\n\r\n    var isNotEmpty = GetFastValue(filteringOptions, 'isNotEmpty', false);\r\n    var isColliding = GetFastValue(filteringOptions, 'isColliding', false);\r\n    var hasInterestingFace = GetFastValue(filteringOptions, 'hasInterestingFace', false);\r\n\r\n    // Clip x, y to top left of map, while shrinking width/height to match.\r\n    if (tileX < 0)\r\n    {\r\n        width += tileX;\r\n        tileX = 0;\r\n    }\r\n\r\n    if (tileY < 0)\r\n    {\r\n        height += tileY;\r\n        tileY = 0;\r\n    }\r\n\r\n    // Clip width and height to bottom right of map.\r\n    if (tileX + width > layer.width)\r\n    {\r\n        width = Math.max(layer.width - tileX, 0);\r\n    }\r\n\r\n    if (tileY + height > layer.height)\r\n    {\r\n        height = Math.max(layer.height - tileY, 0);\r\n    }\r\n\r\n    var results = [];\r\n\r\n    for (var ty = tileY; ty < tileY + height; ty++)\r\n    {\r\n        for (var tx = tileX; tx < tileX + width; tx++)\r\n        {\r\n            var tile = layer.data[ty][tx];\r\n\r\n            if (tile !== null)\r\n            {\r\n                if (isNotEmpty && tile.index === -1)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (isColliding && !tile.collides)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                if (hasInterestingFace && !tile.hasInterestingFace)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                results.push(tile);\r\n            }\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n\r\nmodule.exports = GetTilesWithin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Components\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    CalculateFacesAt: require('./CalculateFacesAt'),\r\n    CalculateFacesWithin: require('./CalculateFacesWithin'),\r\n    CheckIsoBounds: require('./CheckIsoBounds'),\r\n    Copy: require('./Copy'),\r\n    CreateFromTiles: require('./CreateFromTiles'),\r\n    CullBounds: require('./CullBounds'),\r\n    CullTiles: require('./CullTiles'),\r\n    Fill: require('./Fill'),\r\n    FilterTiles: require('./FilterTiles'),\r\n    FindByIndex: require('./FindByIndex'),\r\n    FindTile: require('./FindTile'),\r\n    ForEachTile: require('./ForEachTile'),\r\n    GetCullTilesFunction: require('./GetCullTilesFunction'),\r\n    GetTileAt: require('./GetTileAt'),\r\n    GetTileAtWorldXY: require('./GetTileAtWorldXY'),\r\n    GetTilesWithin: require('./GetTilesWithin'),\r\n    GetTilesWithinShape: require('./GetTilesWithinShape'),\r\n    GetTilesWithinWorldXY: require('./GetTilesWithinWorldXY'),\r\n    GetTileToWorldXFunction: require('./GetTileToWorldXFunction'),\r\n    GetTileToWorldXYFunction: require('./GetTileToWorldXYFunction'),\r\n    GetTileToWorldYFunction: require('./GetTileToWorldYFunction'),\r\n    GetWorldToTileXFunction: require('./GetWorldToTileXFunction'),\r\n    GetWorldToTileXYFunction: require('./GetWorldToTileXYFunction'),\r\n    GetWorldToTileYFunction: require('./GetWorldToTileYFunction'),\r\n    HasTileAt: require('./HasTileAt'),\r\n    HasTileAtWorldXY: require('./HasTileAtWorldXY'),\r\n    HexagonalCullBounds: require('./HexagonalCullBounds'),\r\n    HexagonalCullTiles: require('./HexagonalCullTiles'),\r\n    HexagonalTileToWorldXY: require('./HexagonalTileToWorldXY'),\r\n    HexagonalTileToWorldY: require('./HexagonalTileToWorldY'),\r\n    HexagonalWorldToTileXY: require('./HexagonalWorldToTileXY'),\r\n    HexagonalWorldToTileY: require('./HexagonalWorldToTileY'),\r\n    IsInLayerBounds: require('./IsInLayerBounds'),\r\n    IsometricCullTiles: require('./IsometricCullTiles'),\r\n    IsometricTileToWorldXY: require('./IsometricTileToWorldXY'),\r\n    IsometricWorldToTileXY: require('./IsometricWorldToTileXY'),\r\n    PutTileAt: require('./PutTileAt'),\r\n    PutTileAtWorldXY: require('./PutTileAtWorldXY'),\r\n    PutTilesAt: require('./PutTilesAt'),\r\n    Randomize: require('./Randomize'),\r\n    RemoveTileAt: require('./RemoveTileAt'),\r\n    RemoveTileAtWorldXY: require('./RemoveTileAtWorldXY'),\r\n    RenderDebug: require('./RenderDebug'),\r\n    ReplaceByIndex: require('./ReplaceByIndex'),\r\n    RunCull: require('./RunCull'),\r\n    SetCollision: require('./SetCollision'),\r\n    SetCollisionBetween: require('./SetCollisionBetween'),\r\n    SetCollisionByExclusion: require('./SetCollisionByExclusion'),\r\n    SetCollisionByProperty: require('./SetCollisionByProperty'),\r\n    SetCollisionFromCollisionGroup: require('./SetCollisionFromCollisionGroup'),\r\n    SetLayerCollisionIndex: require('./SetLayerCollisionIndex'),\r\n    SetTileCollision: require('./SetTileCollision'),\r\n    SetTileIndexCallback: require('./SetTileIndexCallback'),\r\n    SetTileLocationCallback: require('./SetTileLocationCallback'),\r\n    Shuffle: require('./Shuffle'),\r\n    StaggeredCullBounds: require('./StaggeredCullBounds'),\r\n    StaggeredCullTiles: require('./StaggeredCullTiles'),\r\n    StaggeredTileToWorldXY: require('./StaggeredTileToWorldXY'),\r\n    StaggeredTileToWorldY: require('./StaggeredTileToWorldY'),\r\n    StaggeredWorldToTileXY: require('./StaggeredWorldToTileXY'),\r\n    StaggeredWorldToTileY: require('./StaggeredWorldToTileY'),\r\n    SwapByIndex: require('./SwapByIndex'),\r\n    TileToWorldX: require('./TileToWorldX'),\r\n    TileToWorldXY: require('./TileToWorldXY'),\r\n    TileToWorldY: require('./TileToWorldY'),\r\n    WeightedRandomize: require('./WeightedRandomize'),\r\n    WorldToTileX: require('./WorldToTileX'),\r\n    WorldToTileXY: require('./WorldToTileXY'),\r\n    WorldToTileY: require('./WorldToTileY')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTileAt = require('./GetTileAt');\r\n\r\n/**\r\n * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n * internally to optimize recalculating faces when only one tile has been changed.\r\n *\r\n * @function Phaser.Tilemaps.Components.CalculateFacesAt\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate.\r\n * @param {number} tileY - The y coordinate.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar CalculateFacesAt = function (tileX, tileY, layer)\r\n{\r\n    var tile = GetTileAt(tileX, tileY, true, layer);\r\n    var above = GetTileAt(tileX, tileY - 1, true, layer);\r\n    var below = GetTileAt(tileX, tileY + 1, true, layer);\r\n    var left = GetTileAt(tileX - 1, tileY, true, layer);\r\n    var right = GetTileAt(tileX + 1, tileY, true, layer);\r\n    var tileCollides = tile && tile.collides;\r\n\r\n    // Assume the changed tile has all interesting edges\r\n    if (tileCollides)\r\n    {\r\n        tile.faceTop = true;\r\n        tile.faceBottom = true;\r\n        tile.faceLeft = true;\r\n        tile.faceRight = true;\r\n    }\r\n\r\n    // Reset edges that are shared between tile and its neighbors\r\n    if (above && above.collides)\r\n    {\r\n        if (tileCollides)\r\n        {\r\n            tile.faceTop = false;\r\n        }\r\n\r\n        above.faceBottom = !tileCollides;\r\n    }\r\n\r\n    if (below && below.collides)\r\n    {\r\n        if (tileCollides)\r\n        {\r\n            tile.faceBottom = false;\r\n        }\r\n\r\n        below.faceTop = !tileCollides;\r\n    }\r\n\r\n    if (left && left.collides)\r\n    {\r\n        if (tileCollides)\r\n        {\r\n            tile.faceLeft = false;\r\n        }\r\n\r\n        left.faceRight = !tileCollides;\r\n    }\r\n\r\n    if (right && right.collides)\r\n    {\r\n        if (tileCollides)\r\n        {\r\n            tile.faceRight = false;\r\n        }\r\n\r\n        right.faceLeft = !tileCollides;\r\n    }\r\n\r\n    if (tile && !tile.collides)\r\n    {\r\n        tile.resetFaces();\r\n    }\r\n\r\n    return tile;\r\n};\r\n\r\nmodule.exports = CalculateFacesAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.TileToWorldX\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number}\r\n */\r\nvar TileToWorldX = function (tileX, camera, layer)\r\n{\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    var layerWorldX = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    return layerWorldX + tileX * tileWidth;\r\n};\r\n\r\nmodule.exports = TileToWorldX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.TileToWorldY\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in world coordinates.\r\n */\r\nvar TileToWorldY = function (tileY, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    return layerWorldY + tileY * tileHeight;\r\n};\r\n\r\nmodule.exports = TileToWorldY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.WorldToTileX\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {?Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The X location in tile units.\r\n */\r\nvar WorldToTileX = function (worldX, snapToFloor, camera, layer)\r\n{\r\n    if (snapToFloor === undefined) { snapToFloor = true; }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's horizontal scroll\r\n        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    return (snapToFloor) ? Math.floor(worldX / tileWidth) : worldX / tileWidth;\r\n};\r\n\r\nmodule.exports = WorldToTileX;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.WorldToTileY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {?Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in tile units.\r\n */\r\nvar WorldToTileY = function (worldY, snapToFloor, camera, layer)\r\n{\r\n    if (snapToFloor === undefined) { snapToFloor = true; }\r\n\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's vertical scroll\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    return (snapToFloor) ? Math.floor(worldY / tileHeight) : worldY / tileHeight;\r\n};\r\n\r\nmodule.exports = WorldToTileY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tile = require('../Tile');\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\nvar CalculateFacesAt = require('./CalculateFacesAt');\r\nvar SetTileCollision = require('./SetTileCollision');\r\n\r\n/**\r\n * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n * location. If you pass in an index, only the index at the specified location will be changed.\r\n * Collision information will be recalculated at the specified location.\r\n *\r\n * @function Phaser.Tilemaps.Components.PutTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was created or added to this map.\r\n */\r\nvar PutTileAt = function (tile, tileX, tileY, recalculateFaces, layer)\r\n{\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (!IsInLayerBounds(tileX, tileY, layer))\r\n    {\r\n        return null;\r\n    }\r\n\r\n    var oldTile = layer.data[tileY][tileX];\r\n    var oldTileCollides = oldTile && oldTile.collides;\r\n\r\n    if (tile instanceof Tile)\r\n    {\r\n        if (layer.data[tileY][tileX] === null)\r\n        {\r\n            layer.data[tileY][tileX] = new Tile(layer, tile.index, tileX, tileY, layer.tileWidth, layer.tileHeight);\r\n        }\r\n\r\n        layer.data[tileY][tileX].copy(tile);\r\n    }\r\n    else\r\n    {\r\n        var index = tile;\r\n\r\n        if (layer.data[tileY][tileX] === null)\r\n        {\r\n            layer.data[tileY][tileX] = new Tile(layer, index, tileX, tileY, layer.tileWidth, layer.tileHeight);\r\n        }\r\n        else\r\n        {\r\n            layer.data[tileY][tileX].index = index;\r\n        }\r\n    }\r\n\r\n    // Updating colliding flag on the new tile\r\n    var newTile = layer.data[tileY][tileX];\r\n    var collides = layer.collideIndexes.indexOf(newTile.index) !== -1;\r\n\r\n    SetTileCollision(newTile, collides);\r\n\r\n    // Recalculate faces only if the colliding flag at (tileX, tileY) has changed\r\n    if (recalculateFaces && (oldTileCollides !== newTile.collides))\r\n    {\r\n        CalculateFacesAt(tileX, tileY, layer);\r\n    }\r\n\r\n    return newTile;\r\n};\r\n\r\nmodule.exports = PutTileAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('../const/ORIENTATION_CONST');\r\n\r\n/**\r\n * Get the Tilemap orientation from the given string.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.FromOrientationString\r\n * @since 3.50.0\r\n *\r\n * @param {string} [orientation] - The orientation type as a string.\r\n *\r\n * @return {Phaser.Tilemaps.OrientationType} The Tilemap Orientation type.\r\n */\r\nvar FromOrientationString = function (orientation)\r\n{\r\n    orientation = orientation.toLowerCase();\r\n\r\n    if (orientation === 'isometric')\r\n    {\r\n        return CONST.ISOMETRIC;\r\n    }\r\n    else if (orientation === 'staggered')\r\n    {\r\n        return CONST.STAGGERED;\r\n    }\r\n    else if (orientation === 'hexagonal')\r\n    {\r\n        return CONST.HEXAGONAL;\r\n    }\r\n    else\r\n    {\r\n        return CONST.ORTHOGONAL;\r\n    }\r\n};\r\n\r\nmodule.exports = FromOrientationString;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('../Formats');\r\nvar LayerData = require('../mapdata/LayerData');\r\nvar MapData = require('../mapdata/MapData');\r\nvar Tile = require('../Tile');\r\n\r\n/**\r\n * Parses a 2D array of tile indexes into a new MapData object with a single layer.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Parse2DArray\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {number[][]} data - 2D array, CSV string or Tiled JSON object.\r\n * @param {number} tileWidth - The width of a tile in pixels.\r\n * @param {number} tileHeight - The height of a tile in pixels.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} The MapData object.\r\n */\r\nvar Parse2DArray = function (name, data, tileWidth, tileHeight, insertNull)\r\n{\r\n    var layerData = new LayerData({\r\n        tileWidth: tileWidth,\r\n        tileHeight: tileHeight\r\n    });\r\n    \r\n    var mapData = new MapData({\r\n        name: name,\r\n        tileWidth: tileWidth,\r\n        tileHeight: tileHeight,\r\n        format: Formats.ARRAY_2D,\r\n        layers: [ layerData ]\r\n    });\r\n\r\n    var tiles = [];\r\n    var height = data.length;\r\n    var width = 0;\r\n\r\n    for (var y = 0; y < data.length; y++)\r\n    {\r\n        tiles[y] = [];\r\n        var row = data[y];\r\n\r\n        for (var x = 0; x < row.length; x++)\r\n        {\r\n            var tileIndex = parseInt(row[x], 10);\r\n\r\n            if (isNaN(tileIndex) || tileIndex === -1)\r\n            {\r\n                tiles[y][x] = insertNull\r\n                    ? null\r\n                    : new Tile(layerData, -1, x, y, tileWidth, tileHeight);\r\n            }\r\n            else\r\n            {\r\n                tiles[y][x] = new Tile(layerData, tileIndex, x, y, tileWidth, tileHeight);\r\n            }\r\n        }\r\n\r\n        if (width === 0)\r\n        {\r\n            width = row.length;\r\n        }\r\n    }\r\n\r\n    mapData.width = layerData.width = width;\r\n    mapData.height = layerData.height = height;\r\n    mapData.widthInPixels = layerData.widthInPixels = width * tileWidth;\r\n    mapData.heightInPixels = layerData.heightInPixels = height * tileHeight;\r\n    layerData.data = tiles;\r\n\r\n    return mapData;\r\n};\r\n\r\nmodule.exports = Parse2DArray;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Pick = require('../../../utils/object/Pick');\r\nvar ParseGID = require('./ParseGID');\r\n\r\nvar copyPoints = function (p) { return { x: p.x, y: p.y }; };\r\n\r\nvar commonObjectProps = [ 'id', 'name', 'type', 'rotation', 'properties', 'visible', 'x', 'y', 'width', 'height' ];\r\n\r\n/**\r\n * Convert a Tiled object to an internal parsed object normalising and copying properties over, while applying optional x and y offsets. The parsed object will always have the properties `id`, `name`, `type`, `rotation`, `properties`, `visible`, `x`, `y`, `width` and `height`. Other properties will be added according to the object type (such as text, polyline, gid etc.)\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseObject\r\n * @since 3.0.0\r\n *\r\n * @param {object} tiledObject - Tiled object to convert to an internal parsed object normalising and copying properties over.\r\n * @param {number} [offsetX=0] - Optional additional offset to apply to the object's x property. Defaults to 0.\r\n * @param {number} [offsetY=0] - Optional additional offset to apply to the object's y property. Defaults to 0.\r\n *\r\n * @return {object} The parsed object containing properties read from the Tiled object according to it's type with x and y values updated according to the given offsets.\r\n */\r\nvar ParseObject = function (tiledObject, offsetX, offsetY)\r\n{\r\n    if (offsetX === undefined) { offsetX = 0; }\r\n    if (offsetY === undefined) { offsetY = 0; }\r\n\r\n    var parsedObject = Pick(tiledObject, commonObjectProps);\r\n\r\n    parsedObject.x += offsetX;\r\n    parsedObject.y += offsetY;\r\n\r\n    if (tiledObject.gid)\r\n    {\r\n        //  Object tiles\r\n        var gidInfo = ParseGID(tiledObject.gid);\r\n        parsedObject.gid = gidInfo.gid;\r\n        parsedObject.flippedHorizontal = gidInfo.flippedHorizontal;\r\n        parsedObject.flippedVertical = gidInfo.flippedVertical;\r\n        parsedObject.flippedAntiDiagonal = gidInfo.flippedAntiDiagonal;\r\n    }\r\n    else if (tiledObject.polyline)\r\n    {\r\n        parsedObject.polyline = tiledObject.polyline.map(copyPoints);\r\n    }\r\n    else if (tiledObject.polygon)\r\n    {\r\n        parsedObject.polygon = tiledObject.polygon.map(copyPoints);\r\n    }\r\n    else if (tiledObject.ellipse)\r\n    {\r\n        parsedObject.ellipse = tiledObject.ellipse;\r\n    }\r\n    else if (tiledObject.text)\r\n    {\r\n        parsedObject.text = tiledObject.text;\r\n    }\r\n    else if (tiledObject.point)\r\n    {\r\n        parsedObject.point = true;\r\n    }\r\n    else\r\n    {\r\n        // Otherwise, assume it is a rectangle\r\n        parsedObject.rectangle = true;\r\n    }\r\n\r\n    return parsedObject;\r\n};\r\n\r\nmodule.exports = ParseObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FLIPPED_HORIZONTAL = 0x80000000;\r\nvar FLIPPED_VERTICAL = 0x40000000;\r\nvar FLIPPED_ANTI_DIAGONAL = 0x20000000; // Top-right is swapped with bottom-left corners\r\n\r\n/**\r\n * See Tiled documentation on tile flipping:\r\n * http://docs.mapeditor.org/en/latest/reference/tmx-map-format/\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseGID\r\n * @since 3.0.0\r\n *\r\n * @param {number} gid - A Tiled GID.\r\n *\r\n * @return {Phaser.Types.Tilemaps.GIDData} The GID Data.\r\n */\r\nvar ParseGID = function (gid)\r\n{\r\n    var flippedHorizontal = Boolean(gid & FLIPPED_HORIZONTAL);\r\n    var flippedVertical = Boolean(gid & FLIPPED_VERTICAL);\r\n    var flippedAntiDiagonal = Boolean(gid & FLIPPED_ANTI_DIAGONAL);\r\n    gid = gid & ~(FLIPPED_HORIZONTAL | FLIPPED_VERTICAL | FLIPPED_ANTI_DIAGONAL);\r\n\r\n    // Parse the flip flags into something Phaser can use\r\n    var rotation = 0;\r\n    var flipped = false;\r\n\r\n    if (flippedHorizontal && flippedVertical && flippedAntiDiagonal)\r\n    {\r\n        rotation = Math.PI / 2;\r\n        flipped = true;\r\n    }\r\n    else if (flippedHorizontal && flippedVertical && !flippedAntiDiagonal)\r\n    {\r\n        rotation = Math.PI;\r\n        flipped = false;\r\n    }\r\n    else if (flippedHorizontal && !flippedVertical && flippedAntiDiagonal)\r\n    {\r\n        rotation = Math.PI / 2;\r\n        flipped = false;\r\n    }\r\n    else if (flippedHorizontal && !flippedVertical && !flippedAntiDiagonal)\r\n    {\r\n        rotation = 0;\r\n        flipped = true;\r\n    }\r\n    else if (!flippedHorizontal && flippedVertical && flippedAntiDiagonal)\r\n    {\r\n        rotation = 3 * Math.PI / 2;\r\n        flipped = false;\r\n    }\r\n    else if (!flippedHorizontal && flippedVertical && !flippedAntiDiagonal)\r\n    {\r\n        rotation = Math.PI;\r\n        flipped = true;\r\n    }\r\n    else if (!flippedHorizontal && !flippedVertical && flippedAntiDiagonal)\r\n    {\r\n        rotation = 3 * Math.PI / 2;\r\n        flipped = true;\r\n    }\r\n    else if (!flippedHorizontal && !flippedVertical && !flippedAntiDiagonal)\r\n    {\r\n        rotation = 0;\r\n        flipped = false;\r\n    }\r\n\r\n    return {\r\n        gid: gid,\r\n        flippedHorizontal: flippedHorizontal,\r\n        flippedVertical: flippedVertical,\r\n        flippedAntiDiagonal: flippedAntiDiagonal,\r\n        rotation: rotation,\r\n        flipped: flipped\r\n    };\r\n};\r\n\r\nmodule.exports = ParseGID;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('./Formats');\r\nvar MapData = require('./mapdata/MapData');\r\nvar Parse = require('./parsers/Parse');\r\nvar Tilemap = require('./Tilemap');\r\n\r\n/**\r\n * Create a Tilemap from the given key or data. If neither is given, make a blank Tilemap. When\r\n * loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing from\r\n * a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map data. For\r\n * an empty map, you should specify tileWidth, tileHeight, width & height.\r\n *\r\n * @function Phaser.Tilemaps.ParseToTilemap\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Tilemap belongs.\r\n * @param {string} [key] - The key in the Phaser cache that corresponds to the loaded tilemap data.\r\n * @param {number} [tileWidth=32] - The width of a tile in pixels.\r\n * @param {number} [tileHeight=32] - The height of a tile in pixels.\r\n * @param {number} [width=10] - The width of the map in tiles.\r\n * @param {number} [height=10] - The height of the map in tiles.\r\n * @param {number[][]} [data] - Instead of loading from the cache, you can also load directly from\r\n * a 2D array of tile indexes.\r\n * @param {boolean} [insertNull=false] - Controls how empty tiles, tiles with an index of -1, in the\r\n * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.Tilemap}\r\n */\r\nvar ParseToTilemap = function (scene, key, tileWidth, tileHeight, width, height, data, insertNull)\r\n{\r\n    if (tileWidth === undefined) { tileWidth = 32; }\r\n    if (tileHeight === undefined) { tileHeight = 32; }\r\n    if (width === undefined) { width = 10; }\r\n    if (height === undefined) { height = 10; }\r\n    if (insertNull === undefined) { insertNull = false; }\r\n\r\n    var mapData = null;\r\n\r\n    if (Array.isArray(data))\r\n    {\r\n        var name = key !== undefined ? key : 'map';\r\n        mapData = Parse(name, Formats.ARRAY_2D, data, tileWidth, tileHeight, insertNull);\r\n    }\r\n    else if (key !== undefined)\r\n    {\r\n        var tilemapData = scene.cache.tilemap.get(key);\r\n\r\n        if (!tilemapData)\r\n        {\r\n            console.warn('No map data found for key ' + key);\r\n        }\r\n        else\r\n        {\r\n            mapData = Parse(key, tilemapData.format, tilemapData.data, tileWidth, tileHeight, insertNull);\r\n        }\r\n    }\r\n\r\n    if (mapData === null)\r\n    {\r\n        mapData = new MapData({\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height\r\n        });\r\n    }\r\n\r\n    return new Tilemap(scene, mapData);\r\n};\r\n\r\nmodule.exports = ParseToTilemap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Tilemap constants for orientation.\r\n * \r\n * @namespace Phaser.Tilemaps.Orientation\r\n * @memberof Phaser.Tilemaps\r\n * @since 3.50.0\r\n */\r\n\r\n/**\r\n * Phaser Tilemap constants for orientation.\r\n * \r\n * To find out what each mode does please see [Phaser.Tilemaps.Orientation]{@link Phaser.Tilemaps.Orientation}.\r\n * \r\n * @typedef {Phaser.Tilemaps.Orientation} Phaser.Tilemaps.OrientationType\r\n * @memberof Phaser.Tilemaps\r\n * @since 3.50.0\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * Orthogonal Tilemap orientation constant.\r\n     * \r\n     * @name Phaser.Tilemaps.Orientation.ORTHOGONAL\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    ORTHOGONAL: 0,\r\n\r\n    /**\r\n     * Isometric Tilemap orientation constant.\r\n     *\r\n     * @name Phaser.Tilemaps.Orientation.ISOMETRIC\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    ISOMETRIC: 1,\r\n\r\n    /**\r\n     * Staggered Tilemap orientation constant.\r\n     *\r\n     * @name Phaser.Tilemaps.Orientation.STAGGERED\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    STAGGERED: 2,\r\n\r\n    /**\r\n     * Hexagonal Tilemap orientation constant.\r\n     *\r\n     * @name Phaser.Tilemaps.Orientation.HEXAGONAL\r\n     * @type {number}\r\n     * @const\r\n     * @since 3.50.0\r\n     */\r\n    HEXAGONAL: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Formats\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * CSV Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.CSV\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    CSV: 0,\r\n\r\n    /**\r\n     * Tiled JSON Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.TILED_JSON\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    TILED_JSON: 1,\r\n\r\n    /**\r\n     * 2D Array Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.ARRAY_2D\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    ARRAY_2D: 2,\r\n\r\n    /**\r\n     * Weltmeister (Impact.js) Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.WELTMEISTER\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    WELTMEISTER: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\nvar point = new Vector2();\r\n\r\n/**\r\n * Checks if the given tile coordinate is within the isometric layer bounds, or not.\r\n *\r\n * @function Phaser.Tilemaps.Components.CheckIsoBounds\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to check against.\r\n * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.\r\n *\r\n * @return {boolean} Returns `true` if the coordinates are within the iso bounds.\r\n */\r\nvar CheckIsoBounds = function (tileX, tileY, layer, camera)\r\n{\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var cullPaddingX = tilemapLayer.cullPaddingX;\r\n    var cullPaddingY = tilemapLayer.cullPaddingY;\r\n\r\n    var pos = tilemapLayer.tilemap.tileToWorldXY(tileX, tileY, point, camera, tilemapLayer);\r\n\r\n    // we always subtract 1/2 of the tile's height/width to make the culling distance start from the center of the tiles.\r\n    return pos.x > camera.worldView.x + tilemapLayer.scaleX * layer.tileWidth * (-cullPaddingX - 0.5)\r\n        && pos.x < camera.worldView.right + tilemapLayer.scaleX * layer.tileWidth * (cullPaddingX - 0.5)\r\n        && pos.y > camera.worldView.y + tilemapLayer.scaleY * layer.tileHeight * (-cullPaddingY - 1.0)\r\n        && pos.y < camera.worldView.bottom + tilemapLayer.scaleY * layer.tileHeight * (cullPaddingY - 0.5);\r\n};\r\n\r\nmodule.exports = CheckIsoBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n * not change collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.ReplaceByIndex\r\n * @since 3.0.0\r\n *\r\n * @param {number} findIndex - The index of the tile to search for.\r\n * @param {number} newIndex - The index of the tile to replace it with.\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar ReplaceByIndex = function (findIndex, newIndex, tileX, tileY, width, height, layer)\r\n{\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        if (tiles[i] && tiles[i].index === findIndex)\r\n        {\r\n            tiles[i].index = newIndex;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = ReplaceByIndex;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar SnapCeil = require('../../math/snap/SnapCeil');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\nvar bounds = new Rectangle();\r\n\r\n/**\r\n * Returns the bounds in the given orthogonal layer that are within the cameras viewport.\r\n * This is used internally by the cull tiles function.\r\n *\r\n * @function Phaser.Tilemaps.Components.CullBounds\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n *\r\n * @return {Phaser.Geom.Rectangle} A rectangle containing the culled bounds. If you wish to retain this object, clone it, as it's recycled internally.\r\n */\r\nvar CullBounds = function (layer, camera)\r\n{\r\n    var tilemap = layer.tilemapLayer.tilemap;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    //  We need to use the tile sizes defined for the map as a whole, not the layer,\r\n    //  in order to calculate the bounds correctly. As different sized tiles may be\r\n    //  placed on the grid and we cannot trust layer.baseTileWidth to give us the true size.\r\n    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);\r\n    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);\r\n\r\n    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;\r\n    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;\r\n\r\n    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH, 0, true) - tilemapLayer.cullPaddingY;\r\n    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH, 0, true) + tilemapLayer.cullPaddingY;\r\n\r\n    return bounds.setTo(\r\n        boundsLeft,\r\n        boundsTop,\r\n        (boundsRight - boundsLeft),\r\n        (boundsBottom - boundsTop)\r\n    );\r\n};\r\n\r\nmodule.exports = CullBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CullBounds = require('./CullBounds');\r\nvar RunCull = require('./RunCull');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.CullTiles\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n * @param {number} [renderOrder=0] - The rendering order constant.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar CullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    //  Camera world view bounds, snapped for scaled tile size\r\n    //  Cull Padding values are given in tiles, not pixels\r\n    var bounds = CullBounds(layer, camera);\r\n\r\n    if (tilemapLayer.skipCull || tilemapLayer.scrollFactorX !== 1 || tilemapLayer.scrollFactorY !== 1)\r\n    {\r\n        bounds.left = 0;\r\n        bounds.right = layer.width;\r\n        bounds.top = 0;\r\n        bounds.bottom = layer.height;\r\n    }\r\n\r\n    RunCull(layer, bounds, renderOrder, outputArray);\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = CullTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CullBounds = require('./HexagonalCullBounds');\r\nvar RunCull = require('./RunCull');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalCullTiles\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n * @param {number} [renderOrder=0] - The rendering order constant.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar HexagonalCullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1)\r\n    {\r\n        //  Camera world view bounds, snapped for scaled tile size\r\n        //  Cull Padding values are given in tiles, not pixels\r\n\r\n        var bounds = CullBounds(layer, camera);\r\n\r\n        RunCull(layer, bounds, renderOrder, outputArray);\r\n    }\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = HexagonalCullTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SnapCeil = require('../../math/snap/SnapCeil');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\n/**\r\n * Returns the bounds in the given layer that are within the camera's viewport.\r\n * This is used internally by the cull tiles function.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalCullBounds\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n *\r\n * @return {object} An object containing the `left`, `right`, `top` and `bottom` bounds.\r\n */\r\nvar HexagonalCullBounds = function (layer, camera)\r\n{\r\n    var tilemap = layer.tilemapLayer.tilemap;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    //  We need to use the tile sizes defined for the map as a whole, not the layer,\r\n    //  in order to calculate the bounds correctly. As different sized tiles may be\r\n    //  placed on the grid and we cannot trust layer.baseTileWidth to give us the true size.\r\n    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);\r\n    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);\r\n\r\n    var len = layer.hexSideLength;\r\n    var rowH = ((tileH - len) / 2 + len);\r\n\r\n    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;\r\n    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;\r\n\r\n    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, rowH, 0, true) - tilemapLayer.cullPaddingY;\r\n    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, rowH, 0, true) + tilemapLayer.cullPaddingY;\r\n\r\n    return {\r\n        left: boundsLeft,\r\n        right: boundsRight,\r\n        top: boundsTop,\r\n        bottom: boundsBottom\r\n    };\r\n};\r\n\r\nmodule.exports = HexagonalCullBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CheckIsoBounds = require('./CheckIsoBounds');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsometricCullTiles\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n * @param {number} [renderOrder=0] - The rendering order constant.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar IsometricCullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var mapData = layer.data;\r\n    var mapWidth = layer.width;\r\n    var mapHeight = layer.height;\r\n\r\n    var drawLeft = 0;\r\n    var drawRight = mapWidth;\r\n    var drawTop = 0;\r\n    var drawBottom = mapHeight;\r\n\r\n    if (!tilemapLayer.skipCull)\r\n    {\r\n        var x;\r\n        var y;\r\n        var tile;\r\n\r\n        if (renderOrder === 0)\r\n        {\r\n            //  right-down\r\n\r\n            for (y = drawTop; y < drawBottom; y++)\r\n            {\r\n                for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n                {\r\n                    if (CheckIsoBounds(x, y, layer, camera))\r\n                    {\r\n                        tile = mapData[y][x];\r\n\r\n                        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        outputArray.push(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (renderOrder === 1)\r\n        {\r\n            //  left-down\r\n\r\n            for (y = drawTop; y < drawBottom; y++)\r\n            {\r\n                for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n                {\r\n                    if (CheckIsoBounds(x, y, layer, camera))\r\n                    {\r\n                        tile = mapData[y][x];\r\n\r\n                        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        outputArray.push(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (renderOrder === 2)\r\n        {\r\n            //  right-up\r\n\r\n            for (y = drawBottom; y >= drawTop; y--)\r\n            {\r\n                for (x = drawLeft; mapData[y] && x < drawRight; x++)\r\n                {\r\n                    if (CheckIsoBounds(x, y, layer, camera))\r\n                    {\r\n                        tile = mapData[y][x];\r\n\r\n                        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        outputArray.push(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (renderOrder === 3)\r\n        {\r\n            //  left-up\r\n\r\n            for (y = drawBottom; y >= drawTop; y--)\r\n            {\r\n                for (x = drawRight; mapData[y] && x >= drawLeft; x--)\r\n                {\r\n                    if (CheckIsoBounds(x, y, layer, camera))\r\n                    {\r\n                        tile = mapData[y][x];\r\n\r\n                        if (!tile || tile.index === -1 || !tile.visible || tile.alpha === 0)\r\n                        {\r\n                            continue;\r\n                        }\r\n\r\n                        outputArray.push(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    tilemapLayer.tilesDrawn = outputArray.length;\r\n    tilemapLayer.tilesTotal = mapWidth * mapHeight;\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = IsometricCullTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CullBounds = require('./StaggeredCullBounds');\r\nvar RunCull = require('./RunCull');\r\n\r\n/**\r\n * Returns the tiles in the given layer that are within the cameras viewport. This is used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredCullTiles\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n * @param {array} [outputArray] - An optional array to store the Tile objects within.\r\n * @param {number} [renderOrder=0] - The rendering order constant.\r\n *\r\n * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n */\r\nvar StaggeredCullTiles = function (layer, camera, outputArray, renderOrder)\r\n{\r\n    if (outputArray === undefined) { outputArray = []; }\r\n    if (renderOrder === undefined) { renderOrder = 0; }\r\n\r\n    outputArray.length = 0;\r\n\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (!tilemapLayer.skipCull && tilemapLayer.scrollFactorX === 1 && tilemapLayer.scrollFactorY === 1)\r\n    {\r\n        //  Camera world view bounds, snapped for scaled tile size\r\n        //  Cull Padding values are given in tiles, not pixels\r\n\r\n        var bounds = CullBounds(layer, camera);\r\n\r\n        RunCull(layer, bounds, renderOrder, outputArray);\r\n    }\r\n\r\n    return outputArray;\r\n};\r\n\r\nmodule.exports = StaggeredCullTiles;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SnapCeil = require('../../math/snap/SnapCeil');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\n/**\r\n * Returns the bounds in the given layer that are within the camera's viewport.\r\n * This is used internally by the cull tiles function.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredCullBounds\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to run the cull check against.\r\n *\r\n * @return {object} An object containing the `left`, `right`, `top` and `bottom` bounds.\r\n */\r\nvar StaggeredCullBounds = function (layer, camera)\r\n{\r\n    var tilemap = layer.tilemapLayer.tilemap;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    //  We need to use the tile sizes defined for the map as a whole, not the layer,\r\n    //  in order to calculate the bounds correctly. As different sized tiles may be\r\n    //  placed on the grid and we cannot trust layer.baseTileWidth to give us the true size.\r\n    var tileW = Math.floor(tilemap.tileWidth * tilemapLayer.scaleX);\r\n    var tileH = Math.floor(tilemap.tileHeight * tilemapLayer.scaleY);\r\n\r\n    var boundsLeft = SnapFloor(camera.worldView.x - tilemapLayer.x, tileW, 0, true) - tilemapLayer.cullPaddingX;\r\n    var boundsRight = SnapCeil(camera.worldView.right - tilemapLayer.x, tileW, 0, true) + tilemapLayer.cullPaddingX;\r\n\r\n    var boundsTop = SnapFloor(camera.worldView.y - tilemapLayer.y, tileH / 2, 0, true) - tilemapLayer.cullPaddingY;\r\n    var boundsBottom = SnapCeil(camera.worldView.bottom - tilemapLayer.y, tileH / 2, 0, true) + tilemapLayer.cullPaddingY;\r\n\r\n    return {\r\n        left: boundsLeft,\r\n        right: boundsRight,\r\n        top: boundsTop,\r\n        bottom: boundsBottom\r\n    };\r\n};\r\n\r\nmodule.exports = StaggeredCullBounds;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from hexagonal tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalTileToWorldXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */\r\nvar HexagonalTileToWorldXY = function (tileX, tileY, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var layerWorldX = 0;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var len = layer.hexSideLength;\r\n    var rowHeight = ((tileHeight - len) / 2 + len);\r\n\r\n    // similar to staggered, because Tiled uses the oddr representation.\r\n    var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);\r\n    var y = layerWorldY + tileY * rowHeight;\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = HexagonalTileToWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from isometric tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsometricTileToWorldXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */\r\nvar IsometricTileToWorldXY = function (tileX, tileY, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var layerWorldX = 0;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var x = layerWorldX + (tileX - tileY) * (tileWidth / 2);\r\n    var y = layerWorldY + (tileX + tileY) * (tileHeight / 2);\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = IsometricTileToWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from staggered tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredTileToWorldXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */\r\nvar StaggeredTileToWorldXY = function (tileX, tileY, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    var layerWorldX = 0;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldX = tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX);\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var x = layerWorldX + tileX * tileWidth + tileY % 2 * (tileWidth / 2);\r\n    var y = layerWorldY + tileY * (tileHeight / 2);\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = StaggeredTileToWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TileToWorldX = require('./TileToWorldX');\r\nvar TileToWorldY = require('./TileToWorldY');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.TileToWorldXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in world coordinates.\r\n */\r\nvar TileToWorldXY = function (tileX, tileY, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(0, 0); }\r\n\r\n    point.x = TileToWorldX(tileX, camera, layer);\r\n    point.y = TileToWorldY(tileY, camera, layer);\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = TileToWorldXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from hexagonal tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n * layer's position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalTileToWorldY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in world coordinates.\r\n */\r\nvar HexagonalTileToWorldY = function (tileY, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (camera === undefined) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var len = tilemapLayer.tilemap.hexSideLength;\r\n\r\n    var rowHeight = ((tileHeight - len) / 2 + len);\r\n\r\n    return layerWorldY + tileY * rowHeight;\r\n};\r\n\r\nmodule.exports = HexagonalTileToWorldY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from staggered tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n * layers position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredTileToWorldY\r\n * @since 3.50.0\r\n *\r\n * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in world coordinates.\r\n */\r\nvar StaggeredTileToWorldY = function (tileY, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n    var layerWorldY = 0;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (camera === undefined) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        layerWorldY = (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    return layerWorldY + tileY * (tileHeight / 2);\r\n};\r\n\r\nmodule.exports = StaggeredTileToWorldY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from world XY coordinates (pixels) to hexagonal tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalWorldToTileXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinates down to the nearest integer.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */\r\nvar HexagonalWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's horizontal scroll\r\n\r\n        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    var len = layer.hexSideLength;\r\n    var rowHeight = ((tileHeight - len) / 2 + len);\r\n\r\n    // similar to staggered, because Tiled uses the oddr representation.\r\n    var y = (snapToFloor) ? Math.floor((worldY / rowHeight)) : (worldY / rowHeight);\r\n    var x = (snapToFloor) ? Math.floor((worldX - (y % 2) * 0.5 * tileWidth) / tileWidth) : (worldX - (y % 2) * 0.5 * tileWidth) / tileWidth;\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = HexagonalWorldToTileXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from world XY coordinates (pixels) to isometric tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.IsometricWorldToTileXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */\r\nvar IsometricWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's horizontal scroll\r\n\r\n        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    var x = (snapToFloor) ? Math.floor((worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2) : ((worldX / (tileWidth / 2) + worldY / (tileHeight / 2)) / 2);\r\n    var y = (snapToFloor) ? Math.floor((worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2) : ((worldY / (tileHeight / 2) - worldX / (tileWidth / 2)) / 2);\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = IsometricWorldToTileXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from world XY coordinates (pixels) to staggered tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredWorldToTileXY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */\r\nvar StaggeredWorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)\r\n{\r\n    if (!point) { point = new Vector2(); }\r\n\r\n    var tileWidth = layer.baseTileWidth;\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n\r\n        // Find the world position relative to the static or dynamic layer's top left origin,\r\n        // factoring in the camera's horizontal scroll\r\n\r\n        worldX = worldX - (tilemapLayer.x + camera.scrollX * (1 - tilemapLayer.scrollFactorX));\r\n\r\n        tileWidth *= tilemapLayer.scaleX;\r\n    }\r\n\r\n    var y = (snapToFloor) ? Math.floor((worldY / (tileHeight / 2))) : (worldY / (tileHeight / 2));\r\n    var x = (snapToFloor) ? Math.floor((worldX + (y % 2) * 0.5 * tileWidth) / tileWidth) : (worldX + (y % 2) * 0.5 * tileWidth) / tileWidth;\r\n\r\n    return point.set(x, y);\r\n};\r\n\r\nmodule.exports = StaggeredWorldToTileXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar WorldToTileX = require('./WorldToTileX');\r\nvar WorldToTileY = require('./WorldToTileY');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n * layer's position, scale and scroll. This will return a new Vector2 object or update the given\r\n * `point` object.\r\n *\r\n * @function Phaser.Tilemaps.Components.WorldToTileXY\r\n * @since 3.0.0\r\n *\r\n * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Math.Vector2} point - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Math.Vector2} The XY location in tile units.\r\n */\r\nvar WorldToTileXY = function (worldX, worldY, snapToFloor, point, camera, layer)\r\n{\r\n    if (snapToFloor === undefined) { snapToFloor = true; }\r\n    if (!point) { point = new Vector2(0, 0); }\r\n\r\n    point.x = WorldToTileX(worldX, snapToFloor, camera, layer);\r\n    point.y = WorldToTileY(worldY, snapToFloor, camera, layer);\r\n\r\n    return point;\r\n};\r\n\r\nmodule.exports = WorldToTileXY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from world Y coordinates (pixels) to hexagonal tile Y coordinates (tile units), factoring in the\r\n * layers position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.HexagonalWorldToTileY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in tile units.\r\n */\r\nvar HexagonalWorldToTileY = function (worldY, snapToFloor, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        //  Find the world position relative to the static or dynamic layer's top left origin,\r\n        //  factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    var len = layer.hexSideLength;\r\n\r\n    var rowHeight = ((tileHeight - len) / 2 + len);\r\n\r\n    return (snapToFloor) ? Math.floor(worldY / rowHeight) : worldY / rowHeight;\r\n};\r\n\r\nmodule.exports = HexagonalWorldToTileY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Converts from world Y coordinates (pixels) to staggered tile Y coordinates (tile units), factoring in the\r\n * layers position, scale and scroll.\r\n *\r\n * @function Phaser.Tilemaps.Components.StaggeredWorldToTileY\r\n * @since 3.50.0\r\n *\r\n * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n * @param {boolean} snapToFloor - Whether or not to round the tile coordinate down to the nearest integer.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use when calculating the tile index from the world values.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {number} The Y location in tile units.\r\n */\r\nvar StaggeredWorldToTileY = function (worldY, snapToFloor, camera, layer)\r\n{\r\n    var tileHeight = layer.baseTileHeight;\r\n    var tilemapLayer = layer.tilemapLayer;\r\n\r\n    if (tilemapLayer)\r\n    {\r\n        if (!camera) { camera = tilemapLayer.scene.cameras.main; }\r\n\r\n        //  Find the world position relative to the static or dynamic layer's top left origin,\r\n        //  factoring in the camera's vertical scroll\r\n\r\n        worldY = worldY - (tilemapLayer.y + camera.scrollY * (1 - tilemapLayer.scrollFactorY));\r\n\r\n        tileHeight *= tilemapLayer.scaleY;\r\n    }\r\n\r\n    return (snapToFloor) ? Math.floor(worldY / (tileHeight / 2)) : worldY / (tileHeight / 2);\r\n};\r\n\r\nmodule.exports = StaggeredWorldToTileY;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\n\r\n/**\r\n * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n * false if there is no tile or if the tile at that location has an index of -1.\r\n *\r\n * @function Phaser.Tilemaps.Components.HasTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - X position to get the tile from (given in tile units, not pixels).\r\n * @param {number} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n */\r\nvar HasTileAt = function (tileX, tileY, layer)\r\n{\r\n    if (IsInLayerBounds(tileX, tileY, layer))\r\n    {\r\n        var tile = layer.data[tileY][tileX];\r\n\r\n        return (tile !== null && tile.index > -1);\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = HasTileAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tile = require('../Tile');\r\nvar IsInLayerBounds = require('./IsInLayerBounds');\r\nvar CalculateFacesAt = require('./CalculateFacesAt');\r\n\r\n/**\r\n * Removes the tile at the given tile coordinates in the specified layer and updates the layer's\r\n * collision information.\r\n *\r\n * @function Phaser.Tilemaps.Components.RemoveTileAt\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The x coordinate.\r\n * @param {number} tileY - The y coordinate.\r\n * @param {boolean} replaceWithNull - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n * @param {boolean} recalculateFaces - `true` if the faces data should be recalculated.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n *\r\n * @return {Phaser.Tilemaps.Tile} The Tile object that was removed.\r\n */\r\nvar RemoveTileAt = function (tileX, tileY, replaceWithNull, recalculateFaces, layer)\r\n{\r\n    if (replaceWithNull === undefined) { replaceWithNull = true; }\r\n    if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n    if (!IsInLayerBounds(tileX, tileY, layer))\r\n    {\r\n        return null;\r\n    }\r\n\r\n    var tile = layer.data[tileY][tileX];\r\n\r\n    if (!tile)\r\n    {\r\n        return null;\r\n    }\r\n    else\r\n    {\r\n        layer.data[tileY][tileX] = (replaceWithNull) ? null : new Tile(layer, -1, tileX, tileY, layer.tileWidth, layer.tileHeight);\r\n    }\r\n\r\n    //  Recalculate faces only if the removed tile was a colliding tile\r\n    if (recalculateFaces && tile && tile.collides)\r\n    {\r\n        CalculateFacesAt(tileX, tileY, layer);\r\n    }\r\n\r\n    return tile;\r\n};\r\n\r\nmodule.exports = RemoveTileAt;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('../Formats');\r\nvar Parse2DArray = require('./Parse2DArray');\r\nvar ParseCSV = require('./ParseCSV');\r\nvar ParseJSONTiled = require('./tiled/ParseJSONTiled');\r\nvar ParseWeltmeister = require('./impact/ParseWeltmeister');\r\n\r\n/**\r\n * Parses raw data of a given Tilemap format into a new MapData object. If no recognized data format\r\n * is found, returns `null`. When loading from CSV or a 2D array, you should specify the tileWidth &\r\n * tileHeight. When parsing from a map from Tiled, the tileWidth & tileHeight will be pulled from\r\n * the map data.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Parse\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {number} mapFormat - See ../Formats.js.\r\n * @param {(number[][]|string|object)} data - 2D array, CSV string or Tiled JSON object.\r\n * @param {number} tileWidth - The width of a tile in pixels. Required for 2D array and CSV, but\r\n * ignored for Tiled JSON.\r\n * @param {number} tileHeight - The height of a tile in pixels. Required for 2D array and CSV, but\r\n * ignored for Tiled JSON.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} The created `MapData` object.\r\n */\r\nvar Parse = function (name, mapFormat, data, tileWidth, tileHeight, insertNull)\r\n{\r\n    var newMap;\r\n\r\n    switch (mapFormat)\r\n    {\r\n        case (Formats.ARRAY_2D):\r\n            newMap = Parse2DArray(name, data, tileWidth, tileHeight, insertNull);\r\n            break;\r\n        case (Formats.CSV):\r\n            newMap = ParseCSV(name, data, tileWidth, tileHeight, insertNull);\r\n            break;\r\n        case (Formats.TILED_JSON):\r\n            newMap = ParseJSONTiled(name, data, insertNull);\r\n            break;\r\n        case (Formats.WELTMEISTER):\r\n            newMap = ParseWeltmeister(name, data, insertNull);\r\n            break;\r\n        default:\r\n            console.warn('Unrecognized tilemap data format: ' + mapFormat);\r\n            newMap = null;\r\n    }\r\n\r\n    return newMap;\r\n};\r\n\r\nmodule.exports = Parse;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('../Formats');\r\nvar Parse2DArray = require('./Parse2DArray');\r\n\r\n/**\r\n * Parses a CSV string of tile indexes into a new MapData object with a single layer.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.ParseCSV\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {string} data - CSV string of tile indexes.\r\n * @param {number} tileWidth - The width of a tile in pixels.\r\n * @param {number} tileHeight - The height of a tile in pixels.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {Phaser.Tilemaps.MapData} The resulting MapData object.\r\n */\r\nvar ParseCSV = function (name, data, tileWidth, tileHeight, insertNull)\r\n{\r\n    var array2D = data\r\n        .trim()\r\n        .split('\\n')\r\n        .map(function (row) { return row.split(','); });\r\n\r\n    var map = Parse2DArray(name, array2D, tileWidth, tileHeight, insertNull);\r\n    map.format = Formats.CSV;\r\n\r\n    return map;\r\n};\r\n\r\nmodule.exports = ParseCSV;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AssignTileProperties = require('./AssignTileProperties');\r\nvar BuildTilesetIndex = require('./BuildTilesetIndex');\r\nvar CONST = require('../../const/ORIENTATION_CONST');\r\nvar Formats = require('../../Formats');\r\nvar FromOrientationString = require('../FromOrientationString');\r\nvar MapData = require('../../mapdata/MapData');\r\nvar ParseImageLayers = require('./ParseImageLayers');\r\nvar ParseObjectLayers = require('./ParseObjectLayers');\r\nvar ParseTileLayers = require('./ParseTileLayers');\r\nvar ParseTilesets = require('./ParseTilesets');\r\n\r\n/**\r\n * Parses a Tiled JSON object into a new MapData object.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseJSONTiled\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {object} json - The Tiled JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {?Phaser.Tilemaps.MapData} The created MapData object, or `null` if the data can't be parsed.\r\n */\r\nvar ParseJSONTiled = function (name, json, insertNull)\r\n{\r\n    //  Map data will consist of: layers, objects, images, tilesets, sizes\r\n    var mapData = new MapData({\r\n        width: json.width,\r\n        height: json.height,\r\n        name: name,\r\n        tileWidth: json.tilewidth,\r\n        tileHeight: json.tileheight,\r\n        orientation: FromOrientationString(json.orientation),\r\n        format: Formats.TILED_JSON,\r\n        version: json.version,\r\n        properties: json.properties,\r\n        renderOrder: json.renderorder,\r\n        infinite: json.infinite\r\n    });\r\n\r\n    if (mapData.orientation === CONST.HEXAGONAL)\r\n    {\r\n        mapData.hexSideLength = json.hexsidelength;\r\n    }\r\n\r\n    mapData.layers = ParseTileLayers(json, insertNull);\r\n    mapData.images = ParseImageLayers(json);\r\n\r\n    var sets = ParseTilesets(json);\r\n\r\n    mapData.tilesets = sets.tilesets;\r\n    mapData.imageCollections = sets.imageCollections;\r\n\r\n    mapData.objects = ParseObjectLayers(json);\r\n\r\n    mapData.tiles = BuildTilesetIndex(mapData);\r\n\r\n    AssignTileProperties(mapData);\r\n\r\n    return mapData;\r\n};\r\n\r\nmodule.exports = ParseJSONTiled;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Extend = require('../../../utils/object/Extend');\r\n\r\n/**\r\n * Copy properties from tileset to tiles.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.AssignTileProperties\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.MapData} mapData - The Map Data object.\r\n */\r\nvar AssignTileProperties = function (mapData)\r\n{\r\n    var layerData;\r\n    var tile;\r\n    var sid;\r\n    var set;\r\n    var row;\r\n\r\n    // go through each of the map data layers\r\n    for (var i = 0; i < mapData.layers.length; i++)\r\n    {\r\n        layerData = mapData.layers[i];\r\n\r\n        set = null;\r\n\r\n        // rows of tiles\r\n        for (var j = 0; j < layerData.data.length; j++)\r\n        {\r\n            row = layerData.data[j];\r\n\r\n            // individual tiles\r\n            for (var k = 0; k < row.length; k++)\r\n            {\r\n                tile = row[k];\r\n\r\n                if (tile === null || tile.index < 0)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                // find the relevant tileset\r\n                sid = mapData.tiles[tile.index][2];\r\n                set = mapData.tilesets[sid];\r\n\r\n                // Ensure that a tile's size matches its tileset\r\n                tile.width = set.tileWidth;\r\n                tile.height = set.tileHeight;\r\n\r\n                // if that tile type has any properties, add them to the tile object\r\n                if (set.tileProperties && set.tileProperties[tile.index - set.firstgid])\r\n                {\r\n                    tile.properties = Extend(\r\n                        tile.properties, set.tileProperties[tile.index - set.firstgid]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = AssignTileProperties;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tileset = require('../../Tileset');\r\n\r\n/**\r\n * Master list of tiles -> x, y, index in tileset.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.BuildTilesetIndex\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.MapData} mapData - The Map Data object.\r\n *\r\n * @return {array} An array of Tileset objects.\r\n */\r\nvar BuildTilesetIndex = function (mapData)\r\n{\r\n    var i;\r\n    var set;\r\n    var tiles = [];\r\n\r\n    for (i = 0; i < mapData.imageCollections.length; i++)\r\n    {\r\n        var collection = mapData.imageCollections[i];\r\n        var images = collection.images;\r\n\r\n        for (var j = 0; j < images.length; j++)\r\n        {\r\n            var image = images[j];\r\n\r\n            set = new Tileset(image.image, image.gid, collection.imageWidth, collection.imageHeight, 0, 0);\r\n\r\n            set.updateTileData(collection.imageWidth, collection.imageHeight);\r\n\r\n            mapData.tilesets.push(set);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < mapData.tilesets.length; i++)\r\n    {\r\n        set = mapData.tilesets[i];\r\n\r\n        var x = set.tileMargin;\r\n        var y = set.tileMargin;\r\n\r\n        var count = 0;\r\n        var countX = 0;\r\n        var countY = 0;\r\n\r\n        for (var t = set.firstgid; t < set.firstgid + set.total; t++)\r\n        {\r\n            //  Can add extra properties here as needed\r\n            tiles[t] = [ x, y, i ];\r\n\r\n            x += set.tileWidth + set.tileSpacing;\r\n\r\n            count++;\r\n\r\n            if (count === set.total)\r\n            {\r\n                break;\r\n            }\r\n\r\n            countX++;\r\n\r\n            if (countX === set.columns)\r\n            {\r\n                x = set.tileMargin;\r\n                y += set.tileHeight + set.tileSpacing;\r\n\r\n                countX = 0;\r\n                countY++;\r\n\r\n                if (countY === set.rows)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tiles;\r\n};\r\n\r\nmodule.exports = BuildTilesetIndex;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar CreateGroupLayer = require('./CreateGroupLayer');\r\n\r\n/**\r\n * Parses a Tiled JSON object into an array of objects with details about the image layers.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseImageLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n *\r\n * @return {array} Array of objects that include critical info about the map's image layers\r\n */\r\nvar ParseImageLayers = function (json)\r\n{\r\n    var images = [];\r\n\r\n    // State inherited from a parent group\r\n    var groupStack = [];\r\n    var curGroupState = CreateGroupLayer(json);\r\n\r\n    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)\r\n    {\r\n        if (curGroupState.i >= curGroupState.layers.length)\r\n        {\r\n            // Ensure recursion stack is not empty first\r\n            if (groupStack.length < 1)\r\n            {\r\n                console.warn(\r\n                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'\r\n                );\r\n                break;\r\n            }\r\n\r\n            // Return to previous recursive state\r\n            curGroupState = groupStack.pop();\r\n            continue;\r\n        }\r\n\r\n        // Get current layer and advance iterator\r\n        var curi = curGroupState.layers[curGroupState.i];\r\n        curGroupState.i++;\r\n\r\n        if (curi.type !== 'imagelayer')\r\n        {\r\n            if (curi.type === 'group')\r\n            {\r\n                // Compute next state inherited from group\r\n                var nextGroupState = CreateGroupLayer(json, curi, curGroupState);\r\n\r\n                // Preserve current state before recursing\r\n                groupStack.push(curGroupState);\r\n                curGroupState = nextGroupState;\r\n            }\r\n\r\n            // Skip this layer OR 'recurse' (iterative style) into the group\r\n            continue;\r\n        }\r\n\r\n        var layerOffsetX = GetFastValue(curi, 'offsetx', 0) + GetFastValue(curi, 'startx', 0);\r\n        var layerOffsetY = GetFastValue(curi, 'offsety', 0) + GetFastValue(curi, 'starty', 0);\r\n        images.push({\r\n            name: (curGroupState.name + curi.name),\r\n            image: curi.image,\r\n            x: (curGroupState.x + layerOffsetX + curi.x),\r\n            y: (curGroupState.y + layerOffsetY + curi.y),\r\n            alpha: (curGroupState.opacity * curi.opacity),\r\n            visible: (curGroupState.visible && curi.visible),\r\n            properties: GetFastValue(curi, 'properties', {})\r\n        });\r\n    }\r\n\r\n    return images;\r\n};\r\n\r\nmodule.exports = ParseImageLayers;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar ParseObject = require('./ParseObject');\r\nvar ObjectLayer = require('../../mapdata/ObjectLayer');\r\nvar CreateGroupLayer = require('./CreateGroupLayer');\r\n\r\n/**\r\n * Parses a Tiled JSON object into an array of ObjectLayer objects.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseObjectLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n *\r\n * @return {array} An array of all object layers in the tilemap as `ObjectLayer`s.\r\n */\r\nvar ParseObjectLayers = function (json)\r\n{\r\n    var objectLayers = [];\r\n\r\n    // State inherited from a parent group\r\n    var groupStack = [];\r\n    var curGroupState = CreateGroupLayer(json);\r\n\r\n    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)\r\n    {\r\n        if (curGroupState.i >= curGroupState.layers.length)\r\n        {\r\n            // Ensure recursion stack is not empty first\r\n            if (groupStack.length < 1)\r\n            {\r\n                console.warn(\r\n                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'\r\n                );\r\n                break;\r\n            }\r\n\r\n            // Return to previous recursive state\r\n            curGroupState = groupStack.pop();\r\n            continue;\r\n        }\r\n\r\n        // Get current layer and advance iterator\r\n        var curo = curGroupState.layers[curGroupState.i];\r\n        curGroupState.i++;\r\n\r\n        // Modify inherited properties\r\n        curo.opacity *= curGroupState.opacity;\r\n        curo.visible = curGroupState.visible && curo.visible;\r\n\r\n        if (curo.type !== 'objectgroup')\r\n        {\r\n            if (curo.type === 'group')\r\n            {\r\n                // Compute next state inherited from group\r\n                var nextGroupState = CreateGroupLayer(json, curo, curGroupState);\r\n\r\n                // Preserve current state before recursing\r\n                groupStack.push(curGroupState);\r\n                curGroupState = nextGroupState;\r\n            }\r\n\r\n            // Skip this layer OR 'recurse' (iterative style) into the group\r\n            continue;\r\n        }\r\n\r\n        curo.name = curGroupState.name + curo.name;\r\n        var offsetX = curGroupState.x + GetFastValue(curo, 'startx', 0) + GetFastValue(curo, 'offsetx', 0);\r\n        var offsetY = curGroupState.y + GetFastValue(curo, 'starty', 0) + GetFastValue(curo, 'offsety', 0);\r\n\r\n        var objects = [];\r\n        for (var j = 0; j < curo.objects.length; j++)\r\n        {\r\n            var parsedObject = ParseObject(curo.objects[j], offsetX, offsetY);\r\n\r\n            objects.push(parsedObject);\r\n        }\r\n\r\n        var objectLayer = new ObjectLayer(curo);\r\n        objectLayer.objects = objects;\r\n\r\n        objectLayers.push(objectLayer);\r\n    }\r\n\r\n    return objectLayers;\r\n};\r\n\r\nmodule.exports = ParseObjectLayers;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * @classdesc\r\n * A class for representing a Tiled object layer in a map. This mirrors the structure of a Tiled\r\n * object layer, except:\r\n *  - \"x\" & \"y\" properties are ignored since these cannot be changed in Tiled.\r\n *  - \"offsetx\" & \"offsety\" are applied to the individual object coordinates directly, so they\r\n *    are ignored as well.\r\n *  - \"draworder\" is ignored.\r\n *\r\n * @class ObjectLayer\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Tilemaps.ObjectLayerConfig} [config] - The data for the layer from the Tiled JSON object.\r\n */\r\nvar ObjectLayer = new Class({\r\n\r\n    initialize:\r\n\r\n    function ObjectLayer (config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        /**\r\n         * The name of the Object Layer.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', 'object layer');\r\n\r\n        /**\r\n         * The opacity of the layer, between 0 and 1.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#opacity\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.opacity = GetFastValue(config, 'opacity', 1);\r\n\r\n        /**\r\n         * The custom properties defined on the Object Layer, keyed by their name.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = GetFastValue(config, 'properties', {});\r\n\r\n        /**\r\n         * The type of each custom property defined on the Object Layer, keyed by its name.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#propertyTypes\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.propertyTypes = GetFastValue(config, 'propertytypes', {});\r\n\r\n        /**\r\n         * The type of the layer, which should be `objectgroup`.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = GetFastValue(config, 'type', 'objectgroup');\r\n\r\n        /**\r\n         * Whether the layer is shown (`true`) or hidden (`false`).\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#visible\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.visible = GetFastValue(config, 'visible', true);\r\n\r\n        /**\r\n         * An array of all objects on this Object Layer.\r\n         *\r\n         * Each Tiled object corresponds to a JavaScript object in this array. It has an `id` (unique),\r\n         * `name` (as assigned in Tiled), `type` (as assigned in Tiled), `rotation` (in clockwise degrees),\r\n         * `properties` (if any), `visible` state (`true` if visible, `false` otherwise),\r\n         * `x` and `y` coordinates (in pixels, relative to the tilemap), and a `width` and `height` (in pixels).\r\n         *\r\n         * An object tile has a `gid` property (GID of the represented tile), a `flippedHorizontal` property,\r\n         * a `flippedVertical` property, and `flippedAntiDiagonal` property.\r\n         * The {@link http://docs.mapeditor.org/en/latest/reference/tmx-map-format/|Tiled documentation} contains\r\n         * information on flipping and rotation.\r\n         *\r\n         * Polylines have a `polyline` property, which is an array of objects corresponding to points,\r\n         * where each point has an `x` property and a `y` property. Polygons have an identically structured\r\n         * array in their `polygon` property. Text objects have a `text` property with the text's properties.\r\n         *\r\n         * Rectangles and ellipses have a `rectangle` or `ellipse` property set to `true`.\r\n         *\r\n         * @name Phaser.Tilemaps.ObjectLayer#objects\r\n         * @type {Phaser.Types.Tilemaps.TiledObject[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.objects = GetFastValue(config, 'objects', []);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ObjectLayer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Base64Decode = require('./Base64Decode');\r\nvar CONST = require('../../const/ORIENTATION_CONST');\r\nvar CreateGroupLayer = require('./CreateGroupLayer');\r\nvar FromOrientationString = require('../FromOrientationString');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar LayerData = require('../../mapdata/LayerData');\r\nvar ParseGID = require('./ParseGID');\r\nvar Tile = require('../../Tile');\r\n\r\n/**\r\n * Parses all tilemap layers in a Tiled JSON object into new LayerData objects.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseTileLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled (see {@link Phaser.Tilemaps.Parsers.Tiled.ParseJSONTiled}).\r\n *\r\n * @return {Phaser.Tilemaps.LayerData[]} - An array of LayerData objects, one for each entry in\r\n * json.layers with the type 'tilelayer'.\r\n */\r\nvar ParseTileLayers = function (json, insertNull)\r\n{\r\n    var infiniteMap = GetFastValue(json, 'infinite', false);\r\n    var tileLayers = [];\r\n\r\n    // State inherited from a parent group\r\n    var groupStack = [];\r\n    var curGroupState = CreateGroupLayer(json);\r\n\r\n    while (curGroupState.i < curGroupState.layers.length || groupStack.length > 0)\r\n    {\r\n        if (curGroupState.i >= curGroupState.layers.length)\r\n        {\r\n            // Ensure recursion stack is not empty first\r\n            if (groupStack.length < 1)\r\n            {\r\n                console.warn(\r\n                    'TilemapParser.parseTiledJSON - Invalid layer group hierarchy'\r\n                );\r\n                break;\r\n            }\r\n\r\n            // Return to previous recursive state\r\n            curGroupState = groupStack.pop();\r\n            continue;\r\n        }\r\n\r\n        var curl = curGroupState.layers[curGroupState.i];\r\n        curGroupState.i++;\r\n\r\n        if (curl.type !== 'tilelayer')\r\n        {\r\n            if (curl.type === 'group')\r\n            {\r\n                // Compute next state inherited from group\r\n                var nextGroupState = CreateGroupLayer(json, curl, curGroupState);\r\n\r\n                // Preserve current state before recursing\r\n                groupStack.push(curGroupState);\r\n                curGroupState = nextGroupState;\r\n            }\r\n\r\n            // Skip this layer OR 'recurse' (iterative style) into the group\r\n            continue;\r\n        }\r\n\r\n        // Base64 decode data if necessary. NOTE: uncompressed base64 only.\r\n        if (curl.compression)\r\n        {\r\n            console.warn(\r\n                'TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer \\''\r\n                + curl.name + '\\''\r\n            );\r\n            continue;\r\n        }\r\n        else if (curl.encoding && curl.encoding === 'base64')\r\n        {\r\n            // Chunks for an infinite map\r\n            if (curl.chunks)\r\n            {\r\n                for (var i = 0; i < curl.chunks.length; i++)\r\n                {\r\n                    curl.chunks[i].data = Base64Decode(curl.chunks[i].data);\r\n                }\r\n            }\r\n\r\n            // Non-infinite map data\r\n            if (curl.data)\r\n            {\r\n                curl.data = Base64Decode(curl.data);\r\n            }\r\n\r\n            delete curl.encoding; // Allow the same map to be parsed multiple times\r\n        }\r\n\r\n        //  This is an array containing the tile indexes, one after the other. -1 = no tile,\r\n        //  everything else = the tile index (starting at 1 for Tiled, 0 for CSV) If the map\r\n        //  contains multiple tilesets then the indexes are relative to that which the set starts\r\n        //  from. Need to set which tileset in the cache = which tileset in the JSON, if you do this\r\n        //  manually it means you can use the same map data but a new tileset.\r\n\r\n        var layerData;\r\n        var gidInfo;\r\n        var tile;\r\n        var blankTile;\r\n\r\n        var output = [];\r\n        var x = 0;\r\n\r\n        if (infiniteMap)\r\n        {\r\n            var layerOffsetX = (GetFastValue(curl, 'startx', 0) + curl.x);\r\n            var layerOffsetY = (GetFastValue(curl, 'starty', 0) + curl.y);\r\n\r\n            layerData = new LayerData({\r\n                name: (curGroupState.name + curl.name),\r\n                x: (curGroupState.x + GetFastValue(curl, 'offsetx', 0) + layerOffsetX * json.tilewidth),\r\n                y: (curGroupState.y + GetFastValue(curl, 'offsety', 0) + layerOffsetY * json.tileheight),\r\n                width: curl.width,\r\n                height: curl.height,\r\n                tileWidth: json.tilewidth,\r\n                tileHeight: json.tileheight,\r\n                alpha: (curGroupState.opacity * curl.opacity),\r\n                visible: (curGroupState.visible && curl.visible),\r\n                properties: GetFastValue(curl, 'properties', []),\r\n                orientation: FromOrientationString(json.orientation)\r\n            });\r\n\r\n            if (layerData.orientation === CONST.HEXAGONAL)\r\n            {\r\n                layerData.hexSideLength = json.hexsidelength;\r\n            }\r\n\r\n            for (var c = 0; c < curl.height; c++)\r\n            {\r\n                output.push([ null ]);\r\n\r\n                for (var j = 0; j < curl.width; j++)\r\n                {\r\n                    output[c][j] = null;\r\n                }\r\n            }\r\n\r\n            for (c = 0, len = curl.chunks.length; c < len; c++)\r\n            {\r\n                var chunk = curl.chunks[c];\r\n\r\n                var offsetX = (chunk.x - layerOffsetX);\r\n                var offsetY = (chunk.y - layerOffsetY);\r\n\r\n                var y = 0;\r\n\r\n                for (var t = 0, len2 = chunk.data.length; t < len2; t++)\r\n                {\r\n                    var newOffsetX = x + offsetX;\r\n                    var newOffsetY = y + offsetY;\r\n\r\n                    gidInfo = ParseGID(chunk.data[t]);\r\n\r\n                    //  index, x, y, width, height\r\n                    if (gidInfo.gid > 0)\r\n                    {\r\n                        tile = new Tile(layerData, gidInfo.gid, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);\r\n\r\n                        // Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal\r\n                        // propeties into flipX, flipY and rotation\r\n                        tile.rotation = gidInfo.rotation;\r\n                        tile.flipX = gidInfo.flipped;\r\n\r\n                        output[newOffsetY][newOffsetX] = tile;\r\n                    }\r\n                    else\r\n                    {\r\n                        blankTile = insertNull\r\n                            ? null\r\n                            : new Tile(layerData, -1, newOffsetX, newOffsetY, json.tilewidth, json.tileheight);\r\n\r\n                        output[newOffsetY][newOffsetX] = blankTile;\r\n                    }\r\n\r\n                    x++;\r\n\r\n                    if (x === chunk.width)\r\n                    {\r\n                        y++;\r\n                        x = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            layerData = new LayerData({\r\n                name: (curGroupState.name + curl.name),\r\n                x: (curGroupState.x + GetFastValue(curl, 'offsetx', 0) + curl.x),\r\n                y: (curGroupState.y + GetFastValue(curl, 'offsety', 0) + curl.y),\r\n                width: curl.width,\r\n                height: curl.height,\r\n                tileWidth: json.tilewidth,\r\n                tileHeight: json.tileheight,\r\n                alpha: (curGroupState.opacity * curl.opacity),\r\n                visible: (curGroupState.visible && curl.visible),\r\n                properties: GetFastValue(curl, 'properties', []),\r\n                orientation: FromOrientationString(json.orientation)\r\n            });\r\n\r\n            if (layerData.orientation === CONST.HEXAGONAL)\r\n            {\r\n                layerData.hexSideLength = json.hexsidelength;\r\n            }\r\n            var row = [];\r\n\r\n            //  Loop through the data field in the JSON.\r\n            for (var k = 0, len = curl.data.length; k < len; k++)\r\n            {\r\n                gidInfo = ParseGID(curl.data[k]);\r\n\r\n                //  index, x, y, width, height\r\n                if (gidInfo.gid > 0)\r\n                {\r\n                    tile = new Tile(layerData, gidInfo.gid, x, output.length, json.tilewidth, json.tileheight);\r\n\r\n                    // Turning Tiled's FlippedHorizontal, FlippedVertical and FlippedAntiDiagonal\r\n                    // propeties into flipX, flipY and rotation\r\n                    tile.rotation = gidInfo.rotation;\r\n                    tile.flipX = gidInfo.flipped;\r\n\r\n                    row.push(tile);\r\n                }\r\n                else\r\n                {\r\n                    blankTile = insertNull\r\n                        ? null\r\n                        : new Tile(layerData, -1, x, output.length, json.tilewidth, json.tileheight);\r\n                    row.push(blankTile);\r\n                }\r\n\r\n                x++;\r\n\r\n                if (x === curl.width)\r\n                {\r\n                    output.push(row);\r\n                    x = 0;\r\n                    row = [];\r\n                }\r\n            }\r\n        }\r\n\r\n        layerData.data = output;\r\n        tileLayers.push(layerData);\r\n    }\r\n\r\n    return tileLayers;\r\n};\r\n\r\nmodule.exports = ParseTileLayers;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Decode base-64 encoded data, for example as exported by Tiled.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.Base64Decode\r\n * @since 3.0.0\r\n *\r\n * @param {object} data - Base-64 encoded data to decode.\r\n *\r\n * @return {array} Array containing the decoded bytes.\r\n */\r\nvar Base64Decode = function (data)\r\n{\r\n    var binaryString = window.atob(data);\r\n    var len = binaryString.length;\r\n    var bytes = new Array(len / 4);\r\n\r\n    // Interpret binaryString as an array of bytes representing little-endian encoded uint32 values.\r\n    for (var i = 0; i < len; i += 4)\r\n    {\r\n        bytes[i / 4] = (\r\n            binaryString.charCodeAt(i) |\r\n            binaryString.charCodeAt(i + 1) << 8 |\r\n            binaryString.charCodeAt(i + 2) << 16 |\r\n            binaryString.charCodeAt(i + 3) << 24\r\n        ) >>> 0;\r\n    }\r\n\r\n    return bytes;\r\n};\r\n\r\nmodule.exports = Base64Decode;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tileset = require('../../Tileset');\r\nvar ImageCollection = require('../../ImageCollection');\r\nvar ParseObject = require('./ParseObject');\r\nvar ParseWangsets = require('./ParseWangsets');\r\n\r\n/**\r\n * Tilesets and Image Collections.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Tiled.ParseTilesets\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Tiled JSON data.\r\n *\r\n * @return {object} An object containing the tileset and image collection data.\r\n */\r\nvar ParseTilesets = function (json)\r\n{\r\n    var tilesets = [];\r\n    var imageCollections = [];\r\n    var lastSet = null;\r\n    var stringID;\r\n\r\n    for (var i = 0; i < json.tilesets.length; i++)\r\n    {\r\n        //  name, firstgid, width, height, margin, spacing, properties\r\n        var set = json.tilesets[i];\r\n\r\n        if (set.source)\r\n        {\r\n            console.warn('External tilesets unsupported. Use Embed Tileset and re-export');\r\n        }\r\n        else if (set.image)\r\n        {\r\n            var newSet = new Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing);\r\n\r\n            if (json.version > 1)\r\n            {\r\n                var datas = undefined;\r\n                var props = undefined;\r\n\r\n                if (Array.isArray(set.tiles))\r\n                {\r\n                    datas = datas || {};\r\n                    props = props || {};\r\n\r\n                    // Tiled 1.2+\r\n                    for (var t = 0; t < set.tiles.length; t++)\r\n                    {\r\n                        var tile = set.tiles[t];\r\n\r\n                        //  Convert tileproperties.\r\n                        if (tile.properties)\r\n                        {\r\n                            var newPropData = {};\r\n\r\n                            tile.properties.forEach(function (propData)\r\n                            {\r\n                                newPropData[propData['name']] = propData['value'];\r\n                            });\r\n\r\n                            props[tile.id] = newPropData;\r\n                        }\r\n\r\n                        //  Convert objectgroup\r\n                        if (tile.objectgroup)\r\n                        {\r\n                            (datas[tile.id] || (datas[tile.id] = {})).objectgroup = tile.objectgroup;\r\n\r\n                            if (tile.objectgroup.objects)\r\n                            {\r\n                                var parsedObjects2 = tile.objectgroup.objects.map(function (obj)\r\n                                {\r\n                                    return ParseObject(obj);\r\n                                });\r\n\r\n                                datas[tile.id].objectgroup.objects = parsedObjects2;\r\n                            }\r\n                        }\r\n\r\n                        // Copy animation data\r\n                        if (tile.animation)\r\n                        {\r\n                            (datas[tile.id] || (datas[tile.id] = {})).animation = tile.animation;\r\n                        }\r\n\r\n                        // Copy tile `type` field\r\n                        // (see https://doc.mapeditor.org/en/latest/manual/custom-properties/#typed-tiles).\r\n                        if (tile.type)\r\n                        {\r\n                            (datas[tile.id] || (datas[tile.id] = {})).type = tile.type;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (Array.isArray(set.wangsets))\r\n                {\r\n                    datas = datas || {};\r\n                    props = props || {};\r\n\r\n                    ParseWangsets(set.wangsets, datas);\r\n                }\r\n\r\n                if (datas) // Implies also props is set.\r\n                {\r\n                    newSet.tileData = datas;\r\n                    newSet.tileProperties = props;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // Tiled 1\r\n\r\n                // Properties stored per-tile in object with string indexes starting at \"0\"\r\n                if (set.tileproperties)\r\n                {\r\n                    newSet.tileProperties = set.tileproperties;\r\n                }\r\n\r\n                // Object & terrain shapes stored per-tile in object with string indexes starting at \"0\"\r\n                if (set.tiles)\r\n                {\r\n                    newSet.tileData = set.tiles;\r\n\r\n                    // Parse the objects into Phaser format to match handling of other Tiled objects\r\n                    for (stringID in newSet.tileData)\r\n                    {\r\n                        var objectGroup = newSet.tileData[stringID].objectgroup;\r\n\r\n                        if (objectGroup && objectGroup.objects)\r\n                        {\r\n                            var parsedObjects1 = objectGroup.objects.map(function (obj)\r\n                            {\r\n                                return ParseObject(obj);\r\n                            });\r\n\r\n                            newSet.tileData[stringID].objectgroup.objects = parsedObjects1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // For a normal sliced tileset the row/count/size information is computed when updated.\r\n            // This is done (again) after the image is set.\r\n            newSet.updateTileData(set.imagewidth, set.imageheight);\r\n\r\n            tilesets.push(newSet);\r\n        }\r\n        else\r\n        {\r\n            var newCollection = new ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);\r\n\r\n            var maxId = 0;\r\n\r\n            for (t = 0; t < set.tiles.length; t++)\r\n            {\r\n                tile = set.tiles[t];\r\n\r\n                var image = tile.image;\r\n                var tileId = parseInt(tile.id, 10);\r\n                var gid = set.firstgid + tileId;\r\n                newCollection.addImage(gid, image);\r\n\r\n                maxId = Math.max(tileId, maxId);\r\n            }\r\n\r\n            newCollection.maxId = maxId;\r\n\r\n            imageCollections.push(newCollection);\r\n        }\r\n\r\n        //  We've got a new Tileset, so set the lastgid into the previous one\r\n        if (lastSet)\r\n        {\r\n            lastSet.lastgid = set.firstgid - 1;\r\n        }\r\n\r\n        lastSet = set;\r\n    }\r\n\r\n    return { tilesets: tilesets, imageCollections: imageCollections };\r\n};\r\n\r\nmodule.exports = ParseTilesets;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * An Image Collection is a special Tile Set containing multiple images, with no slicing into each image.\r\n *\r\n * Image Collections are normally created automatically when Tiled data is loaded.\r\n *\r\n * @class ImageCollection\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n * \r\n * @param {string} name - The name of the image collection in the map data.\r\n * @param {number} firstgid - The first image index this image collection contains.\r\n * @param {number} [width=32] - Width of widest image (in pixels).\r\n * @param {number} [height=32] - Height of tallest image (in pixels).\r\n * @param {number} [margin=0] - The margin around all images in the collection (in pixels).\r\n * @param {number} [spacing=0] - The spacing between each image in the collection (in pixels).\r\n * @param {object} [properties={}] - Custom Image Collection properties.\r\n */\r\nvar ImageCollection = new Class({\r\n\r\n    initialize:\r\n\r\n    function ImageCollection (name, firstgid, width, height, margin, spacing, properties)\r\n    {\r\n        if (width === undefined || width <= 0) { width = 32; }\r\n        if (height === undefined || height <= 0) { height = 32; }\r\n        if (margin === undefined) { margin = 0; }\r\n        if (spacing === undefined) { spacing = 0; }\r\n\r\n        /**\r\n         * The name of the Image Collection.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n        */\r\n        this.name = name;\r\n\r\n        /**\r\n         * The Tiled firstgid value.\r\n         * This is the starting index of the first image index this Image Collection contains.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#firstgid\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.firstgid = firstgid | 0;\r\n\r\n        /**\r\n         * The width of the widest image (in pixels).\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageWidth\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.imageWidth = width | 0;\r\n\r\n        /**\r\n         * The height of the tallest image (in pixels).\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageHeight\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.imageHeight = height | 0;\r\n\r\n        /**\r\n         * The margin around the images in the collection (in pixels).\r\n         * Use `setSpacing` to change.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageMarge\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.imageMargin = margin | 0;\r\n\r\n        /**\r\n         * The spacing between each image in the collection (in pixels).\r\n         * Use `setSpacing` to change.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#imageSpacing\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.imageSpacing = spacing | 0;\r\n\r\n        /**\r\n         * Image Collection-specific properties that are typically defined in the Tiled editor.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = properties || {};\r\n\r\n        /**\r\n         * The cached images that are a part of this collection.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#images\r\n         * @type {array}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.images = [];\r\n\r\n        /**\r\n         * The total number of images in the image collection.\r\n         * \r\n         * @name Phaser.Tilemaps.ImageCollection#total\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.total = 0;\r\n    },\r\n\r\n    /**\r\n     * Returns true if and only if this image collection contains the given image index.\r\n     *\r\n     * @method Phaser.Tilemaps.ImageCollection#containsImageIndex\r\n     * @since 3.0.0\r\n     * \r\n     * @param {number} imageIndex - The image index to search for.\r\n     * \r\n     * @return {boolean} True if this Image Collection contains the given index.\r\n     */\r\n    containsImageIndex: function (imageIndex)\r\n    {\r\n        return (imageIndex >= this.firstgid && imageIndex < (this.firstgid + this.total));\r\n    },\r\n\r\n    /**\r\n     * Add an image to this Image Collection.\r\n     *\r\n     * @method Phaser.Tilemaps.ImageCollection#addImage\r\n     * @since 3.0.0\r\n     * \r\n     * @param {number} gid - The gid of the image in the Image Collection.\r\n     * @param {string} image - The the key of the image in the Image Collection and in the cache.\r\n     *\r\n     * @return {Phaser.Tilemaps.ImageCollection} This ImageCollection object.\r\n     */\r\n    addImage: function (gid, image)\r\n    {\r\n        this.images.push({ gid: gid, image: image });\r\n        this.total++;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ImageCollection;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Formats = require('../../Formats');\r\nvar MapData = require('../../mapdata/MapData');\r\nvar ParseTileLayers = require('./ParseTileLayers');\r\nvar ParseTilesets = require('./ParseTilesets');\r\n\r\n/**\r\n * Parses a Weltmeister JSON object into a new MapData object.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Impact.ParseWeltmeister\r\n * @since 3.0.0\r\n *\r\n * @param {string} name - The name of the tilemap, used to set the name on the MapData.\r\n * @param {object} json - The Weltmeister JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty\r\n * location will get a Tile object with an index of -1. If you've a large sparsely populated map and\r\n * the tile data doesn't need to change then setting this value to `true` will help with memory\r\n * consumption. However if your map is small or you need to update the tiles dynamically, then leave\r\n * the default value set.\r\n *\r\n * @return {?Phaser.Tilemaps.MapData} The created MapData object, or `null` if the data can't be parsed.\r\n */\r\nvar ParseWeltmeister = function (name, json, insertNull)\r\n{\r\n    if (json.layer.length === 0)\r\n    {\r\n        console.warn('No layers found in the Weltmeister map: ' + name);\r\n        return null;\r\n    }\r\n\r\n    var width = 0;\r\n    var height = 0;\r\n\r\n    for (var i = 0; i < json.layer.length; i++)\r\n    {\r\n        if (json.layer[i].width > width) { width = json.layer[i].width; }\r\n        if (json.layer[i].height > height) { height = json.layer[i].height; }\r\n    }\r\n\r\n    var mapData = new MapData({\r\n        width: width,\r\n        height: height,\r\n        name: name,\r\n        tileWidth: json.layer[0].tilesize,\r\n        tileHeight: json.layer[0].tilesize,\r\n        format: Formats.WELTMEISTER\r\n    });\r\n\r\n    mapData.layers = ParseTileLayers(json, insertNull);\r\n    mapData.tilesets = ParseTilesets(json);\r\n\r\n    return mapData;\r\n};\r\n\r\nmodule.exports = ParseWeltmeister;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar LayerData = require('../../mapdata/LayerData');\r\nvar Tile = require('../../Tile');\r\n\r\n/**\r\n * Parses all tilemap layers in an Impact JSON object into new LayerData objects.\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Impact.ParseTileLayers\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Impact JSON object.\r\n * @param {boolean} insertNull - Controls how empty tiles, tiles with an index of -1, in the map\r\n * data are handled (see {@link Phaser.Tilemaps.Parsers.Tiled.ParseJSONTiled}).\r\n *\r\n * @return {Phaser.Tilemaps.LayerData[]} - An array of LayerData objects, one for each entry in\r\n * json.layers with the type 'tilelayer'.\r\n */\r\nvar ParseTileLayers = function (json, insertNull)\r\n{\r\n    var tileLayers = [];\r\n\r\n    for (var i = 0; i < json.layer.length; i++)\r\n    {\r\n        var layer = json.layer[i];\r\n\r\n        var layerData = new LayerData({\r\n            name: layer.name,\r\n            width: layer.width,\r\n            height: layer.height,\r\n            tileWidth: layer.tilesize,\r\n            tileHeight: layer.tilesize,\r\n            visible: layer.visible === 1\r\n        });\r\n\r\n        var row = [];\r\n        var tileGrid = [];\r\n\r\n        //  Loop through the data field in the JSON. This is a 2D array containing the tile indexes,\r\n        //  one after the other. The indexes are relative to the tileset that contains the tile.\r\n        for (var y = 0; y < layer.data.length; y++)\r\n        {\r\n            for (var x = 0; x < layer.data[y].length; x++)\r\n            {\r\n                // In Weltmeister, 0 = no tile, but the Tilemap API expects -1 = no tile.\r\n                var index = layer.data[y][x] - 1;\r\n\r\n                var tile;\r\n\r\n                if (index > -1)\r\n                {\r\n                    tile = new Tile(layerData, index, x, y, layer.tilesize, layer.tilesize);\r\n                }\r\n                else\r\n                {\r\n                    tile = insertNull\r\n                        ? null\r\n                        : new Tile(layerData, -1, x, y, layer.tilesize, layer.tilesize);\r\n                }\r\n\r\n                row.push(tile);\r\n            }\r\n\r\n            tileGrid.push(row);\r\n            row = [];\r\n        }\r\n\r\n        layerData.data = tileGrid;\r\n\r\n        tileLayers.push(layerData);\r\n    }\r\n\r\n    return tileLayers;\r\n};\r\n\r\nmodule.exports = ParseTileLayers;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Tileset = require('../../Tileset');\r\n\r\n/**\r\n * Tilesets and Image Collections\r\n *\r\n * @function Phaser.Tilemaps.Parsers.Impact.ParseTilesets\r\n * @since 3.0.0\r\n *\r\n * @param {object} json - The Impact JSON data.\r\n *\r\n * @return {array} An array of Tilesets.\r\n */\r\nvar ParseTilesets = function (json)\r\n{\r\n    var tilesets = [];\r\n    var tilesetsNames = [];\r\n\r\n    for (var i = 0; i < json.layer.length; i++)\r\n    {\r\n        var layer = json.layer[i];\r\n\r\n        // A relative filepath to the source image (within Weltmeister) is used for the name\r\n        var tilesetName = layer.tilesetName;\r\n\r\n        // Only add unique tilesets that have a valid name. Collision layers will have a blank name.\r\n        if (tilesetName !== '' && tilesetsNames.indexOf(tilesetName) === -1)\r\n        {\r\n            tilesetsNames.push(tilesetName);\r\n\r\n            // Tiles are stored with an ID relative to the tileset, rather than a globally unique ID\r\n            // across all tilesets. Also, tilesets in Weltmeister have no margin or padding.\r\n            tilesets.push(new Tileset(tilesetName, 0, layer.tilesize, layer.tilesize, 0, 0));\r\n        }\r\n    }\r\n\r\n    return tilesets;\r\n};\r\n\r\nmodule.exports = ParseTilesets;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar DegToRad = require('../math/DegToRad');\r\nvar Formats = require('./Formats');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar LayerData = require('./mapdata/LayerData');\r\nvar ORIENTATION = require('./const/ORIENTATION_CONST');\r\nvar Rotate = require('../math/Rotate');\r\nvar SpliceOne = require('../utils/array/SpliceOne');\r\nvar Sprite = require('../gameobjects/sprite/Sprite');\r\nvar Tile = require('./Tile');\r\nvar TilemapComponents = require('./components');\r\nvar TilemapLayer = require('./TilemapLayer');\r\nvar Tileset = require('./Tileset');\r\n\r\n/**\r\n * @callback TilemapFilterCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} value - An object found in the filtered area.\r\n * @param {number} index - The index of the object within the array.\r\n * @param {Phaser.GameObjects.GameObject[]} array - An array of all the objects found.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The object.\r\n */\r\n\r\n/**\r\n * @callback TilemapFindCallback\r\n *\r\n * @param {Phaser.GameObjects.GameObject} value - An object found.\r\n * @param {number} index - The index of the object within the array.\r\n * @param {Phaser.GameObjects.GameObject[]} array - An array of all the objects found.\r\n *\r\n * @return {boolean} `true` if the callback should be invoked, otherwise `false`.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Tilemap is a container for Tilemap data. This isn't a display object, rather, it holds data\r\n * about the map and allows you to add tilesets and tilemap layers to it. A map can have one or\r\n * more tilemap layers, which are the display objects that actually render the tiles.\r\n *\r\n * The Tilemap data can be parsed from a Tiled JSON file, a CSV file or a 2D array. Tiled is a free\r\n * software package specifically for creating tile maps, and is available from:\r\n * http://www.mapeditor.org\r\n *\r\n * As of Phaser 3.50.0 the Tilemap API now supports the following types of map:\r\n *\r\n * 1) Orthogonal\r\n * 2) Isometric\r\n * 3) Hexagonal\r\n * 4) Staggered\r\n *\r\n * Prior to this release, only orthogonal maps were supported.\r\n *\r\n * Another large change in 3.50 was the consolidation of Tilemap Layers. Previously, you created\r\n * either a Static or Dynamic Tilemap Layer. However, as of 3.50 the features of both have been\r\n * merged and the API simplified, so now there is just the single `TilemapLayer` class.\r\n *\r\n * A Tilemap has handy methods for getting and manipulating the tiles within a layer, allowing\r\n * you to build or modify the tilemap data at runtime.\r\n *\r\n * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a\r\n * TilemapLayer may have its own unique tile size that overrides this.\r\n *\r\n * As of Phaser 3.21.0, if your tilemap includes layer groups (a feature of Tiled 1.2.0+) these\r\n * will be traversed and the following properties will impact children:\r\n *\r\n * - Opacity (blended with parent) and visibility (parent overrides child)\r\n * - Vertical and horizontal offset\r\n *\r\n * The grouping hierarchy is not preserved and all layers will be flattened into a single array.\r\n *\r\n * Group layers are parsed during Tilemap construction but are discarded after parsing so dynamic\r\n * layers will NOT continue to be affected by a parent.\r\n *\r\n * To avoid duplicate layer names, a layer that is a child of a group layer will have its parent\r\n * group name prepended with a '/'.  For example, consider a group called 'ParentGroup' with a\r\n * child called 'Layer 1'. In the Tilemap object, 'Layer 1' will have the name\r\n * 'ParentGroup/Layer 1'.\r\n *\r\n * @class Tilemap\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Tilemap belongs.\r\n * @param {Phaser.Tilemaps.MapData} mapData - A MapData instance containing Tilemap data.\r\n */\r\nvar Tilemap = new Class({\r\n\r\n    initialize:\r\n\r\n    function Tilemap (scene, mapData)\r\n    {\r\n        /**\r\n         * @name Phaser.Tilemaps.Tilemap#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The base width of a tile in pixels. Note that individual layers may have a different tile\r\n         * width.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tileWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileWidth = mapData.tileWidth;\r\n\r\n        /**\r\n         * The base height of a tile in pixels. Note that individual layers may have a different\r\n         * tile height.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tileHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.tileHeight = mapData.tileHeight;\r\n\r\n        /**\r\n         * The width of the map (in tiles).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = mapData.width;\r\n\r\n        /**\r\n         * The height of the map (in tiles).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = mapData.height;\r\n\r\n        /**\r\n         * The orientation of the map data (as specified in Tiled), usually 'orthogonal'.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#orientation\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.orientation = mapData.orientation;\r\n\r\n        /**\r\n         * The render (draw) order of the map data (as specified in Tiled), usually 'right-down'.\r\n         *\r\n         * The draw orders are:\r\n         *\r\n         * right-down\r\n         * left-down\r\n         * right-up\r\n         * left-up\r\n         *\r\n         * This can be changed via the `setRenderOrder` method.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#renderOrder\r\n         * @type {string}\r\n         * @since 3.12.0\r\n         */\r\n        this.renderOrder = mapData.renderOrder;\r\n\r\n        /**\r\n         * The format of the map data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#format\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.format = mapData.format;\r\n\r\n        /**\r\n         * The version of the map data (as specified in Tiled, usually 1).\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#version\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.version = mapData.version;\r\n\r\n        /**\r\n         * Map specific properties as specified in Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#properties\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = mapData.properties;\r\n\r\n        /**\r\n         * The width of the map in pixels based on width * tileWidth.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#widthInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.widthInPixels = mapData.widthInPixels;\r\n\r\n        /**\r\n         * The height of the map in pixels based on height * tileHeight.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#heightInPixels\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.heightInPixels = mapData.heightInPixels;\r\n\r\n        /**\r\n         * A collection of Images, as parsed from Tiled map data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#imageCollections\r\n         * @type {Phaser.Tilemaps.ImageCollection[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.imageCollections = mapData.imageCollections;\r\n\r\n        /**\r\n         * An array of Tiled Image Layers.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#images\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.images = mapData.images;\r\n\r\n        /**\r\n         * An array of Tilemap layer data.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#layers\r\n         * @type {Phaser.Tilemaps.LayerData[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.layers = mapData.layers;\r\n\r\n        /**\r\n         * An array of Tilesets used in the map.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#tilesets\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.tilesets = mapData.tilesets;\r\n\r\n        /**\r\n         * An array of ObjectLayer instances parsed from Tiled object layers.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#objects\r\n         * @type {Phaser.Tilemaps.ObjectLayer[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.objects = mapData.objects;\r\n\r\n        /**\r\n         * The index of the currently selected LayerData object.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#currentLayerIndex\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentLayerIndex = 0;\r\n\r\n        /**\r\n         * The length of the horizontal sides of the hexagon.\r\n         * Only used for hexagonal orientation Tilemaps.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#hexSideLength\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.hexSideLength = mapData.hexSideLength;\r\n\r\n        var orientation = this.orientation;\r\n\r\n        /**\r\n         * Functions used to handle world to tile, and tile to world, conversion.\r\n         * Cached here for internal use by public methods such as `worldToTileXY`, etc.\r\n         *\r\n         * @name Phaser.Tilemaps.Tilemap#_convert\r\n         * @private\r\n         * @type {object}\r\n         * @since 3.50.0\r\n         */\r\n        this._convert = {\r\n            WorldToTileXY: TilemapComponents.GetWorldToTileXYFunction(orientation),\r\n            WorldToTileX: TilemapComponents.GetWorldToTileXFunction(orientation),\r\n            WorldToTileY: TilemapComponents.GetWorldToTileYFunction(orientation),\r\n            TileToWorldXY: TilemapComponents.GetTileToWorldXYFunction(orientation),\r\n            TileToWorldX: TilemapComponents.GetTileToWorldXFunction(orientation),\r\n            TileToWorldY: TilemapComponents.GetTileToWorldYFunction(orientation)\r\n        };\r\n    },\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    createBlankDynamicLayer: function (name, tileset, x, y, width, height, tileWidth, tileHeight)\r\n    {\r\n        console.warn('createBlankDynamicLayer is deprecated. Use createBlankLayer');\r\n\r\n        return this.createBlankLayer(name, tileset, x, y, width, height, tileWidth, tileHeight);\r\n    },\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    createDynamicLayer: function (layerID, tileset, x, y)\r\n    {\r\n        console.warn('createDynamicLayer is deprecated. Use createLayer');\r\n\r\n        return this.createLayer(layerID, tileset, x, y);\r\n    },\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    createStaticLayer: function (layerID, tileset, x, y)\r\n    {\r\n        console.warn('createStaticLayer is deprecated. Use createLayer');\r\n\r\n        return this.createLayer(layerID, tileset, x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets the rendering (draw) order of the tiles in this map.\r\n     *\r\n     * The default is 'right-down', meaning it will order the tiles starting from the top-left,\r\n     * drawing to the right and then moving down to the next row.\r\n     *\r\n     * The draw orders are:\r\n     *\r\n     * 0 = right-down\r\n     * 1 = left-down\r\n     * 2 = right-up\r\n     * 3 = left-up\r\n     *\r\n     * Setting the render order does not change the tiles or how they are stored in the layer,\r\n     * it purely impacts the order in which they are rendered.\r\n     *\r\n     * You can provide either an integer (0 to 3), or the string version of the order.\r\n     *\r\n     * Calling this method _after_ creating Tilemap Layers will **not** automatically\r\n     * update them to use the new render order. If you call this method after creating layers, use their\r\n     * own `setRenderOrder` methods to change them as needed.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setRenderOrder\r\n     * @since 3.12.0\r\n     *\r\n     * @param {(number|string)} renderOrder - The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setRenderOrder: function (renderOrder)\r\n    {\r\n        var orders = [ 'right-down', 'left-down', 'right-up', 'left-up' ];\r\n\r\n        if (typeof renderOrder === 'number')\r\n        {\r\n            renderOrder = orders[renderOrder];\r\n        }\r\n\r\n        if (orders.indexOf(renderOrder) > -1)\r\n        {\r\n            this.renderOrder = renderOrder;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.\r\n     * Note that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled\r\n     * editor.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#addTilesetImage\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} tilesetName - The name of the tileset as specified in the map data.\r\n     * @param {string} [key] - The key of the Phaser.Cache image used for this tileset. If\r\n     * `undefined` or `null` it will look for an image with a key matching the tilesetName parameter.\r\n     * @param {number} [tileWidth] - The width of the tile (in pixels) in the Tileset Image. If not\r\n     * given it will default to the map's tileWidth value, or the tileWidth specified in the Tiled\r\n     * JSON file.\r\n     * @param {number} [tileHeight] - The height of the tiles (in pixels) in the Tileset Image. If\r\n     * not given it will default to the map's tileHeight value, or the tileHeight specified in the\r\n     * Tiled JSON file.\r\n     * @param {number} [tileMargin] - The margin around the tiles in the sheet (in pixels). If not\r\n     * specified, it will default to 0 or the value specified in the Tiled JSON file.\r\n     * @param {number} [tileSpacing] - The spacing between each the tile in the sheet (in pixels).\r\n     * If not specified, it will default to 0 or the value specified in the Tiled JSON file.\r\n     * @param {number} [gid=0] - If adding multiple tilesets to a blank map, specify the starting\r\n     * GID this set will use here.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tileset} Returns the Tileset object that was created or updated, or null if it\r\n     * failed.\r\n     */\r\n    addTilesetImage: function (tilesetName, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid)\r\n    {\r\n        if (tilesetName === undefined) { return null; }\r\n        if (key === undefined || key === null) { key = tilesetName; }\r\n\r\n        if (!this.scene.sys.textures.exists(key))\r\n        {\r\n            console.warn('Invalid Tileset Image: ' + key);\r\n            return null;\r\n        }\r\n\r\n        var texture = this.scene.sys.textures.get(key);\r\n\r\n        var index = this.getTilesetIndex(tilesetName);\r\n\r\n        if (index === null && this.format === Formats.TILED_JSON)\r\n        {\r\n            console.warn('No data found for Tileset: ' + tilesetName);\r\n            return null;\r\n        }\r\n\r\n        var tileset = this.tilesets[index];\r\n\r\n        if (tileset)\r\n        {\r\n            tileset.setTileSize(tileWidth, tileHeight);\r\n            tileset.setSpacing(tileMargin, tileSpacing);\r\n            tileset.setImage(texture);\r\n\r\n            return tileset;\r\n        }\r\n\r\n        if (tileWidth === undefined) { tileWidth = this.tileWidth; }\r\n        if (tileHeight === undefined) { tileHeight = this.tileHeight; }\r\n        if (tileMargin === undefined) { tileMargin = 0; }\r\n        if (tileSpacing === undefined) { tileSpacing = 0; }\r\n        if (gid === undefined) { gid = 0; }\r\n\r\n        tileset = new Tileset(tilesetName, gid, tileWidth, tileHeight, tileMargin, tileSpacing);\r\n\r\n        tileset.setImage(texture);\r\n\r\n        this.tilesets.push(tileset);\r\n\r\n        return tileset;\r\n    },\r\n\r\n    /**\r\n     * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n     * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n     * information in the destination region.\r\n     *\r\n     * If no layer specified, the map's current layer is used. This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {number} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {number} width - The width of the area to copy, in tiles, not pixels.\r\n     * @param {number} height - The height of the area to copy, in tiles, not pixels.\r\n     * @param {number} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {number} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    copy: function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer !== null)\r\n        {\r\n            TilemapComponents.Copy(\r\n                srcTileX, srcTileY,\r\n                width, height,\r\n                destTileX, destTileY,\r\n                recalculateFaces, layer\r\n            );\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a new and empty Tilemap Layer. The currently selected layer in the map is set to this new layer.\r\n     *\r\n     * Prior to v3.50.0 this method was called `createBlankDynamicLayer`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createBlankLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of this layer. Must be unique within the map.\r\n     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n     * @param {number} [x=0] - The world x position where the top left of this layer will be placed.\r\n     * @param {number} [y=0] - The world y position where the top left of this layer will be placed.\r\n     * @param {number} [width] - The width of the layer in tiles. If not specified, it will default to the map's width.\r\n     * @param {number} [height] - The height of the layer in tiles. If not specified, it will default to the map's height.\r\n     * @param {number} [tileWidth] - The width of the tiles the layer uses for calculations. If not specified, it will default to the map's tileWidth.\r\n     * @param {number} [tileHeight] - The height of the tiles the layer uses for calculations. If not specified, it will default to the map's tileHeight.\r\n     *\r\n     * @return {?Phaser.Tilemaps.TilemapLayer} Returns the new layer that was created, or `null` if it failed.\r\n     */\r\n    createBlankLayer: function (name, tileset, x, y, width, height, tileWidth, tileHeight)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.width; }\r\n        if (height === undefined) { height = this.height; }\r\n        if (tileWidth === undefined) { tileWidth = this.tileWidth; }\r\n        if (tileHeight === undefined) { tileHeight = this.tileHeight; }\r\n\r\n        var index = this.getLayerIndex(name);\r\n\r\n        if (index !== null)\r\n        {\r\n            console.warn('Invalid Tilemap Layer ID: ' + name);\r\n            return null;\r\n        }\r\n\r\n        var layerData = new LayerData({\r\n            name: name,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height,\r\n            orientation: this.orientation\r\n        });\r\n\r\n        var row;\r\n\r\n        for (var tileY = 0; tileY < height; tileY++)\r\n        {\r\n            row = [];\r\n\r\n            for (var tileX = 0; tileX < width; tileX++)\r\n            {\r\n                row.push(new Tile(layerData, -1, tileX, tileY, tileWidth, tileHeight, this.tileWidth, this.tileHeight));\r\n            }\r\n\r\n            layerData.data.push(row);\r\n        }\r\n\r\n        this.layers.push(layerData);\r\n\r\n        this.currentLayerIndex = this.layers.length - 1;\r\n\r\n        var layer = new TilemapLayer(this.scene, this, this.currentLayerIndex, tileset, x, y);\r\n\r\n        layer.setRenderOrder(this.renderOrder);\r\n\r\n        this.scene.sys.displayList.add(layer);\r\n\r\n        return layer;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Tilemap Layer that renders the LayerData associated with the given\r\n     * `layerID`. The currently selected layer in the map is set to this new layer.\r\n     *\r\n     * The `layerID` is important. If you've created your map in Tiled then you can get this by\r\n     * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and\r\n     * look at the layers[].name value. Either way it must match.\r\n     *\r\n     * Prior to v3.50.0 this method was called `createDynamicLayer`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|string)} layerID - The layer array index value, or if a string is given, the layer name from Tiled.\r\n     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n     * @param {number} [x=0] - The x position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n     * @param {number} [y=0] - The y position to place the layer in the world. If not specified, it will default to the layer offset from Tiled or 0.\r\n     *\r\n     * @return {?Phaser.Tilemaps.TilemapLayer} Returns the new layer was created, or null if it failed.\r\n     */\r\n    createLayer: function (layerID, tileset, x, y)\r\n    {\r\n        var index = this.getLayerIndex(layerID);\r\n\r\n        if (index === null)\r\n        {\r\n            console.warn('Invalid Tilemap Layer ID: ' + layerID);\r\n\r\n            if (typeof layerID === 'string')\r\n            {\r\n                console.warn('Valid tilelayer names:\\n\\t' + this.getTileLayerNames().join(',\\n\\t'));\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        var layerData = this.layers[index];\r\n\r\n        // Check for an associated static or dynamic tilemap layer\r\n        if (layerData.tilemapLayer)\r\n        {\r\n            console.warn('Tilemap Layer ID already exists:' + layerID);\r\n            return null;\r\n        }\r\n\r\n        this.currentLayerIndex = index;\r\n\r\n        //  Default the x/y position to match Tiled layer offset, if it exists.\r\n\r\n        if (x === undefined)\r\n        {\r\n            x = layerData.x;\r\n        }\r\n\r\n        if (y === undefined)\r\n        {\r\n            y = layerData.y;\r\n        }\r\n\r\n        var layer = new TilemapLayer(this.scene, this, index, tileset, x, y);\r\n\r\n        layer.setRenderOrder(this.renderOrder);\r\n\r\n        this.scene.sys.displayList.add(layer);\r\n\r\n        return layer;\r\n    },\r\n\r\n    /**\r\n     * This method will iterate through all of the objects defined in a Tiled Object Layer and then\r\n     * convert the matching results into Phaser Game Objects (by default, Sprites)\r\n     *\r\n     * Objects are matched on one of 3 criteria: The Object ID, the Object GID or the Object Name.\r\n     *\r\n     * Within Tiled, Object IDs are unique per Object. Object GIDs, however, are shared by all objects\r\n     * using the same image. Finally, Object Names are strings and the same name can be used on multiple\r\n     * Objects in Tiled, they do not have to be unique.\r\n     *\r\n     * You set the configuration parameter accordingly, based on which type of criteria you wish\r\n     * to match against. For example, to convert all items on an Object Layer with a `gid` of 26:\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, {\r\n     *   gid: 26\r\n     * });\r\n     * ```\r\n     *\r\n     * Or, to convert objects with the name 'bonus':\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, {\r\n     *   name: 'bonus'\r\n     * });\r\n     * ```\r\n     *\r\n     * Or, to convert an object with a specific id:\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, {\r\n     *   id: 9\r\n     * });\r\n     * ```\r\n     *\r\n     * You should only specify either `id`, `gid`, `name`, or none of them. Do not add more than\r\n     * one criteria to your config. If you do not specify any criteria, then _all_ objects in the\r\n     * Object Layer will be converted.\r\n     *\r\n     * By default this method will convert objects into `Sprite` instances, but you can override\r\n     * this by providing your own class type:\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, {\r\n     *   gid: 26,\r\n     *   classType: Coin\r\n     * });\r\n     * ```\r\n     *\r\n     * This will convert all Objects with a gid of 26 into your custom `Coin` class. You can pass\r\n     * any class type here, but it _must_ extend `Phaser.GameObjects.GameObject` as its base class.\r\n     * Your class will always be passed 1 parameter: `scene`, which is a reference to either the Scene\r\n     * specified in the config object or, if not given, the Scene to which this Tilemap belongs.\r\n     *\r\n     * All properties from object are copied into the Game Object, so you can use this as an easy\r\n     * way to configure properties from within the map editor. For example giving an object a\r\n     * property of `alpha: 0.5` in Tiled will be reflected in the Game Object that is created.\r\n     *\r\n     * Custom object properties that do not exist as a Game Object property are set in the\r\n     * Game Objects {@link Phaser.GameObjects.GameObject#data data store}.\r\n     *\r\n     * You can use set a `container` property in the config. If given, the class will be added to\r\n     * the Container instance instead of the Scene.\r\n     *\r\n     * Finally, you can provide an array of config objects, to convert multiple types of object in\r\n     * a single call:\r\n     *\r\n     * ```javascript\r\n     * createFromObjects(layerName, [\r\n     *   {\r\n     *     gid: 26,\r\n     *     classType: Coin\r\n     *   },\r\n     *   {\r\n     *     id: 9,\r\n     *     classType: BossMonster\r\n     *   },\r\n     *   {\r\n     *     name: 'lava',\r\n     *     classType: LavaTile\r\n     *   }\r\n     * ]);\r\n     * ```\r\n     *\r\n     * The signature of this method changed significantly in v3.50.0. Prior to this, it did not take config objects.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createFromObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} objectLayerName - The name of the Tiled object layer to create the Game Objects from.\r\n     * @param {Phaser.Types.Tilemaps.CreateFromObjectLayerConfig|Phaser.Types.Tilemaps.CreateFromObjectLayerConfig[]} config - A CreateFromObjects configuration object, or an array of them.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array containing the Game Objects that were created. Empty if invalid object layer, or no matching id/gid/name was found.\r\n     */\r\n    createFromObjects: function (objectLayerName, config)\r\n    {\r\n        var results = [];\r\n\r\n        var objectLayer = this.getObjectLayer(objectLayerName);\r\n\r\n        if (!objectLayer)\r\n        {\r\n            console.warn('createFromObjects: Invalid objectLayerName given: ' + objectLayerName);\r\n\r\n            return results;\r\n        }\r\n\r\n        if (!Array.isArray(config))\r\n        {\r\n            config = [ config ];\r\n        }\r\n\r\n        var objects = objectLayer.objects;\r\n\r\n        for (var c = 0; c < config.length; c++)\r\n        {\r\n            var singleConfig = config[c];\r\n\r\n            var id = GetFastValue(singleConfig, 'id', null);\r\n            var gid = GetFastValue(singleConfig, 'gid', null);\r\n            var name = GetFastValue(singleConfig, 'name', null);\r\n\r\n            var obj;\r\n            var toConvert = [];\r\n\r\n            //  Sweep to get all the objects we want to convert in this pass\r\n            for (var s = 0; s < objects.length; s++)\r\n            {\r\n                obj = objects[s];\r\n\r\n                if (\r\n                    (id === null && gid === null && name === null) ||\r\n                    (id !== null && obj.id === id) ||\r\n                    (gid !== null && obj.gid === gid) ||\r\n                    (name !== null && obj.name === name)\r\n                )\r\n                {\r\n                    toConvert.push(obj);\r\n                }\r\n            }\r\n\r\n            //  Now let's convert them ...\r\n\r\n            var classType = GetFastValue(singleConfig, 'classType', Sprite);\r\n            var scene = GetFastValue(singleConfig, 'scene', this.scene);\r\n            var container = GetFastValue(singleConfig, 'container', null);\r\n            var texture = GetFastValue(singleConfig, 'key', null);\r\n            var frame = GetFastValue(singleConfig, 'frame', null);\r\n\r\n            for (var i = 0; i < toConvert.length; i++)\r\n            {\r\n                obj = toConvert[i];\r\n\r\n                var sprite = new classType(scene);\r\n\r\n                sprite.setName(obj.name);\r\n                sprite.setPosition(obj.x, obj.y);\r\n                sprite.setTexture(texture, frame);\r\n\r\n                if (obj.width)\r\n                {\r\n                    sprite.displayWidth = obj.width;\r\n                }\r\n\r\n                if (obj.height)\r\n                {\r\n                    sprite.displayHeight = obj.height;\r\n                }\r\n\r\n                //  Origin is (0, 1) in Tiled, so find the offset that matches the Sprites origin.\r\n                //  Do not offset objects with zero dimensions (e.g. points).\r\n                var offset = {\r\n                    x: sprite.originX * obj.width,\r\n                    y: (sprite.originY - 1) * obj.height\r\n                };\r\n\r\n                //  If the object is rotated, then the origin offset also needs to be rotated.\r\n                if (obj.rotation)\r\n                {\r\n                    var angle = DegToRad(obj.rotation);\r\n\r\n                    Rotate(offset, angle);\r\n\r\n                    sprite.rotation = angle;\r\n                }\r\n\r\n                sprite.x += offset.x;\r\n                sprite.y += offset.y;\r\n\r\n                if (obj.flippedHorizontal !== undefined || obj.flippedVertical !== undefined)\r\n                {\r\n                    sprite.setFlip(obj.flippedHorizontal, obj.flippedVertical);\r\n                }\r\n\r\n                if (!obj.visible)\r\n                {\r\n                    sprite.visible = false;\r\n                }\r\n\r\n                //  Set properties the class may have, or setData those it doesn't\r\n                if (Array.isArray(obj.properties))\r\n                {\r\n                    // Tiled objects custom properties format\r\n                    obj.properties.forEach(function (propData)\r\n                    {\r\n                        var key = propData['name'];\r\n                        if (sprite[key] !== undefined)\r\n                        {\r\n                            sprite[key] = propData['value'];\r\n                        }\r\n                        else\r\n                        {\r\n                            sprite.setData(key, propData['value']);\r\n                        }\r\n                    });\r\n                }\r\n                else\r\n                {\r\n                    for (var key in obj.properties)\r\n                    {\r\n                        if (sprite[key] !== undefined)\r\n                        {\r\n                            sprite[key] = obj.properties[key];\r\n                        }\r\n                        else\r\n                        {\r\n                            sprite.setData(key, obj.properties[key]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (container)\r\n                {\r\n                    container.add(sprite);\r\n                }\r\n                else\r\n                {\r\n                    scene.add.existing(sprite);\r\n                }\r\n\r\n                results.push(sprite);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    },\r\n\r\n    /**\r\n     * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n     * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n     * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#createFromTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n     * @param {(number|array)} replacements - The tile index, or array of indexes, to change a converted\r\n     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a\r\n     * one-to-one mapping with the indexes array.\r\n     * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} spriteConfig - The config object to pass into the Sprite creator (i.e. scene.make.sprite).\r\n     * @param {Phaser.Scene} [scene] - The Scene to create the Sprites within.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.GameObjects.Sprite[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    createFromTiles: function (indexes, replacements, spriteConfig, scene, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n     * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n     * Collision information in the region will be recalculated.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     * This cannot be applied to StaticTilemapLayers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#fill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} index - The tile index to fill the area with.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    fill: function (index, tileX, tileY, width, height, recalculateFaces, layer)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * For each object in the given object layer, run the given filter callback function. Any\r\n     * objects that pass the filter test (i.e. where the callback returns true) will returned as a\r\n     * new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#filterObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.ObjectLayer|string)} objectLayer - The name of an object layer (from Tiled) or an ObjectLayer instance.\r\n     * @param {TilemapFilterCallback} callback - The callback. Each object in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     *\r\n     * @return {?Phaser.Types.Tilemaps.TiledObject[]} An array of object that match the search, or null if the objectLayer given was invalid.\r\n     */\r\n    filterObjects: function (objectLayer, callback, context)\r\n    {\r\n        if (typeof objectLayer === 'string')\r\n        {\r\n            var name = objectLayer;\r\n\r\n            objectLayer = this.getObjectLayer(objectLayer);\r\n\r\n            if (!objectLayer)\r\n            {\r\n                console.warn('No object layer found with the name: ' + name);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return objectLayer.objects.filter(callback, context);\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#filterTiles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n     * filter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    filterTiles: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, layer);\r\n    },\r\n\r\n    /**\r\n     * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n     * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n     * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n     * the top-left.\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} index - The tile index value to search for.\r\n     * @param {number} [skip=0] - The number of times to skip a matching tile before returning.\r\n     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.\r\n     */\r\n    findByIndex: function (findIndex, skip, reverse, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.FindByIndex(findIndex, skip, reverse, layer);\r\n    },\r\n\r\n    /**\r\n     * Find the first object in the given object layer that satisfies the provided testing function.\r\n     * I.e. finds the first object for which `callback` returns true. Similar to\r\n     * Array.prototype.find in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findObject\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.ObjectLayer|string)} objectLayer - The name of an object layer (from Tiled) or an ObjectLayer instance.\r\n     * @param {TilemapFindCallback} callback - The callback. Each object in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     *\r\n     * @return {?Phaser.Types.Tilemaps.TiledObject} An object that matches the search, or null if no object found.\r\n     */\r\n    findObject: function (objectLayer, callback, context)\r\n    {\r\n        if (typeof objectLayer === 'string')\r\n        {\r\n            var name = objectLayer;\r\n\r\n            objectLayer = this.getObjectLayer(objectLayer);\r\n\r\n            if (!objectLayer)\r\n            {\r\n                console.warn('No object layer found with the name: ' + name);\r\n                return null;\r\n            }\r\n        }\r\n\r\n        return objectLayer.objects.find(callback, context) || null;\r\n    },\r\n\r\n    /**\r\n     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n     * true. Similar to Array.prototype.find in vanilla JS.\r\n     * If no layer specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#findTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The Tile layer to run the search on. If not provided will use the current layer.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tiles, or null if the layer given was invalid.\r\n     */\r\n    findTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n     *\r\n     * If no layer specified, the map's current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#forEachTile\r\n     * @since 3.0.0\r\n     *\r\n     * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The Tile layer to run the search on. If not provided will use the current layer.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    forEachTile: function (callback, context, tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the image layer index based on its name.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getImageIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the image to get.\r\n     *\r\n     * @return {number} The index of the image in this tilemap, or null if not found.\r\n     */\r\n    getImageIndex: function (name)\r\n    {\r\n        return this.getIndex(this.images, name);\r\n    },\r\n\r\n    /**\r\n     * Return a list of all valid imagelayer names loaded in this Tilemap.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getImageLayerNames\r\n     * @since 3.21.0\r\n     *\r\n     * @return {string[]} Array of valid imagelayer names / IDs loaded into this Tilemap.\r\n     */\r\n    getImageLayerNames: function ()\r\n    {\r\n        if (!this.images || !Array.isArray(this.images))\r\n        {\r\n            return [];\r\n        }\r\n\r\n        return this.images.map(function (image)\r\n        {\r\n            return image.name;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Internally used. Returns the index of the object in one of the Tilemaps arrays whose name\r\n     * property matches the given `name`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {array} location - The Tilemap array to search.\r\n     * @param {string} name - The name of the array element to get.\r\n     *\r\n     * @return {number} The index of the element in the array, or null if not found.\r\n     */\r\n    getIndex: function (location, name)\r\n    {\r\n        for (var i = 0; i < location.length; i++)\r\n        {\r\n            if (location[i].name === name)\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Gets the LayerData from `this.layers` that is associated with the given `layer`, or null if the layer is invalid.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The name of the layer from Tiled, the index of the layer in the map or Tilemap Layer. If not given will default to the maps current layer index.\r\n     *\r\n     * @return {Phaser.Tilemaps.LayerData} The corresponding LayerData within this.layers.\r\n     */\r\n    getLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        return (index !== null) ? this.layers[index] : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the ObjectLayer from `this.objects` that has the given `name`, or null if no ObjectLayer is found with that name.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getObjectLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [name] - The name of the object layer from Tiled.\r\n     *\r\n     * @return {?Phaser.Tilemaps.ObjectLayer} The corresponding `ObjectLayer` within `this.objects`, or null.\r\n     */\r\n    getObjectLayer: function (name)\r\n    {\r\n        var index = this.getIndex(this.objects, name);\r\n\r\n        return (index !== null) ? this.objects[index] : null;\r\n    },\r\n\r\n    /**\r\n     * Return a list of all valid objectgroup names loaded in this Tilemap.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getObjectLayerNames\r\n     * @since 3.21.0\r\n     *\r\n     * @return {string[]} Array of valid objectgroup names / IDs loaded into this Tilemap.\r\n     */\r\n    getObjectLayerNames: function ()\r\n    {\r\n        if (!this.objects || !Array.isArray(this.objects))\r\n        {\r\n            return [];\r\n        }\r\n\r\n        return this.objects.map(function (object)\r\n        {\r\n            return object.name;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Gets the LayerData index of the given `layer` within this.layers, or null if an invalid\r\n     * `layer` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayerIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The name of the layer from Tiled, the index of the layer in the map or a Tilemap Layer. If not given will default to the map's current layer index.\r\n     *\r\n     * @return {number} The LayerData index within this.layers.\r\n     */\r\n    getLayerIndex: function (layer)\r\n    {\r\n        if (layer === undefined)\r\n        {\r\n            return this.currentLayerIndex;\r\n        }\r\n        else if (typeof layer === 'string')\r\n        {\r\n            return this.getLayerIndexByName(layer);\r\n        }\r\n        else if (typeof layer === 'number' && layer < this.layers.length)\r\n        {\r\n            return layer;\r\n        }\r\n        else if (layer instanceof TilemapLayer)\r\n        {\r\n            return layer.layerIndex;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Gets the index of the LayerData within this.layers that has the given `name`, or null if an\r\n     * invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getLayerIndexByName\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the layer to get.\r\n     *\r\n     * @return {number} The LayerData index within this.layers.\r\n     */\r\n    getLayerIndexByName: function (name)\r\n    {\r\n        return this.getIndex(this.layers, name);\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given tile coordinates from the given layer.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - X position to get the tile from (given in tile units, not pixels).\r\n     * @param {number} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n     * @param {boolean} [nonNull] - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    getTileAt: function (tileX, tileY, nonNull, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTileAt(tileX, tileY, nonNull, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given world coordinates from the given layer.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - X position to get the tile from (given in pixels)\r\n     * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n     * @param {boolean} [nonNull] - If true, function won't return null for empty tiles, but a Tile object with an index of -1.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    getTileAtWorldXY: function (worldX, worldY, nonNull, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Return a list of all valid tilelayer names loaded in this Tilemap.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileLayerNames\r\n     * @since 3.21.0\r\n     *\r\n     * @return {string[]} Array of valid tilelayer names / IDs loaded into this Tilemap.\r\n     */\r\n    getTileLayerNames: function ()\r\n    {\r\n        if (!this.layers || !Array.isArray(this.layers))\r\n        {\r\n            return [];\r\n        }\r\n\r\n        return this.layers.map(function (layer)\r\n        {\r\n            return layer.name;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    getTilesWithin: function (tileX, tileY, width, height, filteringOptions, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n     * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithinShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    getTilesWithinShape: function (shape, filteringOptions, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesWithinWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The world x coordinate for the top-left of the area.\r\n     * @param {number} worldY - The world y coordinate for the top-left of the area.\r\n     * @param {number} width - The width of the area.\r\n     * @param {number} height - The height of the area.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile[]} Returns an array of Tiles, or null if the layer given was invalid.\r\n     */\r\n    getTilesWithinWorldXY: function (worldX, worldY, width, height, filteringOptions, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the Tileset that has the given `name`, or null if an invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTileset\r\n     * @since 3.14.0\r\n     *\r\n     * @param {string} name - The name of the Tileset to get.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tileset} The Tileset, or `null` if no matching named tileset was found.\r\n     */\r\n    getTileset: function (name)\r\n    {\r\n        var index = this.getIndex(this.tilesets, name);\r\n\r\n        return (index !== null) ? this.tilesets[index] : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the index of the Tileset within this.tilesets that has the given `name`, or null if an\r\n     * invalid `name` is given.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#getTilesetIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} name - The name of the Tileset to get.\r\n     *\r\n     * @return {number} The Tileset index within this.tilesets.\r\n     */\r\n    getTilesetIndex: function (name)\r\n    {\r\n        return this.getIndex(this.tilesets, name);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#hasTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n     */\r\n    hasTileAt: function (tileX, tileY, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.HasTileAt(tileX, tileY, layer);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#hasTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?boolean} Returns a boolean, or null if the layer given was invalid.\r\n     */\r\n    hasTileAtWorldXY: function (worldX, worldY, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * The LayerData object that is currently selected in the map. You can set this property using\r\n     * any type supported by setLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tilemap#layer\r\n     * @type {Phaser.Tilemaps.LayerData}\r\n     * @since 3.0.0\r\n     */\r\n    layer: {\r\n        get: function ()\r\n        {\r\n            return this.layers[this.currentLayerIndex];\r\n        },\r\n\r\n        set: function (layer)\r\n        {\r\n            this.setLayer(layer);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n     * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n     * location. If you pass in an index, only the index at the specified location will be changed.\r\n     * Collision information will be recalculated at the specified location.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces] - `true` if the faces data should be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid or the coordinates were out of bounds.\r\n     */\r\n    putTileAt: function (tile, tileX, tileY, recalculateFaces, layer)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, layer);\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n     * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n     * specified location. If you pass in an index, only the index at the specified location will be\r\n     * changed. Collision information will be recalculated at the specified location.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [recalculateFaces] - `true` if the faces data should be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    putTileAtWorldXY: function (tile, worldX, worldY, recalculateFaces, camera, layer)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n     * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n     * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n     * index at the specified location will be changed. Collision information will be recalculated\r\n     * within the region tiles were changed.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#putTilesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number[]|number[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces] - `true` if the faces data should be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    putTilesAt: function (tilesArray, tileX, tileY, recalculateFaces, layer)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n     * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n     * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n     * indexes. This method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#randomize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {number[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    randomize: function (tileX, tileY, width, height, indexes, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.Randomize(tileX, tileY, width, height, indexes, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n     * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n     * internally to optimize recalculating faces when only one tile has been changed.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#calculateFacesAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    calculateFacesAt: function (tileX, tileY, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.CalculateFacesAt(tileX, tileY, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n     * is mostly used internally.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#calculateFacesWithin\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    calculateFacesWithin: function (tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the given TilemapLayer from this Tilemap without destroying it.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeLayer\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to be removed.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    removeLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        if (index !== null)\r\n        {\r\n            SpliceOne(this.layers, index);\r\n\r\n            for (var i = index; i < this.layers.length; i++)\r\n            {\r\n                if (this.layers[i].tilemapLayer)\r\n                {\r\n                    this.layers[i].tilemapLayer.layerIndex--;\r\n                }\r\n            }\r\n\r\n            if (this.currentLayerIndex === index)\r\n            {\r\n                this.currentLayerIndex = 0;\r\n            }\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys the given TilemapLayer and removes it from this Tilemap.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#destroyLayer\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to be destroyed.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Returns this, or null if the layer given was invalid.\r\n     */\r\n    destroyLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        if (index !== null)\r\n        {\r\n            layer = this.layers[index];\r\n\r\n            layer.destroy();\r\n\r\n            SpliceOne(this.layers, index);\r\n\r\n            if (this.currentLayerIndex === index)\r\n            {\r\n                this.currentLayerIndex = 0;\r\n            }\r\n\r\n            return this;\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes all Tilemap Layers from this Tilemap and calls `destroy` on each of them.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeAllLayers\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    removeAllLayers: function ()\r\n    {\r\n        var layers = this.layers;\r\n\r\n        for (var i = 0; i < layers.length; i++)\r\n        {\r\n            if (layers[i].tilemapLayer)\r\n            {\r\n                layers[i].tilemapLayer.destroy(false);\r\n            }\r\n        }\r\n\r\n        layers.length = 0;\r\n\r\n        this.currentLayerIndex = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the given Tile, or an array of Tiles, from the layer to which they belong,\r\n     * and optionally recalculates the collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTile\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.Tile|Phaser.Tilemaps.Tile[])} tiles - The Tile to remove, or an array of Tiles.\r\n     * @param {number} [replaceIndex=-1] - After removing the Tile, insert a brand new Tile into its location with the given index. Leave as -1 to just remove the tile.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} Returns an array of Tiles that were removed.\r\n     */\r\n    removeTile: function (tiles, replaceIndex, recalculateFaces)\r\n    {\r\n        if (replaceIndex === undefined) { replaceIndex = -1; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        var removed = [];\r\n\r\n        if (!Array.isArray(tiles))\r\n        {\r\n            tiles = [ tiles ];\r\n        }\r\n\r\n        for (var i = 0; i < tiles.length; i++)\r\n        {\r\n            var tile = tiles[i];\r\n\r\n            removed.push(this.removeTileAt(tile.x, tile.y, true, recalculateFaces, tile.tilemapLayer));\r\n\r\n            if (replaceIndex > -1)\r\n            {\r\n                this.putTileAt(replaceIndex, tile.x, tile.y, recalculateFaces, tile.tilemapLayer);\r\n            }\r\n        }\r\n\r\n        return removed;\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given tile coordinates in the specified layer and updates the layers collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTileAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [replaceWithNull] - If `true` (the default), this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces] - If `true` (the default), the faces data will be recalculated.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns the Tile that was removed, or null if the layer given was invalid.\r\n     */\r\n    removeTileAt: function (tileX, tileY, replaceWithNull, recalculateFaces, layer)\r\n    {\r\n        if (replaceWithNull === undefined) { replaceWithNull = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, layer);\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given world coordinates in the specified layer and updates the layers collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#removeTileAtWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [replaceWithNull] - If `true` (the default), this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces] - If `true` (the default), the faces data will be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} Returns a Tile, or null if the layer given was invalid.\r\n     */\r\n    removeTileAtWorldXY: function (worldX, worldY, replaceWithNull, recalculateFaces, camera, layer)\r\n    {\r\n        if (replaceWithNull === undefined) { replaceWithNull = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Draws a debug representation of the layer to the given Graphics object. This is helpful when you want to\r\n     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n     * wherever you want on the screen.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * **Note:** This method currently only works with orthogonal tilemap layers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#renderDebug\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {Phaser.Types.Tilemaps.StyleConfig} [styleConfig] - An object specifying the colors to use for the debug drawing.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    renderDebug: function (graphics, styleConfig, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        if (this.orientation === ORIENTATION.ORTHOGONAL)\r\n        {\r\n            TilemapComponents.RenderDebug(graphics, styleConfig, layer);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws a debug representation of all layers within this Tilemap to the given Graphics object.\r\n     *\r\n     * This is helpful when you want to get a quick idea of which of your tiles are colliding and which\r\n     * have interesting faces. The tiles are drawn starting at (0, 0) in the Graphics, allowing you to\r\n     * place the debug representation wherever you want on the screen.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#renderDebugFull\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {Phaser.Types.Tilemaps.StyleConfig} [styleConfig] - An object specifying the colors to use for the debug drawing.\r\n     *\r\n     * @return {this} This Tilemap instance.\r\n     */\r\n    renderDebugFull: function (graphics, styleConfig)\r\n    {\r\n        var layers = this.layers;\r\n\r\n        for (var i = 0; i < layers.length; i++)\r\n        {\r\n            TilemapComponents.RenderDebug(graphics, styleConfig, layers[i]);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n     * not change collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#replaceByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} findIndex - The index of the tile to search for.\r\n     * @param {number} newIndex - The index of the tile to replace it with.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    replaceByIndex: function (findIndex, newIndex, tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n     * collision will be enabled (true) or disabled (false).\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollision: function (indexes, collides, recalculateFaces, layer, updateLayer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n        if (updateLayer === undefined) { updateLayer = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollision(indexes, collides, recalculateFaces, layer, updateLayer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n     * enabled (true) or disabled (false).\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionBetween\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} start - The first index of the tile to be set for collision.\r\n     * @param {number} stop - The last index of the tile to be set for collision.\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionBetween: function (start, stop, collides, recalculateFaces, layer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n     * that matches the given properties object, its collision flag will be set. The `collides`\r\n     * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n     * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n     * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n     * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n     * \"types\" property that matches any of those values, its collision flag will be updated.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionByProperty\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} properties - An object with tile properties and corresponding values that should be checked.\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionByProperty: function (properties, collides, recalculateFaces, layer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n     * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n     * disabled (false). Tile indexes not currently in the layer are not affected.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionByExclusion\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number[]} indexes - An array of the tile indexes to not be counted for collision.\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionByExclusion: function (indexes, collides, recalculateFaces, layer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking each tiles collision group data\r\n     * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n     * a tiles collision group, the tiles colliding information will be set. The `collides` parameter\r\n     * controls if collision will be enabled (true) or disabled (false).\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setCollisionFromCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [collides] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setCollisionFromCollisionGroup: function (collides, recalculateFaces, layer)\r\n    {\r\n        if (collides === undefined) { collides = true; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n     * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n     * at a specific location on the map then see `setTileLocationCallback`.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setTileIndexCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|number[])} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for. All values should be integers.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setTileIndexCallback: function (indexes, callback, callbackContext, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n     * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n     * remove it.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setTileLocationCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} [callbackContext] - The context under which the callback is called.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    setTileLocationCallback: function (tileX, tileY, width, height, callback, callbackContext, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current layer to the LayerData associated with `layer`.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The name of the layer from Tiled, the index of the layer in the map or a TilemapLayer. If not given will default to the maps current layer index.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setLayer: function (layer)\r\n    {\r\n        var index = this.getLayerIndex(layer);\r\n\r\n        if (index !== null)\r\n        {\r\n            this.currentLayerIndex = index;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the base tile size for the map. Note: this does not necessarily match the tileWidth and\r\n     * tileHeight for all layers. This also updates the base size on all tiles across all layers.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setBaseTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileWidth - The width of the tiles the map uses for calculations.\r\n     * @param {number} tileHeight - The height of the tiles the map uses for calculations.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setBaseTileSize: function (tileWidth, tileHeight)\r\n    {\r\n        this.tileWidth = tileWidth;\r\n        this.tileHeight = tileHeight;\r\n        this.widthInPixels = this.width * tileWidth;\r\n        this.heightInPixels = this.height * tileHeight;\r\n\r\n        //  Update the base tile size on all layers & tiles\r\n        for (var i = 0; i < this.layers.length; i++)\r\n        {\r\n            this.layers[i].baseTileWidth = tileWidth;\r\n            this.layers[i].baseTileHeight = tileHeight;\r\n\r\n            var mapData = this.layers[i].data;\r\n            var mapWidth = this.layers[i].width;\r\n            var mapHeight = this.layers[i].height;\r\n\r\n            for (var row = 0; row < mapHeight; row++)\r\n            {\r\n                for (var col = 0; col < mapWidth; col++)\r\n                {\r\n                    var tile = mapData[row][col];\r\n\r\n                    if (tile !== null)\r\n                    {\r\n                        tile.setSize(undefined, undefined, tileWidth, tileHeight);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tile size for a specific `layer`. Note: this does not necessarily match the maps\r\n     * tileWidth and tileHeight for all layers. This will set the tile size for the layer and any\r\n     * tiles the layer has.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#setLayerTileSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileWidth - The width of the tiles (in pixels) in the layer.\r\n     * @param {number} tileHeight - The height of the tiles (in pixels) in the layer.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The name of the layer from Tiled, the index of the layer in the map or a TilemapLayer. If not given will default to the maps current layer index.\r\n     *\r\n     * @return {this} This Tilemap object.\r\n     */\r\n    setLayerTileSize: function (tileWidth, tileHeight, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return this; }\r\n\r\n        layer.tileWidth = tileWidth;\r\n        layer.tileHeight = tileHeight;\r\n\r\n        var mapData = layer.data;\r\n        var mapWidth = layer.width;\r\n        var mapHeight = layer.height;\r\n\r\n        for (var row = 0; row < mapHeight; row++)\r\n        {\r\n            for (var col = 0; col < mapWidth; col++)\r\n            {\r\n                var tile = mapData[row][col];\r\n\r\n                if (tile !== null)\r\n                {\r\n                    tile.setSize(tileWidth, tileHeight);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n     * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n     * appear to have changed! This method only modifies tile indexes and does not change collision\r\n     * information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#shuffle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    shuffle: function (tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.Shuffle(tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n     * information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#swapByIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileA - First tile index.\r\n     * @param {number} tileB - Second tile index.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    swapByIndex: function (indexA, indexB, tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    tileToWorldX: function (tileX, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.TileToWorldX(tileX, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    tileToWorldY: function (tileX, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.TileToWorldY(tileX, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#tileToWorldXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Math.Vector2} [vec2] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Math.Vector2} Returns a Vector2, or null if the layer given was invalid.\r\n     */\r\n    tileToWorldXY: function (tileX, tileY, vec2, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.TileToWorldXY(tileX, tileY, vec2, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n     * weightedIndexes array. An example weighted array:\r\n     *\r\n     * [\r\n     *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n     *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n     *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n     *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n     * ]\r\n     *\r\n     * The probability of any index being picked is (the indexs weight) / (sum of all weights). This\r\n     * method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#weightedRandomize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object[]} weightedIndexes - An array of objects to randomly draw from during randomization. They should be in the form: { index: 0, weight: 4 } or { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tilemap} Return this Tilemap object, or null if the layer given was invalid.\r\n     */\r\n    weightedRandomize: function (weightedIndexes, tileX, tileY, width, height, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    worldToTileX: function (worldX, snapToFloor, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.WorldToTileX(worldX, snapToFloor, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?number} Returns a number, or null if the layer given was invalid.\r\n     */\r\n    worldToTileY: function (worldY, snapToFloor, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.WorldToTileY(worldY, snapToFloor, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * If no layer is specified, the maps current layer is used.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#worldToTileXY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Math.Vector2} [vec2] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     * @param {(string|number|Phaser.Tilemaps.TilemapLayer)} [layer] - The tile layer to use. If not given the current layer is used.\r\n     *\r\n     * @return {?Phaser.Math.Vector2} Returns a vec2, or null if the layer given was invalid.\r\n     */\r\n    worldToTileXY: function (worldX, worldY, snapToFloor, vec2, camera, layer)\r\n    {\r\n        layer = this.getLayer(layer);\r\n\r\n        if (layer === null) { return null; }\r\n\r\n        return this._convert.WorldToTileXY(worldX, worldY, snapToFloor, vec2, camera, layer);\r\n    },\r\n\r\n    /**\r\n     * Removes all layer data from this Tilemap and nulls the scene reference. This will destroy any\r\n     * TilemapLayers that have been created.\r\n     *\r\n     * @method Phaser.Tilemaps.Tilemap#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllLayers();\r\n\r\n        this.tilesets.length = 0;\r\n        this.objects.length = 0;\r\n\r\n        this.scene = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Tilemap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Components = require('../gameobjects/components');\r\nvar GameObject = require('../gameobjects/GameObject');\r\nvar TilemapComponents = require('./components');\r\nvar TilemapLayerRender = require('./TilemapLayerRender');\r\n\r\n/**\r\n * @classdesc\r\n * A Tilemap Layer is a Game Object that renders LayerData from a Tilemap when used in combination\r\n * with one, or more, Tilesets.\r\n *\r\n * @class TilemapLayer\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs.\r\n * @param {Phaser.Tilemaps.Tilemap} tilemap - The Tilemap this layer is a part of.\r\n * @param {number} layerIndex - The index of the LayerData associated with this layer.\r\n * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n * @param {number} [x=0] - The world x position where the top left of this layer will be placed.\r\n * @param {number} [y=0] - The world y position where the top left of this layer will be placed.\r\n */\r\nvar TilemapLayer = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Components.ScrollFactor,\r\n        TilemapLayerRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function TilemapLayer (scene, tilemap, layerIndex, tileset, x, y)\r\n    {\r\n        GameObject.call(this, scene, 'TilemapLayer');\r\n\r\n        /**\r\n         * Used internally by physics system to perform fast type checks.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#isTilemap\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.isTilemap = true;\r\n\r\n        /**\r\n         * The Tilemap that this layer is a part of.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#tilemap\r\n         * @type {Phaser.Tilemaps.Tilemap}\r\n         * @since 3.50.0\r\n         */\r\n        this.tilemap = tilemap;\r\n\r\n        /**\r\n         * The index of the LayerData associated with this layer.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#layerIndex\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.layerIndex = layerIndex;\r\n\r\n        /**\r\n         * The LayerData associated with this layer. LayerData can only be associated with one\r\n         * tilemap layer.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#layer\r\n         * @type {Phaser.Tilemaps.LayerData}\r\n         * @since 3.50.0\r\n         */\r\n        this.layer = tilemap.layers[layerIndex];\r\n\r\n        // Link the LayerData with this static tilemap layer\r\n        this.layer.tilemapLayer = this;\r\n\r\n        /**\r\n         * An array of `Tileset` objects associated with this layer.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#tileset\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.tileset = [];\r\n\r\n        /**\r\n         * The total number of tiles drawn by the renderer in the last frame.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#tilesDrawn\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.tilesDrawn = 0;\r\n\r\n        /**\r\n         * The total number of tiles in this layer. Updated every frame.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#tilesTotal\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.tilesTotal = this.layer.width * this.layer.height;\r\n\r\n        /**\r\n         * Used internally during rendering. This holds the tiles that are visible within the Camera.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#culledTiles\r\n         * @type {Phaser.Tilemaps.Tile[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.culledTiles = [];\r\n\r\n        /**\r\n         * You can control if the camera should cull tiles on this layer before rendering them or not.\r\n         *\r\n         * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.\r\n         *\r\n         * However, there are some instances when you may wish to disable this, and toggling this flag allows\r\n         * you to do so. Also see `setSkipCull` for a chainable method that does the same thing.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#skipCull\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.skipCull = false;\r\n\r\n        /**\r\n         * The amount of extra tiles to add into the cull rectangle when calculating its horizontal size.\r\n         *\r\n         * See the method `setCullPadding` for more details.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#cullPaddingX\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.50.0\r\n         */\r\n        this.cullPaddingX = 1;\r\n\r\n        /**\r\n         * The amount of extra tiles to add into the cull rectangle when calculating its vertical size.\r\n         *\r\n         * See the method `setCullPadding` for more details.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#cullPaddingY\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.50.0\r\n         */\r\n        this.cullPaddingY = 1;\r\n\r\n        /**\r\n         * The callback that is invoked when the tiles are culled.\r\n         *\r\n         * It will call a different function based on the map orientation:\r\n         *\r\n         * Orthogonal (the default) is `TilemapComponents.CullTiles`\r\n         * Isometric is `TilemapComponents.IsometricCullTiles`\r\n         * Hexagonal is `TilemapComponents.HexagonalCullTiles`\r\n         * Staggered is `TilemapComponents.StaggeredCullTiles`\r\n         *\r\n         * However, you can override this to call any function you like.\r\n         *\r\n         * It will be sent 4 arguments:\r\n         *\r\n         * 1. The Phaser.Tilemaps.LayerData object for this Layer\r\n         * 2. The Camera that is culling the layer. You can check its `dirty` property to see if it has changed since the last cull.\r\n         * 3. A reference to the `culledTiles` array, which should be used to store the tiles you want rendered.\r\n         * 4. The Render Order constant.\r\n         *\r\n         * See the `TilemapComponents.CullTiles` source code for details on implementing your own culling system.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#cullCallback\r\n         * @type {function}\r\n         * @since 3.50.0\r\n         */\r\n        this.cullCallback = TilemapComponents.GetCullTilesFunction(this.layer.orientation);\r\n\r\n        /**\r\n         * The rendering (draw) order of the tiles in this layer.\r\n         *\r\n         * The default is 0 which is 'right-down', meaning it will draw the tiles starting from the top-left,\r\n         * drawing to the right and then moving down to the next row.\r\n         *\r\n         * The draw orders are:\r\n         *\r\n         * 0 = right-down\r\n         * 1 = left-down\r\n         * 2 = right-up\r\n         * 3 = left-up\r\n         *\r\n         * This can be changed via the `setRenderOrder` method.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#_renderOrder\r\n         * @type {number}\r\n         * @default 0\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this._renderOrder = 0;\r\n\r\n        /**\r\n         * An array holding the mapping between the tile indexes and the tileset they belong to.\r\n         *\r\n         * @name Phaser.Tilemaps.TilemapLayer#gidMap\r\n         * @type {Phaser.Tilemaps.Tileset[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.gidMap = [];\r\n\r\n        this.setTilesets(tileset);\r\n        this.setAlpha(this.layer.alpha);\r\n        this.setPosition(x, y);\r\n        this.setOrigin();\r\n        this.setSize(tilemap.tileWidth * this.layer.width, tilemap.tileHeight * this.layer.height);\r\n\r\n        this.initPipeline();\r\n    },\r\n\r\n    /**\r\n     * Populates the internal `tileset` array with the Tileset references this Layer requires for rendering.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setTilesets\r\n     * @private\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|string[]|Phaser.Tilemaps.Tileset|Phaser.Tilemaps.Tileset[])} tileset - The tileset, or an array of tilesets, used to render this layer. Can be a string or a Tileset object.\r\n     */\r\n    setTilesets: function (tilesets)\r\n    {\r\n        var gidMap = [];\r\n        var setList = [];\r\n        var map = this.tilemap;\r\n\r\n        if (!Array.isArray(tilesets))\r\n        {\r\n            tilesets = [ tilesets ];\r\n        }\r\n\r\n        for (var i = 0; i < tilesets.length; i++)\r\n        {\r\n            var tileset = tilesets[i];\r\n\r\n            if (typeof tileset === 'string')\r\n            {\r\n                tileset = map.getTileset(tileset);\r\n            }\r\n\r\n            if (tileset)\r\n            {\r\n                setList.push(tileset);\r\n\r\n                var s = tileset.firstgid;\r\n\r\n                for (var t = 0; t < tileset.total; t++)\r\n                {\r\n                    gidMap[s + t] = tileset;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.gidMap = gidMap;\r\n        this.tileset = setList;\r\n    },\r\n\r\n    /**\r\n     * Sets the rendering (draw) order of the tiles in this layer.\r\n     *\r\n     * The default is 'right-down', meaning it will order the tiles starting from the top-left,\r\n     * drawing to the right and then moving down to the next row.\r\n     *\r\n     * The draw orders are:\r\n     *\r\n     * 0 = right-down\r\n     * 1 = left-down\r\n     * 2 = right-up\r\n     * 3 = left-up\r\n     *\r\n     * Setting the render order does not change the tiles or how they are stored in the layer,\r\n     * it purely impacts the order in which they are rendered.\r\n     *\r\n     * You can provide either an integer (0 to 3), or the string version of the order.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setRenderOrder\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|string)} renderOrder - The render (draw) order value. Either an integer between 0 and 3, or a string: 'right-down', 'left-down', 'right-up' or 'left-up'.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setRenderOrder: function (renderOrder)\r\n    {\r\n        var orders = [ 'right-down', 'left-down', 'right-up', 'left-up' ];\r\n\r\n        if (typeof renderOrder === 'string')\r\n        {\r\n            renderOrder = orders.indexOf(renderOrder);\r\n        }\r\n\r\n        if (renderOrder >= 0 && renderOrder < 4)\r\n        {\r\n            this._renderOrder = renderOrder;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting\r\n     * faces are used internally for optimizing collisions against tiles. This method is mostly used\r\n     * internally to optimize recalculating faces when only one tile has been changed.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#calculateFacesAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate.\r\n     * @param {number} tileY - The y coordinate.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    calculateFacesAt: function (tileX, tileY)\r\n    {\r\n        TilemapComponents.CalculateFacesAt(tileX, tileY, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n     * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n     * is mostly used internally.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#calculateFacesWithin\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    calculateFacesWithin: function (tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.CalculateFacesWithin(tileX, tileY, width, height, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a Sprite for every object matching the given tile indexes in the layer. You can\r\n     * optionally specify if each tile will be replaced with a new tile after the Sprite has been\r\n     * created. This is useful if you want to lay down special tiles in a level that are converted to\r\n     * Sprites, but want to replace the tile itself with a floor tile or similar once converted.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#createFromTiles\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|array)} indexes - The tile index, or array of indexes, to create Sprites from.\r\n     * @param {(number|array)} replacements - The tile index, or array of indexes, to change a converted\r\n     * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a\r\n     * one-to-one mapping with the indexes array.\r\n     * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} [spriteConfig] - The config object to pass into the Sprite creator (i.e.\r\n     * scene.make.sprite).\r\n     * @param {Phaser.Scene} [scene] - The Scene to create the Sprites within.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when determining the world XY\r\n     *\r\n     * @return {Phaser.GameObjects.Sprite[]} An array of the Sprites that were created.\r\n     */\r\n    createFromTiles: function (indexes, replacements, spriteConfig, scene, camera)\r\n    {\r\n        return TilemapComponents.CreateFromTiles(indexes, replacements, spriteConfig, scene, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Returns the tiles in the given layer that are within the cameras viewport.\r\n     * This is used internally during rendering.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#cull\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to run the cull check against.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects to render.\r\n     */\r\n    cull: function (camera)\r\n    {\r\n        return this.cullCallback(this.layer, camera, this.culledTiles, this._renderOrder);\r\n    },\r\n\r\n    /**\r\n     * Copies the tiles in the source rectangular area to a new destination (all specified in tile\r\n     * coordinates) within the layer. This copies all tile properties & recalculates collision\r\n     * information in the destination region.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#copy\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} srcTileX - The x coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {number} srcTileY - The y coordinate of the area to copy from, in tiles, not pixels.\r\n     * @param {number} width - The width of the area to copy, in tiles, not pixels.\r\n     * @param {number} height - The height of the area to copy, in tiles, not pixels.\r\n     * @param {number} destTileX - The x coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {number} destTileY - The y coordinate of the area to copy to, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    copy: function (srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces)\r\n    {\r\n        TilemapComponents.Copy(srcTileX, srcTileY, width, height, destTileX, destTileY, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the\r\n     * specified index. Tiles will be set to collide if the given index is a colliding index.\r\n     * Collision information in the region will be recalculated.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#fill\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} index - The tile index to fill the area with.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    fill: function (index, tileX, tileY, width, height, recalculateFaces)\r\n    {\r\n        TilemapComponents.Fill(index, tileX, tileY, width, height, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns\r\n     * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#filterTiles\r\n     * @since 3.50.0\r\n     *\r\n     * @param {function} callback - The callback. Each tile in the given area will be passed to this\r\n     * callback as the first and only parameter. The callback should return true for tiles that pass the\r\n     * filter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to filter.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects.\r\n     */\r\n    filterTiles: function (callback, context, tileX, tileY, width, height, filteringOptions)\r\n    {\r\n        return TilemapComponents.FilterTiles(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Searches the entire map layer for the first tile matching the given index, then returns that Tile\r\n     * object. If no match is found, it returns null. The search starts from the top-left tile and\r\n     * continues horizontally until it hits the end of the row, then it drops down to the next column.\r\n     * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to\r\n     * the top-left.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#findByIndex\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} index - The tile index value to search for.\r\n     * @param {number} [skip=0] - The number of times to skip a matching tile before returning.\r\n     * @param {boolean} [reverse=false] - If true it will scan the layer in reverse, starting at the bottom-right. Otherwise it scans from the top-left.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The first matching Tile object.\r\n     */\r\n    findByIndex: function (findIndex, skip, reverse)\r\n    {\r\n        return TilemapComponents.FindByIndex(findIndex, skip, reverse, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Find the first tile in the given rectangular area (in tile coordinates) of the layer that\r\n     * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns\r\n     * true. Similar to Array.prototype.find in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#findTile\r\n     * @since 3.50.0\r\n     *\r\n     * @param {FindTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     *\r\n     * @return {?Phaser.Tilemaps.Tile} The first Tile found at the given location.\r\n     */\r\n    findTile: function (callback, context, tileX, tileY, width, height, filteringOptions)\r\n    {\r\n        return TilemapComponents.FindTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);\r\n    },\r\n\r\n    /**\r\n     * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given\r\n     * callback. Similar to Array.prototype.forEach in vanilla JS.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#forEachTile\r\n     * @since 3.50.0\r\n     *\r\n     * @param {EachTileCallback} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\r\n     * @param {object} [context] - The context, or scope, under which the callback should be run.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area to search.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    forEachTile: function (callback, context, tileX, tileY, width, height, filteringOptions)\r\n    {\r\n        TilemapComponents.ForEachTile(callback, context, tileX, tileY, width, height, filteringOptions, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given tile coordinates from the given layer.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTileAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - X position to get the tile from (given in tile units, not pixels).\r\n     * @param {number} tileY - Y position to get the tile from (given in tile units, not pixels).\r\n     * @param {boolean} [nonNull=false] - If true getTile won't return null for empty tiles, but a Tile object with an index of -1.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The Tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n     */\r\n    getTileAt: function (tileX, tileY, nonNull)\r\n    {\r\n        return TilemapComponents.GetTileAt(tileX, tileY, nonNull, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Gets a tile at the given world coordinates from the given layer.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTileAtWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - X position to get the tile from (given in pixels)\r\n     * @param {number} worldY - Y position to get the tile from (given in pixels)\r\n     * @param {boolean} [nonNull=false] - If true, function won't return null for empty tiles, but a Tile object with an index of -1.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The tile at the given coordinates or null if no tile was found or the coordinates were invalid.\r\n     */\r\n    getTileAtWorldXY: function (worldX, worldY, nonNull, camera)\r\n    {\r\n        return TilemapComponents.GetTileAtWorldXY(worldX, worldY, nonNull, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTilesWithin\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects found within the area.\r\n     */\r\n    getTilesWithin: function (tileX, tileY, width, height, filteringOptions)\r\n    {\r\n        return TilemapComponents.GetTilesWithin(tileX, tileY, width, height, filteringOptions, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,\r\n     * Line, Rectangle or Triangle. The shape should be in world coordinates.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTilesWithinShape\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(Phaser.Geom.Circle|Phaser.Geom.Line|Phaser.Geom.Rectangle|Phaser.Geom.Triangle)} shape - A shape in world (pixel) coordinates\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects found within the shape.\r\n     */\r\n    getTilesWithinShape: function (shape, filteringOptions, camera)\r\n    {\r\n        return TilemapComponents.GetTilesWithinShape(shape, filteringOptions, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Gets the tiles in the given rectangular area (in world coordinates) of the layer.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#getTilesWithinWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The world x coordinate for the top-left of the area.\r\n     * @param {number} worldY - The world y coordinate for the top-left of the area.\r\n     * @param {number} width - The width of the area.\r\n     * @param {number} height - The height of the area.\r\n     * @param {Phaser.Types.Tilemaps.FilteringOptions} [filteringOptions] - Optional filters to apply when getting the tiles.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile[]} An array of Tile objects found within the area.\r\n     */\r\n    getTilesWithinWorldXY: function (worldX, worldY, width, height, filteringOptions, camera)\r\n    {\r\n        return TilemapComponents.GetTilesWithinWorldXY(worldX, worldY, width, height, filteringOptions, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#hasTileAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     *\r\n     * @return {boolean} `true` if a tile was found at the given location, otherwise `false`.\r\n     */\r\n    hasTileAt: function (tileX, tileY)\r\n    {\r\n        return TilemapComponents.HasTileAt(tileX, tileY, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns\r\n     * false if there is no tile or if the tile at that location has an index of -1.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#hasTileAtWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when factoring in which tiles to return.\r\n     *\r\n     * @return {boolean} `true` if a tile was found at the given location, otherwise `false`.\r\n     */\r\n    hasTileAtWorldXY: function (worldX, worldY, camera)\r\n    {\r\n        return TilemapComponents.HasTileAtWorldXY(worldX, worldY, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index\r\n     * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified\r\n     * location. If you pass in an index, only the index at the specified location will be changed.\r\n     * Collision information will be recalculated at the specified location.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#putTileAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The Tile object that was inserted at the given coordinates.\r\n     */\r\n    putTileAt: function (tile, tileX, tileY, recalculateFaces)\r\n    {\r\n        return TilemapComponents.PutTileAt(tile, tileX, tileY, recalculateFaces, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either\r\n     * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the\r\n     * specified location. If you pass in an index, only the index at the specified location will be\r\n     * changed. Collision information will be recalculated at the specified location.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#putTileAtWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|Phaser.Tilemaps.Tile)} tile - The index of this tile to set or a Tile object.\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [recalculateFaces] - `true` if the faces data should be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The Tile object that was inserted at the given coordinates.\r\n     */\r\n    putTileAtWorldXY: function (tile, worldX, worldY, recalculateFaces, camera)\r\n    {\r\n        return TilemapComponents.PutTileAtWorldXY(tile, worldX, worldY, recalculateFaces, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified\r\n     * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,\r\n     * all attributes will be copied over to the specified location. If you pass in an index, only the\r\n     * index at the specified location will be changed. Collision information will be recalculated\r\n     * within the region tiles were changed.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#putTilesAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number[]|number[][]|Phaser.Tilemaps.Tile[]|Phaser.Tilemaps.Tile[][])} tile - A row (array) or grid (2D array) of Tiles or tile indexes to place.\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    putTilesAt: function (tilesArray, tileX, tileY, recalculateFaces)\r\n    {\r\n        TilemapComponents.PutTilesAt(tilesArray, tileX, tileY, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then\r\n     * those will be used for randomly assigning new tile indexes. If an array is not provided, the\r\n     * indexes found within the region (excluding -1) will be used for randomly assigning new tile\r\n     * indexes. This method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#randomize\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {number[]} [indexes] - An array of indexes to randomly draw from during randomization.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    randomize: function (tileX, tileY, width, height, indexes)\r\n    {\r\n        TilemapComponents.Randomize(tileX, tileY, width, height, indexes, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given tile coordinates in the specified layer and updates the layers\r\n     * collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#removeTileAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} A Tile object.\r\n     */\r\n    removeTileAt: function (tileX, tileY, replaceWithNull, recalculateFaces)\r\n    {\r\n        return TilemapComponents.RemoveTileAt(tileX, tileY, replaceWithNull, recalculateFaces, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Removes the tile at the given world coordinates in the specified layer and updates the layers\r\n     * collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#removeTileAtWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The x coordinate, in pixels.\r\n     * @param {number} worldY - The y coordinate, in pixels.\r\n     * @param {boolean} [replaceWithNull=true] - If true, this will replace the tile at the specified location with null instead of a Tile with an index of -1.\r\n     * @param {boolean} [recalculateFaces=true] - `true` if the faces data should be recalculated.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Tilemaps.Tile} The Tile object that was removed from the given location.\r\n     */\r\n    removeTileAtWorldXY: function (worldX, worldY, replaceWithNull, recalculateFaces, camera)\r\n    {\r\n        return TilemapComponents.RemoveTileAtWorldXY(worldX, worldY, replaceWithNull, recalculateFaces, camera, this.layer);\r\n    },\r\n\r\n    /**\r\n     * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to\r\n     * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles\r\n     * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation\r\n     * wherever you want on the screen.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#renderDebug\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The target Graphics object to draw upon.\r\n     * @param {Phaser.Types.Tilemaps.StyleConfig} [styleConfig] - An object specifying the colors to use for the debug drawing.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    renderDebug: function (graphics, styleConfig)\r\n    {\r\n        TilemapComponents.RenderDebug(graphics, styleConfig, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does\r\n     * not change collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#replaceByIndex\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} findIndex - The index of the tile to search for.\r\n     * @param {number} newIndex - The index of the tile to replace it with.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    replaceByIndex: function (findIndex, newIndex, tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.ReplaceByIndex(findIndex, newIndex, tileX, tileY, width, height, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * You can control if the Cameras should cull tiles before rendering them or not.\r\n     *\r\n     * By default the camera will try to cull the tiles in this layer, to avoid over-drawing to the renderer.\r\n     *\r\n     * However, there are some instances when you may wish to disable this.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setSkipCull\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [value=true] - Set to `true` to stop culling tiles. Set to `false` to enable culling again.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setSkipCull: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.skipCull = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When a Camera culls the tiles in this layer it does so using its view into the world, building up a\r\n     * rectangle inside which the tiles must exist or they will be culled. Sometimes you may need to expand the size\r\n     * of this 'cull rectangle', especially if you plan on rotating the Camera viewing the layer. Do so\r\n     * by providing the padding values. The values given are in tiles, not pixels. So if the tile width was 32px\r\n     * and you set `paddingX` to be 4, it would add 32px x 4 to the cull rectangle (adjusted for scale)\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCullPadding\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [paddingX=1] - The amount of extra horizontal tiles to add to the cull check padding.\r\n     * @param {number} [paddingY=1] - The amount of extra vertical tiles to add to the cull check padding.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCullPadding: function (paddingX, paddingY)\r\n    {\r\n        if (paddingX === undefined) { paddingX = 1; }\r\n        if (paddingY === undefined) { paddingY = 1; }\r\n\r\n        this.cullPaddingX = paddingX;\r\n        this.cullPaddingY = paddingY;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the given tile or tiles within a layer by index. You can pass in either a\r\n     * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if\r\n     * collision will be enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollision\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|array)} indexes - Either a single tile index, or an array of tile indexes.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     * @param {boolean} [updateLayer=true] - If true, updates the current tiles on the layer. Set to false if no tiles have been placed for significant performance boost.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollision: function (indexes, collides, recalculateFaces, updateLayer)\r\n    {\r\n        TilemapComponents.SetCollision(indexes, collides, recalculateFaces, this.layer, updateLayer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on a range of tiles in a layer whose index is between the specified `start` and\r\n     * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set\r\n     * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be\r\n     * enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollisionBetween\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} start - The first index of the tile to be set for collision.\r\n     * @param {number} stop - The last index of the tile to be set for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollisionBetween: function (start, stop, collides, recalculateFaces)\r\n    {\r\n        TilemapComponents.SetCollisionBetween(start, stop, collides, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property\r\n     * that matches the given properties object, its collision flag will be set. The `collides`\r\n     * parameter controls if collision will be enabled (true) or disabled (false). Passing in\r\n     * `{ collides: true }` would update the collision flag on any tiles with a \"collides\" property that\r\n     * has a value of true. Any tile that doesn't have \"collides\" set to true will be ignored. You can\r\n     * also use an array of values, e.g. `{ types: [\"stone\", \"lava\", \"sand\" ] }`. If a tile has a\r\n     * \"types\" property that matches any of those values, its collision flag will be updated.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollisionByProperty\r\n     * @since 3.50.0\r\n     *\r\n     * @param {object} properties - An object with tile properties and corresponding values that should be checked.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollisionByProperty: function (properties, collides, recalculateFaces)\r\n    {\r\n        TilemapComponents.SetCollisionByProperty(properties, collides, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on all tiles in the given layer, except for tiles that have an index specified in\r\n     * the given array. The `collides` parameter controls if collision will be enabled (true) or\r\n     * disabled (false). Tile indexes not currently in the layer are not affected.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollisionByExclusion\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number[]} indexes - An array of the tile indexes to not be counted for collision.\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollisionByExclusion: function (indexes, collides, recalculateFaces)\r\n    {\r\n        TilemapComponents.SetCollisionByExclusion(indexes, collides, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets collision on the tiles within a layer by checking each tiles collision group data\r\n     * (typically defined in Tiled within the tileset collision editor). If any objects are found within\r\n     * a tiles collision group, the tile's colliding information will be set. The `collides` parameter\r\n     * controls if collision will be enabled (true) or disabled (false).\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setCollisionFromCollisionGroup\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate the tile faces after the update.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setCollisionFromCollisionGroup: function (collides, recalculateFaces)\r\n    {\r\n        TilemapComponents.SetCollisionFromCollisionGroup(collides, recalculateFaces, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a global collision callback for the given tile index within the layer. This will affect all\r\n     * tiles on this layer that have the same index. If a callback is already set for the tile index it\r\n     * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile\r\n     * at a specific location on the map then see setTileLocationCallback.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setTileIndexCallback\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|number[])} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for.\r\n     * @param {function} callback - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} callbackContext - The context under which the callback is called.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setTileIndexCallback: function (indexes, callback, callbackContext)\r\n    {\r\n        TilemapComponents.SetTileIndexCallback(indexes, callback, callbackContext, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.\r\n     * If a callback is already set for the tile index it will be replaced. Set the callback to null to\r\n     * remove it.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#setTileLocationCallback\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     * @param {function} [callback] - The callback that will be invoked when the tile is collided with.\r\n     * @param {object} [callbackContext] - The context, or scope, under which the callback is invoked.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    setTileLocationCallback: function (tileX, tileY, width, height, callback, callbackContext)\r\n    {\r\n        TilemapComponents.SetTileLocationCallback(tileX, tileY, width, height, callback, callbackContext, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given\r\n     * layer. It will only randomize the tiles in that area, so if they're all the same nothing will\r\n     * appear to have changed! This method only modifies tile indexes and does not change collision\r\n     * information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#shuffle\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    shuffle: function (tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.Shuffle(tileX, tileY, width, height, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching\r\n     * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision\r\n     * information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#swapByIndex\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileA - First tile index.\r\n     * @param {number} tileB - Second tile index.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    swapByIndex: function (indexA, indexB, tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.SwapByIndex(indexA, indexB, tileX, tileY, width, height, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#tileToWorldX\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {number} The Tile X coordinate converted to pixels.\r\n     */\r\n    tileToWorldX: function (tileX, camera)\r\n    {\r\n        return this.tilemap.tileToWorldX(tileX, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#tileToWorldY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {number} The Tile Y coordinate converted to pixels.\r\n     */\r\n    tileToWorldY: function (tileY, camera)\r\n    {\r\n        return this.tilemap.tileToWorldY(tileY, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#tileToWorldXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} tileX - The x coordinate, in tiles, not pixels.\r\n     * @param {number} tileY - The y coordinate, in tiles, not pixels.\r\n     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Math.Vector2} A Vector2 containing the world coordinates of the Tile.\r\n     */\r\n    tileToWorldXY: function (tileX, tileY, point, camera)\r\n    {\r\n        return this.tilemap.tileToWorldXY(tileX, tileY, point, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the\r\n     * specified layer. Each tile will receive a new index. New indexes are drawn from the given\r\n     * weightedIndexes array. An example weighted array:\r\n     *\r\n     * [\r\n     *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8\r\n     *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8\r\n     *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8\r\n     *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8\r\n     * ]\r\n     *\r\n     * The probability of any index being choose is (the index's weight) / (sum of all weights). This\r\n     * method only modifies tile indexes and does not change collision information.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#weightedRandomize\r\n     * @since 3.50.0\r\n     *\r\n     * @param {object[]} weightedIndexes - An array of objects to randomly draw from during randomization. They should be in the form: { index: 0, weight: 4 } or { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.\r\n     * @param {number} [tileX] - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [tileY] - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n     * @param {number} [width] - How many tiles wide from the `tileX` index the area will be.\r\n     * @param {number} [height] - How many tiles tall from the `tileY` index the area will be.\r\n     *\r\n     * @return {this} This Tilemap Layer object.\r\n     */\r\n    weightedRandomize: function (weightedIndexes, tileX, tileY, width, height)\r\n    {\r\n        TilemapComponents.WeightedRandomize(tileX, tileY, width, height, weightedIndexes, this.layer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#worldToTileX\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {number} The tile X coordinate based on the world value.\r\n     */\r\n    worldToTileX: function (worldX, snapToFloor, camera)\r\n    {\r\n        return this.tilemap.worldToTileX(worldX, snapToFloor, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#worldToTileY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {number} The tile Y coordinate based on the world value.\r\n     */\r\n    worldToTileY: function (worldY, snapToFloor, camera)\r\n    {\r\n        return this.tilemap.worldToTileY(worldY, snapToFloor, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the\r\n     * layers position, scale and scroll. This will return a new Vector2 object or update the given\r\n     * `point` object.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#worldToTileXY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} worldX - The x coordinate to be converted, in pixels, not tiles.\r\n     * @param {number} worldY - The y coordinate to be converted, in pixels, not tiles.\r\n     * @param {boolean} [snapToFloor] - Whether or not to round the tile coordinate down to the nearest integer.\r\n     * @param {Phaser.Math.Vector2} [point] - A Vector2 to store the coordinates in. If not given a new Vector2 is created.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use when calculating the tile index from the world values.\r\n     *\r\n     * @return {Phaser.Math.Vector2} A Vector2 containing the tile coordinates of the world values.\r\n     */\r\n    worldToTileXY: function (worldX, worldY, snapToFloor, point, camera)\r\n    {\r\n        return this.tilemap.worldToTileXY(worldX, worldY, snapToFloor, point, camera, this);\r\n    },\r\n\r\n    /**\r\n     * Destroys this TilemapLayer and removes its link to the associated LayerData.\r\n     *\r\n     * @method Phaser.Tilemaps.TilemapLayer#destroy\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [removeFromTilemap=true] - Remove this layer from the parent Tilemap?\r\n     */\r\n    destroy: function (removeFromTilemap)\r\n    {\r\n        if (removeFromTilemap === undefined) { removeFromTilemap = true; }\r\n\r\n        if (!this.tilemap)\r\n        {\r\n            //  Abort, we've already been destroyed\r\n            return;\r\n        }\r\n\r\n        //  Uninstall this layer only if it is still installed on the LayerData object\r\n        if (this.layer.tilemapLayer === this)\r\n        {\r\n            this.layer.tilemapLayer = undefined;\r\n        }\r\n\r\n        if (removeFromTilemap)\r\n        {\r\n            this.tilemap.removeLayer(this);\r\n        }\r\n\r\n        this.tilemap = undefined;\r\n        this.layer = undefined;\r\n        this.culledTiles.length = 0;\r\n        this.cullCallback = null;\r\n\r\n        this.gidMap = [];\r\n        this.tileset = [];\r\n\r\n        GameObject.prototype.destroy.call(this);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = TilemapLayer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar AnimationState = require('../../animations/AnimationState');\nvar Class = require('../../utils/Class');\nvar Components = require('../components');\nvar GameObject = require('../GameObject');\nvar SpriteRender = require('./SpriteRender');\n\n/**\n * @classdesc\n * A Sprite Game Object.\n *\n * A Sprite Game Object is used for the display of both static and animated images in your game.\n * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\n * and animated.\n *\n * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.\n * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\n * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.\n *\n * @class Sprite\n * @extends Phaser.GameObjects.GameObject\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @extends Phaser.GameObjects.Components.Alpha\n * @extends Phaser.GameObjects.Components.BlendMode\n * @extends Phaser.GameObjects.Components.Depth\n * @extends Phaser.GameObjects.Components.Flip\n * @extends Phaser.GameObjects.Components.GetBounds\n * @extends Phaser.GameObjects.Components.Mask\n * @extends Phaser.GameObjects.Components.Origin\n * @extends Phaser.GameObjects.Components.Pipeline\n * @extends Phaser.GameObjects.Components.ScrollFactor\n * @extends Phaser.GameObjects.Components.Size\n * @extends Phaser.GameObjects.Components.TextureCrop\n * @extends Phaser.GameObjects.Components.Tint\n * @extends Phaser.GameObjects.Components.Transform\n * @extends Phaser.GameObjects.Components.Visible\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n */\nvar Sprite = new Class({\n\n    Extends: GameObject,\n\n    Mixins: [\n        Components.Alpha,\n        Components.BlendMode,\n        Components.Depth,\n        Components.Flip,\n        Components.GetBounds,\n        Components.Mask,\n        Components.Origin,\n        Components.Pipeline,\n        Components.ScrollFactor,\n        Components.Size,\n        Components.TextureCrop,\n        Components.Tint,\n        Components.Transform,\n        Components.Visible,\n        SpriteRender\n    ],\n\n    initialize:\n\n    function Sprite (scene, x, y, texture, frame)\n    {\n        GameObject.call(this, scene, 'Sprite');\n\n        /**\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\n         *\n         * @name Phaser.GameObjects.Sprite#_crop\n         * @type {object}\n         * @private\n         * @since 3.11.0\n         */\n        this._crop = this.resetCropObject();\n\n        /**\n         * The Animation State component of this Sprite.\n         *\n         * This component provides features to apply animations to this Sprite.\n         * It is responsible for playing, loading, queuing animations for later playback,\n         * mixing between animations and setting the current animation frame to this Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite#anims\n         * @type {Phaser.Animations.AnimationState}\n         * @since 3.0.0\n         */\n        this.anims = new AnimationState(this);\n\n        this.setTexture(texture, frame);\n        this.setPosition(x, y);\n        this.setSizeToFrame();\n        this.setOriginFromFrame();\n        this.initPipeline();\n    },\n\n    //  Overrides Game Object method\n    addedToScene: function ()\n    {\n        this.scene.sys.updateList.add(this);\n    },\n\n    //  Overrides Game Object method\n    removedFromScene: function ()\n    {\n        this.scene.sys.updateList.remove(this);\n    },\n\n    /**\n     * Update this Sprite's animations.\n     *\n     * @method Phaser.GameObjects.Sprite#preUpdate\n     * @protected\n     * @since 3.0.0\n     *\n     * @param {number} time - The current timestamp.\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\n     */\n    preUpdate: function (time, delta)\n    {\n        this.anims.update(time, delta);\n    },\n\n    /**\n     * Start playing the given animation on this Sprite.\n     *\n     * Animations in Phaser can either belong to the global Animation Manager, or specifically to this Sprite.\n     *\n     * The benefit of a global animation is that multiple Sprites can all play the same animation, without\n     * having to duplicate the data. You can just create it once and then play it on any Sprite.\n     *\n     * The following code shows how to create a global repeating animation. The animation will be created\n     * from all of the frames within the sprite sheet that was loaded with the key 'muybridge':\n     *\n     * ```javascript\n     * var config = {\n     *     key: 'run',\n     *     frames: 'muybridge',\n     *     frameRate: 15,\n     *     repeat: -1\n     * };\n     *\n     * //  This code should be run from within a Scene:\n     * this.anims.create(config);\n     * ```\n     *\n     * However, if you wish to create an animation that is unique to this Sprite, and this Sprite alone,\n     * you can call the `Animation.create` method instead. It accepts the exact same parameters as when\n     * creating a global animation, however the resulting data is kept locally in this Sprite.\n     *\n     * With the animation created, either globally or locally, you can now play it on this Sprite:\n     *\n     * ```javascript\n     * this.add.sprite(x, y).play('run');\n     * ```\n     *\n     * Alternatively, if you wish to run it at a different frame rate, for example, you can pass a config\n     * object instead:\n     *\n     * ```javascript\n     * this.add.sprite(x, y).play({ key: 'run', frameRate: 24 });\n     * ```\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * If you need a Sprite to be able to play both local and global animations, make sure they don't\n     * have conflicting keys.\n     *\n     * See the documentation for the `PlayAnimationConfig` config object for more details about this.\n     *\n     * Also, see the documentation in the Animation Manager for further details on creating animations.\n     *\n     * @method Phaser.GameObjects.Sprite#play\n     * @fires Phaser.Animations.Events#ANIMATION_START\n     * @since 3.0.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\n     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.\n     *\n     * @return {this} This Game Object.\n     */\n    play: function (key, ignoreIfPlaying)\n    {\n        return this.anims.play(key, ignoreIfPlaying);\n    },\n\n    /**\n     * Start playing the given animation on this Sprite, in reverse.\n     *\n     * Animations in Phaser can either belong to the global Animation Manager, or specifically to this Sprite.\n     *\n     * The benefit of a global animation is that multiple Sprites can all play the same animation, without\n     * having to duplicate the data. You can just create it once and then play it on any Sprite.\n     *\n     * The following code shows how to create a global repeating animation. The animation will be created\n     * from all of the frames within the sprite sheet that was loaded with the key 'muybridge':\n     *\n     * ```javascript\n     * var config = {\n     *     key: 'run',\n     *     frames: 'muybridge',\n     *     frameRate: 15,\n     *     repeat: -1\n     * };\n     *\n     * //  This code should be run from within a Scene:\n     * this.anims.create(config);\n     * ```\n     *\n     * However, if you wish to create an animation that is unique to this Sprite, and this Sprite alone,\n     * you can call the `Animation.create` method instead. It accepts the exact same parameters as when\n     * creating a global animation, however the resulting data is kept locally in this Sprite.\n     *\n     * With the animation created, either globally or locally, you can now play it on this Sprite:\n     *\n     * ```javascript\n     * this.add.sprite(x, y).playReverse('run');\n     * ```\n     *\n     * Alternatively, if you wish to run it at a different frame rate, for example, you can pass a config\n     * object instead:\n     *\n     * ```javascript\n     * this.add.sprite(x, y).playReverse({ key: 'run', frameRate: 24 });\n     * ```\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * If you need a Sprite to be able to play both local and global animations, make sure they don't\n     * have conflicting keys.\n     *\n     * See the documentation for the `PlayAnimationConfig` config object for more details about this.\n     *\n     * Also, see the documentation in the Animation Manager for further details on creating animations.\n     *\n     * @method Phaser.GameObjects.Sprite#playReverse\n     * @fires Phaser.Animations.Events#ANIMATION_START\n     * @since 3.50.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\n     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.\n     *\n     * @return {this} This Game Object.\n     */\n    playReverse: function (key, ignoreIfPlaying)\n    {\n        return this.anims.playReverse(key, ignoreIfPlaying);\n    },\n\n    /**\n     * Waits for the specified delay, in milliseconds, then starts playback of the given animation.\n     *\n     * If the animation _also_ has a delay value set in its config, it will be **added** to the delay given here.\n     *\n     * If an animation is already running and a new animation is given to this method, it will wait for\n     * the given delay before starting the new animation.\n     *\n     * If no animation is currently running, the given one begins after the delay.\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * Prior to Phaser 3.50 this method was called 'delayedPlay'.\n     *\n     * @method Phaser.GameObjects.Sprite#playAfterDelay\n     * @fires Phaser.Animations.Events#ANIMATION_START\n     * @since 3.50.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\n     * @param {number} delay - The delay, in milliseconds, to wait before starting the animation playing.\n     *\n     * @return {this} This Game Object.\n     */\n    playAfterDelay: function (key, delay)\n    {\n        return this.anims.playAfterDelay(key, delay);\n    },\n\n    /**\n     * Waits for the current animation to complete the `repeatCount` number of repeat cycles, then starts playback\n     * of the given animation.\n     *\n     * You can use this to ensure there are no harsh jumps between two sets of animations, i.e. going from an\n     * idle animation to a walking animation, by making them blend smoothly into each other.\n     *\n     * If no animation is currently running, the given one will start immediately.\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * @method Phaser.GameObjects.Sprite#playAfterRepeat\n     * @fires Phaser.Animations.Events#ANIMATION_START\n     * @since 3.50.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\n     * @param {number} [repeatCount=1] - How many times should the animation repeat before the next one starts?\n     *\n     * @return {this} This Game Object.\n     */\n    playAfterRepeat: function (key, repeatCount)\n    {\n        return this.anims.playAfterRepeat(key, repeatCount);\n    },\n\n    /**\n     * Sets an animation, or an array of animations, to be played immediately after the current one completes or stops.\n     *\n     * The current animation must enter a 'completed' state for this to happen, i.e. finish all of its repeats, delays, etc,\n     * or have the `stop` method called directly on it.\n     *\n     * An animation set to repeat forever will never enter a completed state.\n     *\n     * You can chain a new animation at any point, including before the current one starts playing, during it,\n     * or when it ends (via its `animationcomplete` event).\n     *\n     * Chained animations are specific to a Game Object, meaning different Game Objects can have different chained\n     * animations without impacting the animation they're playing.\n     *\n     * Call this method with no arguments to reset all currently chained animations.\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * @method Phaser.GameObjects.Sprite#chain\n     * @since 3.50.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig|string[]|Phaser.Animations.Animation[]|Phaser.Types.Animations.PlayAnimationConfig[])} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object, or an array of them.\n     *\n     * @return {this} This Game Object.\n     */\n    chain: function (key)\n    {\n        return this.anims.chain(key);\n    },\n\n    /**\n     * Immediately stops the current animation from playing and dispatches the `ANIMATION_STOP` events.\n     *\n     * If no animation is playing, no event will be dispatched.\n     *\n     * If there is another animation queued (via the `chain` method) then it will start playing immediately.\n     *\n     * @method Phaser.GameObjects.Sprite#stop\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\n     * @since 3.50.0\n     *\n     * @return {this} This Game Object.\n     */\n    stop: function ()\n    {\n        return this.anims.stop();\n    },\n\n    /**\n     * Stops the current animation from playing after the specified time delay, given in milliseconds.\n     *\n     * It then dispatches the `ANIMATION_STOP` event.\n     *\n     * If no animation is running, no events will be dispatched.\n     *\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\n     * when the current one stops.\n     *\n     * @method Phaser.GameObjects.Sprite#stopAfterDelay\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\n     * @since 3.50.0\n     *\n     * @param {number} delay - The number of milliseconds to wait before stopping this animation.\n     *\n     * @return {this} This Game Object.\n     */\n    stopAfterDelay: function (delay)\n    {\n        return this.anims.stopAfterDelay(delay);\n    },\n\n    /**\n     * Stops the current animation from playing after the given number of repeats.\n     *\n     * It then dispatches the `ANIMATION_STOP` event.\n     *\n     * If no animation is running, no events will be dispatched.\n     *\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\n     * when the current one stops.\n     *\n     * @method Phaser.GameObjects.Sprite#stopAfterRepeat\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\n     * @since 3.50.0\n     *\n     * @param {number} [repeatCount=1] - How many times should the animation repeat before stopping?\n     *\n     * @return {this} This Game Object.\n     */\n    stopAfterRepeat: function (repeatCount)\n    {\n        return this.anims.stopAfterRepeat(repeatCount);\n    },\n\n    /**\n     * Stops the current animation from playing when it next sets the given frame.\n     * If this frame doesn't exist within the animation it will not stop it from playing.\n     *\n     * It then dispatches the `ANIMATION_STOP` event.\n     *\n     * If no animation is running, no events will be dispatched.\n     *\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\n     * when the current one stops.\n     *\n     * @method Phaser.GameObjects.Sprite#stopOnFrame\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\n     * @since 3.50.0\n     *\n     * @param {Phaser.Animations.AnimationFrame} frame - The frame to check before stopping this animation.\n     *\n     * @return {this} This Game Object.\n     */\n    stopOnFrame: function (frame)\n    {\n        return this.anims.stopOnFrame(frame);\n    },\n\n    /**\n     * Build a JSON representation of this Sprite.\n     *\n     * @method Phaser.GameObjects.Sprite#toJSON\n     * @since 3.0.0\n     *\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\n     */\n    toJSON: function ()\n    {\n        return Components.ToJSON(this);\n    },\n\n    /**\n     * Handles the pre-destroy step for the Sprite, which removes the Animation component.\n     *\n     * @method Phaser.GameObjects.Sprite#preDestroy\n     * @private\n     * @since 3.14.0\n     */\n    preDestroy: function ()\n    {\n        this.anims.destroy();\n\n        this.anims = undefined;\n    }\n\n});\n\nmodule.exports = Sprite;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetTileAt = require('./GetTileAt');\r\nvar GetTilesWithin = require('./GetTilesWithin');\r\n\r\n/**\r\n * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the\r\n * layer. Interesting faces are used internally for optimizing collisions against tiles. This method\r\n * is mostly used internally.\r\n *\r\n * @function Phaser.Tilemaps.Components.CalculateFacesWithin\r\n * @since 3.0.0\r\n *\r\n * @param {number} tileX - The left most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} tileY - The top most tile index (in tile coordinates) to use as the origin of the area.\r\n * @param {number} width - How many tiles wide from the `tileX` index the area will be.\r\n * @param {number} height - How many tiles tall from the `tileY` index the area will be.\r\n * @param {Phaser.Tilemaps.LayerData} layer - The Tilemap Layer to act upon.\r\n */\r\nvar CalculateFacesWithin = function (tileX, tileY, width, height, layer)\r\n{\r\n    var above = null;\r\n    var below = null;\r\n    var left = null;\r\n    var right = null;\r\n\r\n    var tiles = GetTilesWithin(tileX, tileY, width, height, null, layer);\r\n\r\n    for (var i = 0; i < tiles.length; i++)\r\n    {\r\n        var tile = tiles[i];\r\n\r\n        if (tile)\r\n        {\r\n            if (tile.collides)\r\n            {\r\n                above = GetTileAt(tile.x, tile.y - 1, true, layer);\r\n                below = GetTileAt(tile.x, tile.y + 1, true, layer);\r\n                left = GetTileAt(tile.x - 1, tile.y, true, layer);\r\n                right = GetTileAt(tile.x + 1, tile.y, true, layer);\r\n\r\n                tile.faceTop = (above && above.collides) ? false : true;\r\n                tile.faceBottom = (below && below.collides) ? false : true;\r\n                tile.faceLeft = (left && left.collides) ? false : true;\r\n                tile.faceRight = (right && right.collides) ? false : true;\r\n            }\r\n            else\r\n            {\r\n                tile.resetFaces();\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = CalculateFacesWithin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Internally used method to set the colliding state of a tile. This does not recalculate\r\n * interesting faces.\r\n *\r\n * @function Phaser.Tilemaps.Components.SetTileCollision\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tilemaps.Tile} tile - The Tile to set the collision on.\r\n * @param {boolean} [collides=true] - Should the tile index collide or not?\r\n */\r\nvar SetTileCollision = function (tile, collides)\r\n{\r\n    if (collides)\r\n    {\r\n        tile.setCollision(true, true, true, true, false);\r\n    }\r\n    else\r\n    {\r\n        tile.resetCollision(false);\r\n    }\r\n};\r\n\r\nmodule.exports = SetTileCollision;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const/ORIENTATION_CONST');\r\nvar Class = require('../utils/Class');\r\nvar Components = require('../gameobjects/components');\r\nvar Rectangle = require('../geom/rectangle');\r\n\r\n/**\r\n * @classdesc\r\n * A Tile is a representation of a single tile within the Tilemap. This is a lightweight data\r\n * representation, so its position information is stored without factoring in scroll, layer\r\n * scale or layer position.\r\n *\r\n * @class Tile\r\n * @memberof Phaser.Tilemaps\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Tilemaps.LayerData} layer - The LayerData object in the Tilemap that this tile belongs to.\r\n * @param {number} index - The unique index of this tile within the map.\r\n * @param {number} x - The x coordinate of this tile in tile coordinates.\r\n * @param {number} y - The y coordinate of this tile in tile coordinates.\r\n * @param {number} width - Width of the tile in pixels.\r\n * @param {number} height - Height of the tile in pixels.\r\n * @param {number} baseWidth - The base width a tile in the map (in pixels). Tiled maps support\r\n * multiple tileset sizes within one map, but they are still placed at intervals of the base\r\n * tile width.\r\n * @param {number} baseHeight - The base height of the tile in pixels (in pixels). Tiled maps\r\n * support multiple tileset sizes within one map, but they are still placed at intervals of the\r\n * base tile height.\r\n */\r\nvar Tile = new Class({\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.Flip,\r\n        Components.Visible\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Tile (layer, index, x, y, width, height, baseWidth, baseHeight)\r\n    {\r\n        /**\r\n         * The LayerData in the Tilemap data that this tile belongs to.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#layer\r\n         * @type {Phaser.Tilemaps.LayerData}\r\n         * @since 3.0.0\r\n         */\r\n        this.layer = layer;\r\n\r\n        /**\r\n         * The index of this tile within the map data corresponding to the tileset, or -1 if this\r\n         * represents a blank tile.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = index;\r\n\r\n        /**\r\n         * The x map coordinate of this tile in tile units.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.x = x;\r\n\r\n        /**\r\n         * The y map coordinate of this tile in tile units.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.y = y;\r\n\r\n        /**\r\n         * The width of the tile in pixels.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = width;\r\n\r\n        /**\r\n         * The height of the tile in pixels.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = height;\r\n\r\n        /**\r\n         * The right of the tile in pixels.\r\n         *\r\n         * Set in the `updatePixelXY` method.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#right\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.right;\r\n\r\n        /**\r\n         * The bottom of the tile in pixels.\r\n         *\r\n         * Set in the `updatePixelXY` method.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#bottom\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.bottom;\r\n\r\n        /**\r\n         * The maps base width of a tile in pixels. Tiled maps support multiple tileset sizes\r\n         * within one map, but they are still placed at intervals of the base tile size.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#baseWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseWidth = (baseWidth !== undefined) ? baseWidth : width;\r\n\r\n        /**\r\n         * The maps base height of a tile in pixels. Tiled maps support multiple tileset sizes\r\n         * within one map, but they are still placed at intervals of the base tile size.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#baseHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.baseHeight = (baseHeight !== undefined) ? baseHeight : height;\r\n\r\n        /**\r\n         * The x coordinate of the top left of this tile in pixels. This is relative to the top left\r\n         * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n         * scroll, layer scale or layer position.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#pixelX\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.pixelX = 0;\r\n\r\n        /**\r\n         * The y coordinate of the top left of this tile in pixels. This is relative to the top left\r\n         * of the layer this tile is being rendered within. This property does NOT factor in camera\r\n         * scroll, layer scale or layer position.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#pixelY\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.pixelY = 0;\r\n\r\n        this.updatePixelXY();\r\n\r\n        /**\r\n         * Tile specific properties. These usually come from Tiled.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#properties\r\n         * @type {any}\r\n         * @since 3.0.0\r\n         */\r\n        this.properties = {};\r\n\r\n        /**\r\n         * The rotation angle of this tile.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#rotation\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.rotation = 0;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the left side.\r\n         *\r\n         * This property is used by Arcade Physics only, however, you can also use it\r\n         * in your own checks.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideLeft\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideLeft = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the right side.\r\n         *\r\n         * This property is used by Arcade Physics only, however, you can also use it\r\n         * in your own checks.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideRight\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideRight = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the top side.\r\n         *\r\n         * This property is used by Arcade Physics only, however, you can also use it\r\n         * in your own checks.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideUp\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideUp = false;\r\n\r\n        /**\r\n         * Whether the tile should collide with any object on the bottom side.\r\n         *\r\n         * This property is used by Arcade Physics only, however, you can also use it\r\n         * in your own checks.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collideDown\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.collideDown = false;\r\n\r\n        /**\r\n         * Whether the tiles left edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceLeft\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceLeft = false;\r\n\r\n        /**\r\n         * Whether the tiles right edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceRight\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceRight = false;\r\n\r\n        /**\r\n         * Whether the tiles top edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceTop\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceTop = false;\r\n\r\n        /**\r\n         * Whether the tiles bottom edge is interesting for collisions.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#faceBottom\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.faceBottom = false;\r\n\r\n        /**\r\n         * Tile collision callback.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collisionCallback\r\n         * @type {function}\r\n         * @since 3.0.0\r\n         */\r\n        this.collisionCallback = undefined;\r\n\r\n        /**\r\n         * The context in which the collision callback will be called.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#collisionCallbackContext\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.collisionCallbackContext = this;\r\n\r\n        /**\r\n         * The tint to apply to this tile. Note: tint is currently a single color value instead of\r\n         * the 4 corner tint component on other GameObjects.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#tint\r\n         * @type {number}\r\n         * @default\r\n         * @since 3.0.0\r\n         */\r\n        this.tint = 0xffffff;\r\n\r\n        /**\r\n         * An empty object where physics-engine specific information (e.g. bodies) may be stored.\r\n         *\r\n         * @name Phaser.Tilemaps.Tile#physics\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.physics = {};\r\n    },\r\n\r\n    /**\r\n     * Check if the given x and y world coordinates are within this Tile. This does not factor in\r\n     * camera scroll, layer scale or layer position.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#containsPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to test.\r\n     * @param {number} y - The y coordinate to test.\r\n     *\r\n     * @return {boolean} True if the coordinates are within this Tile, otherwise false.\r\n     */\r\n    containsPoint: function (x, y)\r\n    {\r\n        return !(x < this.pixelX || y < this.pixelY || x > this.right || y > this.bottom);\r\n    },\r\n\r\n    /**\r\n     * Copies the tile data & properties from the given tile to this tile. This copies everything\r\n     * except for position and interesting faces.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#copy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tilemaps.Tile} tile - The tile to copy from.\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    copy: function (tile)\r\n    {\r\n        this.index = tile.index;\r\n        this.alpha = tile.alpha;\r\n        this.properties = tile.properties;\r\n        this.visible = tile.visible;\r\n        this.setFlip(tile.flipX, tile.flipY);\r\n        this.tint = tile.tint;\r\n        this.rotation = tile.rotation;\r\n        this.collideUp = tile.collideUp;\r\n        this.collideDown = tile.collideDown;\r\n        this.collideLeft = tile.collideLeft;\r\n        this.collideRight = tile.collideRight;\r\n        this.collisionCallback = tile.collisionCallback;\r\n        this.collisionCallbackContext = tile.collisionCallbackContext;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The collision group for this Tile, defined within the Tileset. This returns a reference to\r\n     * the collision group stored within the Tileset, so any modification of the returned object\r\n     * will impact all tiles that have the same index as this tile.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCollisionGroup\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?object} The collision group for this Tile, as defined in the Tileset, or `null` if no group was defined.\r\n     */\r\n    getCollisionGroup: function ()\r\n    {\r\n        return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null;\r\n    },\r\n\r\n    /**\r\n     * The tile data for this Tile, defined within the Tileset. This typically contains Tiled\r\n     * collision data, tile animations and terrain information. This returns a reference to the tile\r\n     * data stored within the Tileset, so any modification of the returned object will impact all\r\n     * tiles that have the same index as this tile.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getTileData\r\n     * @since 3.0.0\r\n     *\r\n     * @return {?object} The tile data for this Tile, as defined in the Tileset, or `null` if no data was defined.\r\n     */\r\n    getTileData: function ()\r\n    {\r\n        return this.tileset ? this.tileset.getTileData(this.index) : null;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the left side of the tile, factoring in the layers position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getLeft\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The left (x) value of this tile.\r\n     */\r\n    getLeft: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        return (tilemapLayer) ? tilemapLayer.tileToWorldX(this.x, camera) : this.x * this.baseWidth;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the right side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getRight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The right (x) value of this tile.\r\n     */\r\n    getRight: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        return (tilemapLayer) ? this.getLeft(camera) + this.width * tilemapLayer.scaleX : this.getLeft(camera) + this.width;\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the top side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The top (y) value of this tile.\r\n     */\r\n    getTop: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        // Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile in grid\r\n        // units is the bottom left, so the y coordinate needs to be adjusted by the difference\r\n        // between the base size and this tile's size.\r\n        return tilemapLayer\r\n            ? tilemapLayer.tileToWorldY(this.y, camera) - (this.height - this.baseHeight) * tilemapLayer.scaleY\r\n            : this.y * this.baseHeight - (this.height - this.baseHeight);\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the bottom side of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n\r\n     * @method Phaser.Tilemaps.Tile#getBottom\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The bottom (y) value of this tile.\r\n     */\r\n    getBottom: function (camera)\r\n    {\r\n        var tilemapLayer = this.tilemapLayer;\r\n\r\n        return tilemapLayer\r\n            ? this.getTop(camera) + this.height * tilemapLayer.scaleY\r\n            : this.getTop(camera) + this.height;\r\n    },\r\n\r\n\r\n    /**\r\n     * Gets the world rectangle bounding box for the tile, factoring in the layers position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     * @param {Phaser.Geom.Rectangle} [output] - Optional Rectangle object to store the results in.\r\n     *\r\n     * @return {(Phaser.Geom.Rectangle|object)} The bounds of this Tile.\r\n     */\r\n    getBounds: function (camera, output)\r\n    {\r\n        if (output === undefined) { output = new Rectangle(); }\r\n\r\n        output.x = this.getLeft();\r\n        output.y = this.getTop();\r\n        output.width = this.getRight() - output.x;\r\n        output.height = this.getBottom() - output.y;\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Gets the world X position of the center of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCenterX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The center x position of this Tile.\r\n     */\r\n    getCenterX: function (camera)\r\n    {\r\n        return (this.getLeft(camera) + this.getRight(camera)) / 2;\r\n    },\r\n\r\n    /**\r\n     * Gets the world Y position of the center of the tile, factoring in the layer's position,\r\n     * scale and scroll.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#getCenterY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera to use to perform the check.\r\n     *\r\n     * @return {number} The center y position of this Tile.\r\n     */\r\n    getCenterY: function (camera)\r\n    {\r\n        return (this.getTop(camera) + this.getBottom(camera)) / 2;\r\n    },\r\n\r\n    /**\r\n     * Check for intersection with this tile. This does not factor in camera scroll, layer scale or\r\n     * layer position.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#intersects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x axis in pixels.\r\n     * @param {number} y - The y axis in pixels.\r\n     * @param {number} right - The right point.\r\n     * @param {number} bottom - The bottom point.\r\n     *\r\n     * @return {boolean} `true` if the Tile intersects with the given dimensions, otherwise `false`.\r\n     */\r\n    intersects: function (x, y, right, bottom)\r\n    {\r\n        return !(\r\n            right <= this.pixelX || bottom <= this.pixelY ||\r\n            x >= this.right || y >= this.bottom\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Checks if the tile is interesting.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#isInteresting\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} collides - If true, will consider the tile interesting if it collides on any side.\r\n     * @param {boolean} faces - If true, will consider the tile interesting if it has an interesting face.\r\n     *\r\n     * @return {boolean} True if the Tile is interesting, otherwise false.\r\n     */\r\n    isInteresting: function (collides, faces)\r\n    {\r\n        if (collides && faces)\r\n        {\r\n            return (this.canCollide || this.hasInterestingFace);\r\n        }\r\n        else if (collides)\r\n        {\r\n            return this.collides;\r\n        }\r\n        else if (faces)\r\n        {\r\n            return this.hasInterestingFace;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Reset collision status flags.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#resetCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces for this tile and its neighbors.\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    resetCollision: function (recalculateFaces)\r\n    {\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        this.collideLeft = false;\r\n        this.collideRight = false;\r\n        this.collideUp = false;\r\n        this.collideDown = false;\r\n\r\n        this.faceTop = false;\r\n        this.faceBottom = false;\r\n        this.faceLeft = false;\r\n        this.faceRight = false;\r\n\r\n        if (recalculateFaces)\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                this.tilemapLayer.calculateFacesAt(this.x, this.y);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reset faces.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#resetFaces\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    resetFaces: function ()\r\n    {\r\n        this.faceTop = false;\r\n        this.faceBottom = false;\r\n        this.faceLeft = false;\r\n        this.faceRight = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision flags for each side of this tile and updates the interesting faces list.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} left - Indicating collide with any object on the left.\r\n     * @param {boolean} [right] - Indicating collide with any object on the right.\r\n     * @param {boolean} [up] - Indicating collide with any object on the top.\r\n     * @param {boolean} [down] - Indicating collide with any object on the bottom.\r\n     * @param {boolean} [recalculateFaces=true] - Whether or not to recalculate interesting faces for this tile and its neighbors.\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    setCollision: function (left, right, up, down, recalculateFaces)\r\n    {\r\n        if (right === undefined) { right = left; }\r\n        if (up === undefined) { up = left; }\r\n        if (down === undefined) { down = left; }\r\n        if (recalculateFaces === undefined) { recalculateFaces = true; }\r\n\r\n        this.collideLeft = left;\r\n        this.collideRight = right;\r\n        this.collideUp = up;\r\n        this.collideDown = down;\r\n\r\n        this.faceLeft = left;\r\n        this.faceRight = right;\r\n        this.faceTop = up;\r\n        this.faceBottom = down;\r\n\r\n        if (recalculateFaces)\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                this.tilemapLayer.calculateFacesAt(this.x, this.y);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set a callback to be called when this tile is hit by an object. The callback must true for\r\n     * collision processing to take place.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setCollisionCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - Callback function.\r\n     * @param {object} context - Callback will be called within this context.\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    setCollisionCallback: function (callback, context)\r\n    {\r\n        if (callback === null)\r\n        {\r\n            this.collisionCallback = undefined;\r\n            this.collisionCallbackContext = undefined;\r\n        }\r\n        else\r\n        {\r\n            this.collisionCallback = callback;\r\n            this.collisionCallbackContext = context;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the size of the tile and updates its pixelX and pixelY.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} tileWidth - The width of the tile in pixels.\r\n     * @param {number} tileHeight - The height of the tile in pixels.\r\n     * @param {number} baseWidth - The base width a tile in the map (in pixels).\r\n     * @param {number} baseHeight - The base height of the tile in pixels (in pixels).\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    setSize: function (tileWidth, tileHeight, baseWidth, baseHeight)\r\n    {\r\n        if (tileWidth !== undefined) { this.width = tileWidth; }\r\n        if (tileHeight !== undefined) { this.height = tileHeight; }\r\n        if (baseWidth !== undefined) { this.baseWidth = baseWidth; }\r\n        if (baseHeight !== undefined) { this.baseHeight = baseHeight; }\r\n\r\n        this.updatePixelXY();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Used internally. Updates the tiles world XY position based on the current tile size.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#updatePixelXY\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Tile object instance.\r\n     */\r\n    updatePixelXY: function ()\r\n    {\r\n        var orientation = this.layer.orientation;\r\n\r\n        if (orientation === CONST.ORTHOGONAL)\r\n        {\r\n            //  In orthogonal mode, Tiled places tiles on a grid of baseWidth x baseHeight. The origin for a tile is the\r\n            //  bottom left, while the Phaser renderer assumes the origin is the top left. The y\r\n            //  coordinate needs to be adjusted by the difference.\r\n\r\n            this.pixelX = this.x * this.baseWidth;\r\n            this.pixelY = this.y * this.baseHeight;\r\n        }\r\n        else if (orientation === CONST.ISOMETRIC)\r\n        {\r\n            //  Reminder: For the tilemap to be centered we have to move the image to the right with the camera!\r\n            //  This is crucial for wordtotile, tiletoworld to work.\r\n\r\n            this.pixelX = (this.x - this.y) * this.baseWidth * 0.5;\r\n            this.pixelY = (this.x + this.y) * this.baseHeight * 0.5;\r\n        }\r\n        else if (orientation === CONST.STAGGERED)\r\n        {\r\n            this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);\r\n            this.pixelY = this.y * (this.baseHeight / 2);\r\n        }\r\n        else if (orientation === CONST.HEXAGONAL)\r\n        {\r\n            var len = this.layer.hexSideLength;\r\n            var rowHeight = ((this.baseHeight - len) / 2 + len);\r\n\r\n            this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2);\r\n            this.pixelY = this.y * rowHeight;\r\n        }\r\n\r\n        this.right = this.pixelX + this.baseWidth;\r\n        this.bottom = this.pixelY + this.baseHeight;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clean up memory.\r\n     *\r\n     * @method Phaser.Tilemaps.Tile#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.collisionCallback = undefined;\r\n        this.collisionCallbackContext = undefined;\r\n        this.properties = undefined;\r\n    },\r\n\r\n    /**\r\n     * True if this tile can collide on any of its faces or has a collision callback set.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#canCollide\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    canCollide: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown || (this.collisionCallback !== undefined));\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * True if this tile can collide on any of its faces.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#collides\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    collides: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * True if this tile has any interesting faces.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#hasInterestingFace\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    hasInterestingFace: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The tileset that contains this Tile. This is null if accessed from a LayerData instance\r\n     * before the tile is placed in a TilemapLayer, or if the tile has an index that doesn't correspond\r\n     * to any of the maps tilesets.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tileset\r\n     * @type {?Phaser.Tilemaps.Tileset}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    tileset: {\r\n\r\n        get: function ()\r\n        {\r\n            var tilemapLayer = this.layer.tilemapLayer;\r\n\r\n            if (tilemapLayer)\r\n            {\r\n                var tileset = tilemapLayer.gidMap[this.index];\r\n\r\n                if (tileset)\r\n                {\r\n                    return tileset;\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The tilemap layer that contains this Tile. This will only return null if accessed from a\r\n     * LayerData instance before the tile is placed within a TilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tilemapLayer\r\n     * @type {?Phaser.Tilemaps.TilemapLayer}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    tilemapLayer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.layer.tilemapLayer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The tilemap that contains this Tile. This will only return null if accessed from a LayerData\r\n     * instance before the tile is placed within a TilemapLayer.\r\n     *\r\n     * @name Phaser.Tilemaps.Tile#tilemap\r\n     * @type {?Phaser.Tilemaps.Tilemap}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    tilemap: {\r\n\r\n        get: function ()\r\n        {\r\n            var tilemapLayer = this.tilemapLayer;\r\n\r\n            return tilemapLayer ? tilemapLayer.tilemap : null;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Tile;\r\n"],"sourceRoot":""}