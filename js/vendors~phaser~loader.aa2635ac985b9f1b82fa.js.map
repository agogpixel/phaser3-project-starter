{"version":3,"sources":["webpack:///./node_modules/phaser/src/loader/index.js","webpack:///./node_modules/phaser/src/loader/filetypes/index.js","webpack:///./node_modules/phaser/src/loader/filetypes/AnimationJSONFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/AsepriteFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/AtlasJSONFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/AtlasXMLFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/AudioSpriteFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/BinaryFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/BitmapFontFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/CSSFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/GLSLFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/HTMLFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/HTMLTextureFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/MultiAtlasFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/MultiScriptFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/OBJFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/PackFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/PluginFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/SceneFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/ScenePluginFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/SpriteSheetFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/SVGFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/TilemapCSVFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/TilemapImpactFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/TilemapJSONFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/UnityAtlasFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/VideoFile.js","webpack:///./node_modules/phaser/src/loader/LoaderPlugin.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/ParseXMLBitmapFont.js","webpack:///./node_modules/phaser/src/loader/GetURL.js","webpack:///./node_modules/phaser/src/loader/XHRSettings.js","webpack:///./node_modules/phaser/src/loader/const.js","webpack:///./node_modules/phaser/src/loader/MergeXHRSettings.js","webpack:///./node_modules/phaser/src/loader/filetypes/XMLFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/TextFile.js","webpack:///./node_modules/phaser/src/loader/File.js","webpack:///./node_modules/phaser/src/tilemaps/Formats.js","webpack:///./node_modules/phaser/src/loader/XHRLoader.js","webpack:///./node_modules/phaser/src/loader/filetypes/AudioFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/HTML5AudioFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/ScriptFile.js","webpack:///./node_modules/phaser/src/loader/MultiFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/JSONFile.js","webpack:///./node_modules/phaser/src/loader/filetypes/ImageFile.js"],"names":["CONST","Extend","Loader","Events","FileTypes","File","FileTypesManager","GetURL","LoaderPlugin","MergeXHRSettings","MultiFile","XHRLoader","XHRSettings","module","exports","AnimationJSONFile","AsepriteFile","AtlasJSONFile","AtlasXMLFile","AudioFile","AudioSpriteFile","BinaryFile","BitmapFontFile","CSSFile","GLSLFile","HTML5AudioFile","HTMLFile","HTMLTextureFile","ImageFile","JSONFile","MultiAtlasFile","MultiScriptFile","OBJFile","PackFile","PluginFile","SceneFile","ScenePluginFile","ScriptFile","SpriteSheetFile","SVGFile","TextFile","TilemapCSVFile","TilemapImpactFile","TilemapJSONFile","UnityAtlasFile","VideoFile","XMLFile","Class","LoaderEvents","Extends","initialize","loader","key","url","xhrSettings","dataKey","call","this","type","onProcess","once","POST_PROCESS","onLoadComplete","prototype","systems","anims","fromJSON","data","register","Array","isArray","i","length","addFile","GetFastValue","IsPlainObject","textureURL","atlasURL","textureXhrSettings","atlasXhrSettings","image","config","extension","normalMap","linkFile","addToCache","isReadyToProcess","files","json","textureManager","addAtlas","complete","multifile","pendingDestroy","xml","addAtlasXML","jsonURL","audioURL","audioConfig","audioXhrSettings","jsonXhrSettings","audio","create","resourceLoad","onFileComplete","file","indexOf","pending","hasOwnProperty","urls","resources","addToMultiFile","fileA","fileB","game","gameAudioConfig","deviceAudio","device","noAudio","webAudio","audioData","dataType","fileConfig","cache","cacheManager","binary","responseType","state","FILE_PROCESSING","ctor","xhrLoader","response","onProcessComplete","ParseXMLBitmapFont","fontDataURL","fontDataXhrSettings","texture","get","getFrame","bitmapFont","add","frame","document","createElement","defer","innerHTML","responseText","head","appendChild","Shader","shaderType","undefined","shader","split","block","extractBlock","getShaderName","header","getShaderType","uniforms","getShaderUniforms","shaderSrc","has","fragmentSrc","vertexSrc","offset","headerSource","line","trim","substring","pos","JSON","parse","e","console","warn","headerStart","headerEnd","blockEnd","headerOpen","captureSource","shaderSource","push","join","html","width","height","w","h","svg","_this","blob","window","Blob","FILE_ERRORED","Image","crossOrigin","onload","revokeObjectURL","onerror","onProcessError","createObjectURL","addImage","path","baseURL","textures","currentBaseURL","currentPath","currentPrefix","prefix","setBaseURL","setPath","setPrefix","multiKeyIndex","setLink","fileJSON","images","normalMaps","substr","t","item","addAtlasJSONArray","scriptFile","toString","language","text","ParseObj","ParseObjMaterial","objURL","matURL","flipUV","obj","mat","objData","materials","flipUVs","FILE_POPULATED","addPack","packKey","start","mapping","pluginManager","plugins","install","plugin","scene","code","concat","eval2","eval","sceneManager","systemKey","sceneKey","installScenePlugin","frameConfig","addSpriteSheet","svgConfig","scale","resize","svgXML","DOMParser","parseFromString","getElementsByTagName","hasViewBox","hasAttribute","svgWidth","parseFloat","getAttribute","svgHeight","setAttribute","viewBox","XMLSerializer","serializeToString","retry","src","encodeURIComponent","TILEMAP_FORMATS","tilemap","tilemapFormat","CSV","tiledata","format","WELTMEISTER","TILED_JSON","addUnityAtlas","urlConfig","loadEvent","asBlob","video","onLoadCallback","onVideoLoadHandler","bind","onErrorCallback","onVideoErrorHandler","createVideoElement","onloadeddata","load","controls","muted","defaultMuted","event","target","removeEventListener","resetXHR","nextFile","percentComplete","addEventListener","getVideoURL","videoType","match","toLowerCase","videoFile","CustomSet","EventEmitter","PluginCache","SceneEvents","gameConfig","sys","sceneConfig","settings","loaderBaseURL","loaderPath","loaderPrefix","maxParallelDownloads","loaderMaxParallelDownloads","xhr","loaderResponseType","loaderAsync","loaderUser","loaderPassword","loaderTimeout","loaderWithCredentials","loaderCrossOrigin","totalToLoad","progress","list","inflight","queue","_deleteQueue","totalFailed","totalComplete","LOADER_IDLE","events","BOOT","boot","on","START","pluginStart","DESTROY","destroy","SHUTDOWN","shutdown","setCORS","keyExists","set","emit","ADD","isLoading","updateProgress","keyConflict","hasCacheConflict","iterate","pack","total","Object","defaultType","LOADER_LOADING","LOADER_PROCESSING","isReady","LOADER_COMPLETE","size","loadComplete","clear","checkLoadQueue","UPDATE","update","PROGRESS","each","FILE_PENDING","delete","success","FILE_LOAD","FILE_LOAD_ERROR","fileProcessComplete","multiFile","onFileFailed","FILE_COMPLETE","off","iterateLocal","COMPLETE","flagForRemoval","saveJSON","filename","save","stringify","filetype","URL","a","download","textContent","href","click","reset","LOADER_SHUTDOWN","LOADER_DESTROYED","getValue","node","attribute","parseInt","xSpacing","ySpacing","textureX","cutX","textureY","cutY","textureWidth","source","textureHeight","sourceIndex","info","common","font","lineHeight","chars","letters","adjustForTrim","trimmed","top","left","charCode","letter","String","fromCharCode","gx","gy","gw","gh","x","y","u0","v0","u1","v1","centerX","Math","floor","centerY","xOffset","yOffset","xAdvance","kerning","charFrame","setUVs","kernings","kern","first","second","amount","async","user","password","timeout","withCredentials","headers","headerValue","requestedWith","overrideMimeType","FILE_LOADING","FILE_LOADED","FILE_FAILED","FILE_DESTROYED","global","local","output","setting","ParseXML","loadKey","Error","bytesTotal","bytesLoaded","onprogress","onLoad","localFileOk","responseURL","status","readyState","onError","onProgress","lengthComputable","loaded","min","FILE_PROGRESS","exists","FILE_KEY_COMPLETE","reader","FileReader","removeAttribute","result","readAsDataURL","ARRAY_2D","globalXHRSettings","XMLHttpRequest","open","setRequestHeader","send","audioContext","context","decodeAudioData","audioBuffer","error","message","getAudioURL","disableWebAudio","sound","audioType","audioFile","locked","filesLoaded","filesTotal","oncanplaythrough","instances","Audio","dataset","name","slice","used","preload","setTimeout","finalFiles","forEach","failed","GetValue","normalMapURL"],"mappings":"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","file":"js/vendors~phaser~loader.aa2635ac985b9f1b82fa.js","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Loader\r\n */\r\n\r\nvar Loader = {\r\n\r\n    Events: require('./events'),\r\n\r\n    FileTypes: require('./filetypes'),\r\n\r\n    File: require('./File'),\r\n    FileTypesManager: require('./FileTypesManager'),\r\n    GetURL: require('./GetURL'),\r\n    LoaderPlugin: require('./LoaderPlugin'),\r\n    MergeXHRSettings: require('./MergeXHRSettings'),\r\n    MultiFile: require('./MultiFile'),\r\n    XHRLoader: require('./XHRLoader'),\r\n    XHRSettings: require('./XHRSettings')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\nLoader = Extend(false, Loader, CONST);\r\n\r\nmodule.exports = Loader;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Loader.FileTypes\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    AnimationJSONFile: require('./AnimationJSONFile'),\r\n    AsepriteFile: require('./AsepriteFile'),\r\n    AtlasJSONFile: require('./AtlasJSONFile'),\r\n    AtlasXMLFile: require('./AtlasXMLFile'),\r\n    AudioFile: require('./AudioFile'),\r\n    AudioSpriteFile: require('./AudioSpriteFile'),\r\n    BinaryFile: require('./BinaryFile'),\r\n    BitmapFontFile: require('./BitmapFontFile'),\r\n    CSSFile: require('./CSSFile'),\r\n    GLSLFile: require('./GLSLFile'),\r\n    HTML5AudioFile: require('./HTML5AudioFile'),\r\n    HTMLFile: require('./HTMLFile'),\r\n    HTMLTextureFile: require('./HTMLTextureFile'),\r\n    ImageFile: require('./ImageFile'),\r\n    JSONFile: require('./JSONFile'),\r\n    MultiAtlasFile: require('./MultiAtlasFile'),\r\n    MultiScriptFile: require('./MultiScriptFile'),\r\n    OBJFile: require('./OBJFile'),\r\n    PackFile: require('./PackFile'),\r\n    PluginFile: require('./PluginFile'),\r\n    SceneFile: require('./SceneFile'),\r\n    ScenePluginFile: require('./ScenePluginFile'),\r\n    ScriptFile: require('./ScriptFile'),\r\n    SpriteSheetFile: require('./SpriteSheetFile'),\r\n    SVGFile: require('./SVGFile'),\r\n    TextFile: require('./TextFile'),\r\n    TilemapCSVFile: require('./TilemapCSVFile'),\r\n    TilemapImpactFile: require('./TilemapImpactFile'),\r\n    TilemapJSONFile: require('./TilemapJSONFile'),\r\n    UnityAtlasFile: require('./UnityAtlasFile'),\r\n    VideoFile: require('./VideoFile'),\r\n    XMLFile: require('./XMLFile')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar LoaderEvents = require('../events');\r\n\r\n/**\r\n * @classdesc\r\n * A single Animation JSON File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#animation method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#animation.\r\n *\r\n * @class AnimationJSONFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n */\r\nvar AnimationJSONFile = new Class({\r\n\r\n    Extends: JSONFile,\r\n\r\n    initialize:\r\n\r\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\r\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\r\n\r\n    function AnimationJSONFile (loader, key, url, xhrSettings, dataKey)\r\n    {\r\n        JSONFile.call(this, loader, key, url, xhrSettings, dataKey);\r\n\r\n        this.type = 'animationJSON';\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AnimationJSONFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        //  We need to hook into this event:\r\n        this.loader.once(LoaderEvents.POST_PROCESS, this.onLoadComplete, this);\r\n\r\n        //  But the rest is the same as a normal JSON file\r\n        JSONFile.prototype.onProcess.call(this);\r\n    },\r\n\r\n    /**\r\n     * Called at the end of the load process, after the Loader has finished all files in its queue.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AnimationJSONFile#onLoadComplete\r\n     * @since 3.7.0\r\n     */\r\n    onLoadComplete: function ()\r\n    {\r\n        this.loader.systems.anims.fromJSON(this.data);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an Animation JSON Data file, or array of Animation JSON files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.animation('baddieAnims', 'files/BaddieAnims.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the JSON Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.animation({\r\n *     key: 'baddieAnims',\r\n *     url: 'files/BaddieAnims.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.JSONFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be passed to the global Animation Managers `fromJSON` method.\r\n * This will parse all of the JSON data and create animation data from it. This process happens at the very end\r\n * of the Loader, once every other file in the load queue has finished. The reason for this is to allow you to load\r\n * both animation data and the images it relies upon in the same load call.\r\n *\r\n * Once the animation data has been parsed you will be able to play animations using that data.\r\n * Please see the Animation Manager `fromJSON` method for more details about the format and playback.\r\n *\r\n * You can also access the raw animation data from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.animation('baddieAnims', 'files/BaddieAnims.json');\r\n * // and later in your game ...\r\n * var data = this.cache.json.get('baddieAnims');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the JSON Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\r\n * rather than the whole file. For example, if your JSON data had a structure like this:\r\n *\r\n * ```json\r\n * {\r\n *     \"level1\": {\r\n *         \"baddies\": {\r\n *             \"aliens\": {},\r\n *             \"boss\": {}\r\n *         }\r\n *     },\r\n *     \"level2\": {},\r\n *     \"level3\": {}\r\n * }\r\n * ```\r\n *\r\n * And if you only wanted to create animations from the `boss` data, then you could pass `level1.baddies.boss`as the `dataKey`.\r\n *\r\n * Note: The ability to load this type of file will only be available if the JSON File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#animation\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [dataKey] - When the Animation JSON file loads only this property will be stored in the Cache and used to create animation data.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('animation', function (key, url, dataKey, xhrSettings)\r\n{\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            this.addFile(new AnimationJSONFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new AnimationJSONFile(this, key, url, xhrSettings, dataKey));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = AnimationJSONFile;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar FileTypesManager = require('../FileTypesManager');\nvar GetFastValue = require('../../utils/object/GetFastValue');\nvar ImageFile = require('./ImageFile.js');\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\nvar JSONFile = require('./JSONFile.js');\nvar MultiFile = require('../MultiFile.js');\n\n/**\n * @classdesc\n * A single JSON based Texture Atlas File suitable for loading by the Loader.\n *\n * These are created when you use the Phaser.Loader.LoaderPlugin#atlas method and are not typically created directly.\n *\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#atlas.\n *\n * https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-for-phaser3?source=photonstorm\n *\n * @class AsepriteFile\n * @extends Phaser.Loader.MultiFile\n * @memberof Phaser.Loader.FileTypes\n * @constructor\n * @since 3.50.0\n *\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\n * @param {(string|Phaser.Types.Loader.FileTypes.AsepriteFileConfig)} key - The key to use for this file, or a file configuration object.\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n * @param {object|string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\n */\nvar AsepriteFile = new Class({\n\n    Extends: MultiFile,\n\n    initialize:\n\n    function AsepriteFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\n    {\n        var image;\n        var data;\n\n        if (IsPlainObject(key))\n        {\n            var config = key;\n\n            key = GetFastValue(config, 'key');\n\n            image = new ImageFile(loader, {\n                key: key,\n                url: GetFastValue(config, 'textureURL'),\n                extension: GetFastValue(config, 'textureExtension', 'png'),\n                normalMap: GetFastValue(config, 'normalMap'),\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\n            });\n\n            data = new JSONFile(loader, {\n                key: key,\n                url: GetFastValue(config, 'atlasURL'),\n                extension: GetFastValue(config, 'atlasExtension', 'json'),\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\n            });\n        }\n        else\n        {\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\n            data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);\n        }\n\n        if (image.linkFile)\n        {\n            //  Image has a normal map\n            MultiFile.call(this, loader, 'atlasjson', key, [ image, data, image.linkFile ]);\n        }\n        else\n        {\n            MultiFile.call(this, loader, 'atlasjson', key, [ image, data ]);\n        }\n    },\n\n    /**\n     * Adds this file to its target cache upon successful loading and processing.\n     *\n     * @method Phaser.Loader.FileTypes.AsepriteFile#addToCache\n     * @since 3.7.0\n     */\n    addToCache: function ()\n    {\n        if (this.isReadyToProcess())\n        {\n            var image = this.files[0];\n            var json = this.files[1];\n            var normalMap = (this.files[2]) ? this.files[2].data : null;\n\n            this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);\n\n            json.addToCache();\n\n            this.complete = true;\n        }\n    }\n\n});\n\n/**\n * Aseprite is a powerful animated sprite editor and pixel art tool.\n *\n * You can find more details at https://www.aseprite.org/\n *\n * Adds a JSON based Aseprite Animation, or array of animations, to the current load queue.\n *\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\n *\n * ```javascript\n * function preload ()\n * {\n *     this.load.aseprite('gladiator', 'images/Gladiator.png', 'images/Gladiator.json');\n * }\n * ```\n *\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\n * loaded.\n *\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\n *\n * To export a compatible JSON file in Aseprite, please do the following:\n *\n * 1. Go to \"File - Export Sprite Sheet\"\n *\n * 2. On the **Layout** tab:\n * 2a. Set the \"Sheet type\" to \"Packed\"\n * 2b. Set the \"Constraints\" to \"None\"\n * 2c. Check the \"Merge Duplicates\" checkbox\n *\n * 3. On the **Sprite** tab:\n * 3a. Set \"Layers\" to \"Visible layers\"\n * 3b. Set \"Frames\" to \"All frames\", unless you only wish to export a sub-set of tags\n *\n * 4. On the **Borders** tab:\n * 4a. Check the \"Trim Sprite\" and \"Trim Cells\" options\n * 4b. Ensure \"Border Padding\", \"Spacing\" and \"Inner Padding\" are all > 0 (1 is usually enough)\n *\n * 5. On the **Output** tab:\n * 5a. Check \"Output File\", give your image a name and make sure you choose \"png files\" as the file type\n * 5b. Check \"JSON Data\" and give your json file a name\n * 5c. The JSON Data type can be either a Hash or Array, Phaser doesn't mind.\n * 5d. Make sure \"Tags\" is checked in the Meta options\n * 5e. In the \"Item Filename\" input box, make sure it says just \"{frame}\" and nothing more.\n *\n * 6. Click export\n *\n * This was tested with Aseprite 1.2.25.\n *\n * This will export a png and json file which you can load using the Aseprite Loader, i.e.:\n *\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\n *\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\n * then remove it from the Texture Manager first, before loading a new one.\n *\n * Instead of passing arguments you can pass a configuration object, such as:\n *\n * ```javascript\n * this.load.aseprite({\n *     key: 'gladiator',\n *     textureURL: 'images/Gladiator.png',\n *     atlasURL: 'images/Gladiator.json'\n * });\n * ```\n *\n * See the documentation for `Phaser.Types.Loader.FileTypes.AsepriteFileConfig` for more details.\n *\n * Instead of passing a URL for the JSON data you can also pass in a well formed JSON object instead.\n *\n * Once loaded, you can call this method from within a Scene with the 'atlas' key:\n *\n * ```javascript\n * this.anims.createFromAseprite('paladin');\n * ```\n *\n * Any animations defined in the JSON will now be available to use in Phaser and you play them\n * via their Tag name. For example, if you have an animation called 'War Cry' on your Aseprite timeline,\n * you can play it in Phaser using that Tag name:\n *\n * ```javascript\n * this.add.sprite(400, 300).play('War Cry');\n * ```\n *\n * When calling this method you can optionally provide an array of tag names, and only those animations\n * will be created. For example:\n *\n * ```javascript\n * this.anims.createFromAseprite('paladin', [ 'step', 'War Cry', 'Magnum Break' ]);\n * ```\n *\n * This will only create the 3 animations defined. Note that the tag names are case-sensitive.\n *\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\n * this is what you would use to retrieve the image from the Texture Manager.\n *\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n *\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\n *\n * Note: The ability to load this type of file will only be available if the Aseprite File type has been built into Phaser.\n * It is available in the default build but can be excluded from custom builds.\n *\n * @method Phaser.Loader.LoaderPlugin#aseprite\n * @fires Phaser.Loader.LoaderPlugin#ADD\n * @since 3.50.0\n *\n * @param {(string|Phaser.Types.Loader.FileTypes.AsepriteFileConfig|Phaser.Types.Loader.FileTypes.AsepriteFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\n * @param {object|string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\n *\n * @return {this} The Loader instance.\n */\nFileTypesManager.register('aseprite', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\n{\n    var multifile;\n\n    //  Supports an Object file definition in the key argument\n    //  Or an array of objects in the key argument\n    //  Or a single entry where all arguments have been defined\n\n    if (Array.isArray(key))\n    {\n        for (var i = 0; i < key.length; i++)\n        {\n            multifile = new AsepriteFile(this, key[i]);\n\n            this.addFile(multifile.files);\n        }\n    }\n    else\n    {\n        multifile = new AsepriteFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);\n\n        this.addFile(multifile.files);\n    }\n\n    return this;\n});\n\nmodule.exports = AsepriteFile;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar MultiFile = require('../MultiFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single JSON based Texture Atlas File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#atlas method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#atlas.\r\n *\r\n * https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-for-phaser3?source=photonstorm\r\n *\r\n * @class AtlasJSONFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {object|string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar AtlasJSONFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function AtlasJSONFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n    {\r\n        var image;\r\n        var data;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            image = new ImageFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'textureURL'),\r\n                extension: GetFastValue(config, 'textureExtension', 'png'),\r\n                normalMap: GetFastValue(config, 'normalMap'),\r\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\r\n            });\r\n\r\n            data = new JSONFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'atlasURL'),\r\n                extension: GetFastValue(config, 'atlasExtension', 'json'),\r\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n            data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);\r\n        }\r\n\r\n        if (image.linkFile)\r\n        {\r\n            //  Image has a normal map\r\n            MultiFile.call(this, loader, 'atlasjson', key, [ image, data, image.linkFile ]);\r\n        }\r\n        else\r\n        {\r\n            MultiFile.call(this, loader, 'atlasjson', key, [ image, data ]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AtlasJSONFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var image = this.files[0];\r\n            var json = this.files[1];\r\n            var normalMap = (this.files[2]) ? this.files[2].data : null;\r\n\r\n            this.loader.textureManager.addAtlas(image.key, image.data, json.data, normalMap);\r\n\r\n            json.pendingDestroy();\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON based Texture Atlas, or array of atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.atlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in a JSON file, using either the JSON Hash or JSON Array format.\r\n * These files are created by software such as Texture Packer, Shoebox and Adobe Flash / Animate.\r\n * If you are using Texture Packer and have enabled multi-atlas support, then please use the Phaser Multi Atlas loader\r\n * instead of this one.\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.atlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     atlasURL: 'images/MainMenu.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig` for more details.\r\n *\r\n * Instead of passing a URL for the atlas JSON data you can also pass in a well formed JSON object instead.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.atlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'mainmenu', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.atlas('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.json');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.atlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     normalMap: 'images/MainMenu-n.png',\r\n *     atlasURL: 'images/MainMenu.json'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Atlas JSON File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#atlas\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig|Phaser.Types.Loader.FileTypes.AtlasJSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {object|string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('atlas', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new AtlasJSONFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new AtlasJSONFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = AtlasJSONFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile.js');\r\nvar XMLFile = require('./XMLFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single XML based Texture Atlas File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#atlasXML method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#atlasXML.\r\n *\r\n * @class AtlasXMLFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas xml file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar AtlasXMLFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function AtlasXMLFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n    {\r\n        var image;\r\n        var data;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            image = new ImageFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'textureURL'),\r\n                extension: GetFastValue(config, 'textureExtension', 'png'),\r\n                normalMap: GetFastValue(config, 'normalMap'),\r\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\r\n            });\r\n\r\n            data = new XMLFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'atlasURL'),\r\n                extension: GetFastValue(config, 'atlasExtension', 'xml'),\r\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n            data = new XMLFile(loader, key, atlasURL, atlasXhrSettings);\r\n        }\r\n\r\n        if (image.linkFile)\r\n        {\r\n            //  Image has a normal map\r\n            MultiFile.call(this, loader, 'atlasxml', key, [ image, data, image.linkFile ]);\r\n        }\r\n        else\r\n        {\r\n            MultiFile.call(this, loader, 'atlasxml', key, [ image, data ]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AtlasXMLFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var image = this.files[0];\r\n            var xml = this.files[1];\r\n            var normalMap = (this.files[2]) ? this.files[2].data : null;\r\n\r\n            this.loader.textureManager.addAtlasXML(image.key, image.data, xml.data, normalMap);\r\n\r\n            xml.pendingDestroy();\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an XML based Texture Atlas, or array of atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.atlasXML('mainmenu', 'images/MainMenu.png', 'images/MainMenu.xml');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in an XML file format.\r\n * These files are created by software such as Shoebox and Adobe Flash / Animate.\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.atlasXML({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     atlasURL: 'images/MainMenu.xml'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig` for more details.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.atlasXML('mainmenu', 'images/MainMenu.png', 'images/MainMenu.xml');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'mainmenu', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.atlasXML('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.xml');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.atlasXML({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     normalMap: 'images/MainMenu-n.png',\r\n *     atlasURL: 'images/MainMenu.xml'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Atlas XML File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#atlasXML\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.7.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig|Phaser.Types.Loader.FileTypes.AtlasXMLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas xml file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('atlasXML', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new AtlasXMLFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new AtlasXMLFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = AtlasXMLFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AudioFile = require('./AudioFile.js');\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar MultiFile = require('../MultiFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * An Audio Sprite File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#audioSprite method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#audioSprite.\r\n *\r\n * @class AudioSpriteFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} jsonURL - The absolute or relative URL to load the json file from. Or a well formed JSON object to use instead.\r\n * @param {{(string|string[])}} [audioURL] - The absolute or relative URL to load the audio file from. If empty it will be obtained by parsing the JSON file.\r\n * @param {any} [audioConfig] - The audio configuration options.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [audioXhrSettings] - An XHR Settings configuration object for the audio file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [jsonXhrSettings] - An XHR Settings configuration object for the json file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar AudioSpriteFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function AudioSpriteFile (loader, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings)\r\n    {\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            jsonURL = GetFastValue(config, 'jsonURL');\r\n            audioURL = GetFastValue(config, 'audioURL');\r\n            audioConfig = GetFastValue(config, 'audioConfig');\r\n            audioXhrSettings = GetFastValue(config, 'audioXhrSettings');\r\n            jsonXhrSettings = GetFastValue(config, 'jsonXhrSettings');\r\n        }\r\n\r\n        var data;\r\n\r\n        //  No url? then we're going to do a json load and parse it from that\r\n        if (!audioURL)\r\n        {\r\n            data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);\r\n\r\n            MultiFile.call(this, loader, 'audiosprite', key, [ data ]);\r\n\r\n            this.config.resourceLoad = true;\r\n            this.config.audioConfig = audioConfig;\r\n            this.config.audioXhrSettings = audioXhrSettings;\r\n        }\r\n        else\r\n        {\r\n            var audio = AudioFile.create(loader, key, audioURL, audioConfig, audioXhrSettings);\r\n\r\n            if (audio)\r\n            {\r\n                data = new JSONFile(loader, key, jsonURL, jsonXhrSettings);\r\n\r\n                MultiFile.call(this, loader, 'audiosprite', key, [ audio, data ]);\r\n\r\n                this.config.resourceLoad = false;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AudioSpriteFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n\r\n            if (this.config.resourceLoad && file.type === 'json' && file.data.hasOwnProperty('resources'))\r\n            {\r\n                //  Inspect the data for the files to now load\r\n                var urls = file.data.resources;\r\n\r\n                var audioConfig = GetFastValue(this.config, 'audioConfig');\r\n                var audioXhrSettings = GetFastValue(this.config, 'audioXhrSettings');\r\n\r\n                var audio = AudioFile.create(this.loader, file.key, urls, audioConfig, audioXhrSettings);\r\n\r\n                if (audio)\r\n                {\r\n                    this.addToMultiFile(audio);\r\n\r\n                    this.loader.addFile(audio);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AudioSpriteFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var fileA = this.files[0];\r\n            var fileB = this.files[1];\r\n\r\n            fileA.addToCache();\r\n            fileB.addToCache();\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON based Audio Sprite, or array of audio sprites, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.audioSprite('kyobi', 'kyobi.json', [\r\n *         'kyobi.ogg',\r\n *         'kyobi.mp3',\r\n *         'kyobi.m4a'\r\n *     ]);\r\n * }\r\n * ```\r\n *\r\n * Audio Sprites are a combination of audio files and a JSON configuration.\r\n * The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite\r\n *\r\n * If the JSON file includes a 'resource' object then you can let Phaser parse it and load the audio\r\n * files automatically based on its content. To do this exclude the audio URLs from the load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.audioSprite('kyobi', 'kyobi.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Audio Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Audio Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Audio Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.audioSprite({\r\n *     key: 'kyobi',\r\n *     jsonURL: 'audio/Kyobi.json',\r\n *     audioURL: [\r\n *         'audio/Kyobi.ogg',\r\n *         'audio/Kyobi.mp3',\r\n *         'audio/Kyobi.m4a'\r\n *     ]\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig` for more details.\r\n *\r\n * Instead of passing a URL for the audio JSON data you can also pass in a well formed JSON object instead.\r\n *\r\n * Once the audio has finished loading you can use it create an Audio Sprite by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.audioSprite('kyobi', 'kyobi.json');\r\n * // and later in your game ...\r\n * var music = this.sound.addAudioSprite('kyobi');\r\n * music.play('title');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * Due to different browsers supporting different audio file types you should usually provide your audio files in a variety of formats.\r\n * ogg, mp3 and m4a are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on\r\n * browser support.\r\n *\r\n * If audio has been disabled in your game, either via the game config, or lack of support from the device, then no audio will be loaded.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Audio Sprite File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#audioSprite\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig|Phaser.Types.Loader.FileTypes.AudioSpriteFileConfig[])} key - The key to use for this file, or a file configuration object, or an array of objects.\r\n * @param {string} jsonURL - The absolute or relative URL to load the json file from. Or a well formed JSON object to use instead.\r\n * @param {(string|string[])} [audioURL] - The absolute or relative URL to load the audio file from. If empty it will be obtained by parsing the JSON file.\r\n * @param {any} [audioConfig] - The audio configuration options.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [audioXhrSettings] - An XHR Settings configuration object for the audio file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [jsonXhrSettings] - An XHR Settings configuration object for the json file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader.\r\n */\r\nFileTypesManager.register('audioSprite', function (key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings)\r\n{\r\n    var game = this.systems.game;\r\n    var gameAudioConfig = game.config.audio;\r\n    var deviceAudio = game.device.audio;\r\n\r\n    if ((gameAudioConfig && gameAudioConfig.noAudio) || (!deviceAudio.webAudio && !deviceAudio.audioData))\r\n    {\r\n        //  Sounds are disabled, so skip loading audio\r\n        return this;\r\n    }\r\n\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new AudioSpriteFile(this, key[i]);\r\n\r\n            if (multifile.files)\r\n            {\r\n                this.addFile(multifile.files);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new AudioSpriteFile(this, key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings);\r\n\r\n        if (multifile.files)\r\n        {\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n\r\n    return this;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Binary File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#binary method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#binary.\r\n *\r\n * @class BinaryFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.BinaryFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.bin`, i.e. if `key` was \"alien\" then the URL will be \"alien.bin\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {any} [dataType] - Optional type to cast the binary file to once loaded. For example, `Uint8Array`.\r\n */\r\nvar BinaryFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function BinaryFile (loader, key, url, xhrSettings, dataType)\r\n    {\r\n        var extension = 'bin';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            dataType = GetFastValue(config, 'dataType', dataType);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'binary',\r\n            cache: loader.cacheManager.binary,\r\n            extension: extension,\r\n            responseType: 'arraybuffer',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: { dataType: dataType }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.BinaryFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        var ctor = this.config.dataType;\r\n\r\n        this.data = (ctor) ? new ctor(this.xhrLoader.response) : this.xhrLoader.response;\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Binary file, or array of Binary files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.binary('doom', 'files/Doom.wad');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Binary Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Binary Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Binary Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.binary({\r\n *     key: 'doom',\r\n *     url: 'files/Doom.wad',\r\n *     dataType: Uint8Array\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.BinaryFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.binary('doom', 'files/Doom.wad');\r\n * // and later in your game ...\r\n * var data = this.cache.binary.get('doom');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Data` the final key will be `LEVEL1.Data` and\r\n * this is what you would use to retrieve the text from the Binary Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"doom\"\r\n * and no URL is given then the Loader will set the URL to be \"doom.bin\". It will always add `.bin` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Binary File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#binary\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.BinaryFileConfig|Phaser.Types.Loader.FileTypes.BinaryFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.bin`, i.e. if `key` was \"alien\" then the URL will be \"alien.bin\".\r\n * @param {any} [dataType] - Optional type to cast the binary file to once loaded. For example, `Uint8Array`.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('binary', function (key, url, dataType, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new BinaryFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new BinaryFile(this, key, url, xhrSettings, dataType));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = BinaryFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile.js');\r\nvar ParseXMLBitmapFont = require('../../gameobjects/bitmaptext/ParseXMLBitmapFont.js');\r\nvar XMLFile = require('./XMLFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single Bitmap Font based File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#bitmapFont method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#bitmapFont.\r\n *\r\n * @class BitmapFontFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.BitmapFontFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the font image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [fontDataURL] - The absolute or relative URL to load the font xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the font image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [fontDataXhrSettings] - An XHR Settings configuration object for the font data xml file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar BitmapFontFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function BitmapFontFile (loader, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings)\r\n    {\r\n        var image;\r\n        var data;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            image = new ImageFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'textureURL'),\r\n                extension: GetFastValue(config, 'textureExtension', 'png'),\r\n                normalMap: GetFastValue(config, 'normalMap'),\r\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\r\n            });\r\n\r\n            data = new XMLFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'fontDataURL'),\r\n                extension: GetFastValue(config, 'fontDataExtension', 'xml'),\r\n                xhrSettings: GetFastValue(config, 'fontDataXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n            data = new XMLFile(loader, key, fontDataURL, fontDataXhrSettings);\r\n        }\r\n\r\n        if (image.linkFile)\r\n        {\r\n            //  Image has a normal map\r\n            MultiFile.call(this, loader, 'bitmapfont', key, [ image, data, image.linkFile ]);\r\n        }\r\n        else\r\n        {\r\n            MultiFile.call(this, loader, 'bitmapfont', key, [ image, data ]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.BitmapFontFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var image = this.files[0];\r\n            var xml = this.files[1];\r\n\r\n            image.addToCache();\r\n            xml.pendingDestroy();\r\n\r\n            var texture = image.cache.get(image.key);\r\n\r\n            var data = ParseXMLBitmapFont(xml.data, image.cache.getFrame(image.key), 0, 0, texture);\r\n\r\n            this.loader.cacheManager.bitmapFont.add(image.key, { data: data, texture: image.key, frame: null });\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an XML based Bitmap Font, or array of fonts, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.bitmapFont('goldenFont', 'images/GoldFont.png', 'images/GoldFont.xml');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the font data to be provided in an XML file format.\r\n * These files are created by software such as the [Angelcode Bitmap Font Generator](http://www.angelcode.com/products/bmfont/),\r\n * [Littera](http://kvazars.com/littera/) or [Glyph Designer](https://71squared.com/glyphdesigner)\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.bitmapFont({\r\n *     key: 'goldenFont',\r\n *     textureURL: 'images/GoldFont.png',\r\n *     fontDataURL: 'images/GoldFont.xml'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.BitmapFontFileConfig` for more details.\r\n *\r\n * Once the atlas has finished loading you can use key of it when creating a Bitmap Text Game Object:\r\n *\r\n * ```javascript\r\n * this.load.bitmapFont('goldenFont', 'images/GoldFont.png', 'images/GoldFont.xml');\r\n * // and later in your game ...\r\n * this.add.bitmapText(x, y, 'goldenFont', 'Hello World');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use when creating a Bitmap Text object.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.bitmapFont('goldenFont', [ 'images/GoldFont.png', 'images/GoldFont-n.png' ], 'images/GoldFont.xml');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.bitmapFont({\r\n *     key: 'goldenFont',\r\n *     textureURL: 'images/GoldFont.png',\r\n *     normalMap: 'images/GoldFont-n.png',\r\n *     fontDataURL: 'images/GoldFont.xml'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Bitmap Font File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#bitmapFont\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.BitmapFontFileConfig|Phaser.Types.Loader.FileTypes.BitmapFontFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the font image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [fontDataURL] - The absolute or relative URL to load the font xml data file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the font image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [fontDataXhrSettings] - An XHR Settings configuration object for the font data xml file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('bitmapFont', function (key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new BitmapFontFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new BitmapFontFile(this, key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = BitmapFontFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single CSS File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#css method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#css.\r\n *\r\n * @class CSSFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.17.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.CSSFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar CSSFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function CSSFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'css';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'script',\r\n            cache: false,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.CSSFile#onProcess\r\n     * @since 3.17.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = document.createElement('style');\r\n        this.data.defer = false;\r\n        this.data.innerHTML = this.xhrLoader.responseText;\r\n\r\n        document.head.appendChild(this.data);\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a CSS file, or array of CSS files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.css('headers', 'styles/headers.css');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.css({\r\n *     key: 'headers',\r\n *     url: 'styles/headers.css'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.CSSFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be converted into a style DOM element\r\n * via `document.createElement('style')`. It will have its `defer` property set to false and then the\r\n * resulting element will be appended to `document.head`. The CSS styles are then applied to the current document.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.css\". It will always add `.css` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the CSS File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#css\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.17.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.CSSFileConfig|Phaser.Types.Loader.FileTypes.CSSFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.css`, i.e. if `key` was \"alien\" then the URL will be \"alien.css\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('css', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new CSSFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new CSSFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = CSSFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar Shader = require('../../display/shader/BaseShader');\r\n\r\n/**\r\n * @classdesc\r\n * A single GLSL File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#glsl method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#glsl.\r\n *\r\n * @class GLSLFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.GLSLFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {string} [shaderType='fragment'] - The type of shader. Either `fragment` for a fragment shader, or `vertex` for a vertex shader. This is ignored if you load a shader bundle.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar GLSLFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function GLSLFile (loader, key, url, shaderType, xhrSettings)\r\n    {\r\n        var extension = 'glsl';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            shaderType = GetFastValue(config, 'shaderType', 'fragment');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n        else if (shaderType === undefined)\r\n        {\r\n            shaderType = 'fragment';\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'glsl',\r\n            cache: loader.cacheManager.shader,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            config: {\r\n                shaderType: shaderType\r\n            },\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#addToCache\r\n     * @since 3.17.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var data = this.data.split('\\n');\r\n\r\n        //  Check to see if this is a shader bundle, or raw glsl file.\r\n        var block = this.extractBlock(data, 0);\r\n\r\n        if (block)\r\n        {\r\n            while (block)\r\n            {\r\n                var key = this.getShaderName(block.header);\r\n                var shaderType = this.getShaderType(block.header);\r\n                var uniforms = this.getShaderUniforms(block.header);\r\n                var shaderSrc = block.shader;\r\n\r\n                if (this.cache.has(key))\r\n                {\r\n                    var shader = this.cache.get(key);\r\n\r\n                    if (shaderType === 'fragment')\r\n                    {\r\n                        shader.fragmentSrc = shaderSrc;\r\n                    }\r\n                    else\r\n                    {\r\n                        shader.vertexSrc = shaderSrc;\r\n                    }\r\n\r\n                    if (!shader.uniforms)\r\n                    {\r\n                        shader.uniforms = uniforms;\r\n                    }\r\n                }\r\n                else if (shaderType === 'fragment')\r\n                {\r\n                    this.cache.add(key, new Shader(key, shaderSrc, '', uniforms));\r\n                }\r\n                else\r\n                {\r\n                    this.cache.add(key, new Shader(key, '', shaderSrc, uniforms));\r\n                }\r\n\r\n                block = this.extractBlock(data, block.offset);\r\n            }\r\n        }\r\n        else if (this.config.shaderType === 'fragment')\r\n        {\r\n            //  Single shader\r\n            this.cache.add(this.key, new Shader(this.key, this.data));\r\n        }\r\n        else\r\n        {\r\n            this.cache.add(this.key, new Shader(this.key, '', this.data));\r\n        }\r\n\r\n        this.pendingDestroy();\r\n    },\r\n\r\n    /**\r\n     * Returns the name of the shader from the header block.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#getShaderName\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string[]} headerSource - The header data.\r\n     *\r\n     * @return {string} The shader name.\r\n     */\r\n    getShaderName: function (headerSource)\r\n    {\r\n        for (var i = 0; i < headerSource.length; i++)\r\n        {\r\n            var line = headerSource[i].trim();\r\n\r\n            if (line.substring(0, 5) === 'name:')\r\n            {\r\n                return line.substring(5).trim();\r\n            }\r\n        }\r\n\r\n        return this.key;\r\n    },\r\n\r\n    /**\r\n     * Returns the type of the shader from the header block.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#getShaderType\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string[]} headerSource - The header data.\r\n     *\r\n     * @return {string} The shader type. Either 'fragment' or 'vertex'.\r\n     */\r\n    getShaderType: function (headerSource)\r\n    {\r\n        for (var i = 0; i < headerSource.length; i++)\r\n        {\r\n            var line = headerSource[i].trim();\r\n\r\n            if (line.substring(0, 5) === 'type:')\r\n            {\r\n                return line.substring(5).trim();\r\n            }\r\n        }\r\n\r\n        return this.config.shaderType;\r\n    },\r\n\r\n    /**\r\n     * Returns the shader uniforms from the header block.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#getShaderUniforms\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string[]} headerSource - The header data.\r\n     *\r\n     * @return {any} The shader uniforms object.\r\n     */\r\n    getShaderUniforms: function (headerSource)\r\n    {\r\n        var uniforms = {};\r\n\r\n        for (var i = 0; i < headerSource.length; i++)\r\n        {\r\n            var line = headerSource[i].trim();\r\n\r\n            if (line.substring(0, 8) === 'uniform.')\r\n            {\r\n                var pos = line.indexOf(':');\r\n\r\n                if (pos)\r\n                {\r\n                    var key = line.substring(8, pos);\r\n\r\n                    try\r\n                    {\r\n                        uniforms[key] = JSON.parse(line.substring(pos + 1));\r\n                    }\r\n                    catch (e)\r\n                    {\r\n                        console.warn('Invalid uniform JSON: ' + key);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return uniforms;\r\n    },\r\n\r\n    /**\r\n     * Processes the shader file and extracts the relevant data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.GLSLFile#extractBlock\r\n     * @private\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string[]} data - The array of shader data to process.\r\n     * @param {number} offset - The offset to start processing from.\r\n     *\r\n     * @return {any} The processed shader block, or null.\r\n     */\r\n    extractBlock: function (data, offset)\r\n    {\r\n        var headerStart = -1;\r\n        var headerEnd = -1;\r\n        var blockEnd = -1;\r\n        var headerOpen = false;\r\n        var captureSource = false;\r\n        var headerSource = [];\r\n        var shaderSource = [];\r\n\r\n        for (var i = offset; i < data.length; i++)\r\n        {\r\n            var line = data[i].trim();\r\n\r\n            if (line === '---')\r\n            {\r\n                if (headerStart === -1)\r\n                {\r\n                    headerStart = i;\r\n                    headerOpen = true;\r\n                }\r\n                else if (headerOpen)\r\n                {\r\n                    headerEnd = i;\r\n                    headerOpen = false;\r\n                    captureSource = true;\r\n                }\r\n                else\r\n                {\r\n                    //  We've hit another --- delimiter, break out\r\n                    captureSource = false;\r\n                    break;\r\n                }\r\n            }\r\n            else if (headerOpen)\r\n            {\r\n                headerSource.push(line);\r\n            }\r\n            else if (captureSource)\r\n            {\r\n                shaderSource.push(line);\r\n                blockEnd = i;\r\n            }\r\n        }\r\n\r\n        if (!headerOpen && headerEnd !== -1)\r\n        {\r\n            return { header: headerSource, shader: shaderSource.join('\\n'), offset: blockEnd };\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a GLSL file, or array of GLSL files, to the current load queue.\r\n * In Phaser 3 GLSL files are just plain Text files at the current moment in time.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.glsl('plasma', 'shaders/Plasma.glsl');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Shader Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Shader Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Shader Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.glsl({\r\n *     key: 'plasma',\r\n *     shaderType: 'fragment',\r\n *     url: 'shaders/Plasma.glsl'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.GLSLFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.glsl('plasma', 'shaders/Plasma.glsl');\r\n * // and later in your game ...\r\n * var data = this.cache.shader.get('plasma');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `FX.` and the key was `Plasma` the final key will be `FX.Plasma` and\r\n * this is what you would use to retrieve the text from the Shader Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"plasma\"\r\n * and no URL is given then the Loader will set the URL to be \"plasma.glsl\". It will always add `.glsl` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the GLSL File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#glsl\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.GLSLFileConfig|Phaser.Types.Loader.FileTypes.GLSLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.glsl`, i.e. if `key` was \"alien\" then the URL will be \"alien.glsl\".\r\n * @param {string} [shaderType='fragment'] - The type of shader. Either `fragment` for a fragment shader, or `vertex` for a vertex shader. This is ignored if you load a shader bundle.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('glsl', function (key, url, shaderType, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new GLSLFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new GLSLFile(this, key, url, shaderType, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = GLSLFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single HTML File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#html method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#html.\r\n *\r\n * @class HTMLFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.HTMLFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was \"alien\" then the URL will be \"alien.html\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar HTMLFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function HTMLFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'html';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'text',\r\n            cache: loader.cacheManager.html,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTMLFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an HTML file, or array of HTML files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.html('story', 'files/LoginForm.html');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global HTML Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the HTML Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the HTML Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.html({\r\n *     key: 'login',\r\n *     url: 'files/LoginForm.html'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.HTMLFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.html('login', 'files/LoginForm.html');\r\n * // and later in your game ...\r\n * var data = this.cache.html.get('login');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the html from the HTML Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.html\". It will always add `.html` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the HTML File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#html\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.12.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.HTMLFileConfig|Phaser.Types.Loader.FileTypes.HTMLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was \"alien\" then the URL will be \"alien.html\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('html', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new HTMLFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new HTMLFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = HTMLFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single HTML File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#htmlTexture method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#htmlTexture.\r\n *\r\n * @class HTMLTextureFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.12.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {number} [width] - The width of the texture the HTML will be rendered to.\r\n * @param {number} [height] - The height of the texture the HTML will be rendered to.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar HTMLTextureFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function HTMLTextureFile (loader, key, url, width, height, xhrSettings)\r\n    {\r\n        if (width === undefined) { width = 512; }\r\n        if (height === undefined) { height = 512; }\r\n\r\n        var extension = 'html';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            width = GetFastValue(config, 'width', width);\r\n            height = GetFastValue(config, 'height', height);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'html',\r\n            cache: loader.textureManager,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                width: width,\r\n                height: height\r\n            }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTMLTextureFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        var w = this.config.width;\r\n        var h = this.config.height;\r\n\r\n        var data = [];\r\n\r\n        data.push('<svg width=\"' + w + 'px\" height=\"' + h + 'px\" viewBox=\"0 0 ' + w + ' ' + h + '\" xmlns=\"http://www.w3.org/2000/svg\">');\r\n        data.push('<foreignObject width=\"100%\" height=\"100%\">');\r\n        data.push('<body xmlns=\"http://www.w3.org/1999/xhtml\">');\r\n        data.push(this.xhrLoader.responseText);\r\n        data.push('</body>');\r\n        data.push('</foreignObject>');\r\n        data.push('</svg>');\r\n\r\n        var svg = [ data.join('\\n') ];\r\n        var _this = this;\r\n\r\n        try\r\n        {\r\n            var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });\r\n        }\r\n        catch (e)\r\n        {\r\n            _this.state = CONST.FILE_ERRORED;\r\n\r\n            _this.onProcessComplete();\r\n\r\n            return;\r\n        }\r\n\r\n        this.data = new Image();\r\n\r\n        this.data.crossOrigin = this.crossOrigin;\r\n\r\n        this.data.onload = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessError();\r\n        };\r\n\r\n        File.createObjectURL(this.data, blob, 'image/svg+xml');\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTMLTextureFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture = this.cache.addImage(this.key, this.data);\r\n\r\n        this.pendingDestroy(texture);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an HTML File, or array of HTML Files, to the current load queue. When the files are loaded they\r\n * will be rendered to textures and stored in the Texture Manager.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.htmlTexture('instructions', 'content/intro.html', 256, 512);\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.htmlTexture({\r\n *     key: 'instructions',\r\n *     url: 'content/intro.html',\r\n *     width: 256,\r\n *     height: 512\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.htmlTexture('instructions', 'content/intro.html', 256, 512);\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'instructions');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.html\". It will always add `.html` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * The width and height are the size of the texture to which the HTML will be rendered. It's not possible to determine these\r\n * automatically, so you will need to provide them, either as arguments or in the file config object.\r\n * When the HTML file has loaded a new SVG element is created with a size and viewbox set to the width and height given.\r\n * The SVG file has a body tag added to it, with the HTML file contents included. It then calls `window.Blob` on the SVG,\r\n * and if successful is added to the Texture Manager, otherwise it fails processing. The overall quality of the rendered\r\n * HTML depends on your browser, and some of them may not even support the svg / blob process used. Be aware that there are\r\n * limitations on what HTML can be inside an SVG. You can find out more details in this\r\n * [Mozilla MDN entry](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Drawing_DOM_objects_into_a_canvas).\r\n *\r\n * Note: The ability to load this type of file will only be available if the HTMLTextureFile File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#htmlTexture\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.12.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig|Phaser.Types.Loader.FileTypes.HTMLTextureFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.html`, i.e. if `key` was \"alien\" then the URL will be \"alien.html\".\r\n * @param {number} [width=512] - The width of the texture the HTML will be rendered to.\r\n * @param {number} [height=512] - The height of the texture the HTML will be rendered to.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('htmlTexture', function (key, url, width, height, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new HTMLTextureFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new HTMLTextureFile(this, key, url, width, height, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = HTMLTextureFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar MultiFile = require('../MultiFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single Multi Texture Atlas File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#multiatlas method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#multiatlas.\r\n *\r\n * @class MultiAtlasFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig)} key - The key of the file. Must be unique within both the Loader and the Texture Manager. Or a config object.\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the multi atlas json file from.\r\n * @param {string} [path] - Optional path to use when loading the textures defined in the atlas data.\r\n * @param {string} [baseURL] - Optional Base URL to use when loading the textures defined in the atlas data.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - Extra XHR Settings specifically for the atlas json file.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - Extra XHR Settings specifically for the texture files.\r\n */\r\nvar MultiAtlasFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function MultiAtlasFile (loader, key, atlasURL, path, baseURL, atlasXhrSettings, textureXhrSettings)\r\n    {\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            if (GetFastValue(config, 'url', false))\r\n            {\r\n                atlasURL = GetFastValue(config, 'url');\r\n            }\r\n            else\r\n            {\r\n                atlasURL = GetFastValue(config, 'atlasURL');\r\n            }\r\n\r\n            atlasXhrSettings = GetFastValue(config, 'xhrSettings');\r\n            path = GetFastValue(config, 'path');\r\n            baseURL = GetFastValue(config, 'baseURL');\r\n            textureXhrSettings = GetFastValue(config, 'textureXhrSettings');\r\n        }\r\n\r\n        var data = new JSONFile(loader, key, atlasURL, atlasXhrSettings);\r\n\r\n        MultiFile.call(this, loader, 'multiatlas', key, [ data ]);\r\n\r\n        this.config.path = path;\r\n        this.config.baseURL = baseURL;\r\n        this.config.textureXhrSettings = textureXhrSettings;\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.MultiAtlasFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n\r\n            if (file.type === 'json' && file.data.hasOwnProperty('textures'))\r\n            {\r\n                //  Inspect the data for the files to now load\r\n                var textures = file.data.textures;\r\n\r\n                var config = this.config;\r\n                var loader = this.loader;\r\n\r\n                var currentBaseURL = loader.baseURL;\r\n                var currentPath = loader.path;\r\n                var currentPrefix = loader.prefix;\r\n\r\n                var baseURL = GetFastValue(config, 'baseURL', this.baseURL);\r\n                var path = GetFastValue(config, 'path', this.path);\r\n                var prefix = GetFastValue(config, 'prefix', this.prefix);\r\n                var textureXhrSettings = GetFastValue(config, 'textureXhrSettings');\r\n\r\n                loader.setBaseURL(baseURL);\r\n                loader.setPath(path);\r\n                loader.setPrefix(prefix);\r\n\r\n                for (var i = 0; i < textures.length; i++)\r\n                {\r\n                    //  \"image\": \"texture-packer-multi-atlas-0.png\",\r\n                    var textureURL = textures[i].image;\r\n\r\n                    var key = 'MA' + this.multiKeyIndex + '_' + textureURL;\r\n\r\n                    var image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n\r\n                    this.addToMultiFile(image);\r\n\r\n                    loader.addFile(image);\r\n\r\n                    //  \"normalMap\": \"texture-packer-multi-atlas-0_n.png\",\r\n                    if (textures[i].normalMap)\r\n                    {\r\n                        var normalMap = new ImageFile(loader, key, textures[i].normalMap, textureXhrSettings);\r\n\r\n                        normalMap.type = 'normalMap';\r\n\r\n                        image.setLink(normalMap);\r\n\r\n                        this.addToMultiFile(normalMap);\r\n\r\n                        loader.addFile(normalMap);\r\n                    }\r\n                }\r\n\r\n                //  Reset the loader settings\r\n                loader.setBaseURL(currentBaseURL);\r\n                loader.setPath(currentPath);\r\n                loader.setPrefix(currentPrefix);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.MultiAtlasFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var fileJSON = this.files[0];\r\n\r\n            var data = [];\r\n            var images = [];\r\n            var normalMaps = [];\r\n\r\n            for (var i = 1; i < this.files.length; i++)\r\n            {\r\n                var file = this.files[i];\r\n\r\n                if (file.type === 'normalMap')\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                var pos = file.key.indexOf('_');\r\n                var key = file.key.substr(pos + 1);\r\n\r\n                var image = file.data;\r\n\r\n                //  Now we need to find out which json entry this mapped to\r\n                for (var t = 0; t < fileJSON.data.textures.length; t++)\r\n                {\r\n                    var item = fileJSON.data.textures[t];\r\n\r\n                    if (item.image === key)\r\n                    {\r\n                        images.push(image);\r\n\r\n                        data.push(item);\r\n\r\n                        if (file.linkFile)\r\n                        {\r\n                            normalMaps.push(file.linkFile.data);\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (normalMaps.length === 0)\r\n            {\r\n                normalMaps = undefined;\r\n            }\r\n\r\n            this.loader.textureManager.addAtlasJSONArray(this.key, images, data, normalMaps);\r\n\r\n            this.complete = true;\r\n\r\n            for (i = 0; i < this.files.length; i++)\r\n            {\r\n                this.files[i].pendingDestroy();\r\n            }\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Multi Texture Atlas, or array of multi atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.multiatlas('level1', 'images/Level1.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in a JSON file as exported from the application Texture Packer,\r\n * version 4.6.3 or above, where you have made sure to use the Phaser 3 Export option.\r\n *\r\n * The way it works internally is that you provide a URL to the JSON file. Phaser then loads this JSON, parses it and\r\n * extracts which texture files it also needs to load to complete the process. If the JSON also defines normal maps,\r\n * Phaser will load those as well.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.multiatlas({\r\n *     key: 'level1',\r\n *     atlasURL: 'images/Level1.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig` for more details.\r\n *\r\n * Instead of passing a URL for the atlas JSON data you can also pass in a well formed JSON object instead.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.multiatlas('level1', 'images/Level1.json');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'level1', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Multi Atlas File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#multiatlas\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.7.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig|Phaser.Types.Loader.FileTypes.MultiAtlasFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas json data file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [path] - Optional path to use when loading the textures defined in the atlas data.\r\n * @param {string} [baseURL] - Optional Base URL to use when loading the textures defined in the atlas data.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas json file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('multiatlas', function (key, atlasURL, path, baseURL, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new MultiAtlasFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new MultiAtlasFile(this, key, atlasURL, path, baseURL, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = MultiAtlasFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile.js');\r\nvar ScriptFile = require('./ScriptFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A Multi Script File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#scripts method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#scripts.\r\n *\r\n * @class MultiScriptFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.17.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.MultiScriptFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string[]} [url] - An array of absolute or relative URLs to load the script files from. They are processed in the order given in the array.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object for the script files. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar MultiScriptFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function MultiScriptFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n        var files = [];\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        if (!Array.isArray(url))\r\n        {\r\n            url = [ url ];\r\n        }\r\n\r\n        for (var i = 0; i < url.length; i++)\r\n        {\r\n            var scriptFile = new ScriptFile(loader, {\r\n                key: key + '_' + i.toString(),\r\n                url: url[i],\r\n                extension: extension,\r\n                xhrSettings: xhrSettings\r\n            });\r\n\r\n            //  Override the default onProcess function\r\n            scriptFile.onProcess = function ()\r\n            {\r\n                this.onProcessComplete();\r\n            };\r\n\r\n            files.push(scriptFile);\r\n        }\r\n\r\n        MultiFile.call(this, loader, 'scripts', key, files);\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.MultiScriptFile#addToCache\r\n     * @since 3.17.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            for (var i = 0; i < this.files.length; i++)\r\n            {\r\n                var file = this.files[i];\r\n\r\n                file.data = document.createElement('script');\r\n                file.data.language = 'javascript';\r\n                file.data.type = 'text/javascript';\r\n                file.data.defer = false;\r\n                file.data.text = file.xhrLoader.responseText;\r\n\r\n                document.head.appendChild(file.data);\r\n            }\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an array of Script files to the current load queue.\r\n *\r\n * The difference between this and the `ScriptFile` file type is that you give an array of scripts to this method,\r\n * and the scripts are then processed _exactly_ in that order. This allows you to load a bunch of scripts that\r\n * may have dependencies on each other without worrying about the async nature of traditional script loading.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.scripts('PostProcess', [\r\n *         'libs/shaders/CopyShader.js',\r\n *         'libs/postprocessing/EffectComposer.js',\r\n *         'libs/postprocessing/RenderPass.js',\r\n *         'libs/postprocessing/MaskPass.js',\r\n *         'libs/postprocessing/ShaderPass.js',\r\n *         'libs/postprocessing/AfterimagePass.js'\r\n *    ]);\r\n * }\r\n * ```\r\n *\r\n * In the code above the script files will all be loaded in parallel but only processed (i.e. invoked) in the exact\r\n * order given in the array.\r\n *\r\n * The files are **not** loaded right away. They are added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the files are queued\r\n * it means you cannot use the files immediately after calling this method, but must wait for the files to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.scripts({\r\n *     key: 'PostProcess',\r\n *     url: [\r\n *         'libs/shaders/CopyShader.js',\r\n *         'libs/postprocessing/EffectComposer.js',\r\n *         'libs/postprocessing/RenderPass.js',\r\n *         'libs/postprocessing/MaskPass.js',\r\n *         'libs/postprocessing/ShaderPass.js',\r\n *         'libs/postprocessing/AfterimagePass.js'\r\n *        ]\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.MultiScriptFileConfig` for more details.\r\n *\r\n * Once all the files have finished loading they will automatically be converted into a script element\r\n * via `document.createElement('script')`. They will have their language set to JavaScript, `defer` set to\r\n * false and then the resulting element will be appended to `document.head`. Any code then in the\r\n * script will be executed. This is done in the exact order the files are specified in the url array.\r\n *\r\n * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.\r\n *\r\n * Note: The ability to load this type of file will only be available if the MultiScript File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#scripts\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.17.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.MultiScriptFileConfig|Phaser.Types.Loader.FileTypes.MultiScriptFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string[]} [url] - An array of absolute or relative URLs to load the script files from. They are processed in the order given in the array.\r\n * @param {string} [extension='js'] - The default file extension to use if no url is provided.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for these files.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('scripts', function (key, url, xhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new MultiScriptFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new MultiScriptFile(this, key, url, xhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = MultiScriptFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile');\r\nvar ParseObj = require('../../geom/mesh/ParseObj');\r\nvar ParseObjMaterial = require('../../geom/mesh/ParseObjMaterial');\r\nvar TextFile = require('./TextFile');\r\n\r\n/**\r\n * @classdesc\r\n * A single Wavefront OBJ File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#obj method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#obj.\r\n *\r\n * @class OBJFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.OBJFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [objURL] - The absolute or relative URL to load the obj file from. If undefined or `null` it will be set to `<key>.obj`, i.e. if `key` was \"alien\" then the URL will be \"alien.obj\".\r\n * @param {string} [matURL] - The absolute or relative URL to load the material file from. If undefined or `null` it will be set to `<key>.mat`, i.e. if `key` was \"alien\" then the URL will be \"alien.mat\".\r\n * @param {boolean} [flipUV] - Flip the UV coordinates stored in the model data?\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for these files.\r\n */\r\nvar OBJFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function OBJFile (loader, key, objURL, matURL, flipUV, xhrSettings)\r\n    {\r\n        var obj;\r\n        var mat;\r\n\r\n        var cache = loader.cacheManager.obj;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            obj = new TextFile(loader, {\r\n                key: key,\r\n                type: 'obj',\r\n                cache: cache,\r\n                url: GetFastValue(config, 'url'),\r\n                extension: GetFastValue(config, 'extension', 'obj'),\r\n                xhrSettings: GetFastValue(config, 'xhrSettings'),\r\n                config: {\r\n                    flipUV: GetFastValue(config, 'flipUV', flipUV)\r\n                }\r\n            });\r\n\r\n            matURL = GetFastValue(config, 'matURL');\r\n\r\n            if (matURL)\r\n            {\r\n                mat = new TextFile(loader, {\r\n                    key: key,\r\n                    type: 'mat',\r\n                    cache: cache,\r\n                    url: matURL,\r\n                    extension: GetFastValue(config, 'matExtension', 'mat'),\r\n                    xhrSettings: GetFastValue(config, 'xhrSettings')\r\n                });\r\n            }\r\n        }\r\n        else\r\n        {\r\n            obj = new TextFile(loader, {\r\n                key: key,\r\n                url: objURL,\r\n                type: 'obj',\r\n                cache: cache,\r\n                extension: 'obj',\r\n                xhrSettings: xhrSettings,\r\n                config: {\r\n                    flipUV: flipUV\r\n                }\r\n            });\r\n\r\n            if (matURL)\r\n            {\r\n                mat = new TextFile(loader, {\r\n                    key: key,\r\n                    url: matURL,\r\n                    type: 'mat',\r\n                    cache: cache,\r\n                    extension: 'mat',\r\n                    xhrSettings: xhrSettings\r\n                });\r\n            }\r\n        }\r\n\r\n        MultiFile.call(this, loader, 'obj', key, [ obj, mat ]);\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.OBJFile#addToCache\r\n     * @since 3.50.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var obj = this.files[0];\r\n            var mat = this.files[1];\r\n\r\n            var objData = ParseObj(obj.data, obj.config.flipUV);\r\n\r\n            if (mat)\r\n            {\r\n                objData.materials = ParseObjMaterial(mat.data);\r\n            }\r\n\r\n            obj.cache.add(obj.key, objData);\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Wavefront OBJ file, or array of OBJ files, to the current load queue.\r\n *\r\n * Note: You should ensure your 3D package has triangulated the OBJ file prior to export.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.obj('ufo', 'files/spaceship.obj');\r\n * }\r\n * ```\r\n *\r\n * You can optionally also load a Wavefront Material file as well, by providing the 3rd parameter:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.obj('ufo', 'files/spaceship.obj', 'files/spaceship.mtl');\r\n * }\r\n * ```\r\n *\r\n * If given, the material will be parsed and stored along with the obj data in the cache.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global OBJ Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the OBJ Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the OBJ Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.obj({\r\n *     key: 'ufo',\r\n *     url: 'files/spaceship.obj',\r\n *     matURL: 'files/spaceship.mtl',\r\n *     flipUV: true\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.OBJFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.obj('ufo', 'files/spaceship.obj');\r\n * // and later in your game ...\r\n * var data = this.cache.obj.get('ufo');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the obj from the OBJ Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.obj\". It will always add `.obj` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the OBJ File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#obj\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.50.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.OBJFileConfig|Phaser.Types.Loader.FileTypes.OBJFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [objURL] - The absolute or relative URL to load the obj file from. If undefined or `null` it will be set to `<key>.obj`, i.e. if `key` was \"alien\" then the URL will be \"alien.obj\".\r\n * @param {string} [matURL] - Optional absolute or relative URL to load the obj material file from.\r\n * @param {boolean} [flipUV] - Flip the UV coordinates stored in the model data?\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('obj', function (key, objURL, matURL, flipUVs, xhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new OBJFile(this, key[i]);\r\n\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new OBJFile(this, key, objURL, matURL, flipUVs, xhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = OBJFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar JSONFile = require('./JSONFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single JSON Pack File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#pack method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#pack.\r\n *\r\n * @class PackFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.PackFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n */\r\nvar PackFile = new Class({\r\n\r\n    Extends: JSONFile,\r\n\r\n    initialize:\r\n\r\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\r\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\r\n\r\n    function PackFile (loader, key, url, xhrSettings, dataKey)\r\n    {\r\n        JSONFile.call(this, loader, key, url, xhrSettings, dataKey);\r\n\r\n        this.type = 'packfile';\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.PackFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        if (this.state !== CONST.FILE_POPULATED)\r\n        {\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            this.data = JSON.parse(this.xhrLoader.responseText);\r\n        }\r\n\r\n        //  Let's pass the pack file data over to the Loader ...\r\n        this.loader.addPack(this.data, this.config);\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON File Pack, or array of packs, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.pack('level1', 'data/Level1Files.json');\r\n * }\r\n * ```\r\n *\r\n * A File Pack is a JSON file (or object) that contains details about other files that should be added into the Loader.\r\n * Here is a small example:\r\n *\r\n * ```json\r\n * {\r\n *    \"test1\": {\r\n *        \"files\": [\r\n *            {\r\n *                \"type\": \"image\",\r\n *                \"key\": \"taikodrummaster\",\r\n *                \"url\": \"assets/pics/taikodrummaster.jpg\"\r\n *            },\r\n *            {\r\n *                \"type\": \"image\",\r\n *                \"key\": \"sukasuka-chtholly\",\r\n *                \"url\": \"assets/pics/sukasuka-chtholly.png\"\r\n *            }\r\n *        ]\r\n *    },\r\n *    \"meta\": {\r\n *        \"generated\": \"1401380327373\",\r\n *        \"app\": \"Phaser 3 Asset Packer\",\r\n *        \"url\": \"https://phaser.io\",\r\n *        \"version\": \"1.0\",\r\n *        \"copyright\": \"Photon Storm Ltd. 2018\"\r\n *    }\r\n * }\r\n * ```\r\n *\r\n * The pack can be split into sections. In the example above you'll see a section called `test1. You can tell\r\n * the `load.pack` method to parse only a particular section of a pack. The pack is stored in the JSON Cache,\r\n * so you can pass it to the Loader to process additional sections as needed in your game, or you can just load\r\n * them all at once without specifying anything.\r\n *\r\n * The pack file can contain an entry for any type of file that Phaser can load. The object structures exactly\r\n * match that of the file type configs, and all properties available within the file type configs can be used\r\n * in the pack file too.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the JSON Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.pack({\r\n *     key: 'level1',\r\n *     url: 'data/Level1Files.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.PackFileConfig` for more details.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the JSON Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\r\n * rather than the whole file. For example, if your JSON data had a structure like this:\r\n *\r\n * ```json\r\n * {\r\n *     \"level1\": {\r\n *         \"baddies\": {\r\n *             \"aliens\": {},\r\n *             \"boss\": {}\r\n *         }\r\n *     },\r\n *     \"level2\": {},\r\n *     \"level3\": {}\r\n * }\r\n * ```\r\n *\r\n * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Pack File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#pack\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.7.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.PackFileConfig|Phaser.Types.Loader.FileTypes.PackFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('pack', function (key, url, packKey, xhrSettings)\r\n{\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            this.addFile(new PackFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new PackFile(this, key, url, xhrSettings, packKey));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = PackFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Plugin Script File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#plugin method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#plugin.\r\n *\r\n * @class PluginFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.PluginFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {boolean} [start=false] - Automatically start the plugin after loading?\r\n * @param {string} [mapping] - If this plugin is to be injected into the Scene, this is the property key used.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar PluginFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function PluginFile (loader, key, url, start, mapping, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            start = GetFastValue(config, 'start');\r\n            mapping = GetFastValue(config, 'mapping');\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'plugin',\r\n            cache: false,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                start: start,\r\n                mapping: mapping\r\n            }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        // If the url variable refers to a class, add the plugin directly\r\n        if (typeof url === 'function')\r\n        {\r\n            this.data = url;\r\n\r\n            this.state = CONST.FILE_POPULATED;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.PluginFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        var pluginManager = this.loader.systems.plugins;\r\n        var config = this.config;\r\n\r\n        var start = GetFastValue(config, 'start', false);\r\n        var mapping = GetFastValue(config, 'mapping', null);\r\n\r\n        if (this.state === CONST.FILE_POPULATED)\r\n        {\r\n            pluginManager.install(this.key, this.data, start, mapping);\r\n        }\r\n        else\r\n        {\r\n            //  Plugin added via a js file\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            this.data = document.createElement('script');\r\n            this.data.language = 'javascript';\r\n            this.data.type = 'text/javascript';\r\n            this.data.defer = false;\r\n            this.data.text = this.xhrLoader.responseText;\r\n\r\n            document.head.appendChild(this.data);\r\n\r\n            var plugin = pluginManager.install(this.key, window[this.key], start, mapping);\r\n\r\n            if (start || mapping)\r\n            {\r\n                //  Install into the current Scene Systems and Scene\r\n                this.loader.systems[mapping] = plugin;\r\n                this.loader.scene[mapping] = plugin;\r\n            }\r\n        }\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Plugin Script file, or array of plugin files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.plugin('modplayer', 'plugins/ModPlayer.js');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.plugin({\r\n *     key: 'modplayer',\r\n *     url: 'plugins/ModPlayer.js'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.PluginFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be converted into a script element\r\n * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to\r\n * false and then the resulting element will be appended to `document.head`. Any code then in the\r\n * script will be executed. It will then be passed to the Phaser PluginCache.register method.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.js\". It will always add `.js` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Plugin File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#plugin\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.PluginFileConfig|Phaser.Types.Loader.FileTypes.PluginFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(string|function)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\". Or, a plugin function.\r\n * @param {boolean} [start] - Automatically start the plugin after loading?\r\n * @param {string} [mapping] - If this plugin is to be injected into the Scene, this is the property key used.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('plugin', function (key, url, start, mapping, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new PluginFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new PluginFile(this, key, url, start, mapping, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = PluginFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * An external Scene JavaScript File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#sceneFile method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#sceneFile.\r\n *\r\n * @class SceneFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SceneFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar SceneFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function SceneFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'text',\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SceneFile#onProcess\r\n     * @since 3.16.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SceneFile#addToCache\r\n     * @since 3.16.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var code = this.data.concat('(function(){\\n' + 'return new ' + this.key + '();\\n' + '}).call(this);');\r\n\r\n        //  Stops rollup from freaking out during build\r\n        var eval2 = eval;\r\n\r\n        this.loader.sceneManager.add(this.key, eval2(code));\r\n\r\n        this.complete = true;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an external Scene file, or array of Scene files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.sceneFile('Level1', 'src/Level1.js');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Scene Manager upon a successful load.\r\n *\r\n * For a Scene File it's vitally important that the key matches the class name in the JavaScript file.\r\n *\r\n * For example here is the source file:\r\n *\r\n * ```javascript\r\n * class ExternalScene extends Phaser.Scene {\r\n *\r\n *     constructor ()\r\n *     {\r\n *         super('myScene');\r\n *     }\r\n *\r\n * }\r\n * ```\r\n *\r\n * Because the class is called `ExternalScene` that is the exact same key you must use when loading it:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.sceneFile('ExternalScene', 'src/yourScene.js');\r\n * }\r\n * ```\r\n *\r\n * The key that is used within the Scene Manager can either be set to the same, or you can override it in the Scene\r\n * constructor, as we've done in the example above, where the Scene key was changed to `myScene`.\r\n *\r\n * The key should be unique both in terms of files being loaded and Scenes already present in the Scene Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Scene Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.sceneFile({\r\n *     key: 'Level1',\r\n *     url: 'src/Level1.js'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.SceneFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will be added to the Scene Manager.\r\n *\r\n * ```javascript\r\n * this.load.sceneFile('Level1', 'src/Level1.js');\r\n * // and later in your game ...\r\n * this.scene.start('Level1');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `WORLD1.` and the key was `Story` the final key will be `WORLD1.Story` and\r\n * this is what you would use to retrieve the text from the Scene Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.js\". It will always add `.js` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Scene File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#sceneFile\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.16.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SceneFileConfig|Phaser.Types.Loader.FileTypes.SceneFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('sceneFile', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new SceneFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new SceneFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = SceneFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Scene Plugin Script File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#scenePlugin method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#scenePlugin.\r\n *\r\n * @class ScenePluginFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.8.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ScenePluginFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {string} [systemKey] - If this plugin is to be added to Scene.Systems, this is the property key for it.\r\n * @param {string} [sceneKey] - If this plugin is to be added to the Scene, this is the property key for it.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar ScenePluginFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function ScenePluginFile (loader, key, url, systemKey, sceneKey, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            systemKey = GetFastValue(config, 'systemKey');\r\n            sceneKey = GetFastValue(config, 'sceneKey');\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'scenePlugin',\r\n            cache: false,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                systemKey: systemKey,\r\n                sceneKey: sceneKey\r\n            }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        // If the url variable refers to a class, add the plugin directly\r\n        if (typeof url === 'function')\r\n        {\r\n            this.data = url;\r\n\r\n            this.state = CONST.FILE_POPULATED;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ScenePluginFile#onProcess\r\n     * @since 3.8.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        var pluginManager = this.loader.systems.plugins;\r\n        var config = this.config;\r\n\r\n        var key = this.key;\r\n        var systemKey = GetFastValue(config, 'systemKey', key);\r\n        var sceneKey = GetFastValue(config, 'sceneKey', key);\r\n\r\n        if (this.state === CONST.FILE_POPULATED)\r\n        {\r\n            pluginManager.installScenePlugin(systemKey, this.data, sceneKey, this.loader.scene, true);\r\n        }\r\n        else\r\n        {\r\n            //  Plugin added via a js file\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            this.data = document.createElement('script');\r\n            this.data.language = 'javascript';\r\n            this.data.type = 'text/javascript';\r\n            this.data.defer = false;\r\n            this.data.text = this.xhrLoader.responseText;\r\n\r\n            document.head.appendChild(this.data);\r\n\r\n            pluginManager.installScenePlugin(systemKey, window[this.key], sceneKey, this.loader.scene, true);\r\n        }\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Scene Plugin Script file, or array of plugin files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.scenePlugin('ModPlayer', 'plugins/ModPlayer.js', 'modPlayer', 'mods');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.scenePlugin({\r\n *     key: 'modplayer',\r\n *     url: 'plugins/ModPlayer.js'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.ScenePluginFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be converted into a script element\r\n * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to\r\n * false and then the resulting element will be appended to `document.head`. Any code then in the\r\n * script will be executed. It will then be passed to the Phaser PluginCache.register method.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.js\". It will always add `.js` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Script File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#scenePlugin\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.8.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ScenePluginFileConfig|Phaser.Types.Loader.FileTypes.ScenePluginFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(string|function)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\". Or, set to a plugin function.\r\n * @param {string} [systemKey] - If this plugin is to be added to Scene.Systems, this is the property key for it.\r\n * @param {string} [sceneKey] - If this plugin is to be added to the Scene, this is the property key for it.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('scenePlugin', function (key, url, systemKey, sceneKey, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new ScenePluginFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new ScenePluginFile(this, key, url, systemKey, sceneKey, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = ScenePluginFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar ImageFile = require('./ImageFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single Sprite Sheet Image File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#spritesheet method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#spritesheet.\r\n *\r\n * @class SpriteSheetFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar SpriteSheetFile = new Class({\r\n\r\n    Extends: ImageFile,\r\n\r\n    initialize:\r\n\r\n    function SpriteSheetFile (loader, key, url, frameConfig, xhrSettings)\r\n    {\r\n        ImageFile.call(this, loader, key, url, xhrSettings, frameConfig);\r\n\r\n        this.type = 'spritesheet';\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SpriteSheetFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture = this.cache.addSpriteSheet(this.key, this.data, this.config);\r\n\r\n        this.pendingDestroy(texture);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Sprite Sheet Image, or array of Sprite Sheet Images, to the current load queue.\r\n *\r\n * The term 'Sprite Sheet' in Phaser means a fixed-size sheet. Where every frame in the sheet is the exact same size,\r\n * and you reference those frames using numbers, not frame names. This is not the same thing as a Texture Atlas, where\r\n * the frames are packed in a way where they take up the least amount of space, and are referenced by their names,\r\n * not numbers. Some articles and software use the term 'Sprite Sheet' to mean Texture Atlas, so please be aware of\r\n * what sort of file you're actually trying to load.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.spritesheet('bot', 'images/robot.png', { frameWidth: 32, frameHeight: 38 });\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback\r\n * of animated gifs to Canvas elements.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.spritesheet({\r\n *     key: 'bot',\r\n *     url: 'images/robot.png',\r\n *     frameConfig: {\r\n *         frameWidth: 32,\r\n *         frameHeight: 38,\r\n *         startFrame: 0,\r\n *         endFrame: 8\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n * \r\n * ```javascript\r\n * this.load.spritesheet('bot', 'images/robot.png', { frameWidth: 32, frameHeight: 38 });\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'bot', 0);\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `PLAYER.` and the key was `Running` the final key will be `PLAYER.Running` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n * \r\n * ```javascript\r\n * this.load.spritesheet('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ], { frameWidth: 256, frameHeight: 80 });\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n * \r\n * ```javascript\r\n * this.load.spritesheet({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png',\r\n *     normalMap: 'images/AtariLogo-n.png',\r\n *     frameConfig: {\r\n *         frameWidth: 256,\r\n *         frameHeight: 80\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n * \r\n * Note: The ability to load this type of file will only be available if the Sprite Sheet File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#spritesheet\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig|Phaser.Types.Loader.FileTypes.SpriteSheetFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object. At a minimum it should have a `frameWidth` property.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('spritesheet', function (key, url, frameConfig, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new SpriteSheetFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new SpriteSheetFile(this, key, url, frameConfig, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = SpriteSheetFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single SVG File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#svg method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#svg.\r\n *\r\n * @class SVGFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SVGFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.svg`, i.e. if `key` was \"alien\" then the URL will be \"alien.svg\".\r\n * @param {Phaser.Types.Loader.FileTypes.SVGSizeConfig} [svgConfig] - The svg size configuration object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar SVGFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function SVGFile (loader, key, url, svgConfig, xhrSettings)\r\n    {\r\n        var extension = 'svg';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            svgConfig = GetFastValue(config, 'svgConfig', {});\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'svg',\r\n            cache: loader.textureManager,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                width: GetFastValue(svgConfig, 'width'),\r\n                height: GetFastValue(svgConfig, 'height'),\r\n                scale: GetFastValue(svgConfig, 'scale')\r\n            }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SVGFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        var text = this.xhrLoader.responseText;\r\n        var svg = [ text ];\r\n        var width = this.config.width;\r\n        var height = this.config.height;\r\n        var scale = this.config.scale;\r\n\r\n        resize: if (width && height || scale)\r\n        {\r\n            var xml = null;\r\n            var parser = new DOMParser();\r\n            xml = parser.parseFromString(text, 'text/xml');\r\n            var svgXML = xml.getElementsByTagName('svg')[0];\r\n\r\n            var hasViewBox = svgXML.hasAttribute('viewBox');\r\n            var svgWidth = parseFloat(svgXML.getAttribute('width'));\r\n            var svgHeight = parseFloat(svgXML.getAttribute('height'));\r\n\r\n            if (!hasViewBox && svgWidth && svgHeight)\r\n            {\r\n                //  If there's no viewBox attribute, set one\r\n                svgXML.setAttribute('viewBox', '0  0 ' + svgWidth + ' ' + svgHeight);\r\n            }\r\n            else if (hasViewBox && !svgWidth && !svgHeight)\r\n            {\r\n                //  Get the w/h from the viewbox\r\n                var viewBox = svgXML.getAttribute('viewBox').split(/\\s+|,/);\r\n\r\n                svgWidth = viewBox[2];\r\n                svgHeight = viewBox[3];\r\n            }\r\n\r\n            if (scale)\r\n            {\r\n                if (svgWidth && svgHeight)\r\n                {\r\n                    width = svgWidth * scale;\r\n                    height = svgHeight * scale;\r\n                }\r\n                else\r\n                {\r\n                    break resize;\r\n                }\r\n            }\r\n\r\n            svgXML.setAttribute('width', width.toString() + 'px');\r\n            svgXML.setAttribute('height', height.toString() + 'px');\r\n\r\n            svg = [ (new XMLSerializer()).serializeToString(svgXML) ];\r\n        }\r\n\r\n        try\r\n        {\r\n            var blob = new window.Blob(svg, { type: 'image/svg+xml;charset=utf-8' });\r\n        }\r\n        catch (e)\r\n        {\r\n            this.onProcessError();\r\n\r\n            return;\r\n        }\r\n\r\n        this.data = new Image();\r\n\r\n        this.data.crossOrigin = this.crossOrigin;\r\n\r\n        var _this = this;\r\n        var retry = false;\r\n\r\n        this.data.onload = function ()\r\n        {\r\n            if (!retry)\r\n            {\r\n                File.revokeObjectURL(_this.data);\r\n            }\r\n\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            //  Safari 8 re-try\r\n            if (!retry)\r\n            {\r\n                retry = true;\r\n\r\n                File.revokeObjectURL(_this.data);\r\n\r\n                _this.data.src = 'data:image/svg+xml,' + encodeURIComponent(svg.join(''));\r\n            }\r\n            else\r\n            {\r\n                _this.onProcessError();\r\n            }\r\n        };\r\n\r\n        File.createObjectURL(this.data, blob, 'image/svg+xml');\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.SVGFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture = this.cache.addImage(this.key, this.data);\r\n\r\n        this.pendingDestroy(texture);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an SVG File, or array of SVG Files, to the current load queue. When the files are loaded they\r\n * will be rendered to bitmap textures and stored in the Texture Manager.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.svg('morty', 'images/Morty.svg');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.svg({\r\n *     key: 'morty',\r\n *     url: 'images/Morty.svg'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.SVGFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.svg('morty', 'images/Morty.svg');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'morty');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.html\". It will always add `.html` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can optionally pass an SVG Resize Configuration object when you load an SVG file. By default the SVG will be rendered to a texture\r\n * at the same size defined in the SVG file attributes. However, this isn't always desirable. You may wish to resize the SVG (either down\r\n * or up) to improve texture clarity, or reduce texture memory consumption. You can either specify an exact width and height to resize\r\n * the SVG to:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.svg('morty', 'images/Morty.svg', { width: 300, height: 600 });\r\n * }\r\n * ```\r\n *\r\n * Or when using a configuration object:\r\n *\r\n * ```javascript\r\n * this.load.svg({\r\n *     key: 'morty',\r\n *     url: 'images/Morty.svg',\r\n *     svgConfig: {\r\n *         width: 300,\r\n *         height: 600\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * Alternatively, you can just provide a scale factor instead:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.svg('morty', 'images/Morty.svg', { scale: 2.5 });\r\n * }\r\n * ```\r\n *\r\n * Or when using a configuration object:\r\n *\r\n * ```javascript\r\n * this.load.svg({\r\n *     key: 'morty',\r\n *     url: 'images/Morty.svg',\r\n *     svgConfig: {\r\n *         scale: 2.5\r\n *     }\r\n * });\r\n * ```\r\n *\r\n * If scale, width and height values are all given, the scale has priority and the width and height values are ignored.\r\n *\r\n * Note: The ability to load this type of file will only be available if the SVG File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#svg\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.SVGFileConfig|Phaser.Types.Loader.FileTypes.SVGFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.svg`, i.e. if `key` was \"alien\" then the URL will be \"alien.svg\".\r\n * @param {Phaser.Types.Loader.FileTypes.SVGSizeConfig} [svgConfig] - The svg size configuration object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('svg', function (key, url, svgConfig, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new SVGFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new SVGFile(this, key, url, svgConfig, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = SVGFile;\r\n\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\r\n\r\n/**\r\n * @classdesc\r\n * A single Tilemap CSV File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#tilemapCSV method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#tilemapCSV.\r\n *\r\n * @class TilemapCSVFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.csv`, i.e. if `key` was \"alien\" then the URL will be \"alien.csv\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar TilemapCSVFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function TilemapCSVFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'csv';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'tilemapCSV',\r\n            cache: loader.cacheManager.tilemap,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        this.tilemapFormat = TILEMAP_FORMATS.CSV;\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TilemapCSVFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TilemapCSVFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var tiledata = { format: this.tilemapFormat, data: this.data };\r\n\r\n        this.cache.add(this.key, tiledata);\r\n\r\n        this.pendingDestroy(tiledata);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a CSV Tilemap file, or array of CSV files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.tilemapCSV('level1', 'maps/Level1.csv');\r\n * }\r\n * ```\r\n *\r\n * Tilemap CSV data can be created in a text editor, or a 3rd party app that exports as CSV.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Text Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.tilemapCSV({\r\n *     key: 'level1',\r\n *     url: 'maps/Level1.csv'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.tilemapCSV('level1', 'maps/Level1.csv');\r\n * // and later in your game ...\r\n * var map = this.make.tilemap({ key: 'level1' });\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the text from the Tilemap Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"level\"\r\n * and no URL is given then the Loader will set the URL to be \"level.csv\". It will always add `.csv` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Tilemap CSV File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#tilemapCSV\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig|Phaser.Types.Loader.FileTypes.TilemapCSVFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.csv`, i.e. if `key` was \"alien\" then the URL will be \"alien.csv\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('tilemapCSV', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new TilemapCSVFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new TilemapCSVFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = TilemapCSVFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar JSONFile = require('./JSONFile.js');\r\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\r\n\r\n/**\r\n * @classdesc\r\n * A single Impact.js Tilemap JSON File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#tilemapImpact method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#tilemapImpact.\r\n *\r\n * @class TilemapImpactFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar TilemapImpactFile = new Class({\r\n\r\n    Extends: JSONFile,\r\n\r\n    initialize:\r\n\r\n    function TilemapImpactFile (loader, key, url, xhrSettings)\r\n    {\r\n        JSONFile.call(this, loader, key, url, xhrSettings);\r\n\r\n        this.type = 'tilemapJSON';\r\n\r\n        this.cache = loader.cacheManager.tilemap;\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TilemapImpactFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var tiledata = { format: TILEMAP_FORMATS.WELTMEISTER, data: this.data };\r\n\r\n        this.cache.add(this.key, tiledata);\r\n\r\n        this.pendingDestroy(tiledata);\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an Impact.js Tilemap file, or array of map files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.tilemapImpact('level1', 'maps/Level1.json');\r\n * }\r\n * ```\r\n *\r\n * Impact Tilemap data is created the Impact.js Map Editor called Weltmeister.\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Text Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.tilemapImpact({\r\n *     key: 'level1',\r\n *     url: 'maps/Level1.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.tilemapImpact('level1', 'maps/Level1.json');\r\n * // and later in your game ...\r\n * var map = this.make.tilemap({ key: 'level1' });\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the text from the Tilemap Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"level\"\r\n * and no URL is given then the Loader will set the URL to be \"level.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Tilemap Impact File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#tilemapImpact\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.7.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig|Phaser.Types.Loader.FileTypes.TilemapImpactFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('tilemapImpact', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new TilemapImpactFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new TilemapImpactFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = TilemapImpactFile;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar FileTypesManager = require('../FileTypesManager');\nvar JSONFile = require('./JSONFile.js');\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\n\n/**\n * @classdesc\n * A single Tiled Tilemap JSON File suitable for loading by the Loader.\n *\n * These are created when you use the Phaser.Loader.LoaderPlugin#tilemapTiledJSON method and are not typically created directly.\n *\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#tilemapTiledJSON.\n *\n * @class TilemapJSONFile\n * @extends Phaser.Loader.File\n * @memberof Phaser.Loader.FileTypes\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig)} key - The key to use for this file, or a file configuration object.\n * @param {object|string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\n */\nvar TilemapJSONFile = new Class({\n\n    Extends: JSONFile,\n\n    initialize:\n\n    function TilemapJSONFile (loader, key, url, xhrSettings)\n    {\n        JSONFile.call(this, loader, key, url, xhrSettings);\n\n        this.type = 'tilemapJSON';\n\n        this.cache = loader.cacheManager.tilemap;\n    },\n\n    /**\n     * Adds this file to its target cache upon successful loading and processing.\n     *\n     * @method Phaser.Loader.FileTypes.TilemapJSONFile#addToCache\n     * @since 3.7.0\n     */\n    addToCache: function ()\n    {\n        var tiledata = { format: TILEMAP_FORMATS.TILED_JSON, data: this.data };\n\n        this.cache.add(this.key, tiledata);\n\n        this.pendingDestroy(tiledata);\n    }\n\n});\n\n/**\n * Adds a Tiled JSON Tilemap file, or array of map files, to the current load queue.\n *\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\n *\n * ```javascript\n * function preload ()\n * {\n *     this.load.tilemapTiledJSON('level1', 'maps/Level1.json');\n * }\n * ```\n *\n * The Tilemap data is created using the Tiled Map Editor and selecting JSON as the export format.\n *\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\n * loaded.\n *\n * The key must be a unique String. It is used to add the file to the global Tilemap Cache upon a successful load.\n * The key should be unique both in terms of files being loaded and files already present in the Tilemap Cache.\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\n * then remove it from the Text Cache first, before loading a new one.\n *\n * Instead of passing arguments you can pass a configuration object, such as:\n *\n * ```javascript\n * this.load.tilemapTiledJSON({\n *     key: 'level1',\n *     url: 'maps/Level1.json'\n * });\n * ```\n *\n * See the documentation for `Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig` for more details.\n *\n * Once the file has finished loading you can access it from its Cache using its key:\n *\n * ```javascript\n * this.load.tilemapTiledJSON('level1', 'maps/Level1.json');\n * // and later in your game ...\n * var map = this.make.tilemap({ key: 'level1' });\n * ```\n *\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\n * this is what you would use to retrieve the text from the Tilemap Cache.\n *\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\n *\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"level\"\n * and no URL is given then the Loader will set the URL to be \"level.json\". It will always add `.json` as the extension, although\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\n *\n * Note: The ability to load this type of file will only be available if the Tilemap JSON File type has been built into Phaser.\n * It is available in the default build but can be excluded from custom builds.\n *\n * @method Phaser.Loader.LoaderPlugin#tilemapTiledJSON\n * @fires Phaser.Loader.LoaderPlugin#ADD\n * @since 3.0.0\n *\n * @param {(string|Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig|Phaser.Types.Loader.FileTypes.TilemapJSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\n * @param {object|string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, a well formed JSON object.\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\n *\n * @return {this} The Loader instance.\n */\nFileTypesManager.register('tilemapTiledJSON', function (key, url, xhrSettings)\n{\n    if (Array.isArray(key))\n    {\n        for (var i = 0; i < key.length; i++)\n        {\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\n            this.addFile(new TilemapJSONFile(this, key[i]));\n        }\n    }\n    else\n    {\n        this.addFile(new TilemapJSONFile(this, key, url, xhrSettings));\n    }\n\n    return this;\n});\n\nmodule.exports = TilemapJSONFile;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar ImageFile = require('./ImageFile.js');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar MultiFile = require('../MultiFile.js');\r\nvar TextFile = require('./TextFile.js');\r\n\r\n/**\r\n * @classdesc\r\n * A single text file based Unity Texture Atlas File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#unityAtlas method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#unityAtlas.\r\n *\r\n * @class UnityAtlasFile\r\n * @extends Phaser.Loader.MultiFile\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.\r\n */\r\nvar UnityAtlasFile = new Class({\r\n\r\n    Extends: MultiFile,\r\n\r\n    initialize:\r\n\r\n    function UnityAtlasFile (loader, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n    {\r\n        var image;\r\n        var data;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n\r\n            image = new ImageFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'textureURL'),\r\n                extension: GetFastValue(config, 'textureExtension', 'png'),\r\n                normalMap: GetFastValue(config, 'normalMap'),\r\n                xhrSettings: GetFastValue(config, 'textureXhrSettings')\r\n            });\r\n\r\n            data = new TextFile(loader, {\r\n                key: key,\r\n                url: GetFastValue(config, 'atlasURL'),\r\n                extension: GetFastValue(config, 'atlasExtension', 'txt'),\r\n                xhrSettings: GetFastValue(config, 'atlasXhrSettings')\r\n            });\r\n        }\r\n        else\r\n        {\r\n            image = new ImageFile(loader, key, textureURL, textureXhrSettings);\r\n            data = new TextFile(loader, key, atlasURL, atlasXhrSettings);\r\n        }\r\n\r\n        if (image.linkFile)\r\n        {\r\n            //  Image has a normal map\r\n            MultiFile.call(this, loader, 'unityatlas', key, [ image, data, image.linkFile ]);\r\n        }\r\n        else\r\n        {\r\n            MultiFile.call(this, loader, 'unityatlas', key, [ image, data ]);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.UnityAtlasFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.isReadyToProcess())\r\n        {\r\n            var image = this.files[0];\r\n            var text = this.files[1];\r\n            var normalMap = (this.files[2]) ? this.files[2].data : null;\r\n\r\n            this.loader.textureManager.addUnityAtlas(image.key, image.data, text.data, normalMap);\r\n\r\n            text.pendingDestroy();\r\n\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Unity YAML based Texture Atlas, or array of atlases, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.unityAtlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.txt');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * If you call this from outside of `preload` then you are responsible for starting the Loader afterwards and monitoring\r\n * its events to know when it's safe to use the asset. Please see the Phaser.Loader.LoaderPlugin class for more details.\r\n *\r\n * Phaser expects the atlas data to be provided in a YAML formatted text file as exported from Unity.\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.unityAtlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     atlasURL: 'images/MainMenu.txt'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig` for more details.\r\n *\r\n * Once the atlas has finished loading you can use frames from it as textures for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.unityAtlas('mainmenu', 'images/MainMenu.png', 'images/MainMenu.json');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'mainmenu', 'background');\r\n * ```\r\n *\r\n * To get a list of all available frames within an atlas please consult your Texture Atlas software.\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.unityAtlas('mainmenu', [ 'images/MainMenu.png', 'images/MainMenu-n.png' ], 'images/MainMenu.txt');\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.unityAtlas({\r\n *     key: 'mainmenu',\r\n *     textureURL: 'images/MainMenu.png',\r\n *     normalMap: 'images/MainMenu-n.png',\r\n *     atlasURL: 'images/MainMenu.txt'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Unity Atlas File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#unityAtlas\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig|Phaser.Types.Loader.FileTypes.UnityAtlasFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [textureURL] - The absolute or relative URL to load the texture image file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {string} [atlasURL] - The absolute or relative URL to load the texture atlas data file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [textureXhrSettings] - An XHR Settings configuration object for the atlas image file. Used in replacement of the Loaders default XHR Settings.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [atlasXhrSettings] - An XHR Settings configuration object for the atlas data file. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('unityAtlas', function (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings)\r\n{\r\n    var multifile;\r\n\r\n    //  Supports an Object file definition in the key argument\r\n    //  Or an array of objects in the key argument\r\n    //  Or a single entry where all arguments have been defined\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            multifile = new UnityAtlasFile(this, key[i]);\r\n\r\n            this.addFile(multifile.files);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        multifile = new UnityAtlasFile(this, key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings);\r\n\r\n        this.addFile(multifile.files);\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = UnityAtlasFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetURL = require('../GetURL');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Video File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#video method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#video.\r\n *\r\n * @class VideoFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.20.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.VideoFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {any} [urlConfig] - The absolute or relative URL to load this file from in a config object.\r\n * @param {string} [loadEvent] - The load event to listen for when _not_ loading as a blob. Either 'loadeddata', 'canplay' or 'canplaythrough'.\r\n * @param {boolean} [asBlob] - Load the video as a data blob, or via the Video element?\r\n * @param {boolean} [noAudio] - Does the video have an audio track? If not you can enable auto-playing on it.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar VideoFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    //  URL is an object created by VideoFile.getVideoURL\r\n    function VideoFile (loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings)\r\n    {\r\n        if (loadEvent === undefined) { loadEvent = 'loadeddata'; }\r\n        if (asBlob === undefined) { asBlob = false; }\r\n        if (noAudio === undefined) { noAudio = false; }\r\n\r\n        if (loadEvent !== 'loadeddata' && loadEvent !== 'canplay' && loadEvent !== 'canplaythrough')\r\n        {\r\n            loadEvent = 'loadeddata';\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'video',\r\n            cache: loader.cacheManager.video,\r\n            extension: urlConfig.type,\r\n            responseType: 'blob',\r\n            key: key,\r\n            url: urlConfig.url,\r\n            xhrSettings: xhrSettings,\r\n            config: {\r\n                loadEvent: loadEvent,\r\n                asBlob: asBlob,\r\n                noAudio: noAudio\r\n            }\r\n        };\r\n\r\n        this.onLoadCallback = this.onVideoLoadHandler.bind(this);\r\n        this.onErrorCallback = this.onVideoErrorHandler.bind(this);\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#onProcess\r\n     * @since 3.20.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        if (!this.config.asBlob)\r\n        {\r\n            this.onProcessComplete();\r\n\r\n            return;\r\n        }\r\n\r\n        //  Load Video as blob\r\n\r\n        var video = this.createVideoElement();\r\n\r\n        this.data = video;\r\n\r\n        var _this = this;\r\n\r\n        this.data.onloadeddata = function ()\r\n        {\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessError();\r\n        };\r\n\r\n        File.createObjectURL(video, this.xhrLoader.response, '');\r\n\r\n        video.load();\r\n    },\r\n\r\n    /**\r\n     * Creates a Video Element within the DOM.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#createVideoElement\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @return {HTMLVideoElement} The newly created Video element.\r\n     */\r\n    createVideoElement: function ()\r\n    {\r\n        var video = document.createElement('video');\r\n\r\n        video.controls = false;\r\n        video.crossOrigin = this.loader.crossOrigin;\r\n\r\n        if (this.config.noAudio)\r\n        {\r\n            video.muted = true;\r\n            video.defaultMuted = true;\r\n\r\n            video.setAttribute('autoplay', 'autoplay');\r\n        }\r\n\r\n        video.setAttribute('playsinline', 'playsinline');\r\n        video.setAttribute('preload', 'auto');\r\n\r\n        return video;\r\n    },\r\n\r\n    /**\r\n     * Internal load event callback.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#onVideoLoadHandler\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */\r\n    onVideoLoadHandler: function (event)\r\n    {\r\n        var video = event.target;\r\n\r\n        video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);\r\n        video.removeEventListener('error', this.onErrorCallback, true);\r\n\r\n        this.data = video;\r\n\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, true);\r\n    },\r\n\r\n    /**\r\n     * Internal load error event callback.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#onVideoErrorHandler\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */\r\n    onVideoErrorHandler: function (event)\r\n    {\r\n        var video = event.target;\r\n\r\n        if (video)\r\n        {\r\n            video.removeEventListener(this.config.loadEvent, this.onLoadCallback, true);\r\n            video.removeEventListener('error', this.onErrorCallback, true);\r\n        }\r\n\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, false);\r\n    },\r\n\r\n    /**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\r\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.VideoFile#load\r\n     * @since 3.20.0\r\n     */\r\n    load: function ()\r\n    {\r\n        var loadEvent = this.config.loadEvent;\r\n\r\n        if (this.config.asBlob)\r\n        {\r\n            File.prototype.load.call(this);\r\n        }\r\n        else\r\n        {\r\n            this.percentComplete = 0;\r\n\r\n            var video = this.createVideoElement();\r\n\r\n            video.addEventListener(loadEvent, this.onLoadCallback, true);\r\n            video.addEventListener('error', this.onErrorCallback, true);\r\n\r\n            video.src = GetURL(this, this.loader.baseURL);\r\n\r\n            video.load();\r\n        }\r\n    }\r\n\r\n});\r\n\r\nVideoFile.create = function (loader, key, urls, loadEvent, asBlob, noAudio, xhrSettings)\r\n{\r\n    var game = loader.systems.game;\r\n\r\n    //  url may be inside key, which may be an object\r\n    if (IsPlainObject(key))\r\n    {\r\n        urls = GetFastValue(key, 'url', []);\r\n        loadEvent = GetFastValue(key, 'loadEvent', 'loadeddata');\r\n        asBlob = GetFastValue(key, 'asBlob', false);\r\n        noAudio = GetFastValue(key, 'noAudio', false);\r\n        xhrSettings = GetFastValue(key, 'xhrSettings');\r\n        key = GetFastValue(key, 'key');\r\n    }\r\n\r\n    var urlConfig = VideoFile.getVideoURL(game, urls);\r\n    \r\n    if (urlConfig)\r\n    {\r\n        return new VideoFile(loader, key, urlConfig, loadEvent, asBlob, noAudio, xhrSettings);\r\n    }\r\n};\r\n\r\nVideoFile.getVideoURL = function (game, urls)\r\n{\r\n    if (!Array.isArray(urls))\r\n    {\r\n        urls = [ urls ];\r\n    }\r\n\r\n    for (var i = 0; i < urls.length; i++)\r\n    {\r\n        var url = GetFastValue(urls[i], 'url', urls[i]);\r\n\r\n        if (url.indexOf('blob:') === 0)\r\n        {\r\n            return {\r\n                url: url,\r\n                type: ''\r\n            };\r\n        }\r\n\r\n        var videoType;\r\n\r\n        if (url.indexOf('data:') === 0)\r\n        {\r\n            videoType = url.split(',')[0].match(/\\/(.*?);/);\r\n        }\r\n        else\r\n        {\r\n            videoType = url.match(/\\.([a-zA-Z0-9]+)($|\\?)/);\r\n        }\r\n\r\n        videoType = GetFastValue(urls[i], 'type', (videoType) ? videoType[1] : '').toLowerCase();\r\n\r\n        if (game.device.video[videoType])\r\n        {\r\n            return {\r\n                url: url,\r\n                type: videoType\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Adds a Video file, or array of video files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.video('intro', [ 'video/level1.mp4', 'video/level1.webm', 'video/level1.mov' ]);\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Video Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Video Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Video Cache first, before loading a new one.\r\n  *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.video({\r\n *     key: 'intro',\r\n *     url: [ 'video/level1.mp4', 'video/level1.webm', 'video/level1.mov' ],\r\n *     asBlob: false,\r\n *     noAudio: true\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.VideoFileConfig` for more details.\r\n *\r\n * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.\r\n *\r\n * Due to different browsers supporting different video file types you should usually provide your video files in a variety of formats.\r\n * mp4, mov and webm are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on\r\n * browser support, starting with the first in the array and progressing to the end.\r\n *\r\n * Unlike most asset-types, videos do not _need_ to be preloaded. You can create a Video Game Object and then call its `loadURL` method,\r\n * to load a video at run-time, rather than in advance.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Video File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#video\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.20.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.VideoFileConfig|Phaser.Types.Loader.FileTypes.VideoFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(string|string[])} [urls] - The absolute or relative URL to load the video files from.\r\n * @param {string} [loadEvent='loadeddata'] - The load event to listen for when _not_ loading as a blob. Either `loadeddata`, `canplay` or `canplaythrough`.\r\n * @param {boolean} [asBlob=false] - Load the video as a data blob, or stream it via the Video element?\r\n * @param {boolean} [noAudio=false] - Does the video have an audio track? If not you can enable auto-playing on it.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('video', function (key, urls, loadEvent, asBlob, noAudio, xhrSettings)\r\n{\r\n    var videoFile;\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            videoFile = VideoFile.create(this, key[i]);\r\n\r\n            if (videoFile)\r\n            {\r\n                this.addFile(videoFile);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        videoFile = VideoFile.create(this, key, urls, loadEvent, asBlob, noAudio, xhrSettings);\r\n\r\n        if (videoFile)\r\n        {\r\n            this.addFile(videoFile);\r\n        }\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = VideoFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar CustomSet = require('../structs/Set');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar FileTypesManager = require('./FileTypesManager');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar SceneEvents = require('../scene/events');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * @classdesc\r\n * The Loader handles loading all external content such as Images, Sounds, Texture Atlases and data files.\r\n * You typically interact with it via `this.load` in your Scene. Scenes can have a `preload` method, which is always\r\n * called before the Scenes `create` method, allowing you to preload assets that the Scene may need.\r\n *\r\n * If you call any `this.load` methods from outside of `Scene.preload` then you need to start the Loader going\r\n * yourself by calling `Loader.start()`. It's only automatically started during the Scene preload.\r\n *\r\n * The Loader uses a combination of tag loading (eg. Audio elements) and XHR and provides progress and completion events.\r\n * Files are loaded in parallel by default. The amount of concurrent connections can be controlled in your Game Configuration.\r\n *\r\n * Once the Loader has started loading you are still able to add files to it. These can be injected as a result of a loader\r\n * event, the type of file being loaded (such as a pack file) or other external events. As long as the Loader hasn't finished\r\n * simply adding a new file to it, while running, will ensure it's added into the current queue.\r\n *\r\n * Every Scene has its own instance of the Loader and they are bound to the Scene in which they are created. However,\r\n * assets loaded by the Loader are placed into global game-level caches. For example, loading an XML file will place that\r\n * file inside `Game.cache.xml`, which is accessible from every Scene in your game, no matter who was responsible\r\n * for loading it. The same is true of Textures. A texture loaded in one Scene is instantly available to all other Scenes\r\n * in your game.\r\n *\r\n * The Loader works by using custom File Types. These are stored in the FileTypesManager, which injects them into the Loader\r\n * when it's instantiated. You can create your own custom file types by extending either the File or MultiFile classes.\r\n * See those files for more details.\r\n *\r\n * @class LoaderPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene which owns this Loader instance.\r\n */\r\nvar LoaderPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function LoaderPlugin (scene)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        var gameConfig = scene.sys.game.config;\r\n        var sceneConfig = scene.sys.settings.loader;\r\n\r\n        /**\r\n         * The Scene which owns this Loader instance.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A reference to the global Cache Manager.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#cacheManager\r\n         * @type {Phaser.Cache.CacheManager}\r\n         * @since 3.7.0\r\n         */\r\n        this.cacheManager = scene.sys.cache;\r\n\r\n        /**\r\n         * A reference to the global Texture Manager.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#textureManager\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.7.0\r\n         */\r\n        this.textureManager = scene.sys.textures;\r\n\r\n        /**\r\n         * A reference to the global Scene Manager.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#sceneManager\r\n         * @type {Phaser.Scenes.SceneManager}\r\n         * @protected\r\n         * @since 3.16.0\r\n         */\r\n        this.sceneManager = scene.sys.game.scene;\r\n\r\n        //  Inject the available filetypes into the Loader\r\n        FileTypesManager.install(this);\r\n\r\n        /**\r\n         * An optional prefix that is automatically prepended to the start of every file key.\r\n         * If prefix was `MENU.` and you load an image with the key 'Background' the resulting key would be `MENU.Background`.\r\n         * You can set this directly, or call `Loader.setPrefix()`. It will then affect every file added to the Loader\r\n         * from that point on. It does _not_ change any file already in the load queue.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#prefix\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.7.0\r\n         */\r\n        this.prefix = '';\r\n\r\n        /**\r\n         * The value of `path`, if set, is placed before any _relative_ file path given. For example:\r\n         *\r\n         * ```javascript\r\n         * this.load.path = \"images/sprites/\";\r\n         * this.load.image(\"ball\", \"ball.png\");\r\n         * this.load.image(\"tree\", \"level1/oaktree.png\");\r\n         * this.load.image(\"boom\", \"http://server.com/explode.png\");\r\n         * ```\r\n         *\r\n         * Would load the `ball` file from `images/sprites/ball.png` and the tree from\r\n         * `images/sprites/level1/oaktree.png` but the file `boom` would load from the URL\r\n         * given as it's an absolute URL.\r\n         *\r\n         * Please note that the path is added before the filename but *after* the baseURL (if set.)\r\n         *\r\n         * If you set this property directly then it _must_ end with a \"/\". Alternatively, call `setPath()` and it'll do it for you.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#path\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.path = '';\r\n\r\n        /**\r\n         * If you want to append a URL before the path of any asset you can set this here.\r\n         *\r\n         * Useful if allowing the asset base url to be configured outside of the game code.\r\n         *\r\n         * If you set this property directly then it _must_ end with a \"/\". Alternatively, call `setBaseURL()` and it'll do it for you.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#baseURL\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.baseURL = '';\r\n\r\n        this.setBaseURL(GetFastValue(sceneConfig, 'baseURL', gameConfig.loaderBaseURL));\r\n\r\n        this.setPath(GetFastValue(sceneConfig, 'path', gameConfig.loaderPath));\r\n\r\n        this.setPrefix(GetFastValue(sceneConfig, 'prefix', gameConfig.loaderPrefix));\r\n\r\n        /**\r\n         * The number of concurrent / parallel resources to try and fetch at once.\r\n         *\r\n         * Old browsers limit 6 requests per domain; modern ones, especially those with HTTP/2 don't limit it at all.\r\n         *\r\n         * The default is 32 but you can change this in your Game Config, or by changing this property before the Loader starts.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#maxParallelDownloads\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.maxParallelDownloads = GetFastValue(sceneConfig, 'maxParallelDownloads', gameConfig.loaderMaxParallelDownloads);\r\n\r\n        /**\r\n         * xhr specific global settings (can be overridden on a per-file basis)\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#xhr\r\n         * @type {Phaser.Types.Loader.XHRSettingsObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhr = XHRSettings(\r\n            GetFastValue(sceneConfig, 'responseType', gameConfig.loaderResponseType),\r\n            GetFastValue(sceneConfig, 'async', gameConfig.loaderAsync),\r\n            GetFastValue(sceneConfig, 'user', gameConfig.loaderUser),\r\n            GetFastValue(sceneConfig, 'password', gameConfig.loaderPassword),\r\n            GetFastValue(sceneConfig, 'timeout', gameConfig.loaderTimeout),\r\n            GetFastValue(sceneConfig, 'withCredentials', gameConfig.loaderWithCredentials)\r\n        );\r\n\r\n        /**\r\n         * The crossOrigin value applied to loaded images. Very often this needs to be set to 'anonymous'.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#crossOrigin\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.crossOrigin = GetFastValue(sceneConfig, 'crossOrigin', gameConfig.loaderCrossOrigin);\r\n\r\n        /**\r\n         * The total number of files to load. It may not always be accurate because you may add to the Loader during the process\r\n         * of loading, especially if you load a Pack File. Therefore this value can change, but in most cases remains static.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#totalToLoad\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.totalToLoad = 0;\r\n\r\n        /**\r\n         * The progress of the current load queue, as a float value between 0 and 1.\r\n         * This is updated automatically as files complete loading.\r\n         * Note that it is possible for this value to go down again if you add content to the current load queue during a load.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#progress\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.progress = 0;\r\n\r\n        /**\r\n         * Files are placed in this Set when they're added to the Loader via `addFile`.\r\n         *\r\n         * They are moved to the `inflight` Set when they start loading, and assuming a successful\r\n         * load, to the `queue` Set for further processing.\r\n         *\r\n         * By the end of the load process this Set will be empty.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#list\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */\r\n        this.list = new CustomSet();\r\n\r\n        /**\r\n         * Files are stored in this Set while they're in the process of being loaded.\r\n         *\r\n         * Upon a successful load they are moved to the `queue` Set.\r\n         *\r\n         * By the end of the load process this Set will be empty.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#inflight\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */\r\n        this.inflight = new CustomSet();\r\n\r\n        /**\r\n         * Files are stored in this Set while they're being processed.\r\n         *\r\n         * If the process is successful they are moved to their final destination, which could be\r\n         * a Cache or the Texture Manager.\r\n         *\r\n         * At the end of the load process this Set will be empty.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#queue\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @since 3.0.0\r\n         */\r\n        this.queue = new CustomSet();\r\n\r\n        /**\r\n         * A temporary Set in which files are stored after processing,\r\n         * awaiting destruction at the end of the load process.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#_deleteQueue\r\n         * @type {Phaser.Structs.Set.<Phaser.Loader.File>}\r\n         * @private\r\n         * @since 3.7.0\r\n         */\r\n        this._deleteQueue = new CustomSet();\r\n\r\n        /**\r\n         * The total number of files that failed to load during the most recent load.\r\n         * This value is reset when you call `Loader.start`.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#totalFailed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.7.0\r\n         */\r\n        this.totalFailed = 0;\r\n\r\n        /**\r\n         * The total number of files that successfully loaded during the most recent load.\r\n         * This value is reset when you call `Loader.start`.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#totalComplete\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.7.0\r\n         */\r\n        this.totalComplete = 0;\r\n\r\n        /**\r\n         * The current state of the Loader.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#state\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.state = CONST.LOADER_IDLE;\r\n\r\n        /**\r\n         * The current index being used by multi-file loaders to avoid key clashes.\r\n         *\r\n         * @name Phaser.Loader.LoaderPlugin#multiKeyIndex\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this.multiKeyIndex = 0;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.pluginStart, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#pluginStart\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    pluginStart: function ()\r\n    {\r\n        this.systems.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * If you want to append a URL before the path of any asset you can set this here.\r\n     *\r\n     * Useful if allowing the asset base url to be configured outside of the game code.\r\n     *\r\n     * Once a base URL is set it will affect every file loaded by the Loader from that point on. It does _not_ change any\r\n     * file _already_ being loaded. To reset it, call this method with no arguments.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setBaseURL\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [url] - The URL to use. Leave empty to reset.\r\n     *\r\n     * @return {this} This Loader object.\r\n     */\r\n    setBaseURL: function (url)\r\n    {\r\n        if (url === undefined) { url = ''; }\r\n\r\n        if (url !== '' && url.substr(-1) !== '/')\r\n        {\r\n            url = url.concat('/');\r\n        }\r\n\r\n        this.baseURL = url;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The value of `path`, if set, is placed before any _relative_ file path given. For example:\r\n     *\r\n     * ```javascript\r\n     * this.load.setPath(\"images/sprites/\");\r\n     * this.load.image(\"ball\", \"ball.png\");\r\n     * this.load.image(\"tree\", \"level1/oaktree.png\");\r\n     * this.load.image(\"boom\", \"http://server.com/explode.png\");\r\n     * ```\r\n     *\r\n     * Would load the `ball` file from `images/sprites/ball.png` and the tree from\r\n     * `images/sprites/level1/oaktree.png` but the file `boom` would load from the URL\r\n     * given as it's an absolute URL.\r\n     *\r\n     * Please note that the path is added before the filename but *after* the baseURL (if set.)\r\n     *\r\n     * Once a path is set it will then affect every file added to the Loader from that point on. It does _not_ change any\r\n     * file _already_ in the load queue. To reset it, call this method with no arguments.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setPath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [path] - The path to use. Leave empty to reset.\r\n     *\r\n     * @return {this} This Loader object.\r\n     */\r\n    setPath: function (path)\r\n    {\r\n        if (path === undefined) { path = ''; }\r\n\r\n        if (path !== '' && path.substr(-1) !== '/')\r\n        {\r\n            path = path.concat('/');\r\n        }\r\n\r\n        this.path = path;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * An optional prefix that is automatically prepended to the start of every file key.\r\n     *\r\n     * If prefix was `MENU.` and you load an image with the key 'Background' the resulting key would be `MENU.Background`.\r\n     *\r\n     * Once a prefix is set it will then affect every file added to the Loader from that point on. It does _not_ change any\r\n     * file _already_ in the load queue. To reset it, call this method with no arguments.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setPrefix\r\n     * @since 3.7.0\r\n     *\r\n     * @param {string} [prefix] - The prefix to use. Leave empty to reset.\r\n     *\r\n     * @return {this} This Loader object.\r\n     */\r\n    setPrefix: function (prefix)\r\n    {\r\n        if (prefix === undefined) { prefix = ''; }\r\n\r\n        this.prefix = prefix;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Cross Origin Resource Sharing value used when loading files.\r\n     *\r\n     * Files can override this value on a per-file basis by specifying an alternative `crossOrigin` value in their file config.\r\n     *\r\n     * Once CORs is set it will then affect every file loaded by the Loader from that point on, as long as they don't have\r\n     * their own CORs setting. To reset it, call this method with no arguments.\r\n     *\r\n     * For more details about CORs see https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#setCORS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [crossOrigin] - The value to use for the `crossOrigin` property in the load request.\r\n     *\r\n     * @return {this} This Loader object.\r\n     */\r\n    setCORS: function (crossOrigin)\r\n    {\r\n        this.crossOrigin = crossOrigin;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a file, or array of files, into the load queue.\r\n     *\r\n     * The file must be an instance of `Phaser.Loader.File`, or a class that extends it. The Loader will check that the key\r\n     * used by the file won't conflict with any other key either in the loader, the inflight queue or the target cache.\r\n     * If allowed it will then add the file into the pending list, read for the load to start. Or, if the load has already\r\n     * started, ready for the next batch of files to be pulled from the list to the inflight queue.\r\n     *\r\n     * You should not normally call this method directly, but rather use one of the Loader methods like `image` or `atlas`,\r\n     * however you can call this as long as the file given to it is well formed.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#addFile\r\n     * @fires Phaser.Loader.Events#ADD\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Loader.File|Phaser.Loader.File[])} file - The file, or array of files, to be added to the load queue.\r\n     */\r\n    addFile: function (file)\r\n    {\r\n        if (!Array.isArray(file))\r\n        {\r\n            file = [ file ];\r\n        }\r\n\r\n        for (var i = 0; i < file.length; i++)\r\n        {\r\n            var item = file[i];\r\n\r\n            //  Does the file already exist in the cache or texture manager?\r\n            //  Or will it conflict with a file already in the queue or inflight?\r\n            if (!this.keyExists(item))\r\n            {\r\n                this.list.set(item);\r\n\r\n                this.emit(Events.ADD, item.key, item.type, this, item);\r\n\r\n                if (this.isLoading())\r\n                {\r\n                    this.totalToLoad++;\r\n                    this.updateProgress();\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks the key and type of the given file to see if it will conflict with anything already\r\n     * in a Cache, the Texture Manager, or the list or inflight queues.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#keyExists\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The file to check the key of.\r\n     *\r\n     * @return {boolean} `true` if adding this file will cause a cache or queue conflict, otherwise `false`.\r\n     */\r\n    keyExists: function (file)\r\n    {\r\n        var keyConflict = file.hasCacheConflict();\r\n\r\n        if (!keyConflict)\r\n        {\r\n            this.list.iterate(function (item)\r\n            {\r\n                if (item.type === file.type && item.key === file.key)\r\n                {\r\n                    keyConflict = true;\r\n\r\n                    return false;\r\n                }\r\n\r\n            });\r\n        }\r\n\r\n        if (!keyConflict && this.isLoading())\r\n        {\r\n            this.inflight.iterate(function (item)\r\n            {\r\n                if (item.type === file.type && item.key === file.key)\r\n                {\r\n                    keyConflict = true;\r\n\r\n                    return false;\r\n                }\r\n\r\n            });\r\n\r\n            this.queue.iterate(function (item)\r\n            {\r\n                if (item.type === file.type && item.key === file.key)\r\n                {\r\n                    keyConflict = true;\r\n\r\n                    return false;\r\n                }\r\n\r\n            });\r\n        }\r\n\r\n        return keyConflict;\r\n    },\r\n\r\n    /**\r\n     * Takes a well formed, fully parsed pack file object and adds its entries into the load queue. Usually you do not call\r\n     * this method directly, but instead use `Loader.pack` and supply a path to a JSON file that holds the\r\n     * pack data. However, if you've got the data prepared you can pass it to this method.\r\n     *\r\n     * You can also provide an optional key. If you do then it will only add the entries from that part of the pack into\r\n     * to the load queue. If not specified it will add all entries it finds. For more details about the pack file format\r\n     * see the `LoaderPlugin.pack` method.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#addPack\r\n     * @since 3.7.0\r\n     *\r\n     * @param {any} pack - The Pack File data to be parsed and each entry of it to added to the load queue.\r\n     * @param {string} [packKey] - An optional key to use from the pack file data.\r\n     *\r\n     * @return {boolean} `true` if any files were added to the queue, otherwise `false`.\r\n     */\r\n    addPack: function (pack, packKey)\r\n    {\r\n        //  if no packKey provided we'll add everything to the queue\r\n        if (packKey && pack.hasOwnProperty(packKey))\r\n        {\r\n            pack = { packKey: pack[packKey] };\r\n        }\r\n\r\n        var total = 0;\r\n\r\n        //  Store the loader settings in case this pack replaces them\r\n        var currentBaseURL = this.baseURL;\r\n        var currentPath = this.path;\r\n        var currentPrefix = this.prefix;\r\n\r\n        //  Here we go ...\r\n        for (var key in pack)\r\n        {\r\n            if (!Object.prototype.hasOwnProperty.call(pack, key))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var config = pack[key];\r\n\r\n            //  Any meta data to process?\r\n            var baseURL = GetFastValue(config, 'baseURL', currentBaseURL);\r\n            var path = GetFastValue(config, 'path', currentPath);\r\n            var prefix = GetFastValue(config, 'prefix', currentPrefix);\r\n            var files = GetFastValue(config, 'files', null);\r\n            var defaultType = GetFastValue(config, 'defaultType', 'void');\r\n\r\n            if (Array.isArray(files))\r\n            {\r\n                this.setBaseURL(baseURL);\r\n                this.setPath(path);\r\n                this.setPrefix(prefix);\r\n\r\n                for (var i = 0; i < files.length; i++)\r\n                {\r\n                    var file = files[i];\r\n                    var type = (file.hasOwnProperty('type')) ? file.type : defaultType;\r\n\r\n                    if (this[type])\r\n                    {\r\n                        this[type](file);\r\n                        total++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //  Reset the loader settings\r\n        this.setBaseURL(currentBaseURL);\r\n        this.setPath(currentPath);\r\n        this.setPrefix(currentPrefix);\r\n\r\n        return (total > 0);\r\n    },\r\n\r\n    /**\r\n     * Is the Loader actively loading, or processing loaded files?\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#isLoading\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if the Loader is busy loading or processing, otherwise `false`.\r\n     */\r\n    isLoading: function ()\r\n    {\r\n        return (this.state === CONST.LOADER_LOADING || this.state === CONST.LOADER_PROCESSING);\r\n    },\r\n\r\n    /**\r\n     * Is the Loader ready to start a new load?\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#isReady\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if the Loader is ready to start a new load, otherwise `false`.\r\n     */\r\n    isReady: function ()\r\n    {\r\n        return (this.state === CONST.LOADER_IDLE || this.state === CONST.LOADER_COMPLETE);\r\n    },\r\n\r\n    /**\r\n     * Starts the Loader running. This will reset the progress and totals and then emit a `start` event.\r\n     * If there is nothing in the queue the Loader will immediately complete, otherwise it will start\r\n     * loading the first batch of files.\r\n     *\r\n     * The Loader is started automatically if the queue is populated within your Scenes `preload` method.\r\n     *\r\n     * However, outside of this, you need to call this method to start it.\r\n     *\r\n     * If the Loader is already running this method will simply return.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#start\r\n     * @fires Phaser.Loader.Events#START\r\n     * @since 3.0.0\r\n     */\r\n    start: function ()\r\n    {\r\n        if (!this.isReady())\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.progress = 0;\r\n\r\n        this.totalFailed = 0;\r\n        this.totalComplete = 0;\r\n        this.totalToLoad = this.list.size;\r\n\r\n        this.emit(Events.START, this);\r\n\r\n        if (this.list.size === 0)\r\n        {\r\n            this.loadComplete();\r\n        }\r\n        else\r\n        {\r\n            this.state = CONST.LOADER_LOADING;\r\n\r\n            this.inflight.clear();\r\n            this.queue.clear();\r\n\r\n            this.updateProgress();\r\n\r\n            this.checkLoadQueue();\r\n\r\n            this.systems.events.on(SceneEvents.UPDATE, this.update, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically during the load process.\r\n     * It updates the `progress` value and then emits a progress event, which you can use to\r\n     * display a loading bar in your game.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#updateProgress\r\n     * @fires Phaser.Loader.Events#PROGRESS\r\n     * @since 3.0.0\r\n     */\r\n    updateProgress: function ()\r\n    {\r\n        this.progress = 1 - ((this.list.size + this.inflight.size) / this.totalToLoad);\r\n\r\n        this.emit(Events.PROGRESS, this.progress);\r\n    },\r\n\r\n    /**\r\n     * Called automatically during the load process.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#update\r\n     * @since 3.10.0\r\n     */\r\n    update: function ()\r\n    {\r\n        if (this.state === CONST.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads)\r\n        {\r\n            this.checkLoadQueue();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * An internal method called by the Loader.\r\n     *\r\n     * It will check to see if there are any more files in the pending list that need loading, and if so it will move\r\n     * them from the list Set into the inflight Set, set their CORs flag and start them loading.\r\n     *\r\n     * It will carrying on doing this for each file in the pending list until it runs out, or hits the max allowed parallel downloads.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#checkLoadQueue\r\n     * @private\r\n     * @since 3.7.0\r\n     */\r\n    checkLoadQueue: function ()\r\n    {\r\n        this.list.each(function (file)\r\n        {\r\n            if (file.state === CONST.FILE_POPULATED || (file.state === CONST.FILE_PENDING && this.inflight.size < this.maxParallelDownloads))\r\n            {\r\n                this.inflight.set(file);\r\n\r\n                this.list.delete(file);\r\n\r\n                //  If the file doesn't have its own crossOrigin set, we'll use the Loaders (which is undefined by default)\r\n                if (!file.crossOrigin)\r\n                {\r\n                    file.crossOrigin = this.crossOrigin;\r\n                }\r\n\r\n                file.load();\r\n            }\r\n\r\n            if (this.inflight.size === this.maxParallelDownloads)\r\n            {\r\n                //  Tells the Set iterator to abort\r\n                return false;\r\n            }\r\n\r\n        }, this);\r\n    },\r\n\r\n    /**\r\n     * An internal method called automatically by the XHRLoader belong to a File.\r\n     *\r\n     * This method will remove the given file from the inflight Set and update the load progress.\r\n     * If the file was successful its `onProcess` method is called, otherwise it is added to the delete queue.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#nextFile\r\n     * @fires Phaser.Loader.Events#FILE_LOAD\r\n     * @fires Phaser.Loader.Events#FILE_LOAD_ERROR\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that just finished loading, or errored during load.\r\n     * @param {boolean} success - `true` if the file loaded successfully, otherwise `false`.\r\n     */\r\n    nextFile: function (file, success)\r\n    {\r\n        //  Has the game been destroyed during load? If so, bail out now.\r\n        if (!this.inflight)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.inflight.delete(file);\r\n\r\n        this.updateProgress();\r\n\r\n        if (success)\r\n        {\r\n            this.totalComplete++;\r\n\r\n            this.queue.set(file);\r\n\r\n            this.emit(Events.FILE_LOAD, file);\r\n\r\n            file.onProcess();\r\n        }\r\n        else\r\n        {\r\n            this.totalFailed++;\r\n\r\n            this._deleteQueue.set(file);\r\n\r\n            this.emit(Events.FILE_LOAD_ERROR, file);\r\n\r\n            this.fileProcessComplete(file);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * An internal method that is called automatically by the File when it has finished processing.\r\n     *\r\n     * If the process was successful, and the File isn't part of a MultiFile, its `addToCache` method is called.\r\n     *\r\n     * It this then removed from the queue. If there are no more files to load `loadComplete` is called.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#fileProcessComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The file that has finished processing.\r\n     */\r\n    fileProcessComplete: function (file)\r\n    {\r\n        //  Has the game been destroyed during load? If so, bail out now.\r\n        if (!this.scene || !this.systems || !this.systems.game || this.systems.game.pendingDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  This file has failed, so move it to the failed Set\r\n        if (file.state === CONST.FILE_ERRORED)\r\n        {\r\n            if (file.multiFile)\r\n            {\r\n                file.multiFile.onFileFailed(file);\r\n            }\r\n        }\r\n        else if (file.state === CONST.FILE_COMPLETE)\r\n        {\r\n            if (file.multiFile)\r\n            {\r\n                if (file.multiFile.isReadyToProcess())\r\n                {\r\n                    //  If we got here then all files the link file needs are ready to add to the cache\r\n                    file.multiFile.addToCache();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  If we got here, then the file processed, so let it add itself to its cache\r\n                file.addToCache();\r\n            }\r\n        }\r\n\r\n        //  Remove it from the queue\r\n        this.queue.delete(file);\r\n\r\n        //  Nothing left to do?\r\n\r\n        if (this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0)\r\n        {\r\n            this.loadComplete();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called at the end when the load queue is exhausted and all files have either loaded or errored.\r\n     * By this point every loaded file will now be in its associated cache and ready for use.\r\n     *\r\n     * Also clears down the Sets, puts progress to 1 and clears the deletion queue.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#loadComplete\r\n     * @fires Phaser.Loader.Events#COMPLETE\r\n     * @fires Phaser.Loader.Events#POST_PROCESS\r\n     * @since 3.7.0\r\n     */\r\n    loadComplete: function ()\r\n    {\r\n        this.emit(Events.POST_PROCESS, this);\r\n\r\n        this.list.clear();\r\n        this.inflight.clear();\r\n        this.queue.clear();\r\n\r\n        this.progress = 1;\r\n\r\n        this.state = CONST.LOADER_COMPLETE;\r\n\r\n        this.systems.events.off(SceneEvents.UPDATE, this.update, this);\r\n\r\n        //  Call 'destroy' on each file ready for deletion\r\n        this._deleteQueue.iterateLocal('destroy');\r\n\r\n        this._deleteQueue.clear();\r\n\r\n        this.emit(Events.COMPLETE, this, this.totalComplete, this.totalFailed);\r\n    },\r\n\r\n    /**\r\n     * Adds a File into the pending-deletion queue.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#flagForRemoval\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File to be queued for deletion when the Loader completes.\r\n     */\r\n    flagForRemoval: function (file)\r\n    {\r\n        this._deleteQueue.set(file);\r\n    },\r\n\r\n    /**\r\n     * Converts the given JSON data into a file that the browser then prompts you to download so you can save it locally.\r\n     *\r\n     * The data must be well formed JSON and ready-parsed, not a JavaScript object.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#saveJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} data - The JSON data, ready parsed.\r\n     * @param {string} [filename=file.json] - The name to save the JSON file as.\r\n     *\r\n     * @return {this} This Loader plugin.\r\n     */\r\n    saveJSON: function (data, filename)\r\n    {\r\n        return this.save(JSON.stringify(data), filename);\r\n    },\r\n\r\n    /**\r\n     * Causes the browser to save the given data as a file to its default Downloads folder.\r\n     *\r\n     * Creates a DOM level anchor link, assigns it as being a `download` anchor, sets the href\r\n     * to be an ObjectURL based on the given data, and then invokes a click event.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#save\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} data - The data to be saved. Will be passed through URL.createObjectURL.\r\n     * @param {string} [filename=file.json] - The filename to save the file as.\r\n     * @param {string} [filetype=application/json] - The file type to use when saving the file. Defaults to JSON.\r\n     *\r\n     * @return {this} This Loader plugin.\r\n     */\r\n    save: function (data, filename, filetype)\r\n    {\r\n        if (filename === undefined) { filename = 'file.json'; }\r\n        if (filetype === undefined) { filetype = 'application/json'; }\r\n\r\n        var blob = new Blob([ data ], { type: filetype });\r\n\r\n        var url = URL.createObjectURL(blob);\r\n\r\n        var a = document.createElement('a');\r\n\r\n        a.download = filename;\r\n        a.textContent = 'Download ' + filename;\r\n        a.href = url;\r\n        a.click();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets the Loader.\r\n     *\r\n     * This will clear all lists and reset the base URL, path and prefix.\r\n     *\r\n     * Warning: If the Loader is currently downloading files, or has files in its queue, they will be aborted.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#reset\r\n     * @since 3.0.0\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.list.clear();\r\n        this.inflight.clear();\r\n        this.queue.clear();\r\n\r\n        var gameConfig = this.systems.game.config;\r\n        var sceneConfig = this.systems.settings.loader;\r\n\r\n        this.setBaseURL(GetFastValue(sceneConfig, 'baseURL', gameConfig.loaderBaseURL));\r\n        this.setPath(GetFastValue(sceneConfig, 'path', gameConfig.loaderPath));\r\n        this.setPrefix(GetFastValue(sceneConfig, 'prefix', gameConfig.loaderPrefix));\r\n\r\n        this.state = CONST.LOADER_IDLE;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.reset();\r\n\r\n        this.state = CONST.LOADER_SHUTDOWN;\r\n\r\n        this.systems.events.off(SceneEvents.UPDATE, this.update, this);\r\n        this.systems.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Loader.LoaderPlugin#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.state = CONST.LOADER_DESTROYED;\r\n\r\n        this.systems.events.off(SceneEvents.UPDATE, this.update, this);\r\n        this.systems.events.off(SceneEvents.START, this.pluginStart, this);\r\n\r\n        this.list = null;\r\n        this.inflight = null;\r\n        this.queue = null;\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n        this.textureManager = null;\r\n        this.cacheManager = null;\r\n        this.sceneManager = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('Loader', LoaderPlugin, 'load');\r\n\r\nmodule.exports = LoaderPlugin;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Read an integer value from an XML Node.\n *\n * @function getValue\n * @since 3.0.0\n * @private\n *\n * @param {Node} node - The XML Node.\n * @param {string} attribute - The attribute to read.\n *\n * @return {number} The parsed value.\n */\nfunction getValue (node, attribute)\n{\n    return parseInt(node.getAttribute(attribute), 10);\n}\n\n/**\n * Parse an XML font to Bitmap Font data for the Bitmap Font cache.\n *\n * @function ParseXMLBitmapFont\n * @since 3.0.0\n * @private\n *\n * @param {XMLDocument} xml - The XML Document to parse the font from.\n * @param {Phaser.Textures.Frame} frame - The texture frame to take into account when creating the uv data.\n * @param {number} [xSpacing=0] - The x-axis spacing to add between each letter.\n * @param {number} [ySpacing=0] - The y-axis spacing to add to the line height.\n * @param {Phaser.Textures.Texture} [texture] - If provided, each glyph in the Bitmap Font will be added to this texture as a frame.\n *\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapFontData} The parsed Bitmap Font data.\n */\nvar ParseXMLBitmapFont = function (xml, frame, xSpacing, ySpacing, texture)\n{\n    if (xSpacing === undefined) { xSpacing = 0; }\n    if (ySpacing === undefined) { ySpacing = 0; }\n\n    var textureX = frame.cutX;\n    var textureY = frame.cutY;\n    var textureWidth = frame.source.width;\n    var textureHeight = frame.source.height;\n    var sourceIndex = frame.sourceIndex;\n\n    var data = {};\n    var info = xml.getElementsByTagName('info')[0];\n    var common = xml.getElementsByTagName('common')[0];\n\n    data.font = info.getAttribute('face');\n    data.size = getValue(info, 'size');\n    data.lineHeight = getValue(common, 'lineHeight') + ySpacing;\n    data.chars = {};\n\n    var letters = xml.getElementsByTagName('char');\n\n    var adjustForTrim = (frame !== undefined && frame.trimmed);\n\n    if (adjustForTrim)\n    {\n        var top = frame.height;\n        var left = frame.width;\n    }\n\n    for (var i = 0; i < letters.length; i++)\n    {\n        var node = letters[i];\n\n        var charCode = getValue(node, 'id');\n        var letter = String.fromCharCode(charCode);\n        var gx = getValue(node, 'x');\n        var gy = getValue(node, 'y');\n        var gw = getValue(node, 'width');\n        var gh = getValue(node, 'height');\n\n        //  Handle frame trim issues\n\n        if (adjustForTrim)\n        {\n            if (gx < left)\n            {\n                left = gx;\n            }\n\n            if (gy < top)\n            {\n                top = gy;\n            }\n        }\n\n        if (adjustForTrim && top !== 0 && left !== 0)\n        {\n            //  Now we know the top and left coordinates of the glyphs in the original data\n            //  so we can work out how much to adjust the glyphs by\n\n            gx -= frame.x;\n            gy -= frame.y;\n        }\n\n        var u0 = (textureX + gx) / textureWidth;\n        var v0 = (textureY + gy) / textureHeight;\n        var u1 = (textureX + gx + gw) / textureWidth;\n        var v1 = (textureY + gy + gh) / textureHeight;\n\n        data.chars[charCode] =\n        {\n            x: gx,\n            y: gy,\n            width: gw,\n            height: gh,\n            centerX: Math.floor(gw / 2),\n            centerY: Math.floor(gh / 2),\n            xOffset: getValue(node, 'xoffset'),\n            yOffset: getValue(node, 'yoffset'),\n            xAdvance: getValue(node, 'xadvance') + xSpacing,\n            data: {},\n            kerning: {},\n            u0: u0,\n            v0: v0,\n            u1: u1,\n            v1: v1\n        };\n\n        if (texture && gw !== 0 && gh !== 0)\n        {\n            var charFrame = texture.add(letter, sourceIndex, gx, gy, gw, gh);\n\n            if (charFrame)\n            {\n                charFrame.setUVs(gw, gh, u0, v0, u1, v1);\n            }\n        }\n    }\n\n    var kernings = xml.getElementsByTagName('kerning');\n\n    for (i = 0; i < kernings.length; i++)\n    {\n        var kern = kernings[i];\n\n        var first = getValue(kern, 'first');\n        var second = getValue(kern, 'second');\n        var amount = getValue(kern, 'amount');\n\n        data.chars[second].kerning[first] = amount;\n    }\n\n    return data;\n};\n\nmodule.exports = ParseXMLBitmapFont;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Given a File and a baseURL value this returns the URL the File will use to download from.\r\n *\r\n * @function Phaser.Loader.GetURL\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File object.\r\n * @param {string} baseURL - A default base URL.\r\n *\r\n * @return {string} The URL the File will use.\r\n */\r\nvar GetURL = function (file, baseURL)\r\n{\r\n    if (!file.url)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (file.url.match(/^(?:blob:|data:|http:\\/\\/|https:\\/\\/|\\/\\/)/))\r\n    {\r\n        return file.url;\r\n    }\r\n    else\r\n    {\r\n        return baseURL + file.url;\r\n    }\r\n};\r\n\r\nmodule.exports = GetURL;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Creates an XHRSettings Object with default values.\r\n *\r\n * @function Phaser.Loader.XHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {XMLHttpRequestResponseType} [responseType=''] - The responseType, such as 'text'.\r\n * @param {boolean} [async=true] - Should the XHR request use async or not?\r\n * @param {string} [user=''] - Optional username for the XHR request.\r\n * @param {string} [password=''] - Optional password for the XHR request.\r\n * @param {number} [timeout=0] - Optional XHR timeout value.\r\n * @param {boolean} [withCredentials=false] - Optional XHR withCredentials value.\r\n *\r\n * @return {Phaser.Types.Loader.XHRSettingsObject} The XHRSettings object as used by the Loader.\r\n */\r\nvar XHRSettings = function (responseType, async, user, password, timeout, withCredentials)\r\n{\r\n    if (responseType === undefined) { responseType = ''; }\r\n    if (async === undefined) { async = true; }\r\n    if (user === undefined) { user = ''; }\r\n    if (password === undefined) { password = ''; }\r\n    if (timeout === undefined) { timeout = 0; }\r\n    if (withCredentials === undefined) { withCredentials = false; }\r\n\r\n    // Before sending a request, set the xhr.responseType to \"text\",\r\n    // \"arraybuffer\", \"blob\", or \"document\", depending on your data needs.\r\n    // Note, setting xhr.responseType = '' (or omitting) will default the response to \"text\".\r\n\r\n    return {\r\n\r\n        //  Ignored by the Loader, only used by File.\r\n        responseType: responseType,\r\n\r\n        async: async,\r\n\r\n        //  credentials\r\n        user: user,\r\n        password: password,\r\n\r\n        //  timeout in ms (0 = no timeout)\r\n        timeout: timeout,\r\n\r\n        //  setRequestHeader\r\n        headers: undefined,\r\n        header: undefined,\r\n        headerValue: undefined,\r\n        requestedWith: false,\r\n\r\n        //  overrideMimeType\r\n        overrideMimeType: undefined,\r\n\r\n        //  withCredentials\r\n        withCredentials: withCredentials\r\n\r\n    };\r\n};\r\n\r\nmodule.exports = XHRSettings;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FILE_CONST = {\r\n\r\n    /**\r\n     * The Loader is idle.\r\n     * \r\n     * @name Phaser.Loader.LOADER_IDLE\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_IDLE: 0,\r\n\r\n    /**\r\n     * The Loader is actively loading.\r\n     * \r\n     * @name Phaser.Loader.LOADER_LOADING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_LOADING: 1,\r\n\r\n    /**\r\n     * The Loader is processing files is has loaded.\r\n     * \r\n     * @name Phaser.Loader.LOADER_PROCESSING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_PROCESSING: 2,\r\n\r\n    /**\r\n     * The Loader has completed loading and processing.\r\n     * \r\n     * @name Phaser.Loader.LOADER_COMPLETE\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_COMPLETE: 3,\r\n\r\n    /**\r\n     * The Loader is shutting down.\r\n     * \r\n     * @name Phaser.Loader.LOADER_SHUTDOWN\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_SHUTDOWN: 4,\r\n\r\n    /**\r\n     * The Loader has been destroyed.\r\n     * \r\n     * @name Phaser.Loader.LOADER_DESTROYED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    LOADER_DESTROYED: 5,\r\n\r\n    /**\r\n     * File is in the load queue but not yet started\r\n     * \r\n     * @name Phaser.Loader.FILE_PENDING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_PENDING: 10,\r\n\r\n    /**\r\n     * File has been started to load by the loader (onLoad called)\r\n     * \r\n     * @name Phaser.Loader.FILE_LOADING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_LOADING: 11,\r\n\r\n    /**\r\n     * File has loaded successfully, awaiting processing    \r\n     * \r\n     * @name Phaser.Loader.FILE_LOADED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_LOADED: 12,\r\n\r\n    /**\r\n     * File failed to load\r\n     * \r\n     * @name Phaser.Loader.FILE_FAILED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_FAILED: 13,\r\n\r\n    /**\r\n     * File is being processed (onProcess callback)\r\n     * \r\n     * @name Phaser.Loader.FILE_PROCESSING\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_PROCESSING: 14,\r\n\r\n    /**\r\n     * The File has errored somehow during processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_ERRORED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_ERRORED: 16,\r\n\r\n    /**\r\n     * File has finished processing.\r\n     * \r\n     * @name Phaser.Loader.FILE_COMPLETE\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_COMPLETE: 17,\r\n\r\n    /**\r\n     * File has been destroyed\r\n     * \r\n     * @name Phaser.Loader.FILE_DESTROYED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_DESTROYED: 18,\r\n\r\n    /**\r\n     * File was populated from local data and doesn't need an HTTP request\r\n     * \r\n     * @name Phaser.Loader.FILE_POPULATED\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    FILE_POPULATED: 19\r\n\r\n};\r\n\r\nmodule.exports = FILE_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Extend = require('../utils/object/Extend');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * Takes two XHRSettings Objects and creates a new XHRSettings object from them.\r\n *\r\n * The new object is seeded by the values given in the global settings, but any setting in\r\n * the local object overrides the global ones.\r\n *\r\n * @function Phaser.Loader.MergeXHRSettings\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} global - The global XHRSettings object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} local - The local XHRSettings object.\r\n *\r\n * @return {Phaser.Types.Loader.XHRSettingsObject} A newly formed XHRSettings object.\r\n */\r\nvar MergeXHRSettings = function (global, local)\r\n{\r\n    var output = (global === undefined) ? XHRSettings() : Extend({}, global);\r\n\r\n    if (local)\r\n    {\r\n        for (var setting in local)\r\n        {\r\n            if (local[setting] !== undefined)\r\n            {\r\n                output[setting] = local[setting];\r\n            }\r\n        }\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = MergeXHRSettings;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar ParseXML = require('../../dom/ParseXML');\r\n\r\n/**\r\n * @classdesc\r\n * A single XML File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#xml method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#xml.\r\n *\r\n * @class XMLFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.XMLFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar XMLFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function XMLFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'xml';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'xml',\r\n            cache: loader.cacheManager.xml,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.XMLFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = ParseXML(this.xhrLoader.responseText);\r\n\r\n        if (this.data)\r\n        {\r\n            this.onProcessComplete();\r\n        }\r\n        else\r\n        {\r\n            console.warn('Invalid XMLFile: ' + this.key);\r\n            \r\n            this.onProcessError();\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an XML file, or array of XML files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.xml('wavedata', 'files/AlienWaveData.xml');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n * \r\n * The key must be a unique String. It is used to add the file to the global XML Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the XML Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the XML Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n * \r\n * ```javascript\r\n * this.load.xml({\r\n *     key: 'wavedata',\r\n *     url: 'files/AlienWaveData.xml'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.XMLFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n * \r\n * ```javascript\r\n * this.load.xml('wavedata', 'files/AlienWaveData.xml');\r\n * // and later in your game ...\r\n * var data = this.cache.xml.get('wavedata');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the XML Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.xml\". It will always add `.xml` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the XML File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#xml\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.XMLFileConfig|Phaser.Types.Loader.FileTypes.XMLFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.xml`, i.e. if `key` was \"alien\" then the URL will be \"alien.xml\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('xml', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new XMLFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new XMLFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = XMLFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Text File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#text method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#text.\r\n *\r\n * @class TextFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar TextFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function TextFile (loader, key, url, xhrSettings)\r\n    {\r\n        var type = 'text';\r\n        var extension = 'txt';\r\n        var cache = loader.cacheManager.text;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            type = GetFastValue(config, 'type', type);\r\n            cache = GetFastValue(config, 'cache', cache);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: type,\r\n            cache: cache,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.TextFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = this.xhrLoader.responseText;\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Text file, or array of Text files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.text('story', 'files/IntroStory.txt');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Text Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Text Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Text Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.text({\r\n *     key: 'story',\r\n *     url: 'files/IntroStory.txt'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.TextFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.text('story', 'files/IntroStory.txt');\r\n * // and later in your game ...\r\n * var data = this.cache.text.get('story');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Story` the final key will be `LEVEL1.Story` and\r\n * this is what you would use to retrieve the text from the Text Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"story\"\r\n * and no URL is given then the Loader will set the URL to be \"story.txt\". It will always add `.txt` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Text File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#text\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.TextFileConfig|Phaser.Types.Loader.FileTypes.TextFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.txt`, i.e. if `key` was \"alien\" then the URL will be \"alien.txt\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('text', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new TextFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new TextFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = TextFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar Events = require('./events');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar GetURL = require('./GetURL');\r\nvar MergeXHRSettings = require('./MergeXHRSettings');\r\nvar XHRLoader = require('./XHRLoader');\r\nvar XHRSettings = require('./XHRSettings');\r\n\r\n/**\r\n * @classdesc\r\n * The base File class used by all File Types that the Loader can support.\r\n * You shouldn't create an instance of a File directly, but should extend it with your own class, setting a custom type and processing methods.\r\n *\r\n * @class File\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\r\n * @param {Phaser.Types.Loader.FileConfig} fileConfig - The file configuration object, as created by the file type.\r\n */\r\nvar File = new Class({\r\n\r\n    initialize:\r\n\r\n    function File (loader, fileConfig)\r\n    {\r\n        /**\r\n         * A reference to the Loader that is going to load this file.\r\n         *\r\n         * @name Phaser.Loader.File#loader\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.loader = loader;\r\n\r\n        /**\r\n         * A reference to the Cache, or Texture Manager, that is going to store this file if it loads.\r\n         *\r\n         * @name Phaser.Loader.File#cache\r\n         * @type {(Phaser.Cache.BaseCache|Phaser.Textures.TextureManager)}\r\n         * @since 3.7.0\r\n         */\r\n        this.cache = GetFastValue(fileConfig, 'cache', false);\r\n\r\n        /**\r\n         * The file type string (image, json, etc) for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.File#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = GetFastValue(fileConfig, 'type', false);\r\n\r\n        /**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.File#key\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.key = GetFastValue(fileConfig, 'key', false);\r\n\r\n        var loadKey = this.key;\r\n\r\n        if (loader.prefix && loader.prefix !== '')\r\n        {\r\n            this.key = loader.prefix + loadKey;\r\n        }\r\n\r\n        if (!this.type || !this.key)\r\n        {\r\n            throw new Error('Invalid Loader.' + this.type + ' key');\r\n        }\r\n\r\n        var url = GetFastValue(fileConfig, 'url');\r\n\r\n        if (url === undefined)\r\n        {\r\n            url = loader.path + loadKey + '.' + GetFastValue(fileConfig, 'extension', '');\r\n        }\r\n        else if (typeof url === 'string' && !url.match(/^(?:blob:|data:|http:\\/\\/|https:\\/\\/|\\/\\/)/))\r\n        {\r\n            url = loader.path + url;\r\n        }\r\n\r\n        /**\r\n         * The URL of the file, not including baseURL.\r\n         *\r\n         * Automatically has Loader.path prepended to it if a string.\r\n         *\r\n         * Can also be a JavaScript Object, such as the results of parsing JSON data.\r\n         *\r\n         * @name Phaser.Loader.File#url\r\n         * @type {object|string}\r\n         * @since 3.0.0\r\n         */\r\n        this.url = url;\r\n\r\n        /**\r\n         * The final URL this file will load from, including baseURL and path.\r\n         * Set automatically when the Loader calls 'load' on this file.\r\n         *\r\n         * @name Phaser.Loader.File#src\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.src = '';\r\n\r\n        /**\r\n         * The merged XHRSettings for this file.\r\n         *\r\n         * @name Phaser.Loader.File#xhrSettings\r\n         * @type {Phaser.Types.Loader.XHRSettingsObject}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhrSettings = XHRSettings(GetFastValue(fileConfig, 'responseType', undefined));\r\n\r\n        if (GetFastValue(fileConfig, 'xhrSettings', false))\r\n        {\r\n            this.xhrSettings = MergeXHRSettings(this.xhrSettings, GetFastValue(fileConfig, 'xhrSettings', {}));\r\n        }\r\n\r\n        /**\r\n         * The XMLHttpRequest instance (as created by XHR Loader) that is loading this File.\r\n         *\r\n         * @name Phaser.Loader.File#xhrLoader\r\n         * @type {?XMLHttpRequest}\r\n         * @since 3.0.0\r\n         */\r\n        this.xhrLoader = null;\r\n\r\n        /**\r\n         * The current state of the file. One of the FILE_CONST values.\r\n         *\r\n         * @name Phaser.Loader.File#state\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.state = (typeof(this.url) === 'function') ? CONST.FILE_POPULATED : CONST.FILE_PENDING;\r\n\r\n        /**\r\n         * The total size of this file.\r\n         * Set by onProgress and only if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesTotal\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.bytesTotal = 0;\r\n\r\n        /**\r\n         * Updated as the file loads.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#bytesLoaded\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.bytesLoaded = -1;\r\n\r\n        /**\r\n         * A percentage value between 0 and 1 indicating how much of this file has loaded.\r\n         * Only set if loading via XHR.\r\n         *\r\n         * @name Phaser.Loader.File#percentComplete\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.percentComplete = -1;\r\n\r\n        /**\r\n         * For CORs based loading.\r\n         * If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)\r\n         *\r\n         * @name Phaser.Loader.File#crossOrigin\r\n         * @type {(string|undefined)}\r\n         * @since 3.0.0\r\n         */\r\n        this.crossOrigin = undefined;\r\n\r\n        /**\r\n         * The processed file data, stored here after the file has loaded.\r\n         *\r\n         * @name Phaser.Loader.File#data\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = undefined;\r\n\r\n        /**\r\n         * A config object that can be used by file types to store transitional data.\r\n         *\r\n         * @name Phaser.Loader.File#config\r\n         * @type {*}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = GetFastValue(fileConfig, 'config', {});\r\n\r\n        /**\r\n         * If this is a multipart file, i.e. an atlas and its json together, then this is a reference\r\n         * to the parent MultiFile. Set and used internally by the Loader or specific file types.\r\n         *\r\n         * @name Phaser.Loader.File#multiFile\r\n         * @type {?Phaser.Loader.MultiFile}\r\n         * @since 3.7.0\r\n         */\r\n        this.multiFile;\r\n\r\n        /**\r\n         * Does this file have an associated linked file? Such as an image and a normal map.\r\n         * Atlases and Bitmap Fonts use the multiFile, because those files need loading together but aren't\r\n         * actually bound by data, where-as a linkFile is.\r\n         *\r\n         * @name Phaser.Loader.File#linkFile\r\n         * @type {?Phaser.Loader.File}\r\n         * @since 3.7.0\r\n         */\r\n        this.linkFile;\r\n    },\r\n\r\n    /**\r\n     * Links this File with another, so they depend upon each other for loading and processing.\r\n     *\r\n     * @method Phaser.Loader.File#setLink\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} fileB - The file to link to this one.\r\n     */\r\n    setLink: function (fileB)\r\n    {\r\n        this.linkFile = fileB;\r\n\r\n        fileB.linkFile = this;\r\n    },\r\n\r\n    /**\r\n     * Resets the XHRLoader instance this file is using.\r\n     *\r\n     * @method Phaser.Loader.File#resetXHR\r\n     * @since 3.0.0\r\n     */\r\n    resetXHR: function ()\r\n    {\r\n        if (this.xhrLoader)\r\n        {\r\n            this.xhrLoader.onload = undefined;\r\n            this.xhrLoader.onerror = undefined;\r\n            this.xhrLoader.onprogress = undefined;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\r\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\r\n     *\r\n     * @method Phaser.Loader.File#load\r\n     * @since 3.0.0\r\n     */\r\n    load: function ()\r\n    {\r\n        if (this.state === CONST.FILE_POPULATED)\r\n        {\r\n            //  Can happen for example in a JSONFile if they've provided a JSON object instead of a URL\r\n            this.loader.nextFile(this, true);\r\n        }\r\n        else\r\n        {\r\n            this.state = CONST.FILE_LOADING;\r\n\r\n            this.src = GetURL(this, this.loader.baseURL);\r\n\r\n            if (this.src.indexOf('data:') === 0)\r\n            {\r\n                console.warn('Local data URIs are not supported: ' + this.key);\r\n            }\r\n            else\r\n            {\r\n                //  The creation of this XHRLoader starts the load process going.\r\n                //  It will automatically call the following, based on the load outcome:\r\n                //\r\n                // xhr.onload = this.onLoad\r\n                // xhr.onerror = this.onError\r\n                // xhr.onprogress = this.onProgress\r\n\r\n                this.xhrLoader = XHRLoader(this, this.loader.xhr);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called when the file finishes loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onLoad\r\n     * @since 3.0.0\r\n     *\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this load.\r\n     */\r\n    onLoad: function (xhr, event)\r\n    {\r\n        // On iOS, Capacitor often runs on a capacitor:// protocol, meaning local files are served from capacitor:// rather than file://\r\n        // See: https://github.com/photonstorm/phaser/issues/5685\r\n\r\n        var isLocalFile = xhr.responseURL && (xhr.responseURL.indexOf('file://') === 0 || xhr.responseURL.indexOf('capacitor://') === 0);\r\n\r\n        var localFileOk = (isLocalFile && event.target.status === 0);\r\n\r\n        var success = !(event.target && event.target.status !== 200) || localFileOk;\r\n\r\n        //  Handle HTTP status codes of 4xx and 5xx as errors, even if xhr.onerror was not called.\r\n        if (xhr.readyState === 4 && xhr.status >= 400 && xhr.status <= 599)\r\n        {\r\n            success = false;\r\n        }\r\n\r\n        this.state = CONST.FILE_LOADED;\r\n\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, success);\r\n    },\r\n\r\n    /**\r\n     * Called if the file errors while loading, is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onError\r\n     * @since 3.0.0\r\n     *\r\n     * @param {XMLHttpRequest} xhr - The XMLHttpRequest that caused this onload event.\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent that resulted from this error.\r\n     */\r\n    onError: function ()\r\n    {\r\n        this.resetXHR();\r\n\r\n        this.loader.nextFile(this, false);\r\n    },\r\n\r\n    /**\r\n     * Called during the file load progress. Is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.File#onProgress\r\n     * @fires Phaser.Loader.Events#FILE_PROGRESS\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ProgressEvent} event - The DOM ProgressEvent.\r\n     */\r\n    onProgress: function (event)\r\n    {\r\n        if (event.lengthComputable)\r\n        {\r\n            this.bytesLoaded = event.loaded;\r\n            this.bytesTotal = event.total;\r\n\r\n            this.percentComplete = Math.min((this.bytesLoaded / this.bytesTotal), 1);\r\n\r\n            this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Usually overridden by the FileTypes and is called by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data, for example a JSON file will parse itself during this stage.\r\n     *\r\n     * @method Phaser.Loader.File#onProcess\r\n     * @since 3.0.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.onProcessComplete();\r\n    },\r\n\r\n    /**\r\n     * Called when the File has completed processing.\r\n     * Checks on the state of its multifile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onProcessComplete\r\n     * @since 3.7.0\r\n     */\r\n    onProcessComplete: function ()\r\n    {\r\n        this.state = CONST.FILE_COMPLETE;\r\n\r\n        if (this.multiFile)\r\n        {\r\n            this.multiFile.onFileComplete(this);\r\n        }\r\n\r\n        this.loader.fileProcessComplete(this);\r\n    },\r\n\r\n    /**\r\n     * Called when the File has completed processing but it generated an error.\r\n     * Checks on the state of its multifile, if set.\r\n     *\r\n     * @method Phaser.Loader.File#onProcessError\r\n     * @since 3.7.0\r\n     */\r\n    onProcessError: function ()\r\n    {\r\n        this.state = CONST.FILE_ERRORED;\r\n\r\n        if (this.multiFile)\r\n        {\r\n            this.multiFile.onFileFailed(this);\r\n        }\r\n\r\n        this.loader.fileProcessComplete(this);\r\n    },\r\n\r\n    /**\r\n     * Checks if a key matching the one used by this file exists in the target Cache or not.\r\n     * This is called automatically by the LoaderPlugin to decide if the file can be safely\r\n     * loaded or will conflict.\r\n     *\r\n     * @method Phaser.Loader.File#hasCacheConflict\r\n     * @since 3.7.0\r\n     *\r\n     * @return {boolean} `true` if adding this file will cause a conflict, otherwise `false`.\r\n     */\r\n    hasCacheConflict: function ()\r\n    {\r\n        return (this.cache && this.cache.exists(this.key));\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     * This method is often overridden by specific file types.\r\n     *\r\n     * @method Phaser.Loader.File#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        if (this.cache)\r\n        {\r\n            this.cache.add(this.key, this.data);\r\n        }\r\n\r\n        this.pendingDestroy();\r\n    },\r\n\r\n    /**\r\n     * Called once the file has been added to its cache and is now ready for deletion from the Loader.\r\n     * It will emit a `filecomplete` event from the LoaderPlugin.\r\n     *\r\n     * @method Phaser.Loader.File#pendingDestroy\r\n     * @fires Phaser.Loader.Events#FILE_COMPLETE\r\n     * @fires Phaser.Loader.Events#FILE_KEY_COMPLETE\r\n     * @since 3.7.0\r\n     */\r\n    pendingDestroy: function (data)\r\n    {\r\n        if (data === undefined) { data = this.data; }\r\n\r\n        var key = this.key;\r\n        var type = this.type;\r\n\r\n        this.loader.emit(Events.FILE_COMPLETE, key, type, data);\r\n        this.loader.emit(Events.FILE_KEY_COMPLETE + type + '-' + key, key, type, data);\r\n\r\n        this.loader.flagForRemoval(this);\r\n    },\r\n\r\n    /**\r\n     * Destroy this File and any references it holds.\r\n     *\r\n     * @method Phaser.Loader.File#destroy\r\n     * @since 3.7.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.loader = null;\r\n        this.cache = null;\r\n        this.xhrSettings = null;\r\n        this.multiFile = null;\r\n        this.linkFile = null;\r\n        this.data = null;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Static method for creating object URL using URL API and setting it as image 'src' attribute.\r\n * If URL API is not supported (usually on old browsers) it falls back to creating Base64 encoded url using FileReader.\r\n *\r\n * @method Phaser.Loader.File.createObjectURL\r\n * @static\r\n * @since 3.7.0\r\n *\r\n * @param {HTMLImageElement} image - Image object which 'src' attribute should be set to object URL.\r\n * @param {Blob} blob - A Blob object to create an object URL for.\r\n * @param {string} defaultType - Default mime type used if blob type is not available.\r\n */\r\nFile.createObjectURL = function (image, blob, defaultType)\r\n{\r\n    if (typeof URL === 'function')\r\n    {\r\n        image.src = URL.createObjectURL(blob);\r\n    }\r\n    else\r\n    {\r\n        var reader = new FileReader();\r\n\r\n        reader.onload = function ()\r\n        {\r\n            image.removeAttribute('crossOrigin');\r\n            image.src = 'data:' + (blob.type || defaultType) + ';base64,' + reader.result.split(',')[1];\r\n        };\r\n\r\n        reader.onerror = image.onerror;\r\n\r\n        reader.readAsDataURL(blob);\r\n    }\r\n};\r\n\r\n/**\r\n * Static method for releasing an existing object URL which was previously created\r\n * by calling {@link File#createObjectURL} method.\r\n *\r\n * @method Phaser.Loader.File.revokeObjectURL\r\n * @static\r\n * @since 3.7.0\r\n *\r\n * @param {HTMLImageElement} image - Image object which 'src' attribute should be revoked.\r\n */\r\nFile.revokeObjectURL = function (image)\r\n{\r\n    if (typeof URL === 'function')\r\n    {\r\n        URL.revokeObjectURL(image.src);\r\n    }\r\n};\r\n\r\nmodule.exports = File;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Tilemaps.Formats\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * CSV Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.CSV\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    CSV: 0,\r\n\r\n    /**\r\n     * Tiled JSON Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.TILED_JSON\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    TILED_JSON: 1,\r\n\r\n    /**\r\n     * 2D Array Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.ARRAY_2D\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    ARRAY_2D: 2,\r\n\r\n    /**\r\n     * Weltmeister (Impact.js) Map Type\r\n     * \r\n     * @name Phaser.Tilemaps.Formats.WELTMEISTER\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    WELTMEISTER: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar MergeXHRSettings = require('./MergeXHRSettings');\r\n\r\n/**\r\n * Creates a new XMLHttpRequest (xhr) object based on the given File and XHRSettings\r\n * and starts the download of it. It uses the Files own XHRSettings and merges them\r\n * with the global XHRSettings object to set the xhr values before download.\r\n *\r\n * @function Phaser.Loader.XHRLoader\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.File} file - The File to download.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} globalXHRSettings - The global XHRSettings object.\r\n *\r\n * @return {XMLHttpRequest} The XHR object.\r\n */\r\nvar XHRLoader = function (file, globalXHRSettings)\r\n{\r\n    var config = MergeXHRSettings(globalXHRSettings, file.xhrSettings);\r\n\r\n    var xhr = new XMLHttpRequest();\r\n\r\n    xhr.open('GET', file.src, config.async, config.user, config.password);\r\n\r\n    xhr.responseType = file.xhrSettings.responseType;\r\n    xhr.timeout = config.timeout;\r\n\r\n    if (config.headers)\r\n    {\r\n        for (var key in config.headers)\r\n        {\r\n            xhr.setRequestHeader(key, config.headers[key]);\r\n        }\r\n    }\r\n\r\n    if (config.header && config.headerValue)\r\n    {\r\n        xhr.setRequestHeader(config.header, config.headerValue);\r\n    }\r\n\r\n    if (config.requestedWith)\r\n    {\r\n        xhr.setRequestHeader('X-Requested-With', config.requestedWith);\r\n    }\r\n\r\n    if (config.overrideMimeType)\r\n    {\r\n        xhr.overrideMimeType(config.overrideMimeType);\r\n    }\r\n\r\n    if (config.withCredentials)\r\n    {\r\n        xhr.withCredentials = true;\r\n    }\r\n\r\n    // After a successful request, the xhr.response property will contain the requested data as a DOMString, ArrayBuffer, Blob, or Document (depending on what was set for responseType.)\r\n\r\n    xhr.onload = file.onLoad.bind(file, xhr);\r\n    xhr.onerror = file.onError.bind(file, xhr);\r\n    xhr.onprogress = file.onProgress.bind(file);\r\n\r\n    //  This is the only standard method, the ones above are browser additions (maybe not universal?)\r\n    // xhr.onreadystatechange\r\n\r\n    xhr.send();\r\n\r\n    return xhr;\r\n};\r\n\r\nmodule.exports = XHRLoader;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar HTML5AudioFile = require('./HTML5AudioFile');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Audio File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#audio method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#audio.\r\n *\r\n * @class AudioFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {any} [urlConfig] - The absolute or relative URL to load this file from in a config object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {AudioContext} [audioContext] - The AudioContext this file will use to process itself.\r\n */\r\nvar AudioFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    //  URL is an object created by AudioFile.findAudioURL\r\n    function AudioFile (loader, key, urlConfig, xhrSettings, audioContext)\r\n    {\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            audioContext = GetFastValue(config, 'context', audioContext);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'audio',\r\n            cache: loader.cacheManager.audio,\r\n            extension: urlConfig.type,\r\n            responseType: 'arraybuffer',\r\n            key: key,\r\n            url: urlConfig.url,\r\n            xhrSettings: xhrSettings,\r\n            config: { context: audioContext }\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.AudioFile#onProcess\r\n     * @since 3.0.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        var _this = this;\r\n\r\n        // interesting read https://github.com/WebAudio/web-audio-api/issues/1305\r\n        this.config.context.decodeAudioData(this.xhrLoader.response,\r\n            function (audioBuffer)\r\n            {\r\n                _this.data = audioBuffer;\r\n\r\n                _this.onProcessComplete();\r\n            },\r\n            function (e)\r\n            {\r\n                // eslint-disable-next-line no-console\r\n                console.error('Error decoding audio: ' + _this.key + ' - ', e ? e.message : null);\r\n\r\n                _this.onProcessError();\r\n            }\r\n        );\r\n\r\n        this.config.context = null;\r\n    }\r\n\r\n});\r\n\r\nAudioFile.create = function (loader, key, urls, config, xhrSettings)\r\n{\r\n    var game = loader.systems.game;\r\n    var audioConfig = game.config.audio;\r\n    var deviceAudio = game.device.audio;\r\n\r\n    //  url may be inside key, which may be an object\r\n    if (IsPlainObject(key))\r\n    {\r\n        urls = GetFastValue(key, 'url', []);\r\n        config = GetFastValue(key, 'config', {});\r\n    }\r\n\r\n    var urlConfig = AudioFile.getAudioURL(game, urls);\r\n\r\n    if (!urlConfig)\r\n    {\r\n        return null;\r\n    }\r\n\r\n    // https://developers.google.com/web/updates/2012/02/HTML5-audio-and-the-Web-Audio-API-are-BFFs\r\n    // var stream = GetFastValue(config, 'stream', false);\r\n\r\n    if (deviceAudio.webAudio && !audioConfig.disableWebAudio)\r\n    {\r\n        return new AudioFile(loader, key, urlConfig, xhrSettings, game.sound.context);\r\n    }\r\n    else\r\n    {\r\n        return new HTML5AudioFile(loader, key, urlConfig, config);\r\n    }\r\n};\r\n\r\nAudioFile.getAudioURL = function (game, urls)\r\n{\r\n    if (!Array.isArray(urls))\r\n    {\r\n        urls = [ urls ];\r\n    }\r\n\r\n    for (var i = 0; i < urls.length; i++)\r\n    {\r\n        var url = GetFastValue(urls[i], 'url', urls[i]);\r\n\r\n        if (url.indexOf('blob:') === 0 || url.indexOf('data:') === 0)\r\n        {\r\n            return {\r\n                url: url,\r\n                type: ''\r\n            };\r\n        }\r\n\r\n        var audioType = url.match(/\\.([a-zA-Z0-9]+)($|\\?)/);\r\n\r\n        audioType = GetFastValue(urls[i], 'type', (audioType) ? audioType[1] : '').toLowerCase();\r\n\r\n        if (game.device.audio[audioType])\r\n        {\r\n            return {\r\n                url: url,\r\n                type: audioType\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Adds an Audio or HTML5Audio file, or array of audio files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.audio('title', [ 'music/Title.ogg', 'music/Title.mp3', 'music/Title.m4a' ]);\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Audio Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Audio Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Audio Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.audio({\r\n *     key: 'title',\r\n *     url: [ 'music/Title.ogg', 'music/Title.mp3', 'music/Title.m4a' ]\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.AudioFileConfig` for more details.\r\n *\r\n * The URLs can be relative or absolute. If the URLs are relative the `Loader.baseURL` and `Loader.path` values will be prepended to them.\r\n *\r\n * Due to different browsers supporting different audio file types you should usually provide your audio files in a variety of formats.\r\n * ogg, mp3 and m4a are the most common. If you provide an array of URLs then the Loader will determine which _one_ file to load based on\r\n * browser support.\r\n *\r\n * If audio has been disabled in your game, either via the game config, or lack of support from the device, then no audio will be loaded.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Audio File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#audio\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioFileConfig|Phaser.Types.Loader.FileTypes.AudioFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(string|string[])} [urls] - The absolute or relative URL to load the audio files from.\r\n * @param {any} [config] - An object containing an `instances` property for HTML5Audio. Defaults to 1.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('audio', function (key, urls, config, xhrSettings)\r\n{\r\n    var game = this.systems.game;\r\n    var audioConfig = game.config.audio;\r\n    var deviceAudio = game.device.audio;\r\n\r\n    if (audioConfig.noAudio || (!deviceAudio.webAudio && !deviceAudio.audioData))\r\n    {\r\n        //  Sounds are disabled, so skip loading audio\r\n        return this;\r\n    }\r\n\r\n    var audioFile;\r\n\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            audioFile = AudioFile.create(this, key[i]);\r\n\r\n            if (audioFile)\r\n            {\r\n                this.addFile(audioFile);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        audioFile = AudioFile.create(this, key, urls, config, xhrSettings);\r\n\r\n        if (audioFile)\r\n        {\r\n            this.addFile(audioFile);\r\n        }\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = AudioFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Events = require('../events');\r\nvar File = require('../File');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetURL = require('../GetURL');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Audio File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#audio method and are not typically created directly.\r\n * \r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#audio.\r\n *\r\n * @class HTML5AudioFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.AudioFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [urlConfig] - The absolute or relative URL to load this file from.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar HTML5AudioFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function HTML5AudioFile (loader, key, urlConfig, audioConfig)\r\n    {\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            audioConfig = GetFastValue(config, 'config', audioConfig);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'audio',\r\n            cache: loader.cacheManager.audio,\r\n            extension: urlConfig.type,\r\n            key: key,\r\n            url: urlConfig.url,\r\n            config: audioConfig\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        //  New properties specific to this class\r\n        this.locked = 'ontouchstart' in window;\r\n        this.loaded = false;\r\n        this.filesLoaded = 0;\r\n        this.filesTotal = 0;\r\n    },\r\n\r\n    /**\r\n     * Called when the file finishes loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTML5AudioFile#onLoad\r\n     * @since 3.0.0\r\n     */\r\n    onLoad: function ()\r\n    {\r\n        if (this.loaded)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.loaded = true;\r\n\r\n        this.loader.nextFile(this, true);\r\n    },\r\n\r\n    /**\r\n     * Called if the file errors while loading.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTML5AudioFile#onError\r\n     * @since 3.0.0\r\n     */\r\n    onError: function ()\r\n    {\r\n        for (var i = 0; i < this.data.length; i++)\r\n        {\r\n            var audio = this.data[i];\r\n\r\n            audio.oncanplaythrough = null;\r\n            audio.onerror = null;\r\n        }\r\n\r\n        this.loader.nextFile(this, false);\r\n    },\r\n\r\n    /**\r\n     * Called during the file load progress. Is sent a DOM ProgressEvent.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTML5AudioFile#onProgress\r\n     * @fires Phaser.Loader.Events#FILE_PROGRESS\r\n     * @since 3.0.0\r\n     */\r\n    onProgress: function (event)\r\n    {\r\n        var audio = event.target;\r\n\r\n        audio.oncanplaythrough = null;\r\n        audio.onerror = null;\r\n\r\n        this.filesLoaded++;\r\n\r\n        this.percentComplete = Math.min((this.filesLoaded / this.filesTotal), 1);\r\n\r\n        this.loader.emit(Events.FILE_PROGRESS, this, this.percentComplete);\r\n\r\n        if (this.filesLoaded === this.filesTotal)\r\n        {\r\n            this.onLoad();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by the Loader, starts the actual file downloading.\r\n     * During the load the methods onLoad, onError and onProgress are called, based on the XHR events.\r\n     * You shouldn't normally call this method directly, it's meant to be invoked by the Loader.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.HTML5AudioFile#load\r\n     * @since 3.0.0\r\n     */\r\n    load: function ()\r\n    {\r\n        this.data = [];\r\n\r\n        var instances = (this.config && this.config.instances) || 1;\r\n\r\n        this.filesTotal = instances;\r\n        this.filesLoaded = 0;\r\n        this.percentComplete = 0;\r\n\r\n        for (var i = 0; i < instances; i++)\r\n        {\r\n            var audio = new Audio();\r\n\r\n            if (!audio.dataset)\r\n            {\r\n                audio.dataset = {};\r\n            }\r\n\r\n            audio.dataset.name = this.key + ('0' + i).slice(-2);\r\n            audio.dataset.used = 'false';\r\n\r\n            if (this.locked)\r\n            {\r\n                audio.dataset.locked = 'true';\r\n            }\r\n            else\r\n            {\r\n                audio.dataset.locked = 'false';\r\n\r\n                audio.preload = 'auto';\r\n                audio.oncanplaythrough = this.onProgress.bind(this);\r\n                audio.onerror = this.onError.bind(this);\r\n            }\r\n\r\n            this.data.push(audio);\r\n        }\r\n\r\n        for (i = 0; i < this.data.length; i++)\r\n        {\r\n            audio = this.data[i];\r\n            audio.src = GetURL(this, this.loader.baseURL);\r\n\r\n            if (!this.locked)\r\n            {\r\n                audio.load();\r\n            }\r\n        }\r\n\r\n        if (this.locked)\r\n        {\r\n            //  This is super-dangerous but works. Race condition potential high.\r\n            //  Is there another way?\r\n            setTimeout(this.onLoad.bind(this));\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = HTML5AudioFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Script File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#script method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#script.\r\n *\r\n * @class ScriptFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ScriptFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n */\r\nvar ScriptFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function ScriptFile (loader, key, url, xhrSettings)\r\n    {\r\n        var extension = 'js';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'script',\r\n            cache: false,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ScriptFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = document.createElement('script');\r\n        this.data.language = 'javascript';\r\n        this.data.type = 'text/javascript';\r\n        this.data.defer = false;\r\n        this.data.text = this.xhrLoader.responseText;\r\n\r\n        document.head.appendChild(this.data);\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a Script file, or array of Script files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.script('aliens', 'lib/aliens.js');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String and not already in-use by another file in the Loader.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.script({\r\n *     key: 'aliens',\r\n *     url: 'lib/aliens.js'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.ScriptFileConfig` for more details.\r\n *\r\n * Once the file has finished loading it will automatically be converted into a script element\r\n * via `document.createElement('script')`. It will have its language set to JavaScript, `defer` set to\r\n * false and then the resulting element will be appended to `document.head`. Any code then in the\r\n * script will be executed.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.js\". It will always add `.js` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Script File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#script\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ScriptFileConfig|Phaser.Types.Loader.FileTypes.ScriptFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.js`, i.e. if `key` was \"alien\" then the URL will be \"alien.js\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('script', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new ScriptFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new ScriptFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = ScriptFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A MultiFile is a special kind of parent that contains two, or more, Files as children and looks after\r\n * the loading and processing of them all. It is commonly extended and used as a base class for file types such as AtlasJSON or BitmapFont.\r\n *\r\n * You shouldn't create an instance of a MultiFile directly, but should extend it with your own class, setting a custom type and processing methods.\r\n *\r\n * @class MultiFile\r\n * @memberof Phaser.Loader\r\n * @constructor\r\n * @since 3.7.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - The Loader that is going to load this File.\r\n * @param {string} type - The file type string for sorting within the Loader.\r\n * @param {string} key - The key of the file within the loader.\r\n * @param {Phaser.Loader.File[]} files - An array of Files that make-up this MultiFile.\r\n */\r\nvar MultiFile = new Class({\r\n\r\n    initialize:\r\n\r\n    function MultiFile (loader, type, key, files)\r\n    {\r\n        var finalFiles = [];\r\n\r\n        //  Clean out any potential 'null' or 'undefined' file entries\r\n        files.forEach(function (file)\r\n        {\r\n            if (file)\r\n            {\r\n                finalFiles.push(file);\r\n            }\r\n        });\r\n\r\n        /**\r\n         * A reference to the Loader that is going to load this file.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#loader\r\n         * @type {Phaser.Loader.LoaderPlugin}\r\n         * @since 3.7.0\r\n         */\r\n        this.loader = loader;\r\n\r\n        /**\r\n         * The file type string for sorting within the Loader.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#type\r\n         * @type {string}\r\n         * @since 3.7.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * Unique cache key (unique within its file type)\r\n         *\r\n         * @name Phaser.Loader.MultiFile#key\r\n         * @type {string}\r\n         * @since 3.7.0\r\n         */\r\n        this.key = key;\r\n\r\n        /**\r\n         * The current index being used by multi-file loaders to avoid key clashes.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#multiKeyIndex\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this.multiKeyIndex = loader.multiKeyIndex++;\r\n\r\n        /**\r\n         * Array of files that make up this MultiFile.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#files\r\n         * @type {Phaser.Loader.File[]}\r\n         * @since 3.7.0\r\n         */\r\n        this.files = finalFiles;\r\n\r\n        /**\r\n         * The completion status of this MultiFile.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#complete\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.7.0\r\n         */\r\n        this.complete = false;\r\n\r\n        /**\r\n         * The number of files to load.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#pending\r\n         * @type {number}\r\n         * @since 3.7.0\r\n         */\r\n\r\n        this.pending = finalFiles.length;\r\n\r\n        /**\r\n         * The number of files that failed to load.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#failed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.7.0\r\n         */\r\n        this.failed = 0;\r\n\r\n        /**\r\n         * A storage container for transient data that the loading files need.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#config\r\n         * @type {any}\r\n         * @since 3.7.0\r\n         */\r\n        this.config = {};\r\n\r\n        /**\r\n         * A reference to the Loaders baseURL at the time this MultiFile was created.\r\n         * Used to populate child-files.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#baseURL\r\n         * @type {string}\r\n         * @since 3.20.0\r\n         */\r\n        this.baseURL = loader.baseURL;\r\n\r\n        /**\r\n         * A reference to the Loaders path at the time this MultiFile was created.\r\n         * Used to populate child-files.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#path\r\n         * @type {string}\r\n         * @since 3.20.0\r\n         */\r\n        this.path = loader.path;\r\n\r\n        /**\r\n         * A reference to the Loaders prefix at the time this MultiFile was created.\r\n         * Used to populate child-files.\r\n         *\r\n         * @name Phaser.Loader.MultiFile#prefix\r\n         * @type {string}\r\n         * @since 3.20.0\r\n         */\r\n        this.prefix = loader.prefix;\r\n\r\n        //  Link the files\r\n        for (var i = 0; i < finalFiles.length; i++)\r\n        {\r\n            finalFiles[i].multiFile = this;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if this MultiFile is ready to process its children or not.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#isReadyToProcess\r\n     * @since 3.7.0\r\n     *\r\n     * @return {boolean} `true` if all children of this MultiFile have loaded, otherwise `false`.\r\n     */\r\n    isReadyToProcess: function ()\r\n    {\r\n        return (this.pending === 0 && this.failed === 0 && !this.complete);\r\n    },\r\n\r\n    /**\r\n     * Adds another child to this MultiFile, increases the pending count and resets the completion status.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#addToMultiFile\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} files - The File to add to this MultiFile.\r\n     *\r\n     * @return {Phaser.Loader.MultiFile} This MultiFile instance.\r\n     */\r\n    addToMultiFile: function (file)\r\n    {\r\n        this.files.push(file);\r\n\r\n        file.multiFile = this;\r\n\r\n        this.pending++;\r\n\r\n        this.complete = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Called by each File when it finishes loading.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileComplete\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has completed processing.\r\n     */\r\n    onFileComplete: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.pending--;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by each File that fails to load.\r\n     *\r\n     * @method Phaser.Loader.MultiFile#onFileFailed\r\n     * @since 3.7.0\r\n     *\r\n     * @param {Phaser.Loader.File} file - The File that has failed to load.\r\n     */\r\n    onFileFailed: function (file)\r\n    {\r\n        var index = this.files.indexOf(file);\r\n\r\n        if (index !== -1)\r\n        {\r\n            this.failed++;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MultiFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single JSON File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#json method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#json.\r\n *\r\n * @class JSONFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {(object|string)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, can be a fully formed JSON Object.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n */\r\nvar JSONFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    //  url can either be a string, in which case it is treated like a proper url, or an object, in which case it is treated as a ready-made JS Object\r\n    //  dataKey allows you to pluck a specific object out of the JSON and put just that into the cache, rather than the whole thing\r\n\r\n    function JSONFile (loader, key, url, xhrSettings, dataKey)\r\n    {\r\n        var extension = 'json';\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            dataKey = GetFastValue(config, 'dataKey', dataKey);\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'json',\r\n            cache: loader.cacheManager.json,\r\n            extension: extension,\r\n            responseType: 'text',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: dataKey\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        if (IsPlainObject(url))\r\n        {\r\n            //  Object provided instead of a URL, so no need to actually load it (populate data with value)\r\n            if (dataKey)\r\n            {\r\n                this.data = GetValue(url, dataKey);\r\n            }\r\n            else\r\n            {\r\n                this.data = url;\r\n            }\r\n\r\n            this.state = CONST.FILE_POPULATED;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.JSONFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        if (this.state !== CONST.FILE_POPULATED)\r\n        {\r\n            this.state = CONST.FILE_PROCESSING;\r\n\r\n            try\r\n            {\r\n                var json = JSON.parse(this.xhrLoader.responseText);\r\n            }\r\n            catch (e)\r\n            {\r\n                console.warn('Invalid JSON: ' + this.key);\r\n\r\n                this.onProcessError();\r\n\r\n                throw e;\r\n            }\r\n\r\n            var key = this.config;\r\n\r\n            if (typeof key === 'string')\r\n            {\r\n                this.data = GetValue(json, key, json);\r\n            }\r\n            else\r\n            {\r\n                this.data = json;\r\n            }\r\n        }\r\n\r\n        this.onProcessComplete();\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds a JSON file, or array of JSON files, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.json('wavedata', 'files/AlienWaveData.json');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global JSON Cache upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the JSON Cache.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the JSON Cache first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.json({\r\n *     key: 'wavedata',\r\n *     url: 'files/AlienWaveData.json'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.JSONFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can access it from its Cache using its key:\r\n *\r\n * ```javascript\r\n * this.load.json('wavedata', 'files/AlienWaveData.json');\r\n * // and later in your game ...\r\n * var data = this.cache.json.get('wavedata');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `LEVEL1.` and the key was `Waves` the final key will be `LEVEL1.Waves` and\r\n * this is what you would use to retrieve the text from the JSON Cache.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"data\"\r\n * and no URL is given then the Loader will set the URL to be \"data.json\". It will always add `.json` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * You can also optionally provide a `dataKey` to use. This allows you to extract only a part of the JSON and store it in the Cache,\r\n * rather than the whole file. For example, if your JSON data had a structure like this:\r\n *\r\n * ```json\r\n * {\r\n *     \"level1\": {\r\n *         \"baddies\": {\r\n *             \"aliens\": {},\r\n *             \"boss\": {}\r\n *         }\r\n *     },\r\n *     \"level2\": {},\r\n *     \"level3\": {}\r\n * }\r\n * ```\r\n *\r\n * And you only wanted to store the `boss` data in the Cache, then you could pass `level1.baddies.boss`as the `dataKey`.\r\n *\r\n * Note: The ability to load this type of file will only be available if the JSON File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#json\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.JSONFileConfig|Phaser.Types.Loader.FileTypes.JSONFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {(object|string)} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.json`, i.e. if `key` was \"alien\" then the URL will be \"alien.json\". Or, can be a fully formed JSON Object.\r\n * @param {string} [dataKey] - When the JSON file loads only this property will be stored in the Cache.\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('json', function (key, url, dataKey, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new JSONFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new JSONFile(this, key, url, xhrSettings, dataKey));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = JSONFile;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../const');\r\nvar File = require('../File');\r\nvar FileTypesManager = require('../FileTypesManager');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\n\r\n/**\r\n * @classdesc\r\n * A single Image File suitable for loading by the Loader.\r\n *\r\n * These are created when you use the Phaser.Loader.LoaderPlugin#image method and are not typically created directly.\r\n *\r\n * For documentation about what all the arguments and configuration options mean please see Phaser.Loader.LoaderPlugin#image.\r\n *\r\n * @class ImageFile\r\n * @extends Phaser.Loader.File\r\n * @memberof Phaser.Loader.FileTypes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Loader.LoaderPlugin} loader - A reference to the Loader that is responsible for this file.\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig)} key - The key to use for this file, or a file configuration object.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - Extra XHR Settings specifically for this file.\r\n * @param {Phaser.Types.Loader.FileTypes.ImageFrameConfig} [frameConfig] - The frame configuration object. Only provided for, and used by, Sprite Sheets.\r\n */\r\nvar ImageFile = new Class({\r\n\r\n    Extends: File,\r\n\r\n    initialize:\r\n\r\n    function ImageFile (loader, key, url, xhrSettings, frameConfig)\r\n    {\r\n        var extension = 'png';\r\n        var normalMapURL;\r\n\r\n        if (IsPlainObject(key))\r\n        {\r\n            var config = key;\r\n\r\n            key = GetFastValue(config, 'key');\r\n            url = GetFastValue(config, 'url');\r\n            normalMapURL = GetFastValue(config, 'normalMap');\r\n            xhrSettings = GetFastValue(config, 'xhrSettings');\r\n            extension = GetFastValue(config, 'extension', extension);\r\n            frameConfig = GetFastValue(config, 'frameConfig');\r\n        }\r\n\r\n        if (Array.isArray(url))\r\n        {\r\n            normalMapURL = url[1];\r\n            url = url[0];\r\n        }\r\n\r\n        var fileConfig = {\r\n            type: 'image',\r\n            cache: loader.textureManager,\r\n            extension: extension,\r\n            responseType: 'blob',\r\n            key: key,\r\n            url: url,\r\n            xhrSettings: xhrSettings,\r\n            config: frameConfig\r\n        };\r\n\r\n        File.call(this, loader, fileConfig);\r\n\r\n        //  Do we have a normal map to load as well?\r\n        if (normalMapURL)\r\n        {\r\n            var normalMap = new ImageFile(loader, this.key, normalMapURL, xhrSettings, frameConfig);\r\n\r\n            normalMap.type = 'normalMap';\r\n\r\n            this.setLink(normalMap);\r\n\r\n            loader.addFile(normalMap);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically by Loader.nextFile.\r\n     * This method controls what extra work this File does with its loaded data.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#onProcess\r\n     * @since 3.7.0\r\n     */\r\n    onProcess: function ()\r\n    {\r\n        this.state = CONST.FILE_PROCESSING;\r\n\r\n        this.data = new Image();\r\n\r\n        this.data.crossOrigin = this.crossOrigin;\r\n\r\n        var _this = this;\r\n\r\n        this.data.onload = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessComplete();\r\n        };\r\n\r\n        this.data.onerror = function ()\r\n        {\r\n            File.revokeObjectURL(_this.data);\r\n\r\n            _this.onProcessError();\r\n        };\r\n\r\n        File.createObjectURL(this.data, this.xhrLoader.response, 'image/png');\r\n    },\r\n\r\n    /**\r\n     * Adds this file to its target cache upon successful loading and processing.\r\n     *\r\n     * @method Phaser.Loader.FileTypes.ImageFile#addToCache\r\n     * @since 3.7.0\r\n     */\r\n    addToCache: function ()\r\n    {\r\n        var texture;\r\n        var linkFile = this.linkFile;\r\n\r\n        if (linkFile && linkFile.state === CONST.FILE_COMPLETE)\r\n        {\r\n            if (this.type === 'image')\r\n            {\r\n                texture = this.cache.addImage(this.key, this.data, linkFile.data);\r\n            }\r\n            else\r\n            {\r\n                texture = this.cache.addImage(linkFile.key, linkFile.data, this.data);\r\n            }\r\n\r\n            this.pendingDestroy(texture);\r\n\r\n            linkFile.pendingDestroy(texture);\r\n        }\r\n        else if (!linkFile)\r\n        {\r\n            texture = this.cache.addImage(this.key, this.data);\r\n\r\n            this.pendingDestroy(texture);\r\n        }\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Adds an Image, or array of Images, to the current load queue.\r\n *\r\n * You can call this method from within your Scene's `preload`, along with any other files you wish to load:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.image('logo', 'images/phaserLogo.png');\r\n * }\r\n * ```\r\n *\r\n * The file is **not** loaded right away. It is added to a queue ready to be loaded either when the loader starts,\r\n * or if it's already running, when the next free load slot becomes available. This happens automatically if you\r\n * are calling this from within the Scene's `preload` method, or a related callback. Because the file is queued\r\n * it means you cannot use the file immediately after calling this method, but must wait for the file to complete.\r\n * The typical flow for a Phaser Scene is that you load assets in the Scene's `preload` method and then when the\r\n * Scene's `create` method is called you are guaranteed that all of those assets are ready for use and have been\r\n * loaded.\r\n *\r\n * Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.\r\n * If you try to load an animated gif only the first frame will be rendered. Browsers do not natively support playback\r\n * of animated gifs to Canvas elements.\r\n *\r\n * The key must be a unique String. It is used to add the file to the global Texture Manager upon a successful load.\r\n * The key should be unique both in terms of files being loaded and files already present in the Texture Manager.\r\n * Loading a file using a key that is already taken will result in a warning. If you wish to replace an existing file\r\n * then remove it from the Texture Manager first, before loading a new one.\r\n *\r\n * Instead of passing arguments you can pass a configuration object, such as:\r\n *\r\n * ```javascript\r\n * this.load.image({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png'\r\n * });\r\n * ```\r\n *\r\n * See the documentation for `Phaser.Types.Loader.FileTypes.ImageFileConfig` for more details.\r\n *\r\n * Once the file has finished loading you can use it as a texture for a Game Object by referencing its key:\r\n *\r\n * ```javascript\r\n * this.load.image('logo', 'images/AtariLogo.png');\r\n * // and later in your game ...\r\n * this.add.image(x, y, 'logo');\r\n * ```\r\n *\r\n * If you have specified a prefix in the loader, via `Loader.setPrefix` then this value will be prepended to this files\r\n * key. For example, if the prefix was `MENU.` and the key was `Background` the final key will be `MENU.Background` and\r\n * this is what you would use to retrieve the image from the Texture Manager.\r\n *\r\n * The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.\r\n *\r\n * If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is \"alien\"\r\n * and no URL is given then the Loader will set the URL to be \"alien.png\". It will always add `.png` as the extension, although\r\n * this can be overridden if using an object instead of method arguments. If you do not desire this action then provide a URL.\r\n *\r\n * Phaser also supports the automatic loading of associated normal maps. If you have a normal map to go with this image,\r\n * then you can specify it by providing an array as the `url` where the second element is the normal map:\r\n *\r\n * ```javascript\r\n * this.load.image('logo', [ 'images/AtariLogo.png', 'images/AtariLogo-n.png' ]);\r\n * ```\r\n *\r\n * Or, if you are using a config object use the `normalMap` property:\r\n *\r\n * ```javascript\r\n * this.load.image({\r\n *     key: 'logo',\r\n *     url: 'images/AtariLogo.png',\r\n *     normalMap: 'images/AtariLogo-n.png'\r\n * });\r\n * ```\r\n *\r\n * The normal map file is subject to the same conditions as the image file with regard to the path, baseURL, CORs and XHR Settings.\r\n * Normal maps are a WebGL only feature.\r\n *\r\n * Note: The ability to load this type of file will only be available if the Image File type has been built into Phaser.\r\n * It is available in the default build but can be excluded from custom builds.\r\n *\r\n * @method Phaser.Loader.LoaderPlugin#image\r\n * @fires Phaser.Loader.LoaderPlugin#ADD\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Types.Loader.FileTypes.ImageFileConfig|Phaser.Types.Loader.FileTypes.ImageFileConfig[])} key - The key to use for this file, or a file configuration object, or array of them.\r\n * @param {string|string[]} [url] - The absolute or relative URL to load this file from. If undefined or `null` it will be set to `<key>.png`, i.e. if `key` was \"alien\" then the URL will be \"alien.png\".\r\n * @param {Phaser.Types.Loader.XHRSettingsObject} [xhrSettings] - An XHR Settings configuration object. Used in replacement of the Loaders default XHR Settings.\r\n *\r\n * @return {this} The Loader instance.\r\n */\r\nFileTypesManager.register('image', function (key, url, xhrSettings)\r\n{\r\n    if (Array.isArray(key))\r\n    {\r\n        for (var i = 0; i < key.length; i++)\r\n        {\r\n            //  If it's an array it has to be an array of Objects, so we get everything out of the 'key' object\r\n            this.addFile(new ImageFile(this, key[i]));\r\n        }\r\n    }\r\n    else\r\n    {\r\n        this.addFile(new ImageFile(this, key, url, xhrSettings));\r\n    }\r\n\r\n    return this;\r\n});\r\n\r\nmodule.exports = ImageFile;\r\n"],"sourceRoot":""}