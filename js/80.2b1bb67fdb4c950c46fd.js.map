{"version":3,"file":"js/80.2b1bb67fdb4c950c46fd.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/group/Group.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/image/Image.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/image/ImageCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/image/ImageRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/image/ImageWebGLRenderer.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Actions = require('../../actions/');\r\nvar Class = require('../../utils/Class');\r\nvar Events = require('../events');\r\nvar EventEmitter = require('eventemitter3');\r\nvar GetAll = require('../../utils/array/GetAll');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar Range = require('../../utils/array/Range');\r\nvar Set = require('../../structs/Set');\r\nvar Sprite = require('../sprite/Sprite');\r\n\r\n/**\r\n * @classdesc\r\n * A Group is a way for you to create, manipulate, or recycle similar Game Objects.\r\n *\r\n * Group membership is non-exclusive. A Game Object can belong to several groups, one group, or none.\r\n *\r\n * Groups themselves aren't displayable, and can't be positioned, rotated, scaled, or hidden.\r\n *\r\n * @class Group\r\n * @memberof Phaser.GameObjects\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n * @param {Phaser.Scene} scene - The scene this group belongs to.\r\n * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.\r\n * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group. If `key` is set, Phaser.GameObjects.Group#createMultiple is also called with these settings.\r\n *\r\n * @see Phaser.Physics.Arcade.Group\r\n * @see Phaser.Physics.Arcade.StaticGroup\r\n */\r\nvar Group = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function Group (scene, children, config)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        //  They can pass in any of the following as the first argument:\r\n\r\n        //  1) A single child\r\n        //  2) An array of children\r\n        //  3) A config object\r\n        //  4) An array of config objects\r\n\r\n        //  Or they can pass in a child, or array of children AND a config object\r\n\r\n        if (config)\r\n        {\r\n            //  config has been set, are the children an array?\r\n\r\n            if (children && !Array.isArray(children))\r\n            {\r\n                children = [ children ];\r\n            }\r\n        }\r\n        else if (Array.isArray(children))\r\n        {\r\n            //  No config, so let's check the children argument\r\n\r\n            if (IsPlainObject(children[0]))\r\n            {\r\n                //  It's an array of plain config objects\r\n                config = children;\r\n                children = null;\r\n            }\r\n        }\r\n        else if (IsPlainObject(children))\r\n        {\r\n            //  Children isn't an array. Is it a config object though?\r\n            config = children;\r\n            children = null;\r\n        }\r\n\r\n        /**\r\n         * This scene this group belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.Group#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Members of this group.\r\n         *\r\n         * @name Phaser.GameObjects.Group#children\r\n         * @type {Phaser.Structs.Set.<Phaser.GameObjects.GameObject>}\r\n         * @since 3.0.0\r\n         */\r\n        this.children = new Set();\r\n\r\n        /**\r\n         * A flag identifying this object as a group.\r\n         *\r\n         * @name Phaser.GameObjects.Group#isParent\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.isParent = true;\r\n\r\n        /**\r\n         * A textual representation of this Game Object.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.GameObjects.Group#type\r\n         * @type {string}\r\n         * @default 'Group'\r\n         * @since 3.21.0\r\n         */\r\n        this.type = 'Group';\r\n\r\n        /**\r\n         * The class to create new group members from.\r\n         *\r\n         * @name Phaser.GameObjects.Group#classType\r\n         * @type {Function}\r\n         * @since 3.0.0\r\n         * @default Phaser.GameObjects.Sprite\r\n         */\r\n        this.classType = GetFastValue(config, 'classType', Sprite);\r\n\r\n        /**\r\n         * The name of this group.\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.Group#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.18.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', '');\r\n\r\n        /**\r\n         * Whether this group runs its {@link Phaser.GameObjects.Group#preUpdate} method (which may update any members).\r\n         *\r\n         * @name Phaser.GameObjects.Group#active\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.active = GetFastValue(config, 'active', true);\r\n\r\n        /**\r\n         * The maximum size of this group, if used as a pool. -1 is no limit.\r\n         *\r\n         * @name Phaser.GameObjects.Group#maxSize\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         * @default -1\r\n         */\r\n        this.maxSize = GetFastValue(config, 'maxSize', -1);\r\n\r\n        /**\r\n         * A default texture key to use when creating new group members.\r\n         *\r\n         * This is used in {@link Phaser.GameObjects.Group#create}\r\n         * but not in {@link Phaser.GameObjects.Group#createMultiple}.\r\n         *\r\n         * @name Phaser.GameObjects.Group#defaultKey\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultKey = GetFastValue(config, 'defaultKey', null);\r\n\r\n        /**\r\n         * A default texture frame to use when creating new group members.\r\n         *\r\n         * @name Phaser.GameObjects.Group#defaultFrame\r\n         * @type {(string|number)}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultFrame = GetFastValue(config, 'defaultFrame', null);\r\n\r\n        /**\r\n         * Whether to call the update method of any members.\r\n         *\r\n         * @name Phaser.GameObjects.Group#runChildUpdate\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Group#preUpdate\r\n         */\r\n        this.runChildUpdate = GetFastValue(config, 'runChildUpdate', false);\r\n\r\n        /**\r\n         * A function to be called when adding or creating group members.\r\n         *\r\n         * @name Phaser.GameObjects.Group#createCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.createCallback = GetFastValue(config, 'createCallback', null);\r\n\r\n        /**\r\n         * A function to be called when removing group members.\r\n         *\r\n         * @name Phaser.GameObjects.Group#removeCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.removeCallback = GetFastValue(config, 'removeCallback', null);\r\n\r\n        /**\r\n         * A function to be called when creating several group members at once.\r\n         *\r\n         * @name Phaser.GameObjects.Group#createMultipleCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupMultipleCreateCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.createMultipleCallback = GetFastValue(config, 'createMultipleCallback', null);\r\n\r\n        /**\r\n         * A function to be called when adding or creating group members.\r\n         * For internal use only by a Group, or any class that extends it.\r\n         *\r\n         * @name Phaser.GameObjects.Group#internalCreateCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n         * @private\r\n         * @since 3.22.0\r\n         */\r\n        this.internalCreateCallback = GetFastValue(config, 'internalCreateCallback', null);\r\n\r\n        /**\r\n         * A function to be called when removing group members.\r\n         * For internal use only by a Group, or any class that extends it.\r\n         *\r\n         * @name Phaser.GameObjects.Group#internalRemoveCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n         * @private\r\n         * @since 3.22.0\r\n         */\r\n        this.internalRemoveCallback = GetFastValue(config, 'internalRemoveCallback', null);\r\n\r\n        if (children)\r\n        {\r\n            this.addMultiple(children);\r\n        }\r\n\r\n        if (config)\r\n        {\r\n            this.createMultiple(config);\r\n        }\r\n\r\n        this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);\r\n        this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * Creates a new Game Object and adds it to this group, unless the group {@link Phaser.GameObjects.Group#isFull is full}.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#createCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal position of the new Game Object in the world.\r\n     * @param {number} [y=0] - The vertical position of the new Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key of the new Game Object.\r\n     * @param {(string|number)} [frame=defaultFrame] - The texture frame of the new Game Object.\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of the new Game Object.\r\n     * @param {boolean} [active=true] - The {@link Phaser.GameObjects.GameObject#active} state of the new Game Object.\r\n     *\r\n     * @return {any} The new Game Object (usually a Sprite, etc.).\r\n     */\r\n    create: function (x, y, key, frame, visible, active)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (key === undefined) { key = this.defaultKey; }\r\n        if (frame === undefined) { frame = this.defaultFrame; }\r\n        if (visible === undefined) { visible = true; }\r\n        if (active === undefined) { active = true; }\r\n\r\n        //  Pool?\r\n        if (this.isFull())\r\n        {\r\n            return null;\r\n        }\r\n\r\n        var child = new this.classType(this.scene, x, y, key, frame);\r\n\r\n        child.addToDisplayList(this.scene.sys.displayList);\r\n        child.addToUpdateList();\r\n\r\n        child.visible = visible;\r\n        child.setActive(active);\r\n\r\n        this.add(child);\r\n\r\n        return child;\r\n    },\r\n\r\n    /**\r\n     * Creates several Game Objects and adds them to this group.\r\n     *\r\n     * If the group becomes {@link Phaser.GameObjects.Group#isFull}, no further Game Objects are created.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#createMultipleCallback} and {@link Phaser.GameObjects.Group#createCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#createMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Group.GroupCreateConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig[]} config - Creation settings. This can be a single configuration object or an array of such objects, which will be applied in turn.\r\n     *\r\n     * @return {any[]} The newly created Game Objects.\r\n     */\r\n    createMultiple: function (config)\r\n    {\r\n        if (this.isFull())\r\n        {\r\n            return [];\r\n        }\r\n\r\n        if (!Array.isArray(config))\r\n        {\r\n            config = [ config ];\r\n        }\r\n\r\n        var output = [];\r\n\r\n        if (config[0].key)\r\n        {\r\n            for (var i = 0; i < config.length; i++)\r\n            {\r\n                var entries = this.createFromConfig(config[i]);\r\n\r\n                output = output.concat(entries);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * A helper for {@link Phaser.GameObjects.Group#createMultiple}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#createFromConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Group.GroupCreateConfig} options - Creation settings.\r\n     *\r\n     * @return {any[]} The newly created Game Objects.\r\n     */\r\n    createFromConfig: function (options)\r\n    {\r\n        if (this.isFull())\r\n        {\r\n            return [];\r\n        }\r\n\r\n        this.classType = GetFastValue(options, 'classType', this.classType);\r\n\r\n        var key = GetFastValue(options, 'key', undefined);\r\n        var frame = GetFastValue(options, 'frame', null);\r\n        var visible = GetFastValue(options, 'visible', true);\r\n        var active = GetFastValue(options, 'active', true);\r\n\r\n        var entries = [];\r\n\r\n        //  Can't do anything without at least a key\r\n        if (key === undefined)\r\n        {\r\n            return entries;\r\n        }\r\n        else\r\n        {\r\n            if (!Array.isArray(key))\r\n            {\r\n                key = [ key ];\r\n            }\r\n\r\n            if (!Array.isArray(frame))\r\n            {\r\n                frame = [ frame ];\r\n            }\r\n        }\r\n\r\n        //  Build an array of key frame pairs to loop through\r\n\r\n        var repeat = GetFastValue(options, 'repeat', 0);\r\n        var randomKey = GetFastValue(options, 'randomKey', false);\r\n        var randomFrame = GetFastValue(options, 'randomFrame', false);\r\n        var yoyo = GetFastValue(options, 'yoyo', false);\r\n        var quantity = GetFastValue(options, 'quantity', false);\r\n        var frameQuantity = GetFastValue(options, 'frameQuantity', 1);\r\n        var max = GetFastValue(options, 'max', 0);\r\n\r\n        //  If a quantity value is set we use that to override the frameQuantity\r\n\r\n        var range = Range(key, frame, {\r\n            max: max,\r\n            qty: (quantity) ? quantity : frameQuantity,\r\n            random: randomKey,\r\n            randomB: randomFrame,\r\n            repeat: repeat,\r\n            yoyo: yoyo\r\n        });\r\n\r\n        if (options.createCallback)\r\n        {\r\n            this.createCallback = options.createCallback;\r\n        }\r\n\r\n        if (options.removeCallback)\r\n        {\r\n            this.removeCallback = options.removeCallback;\r\n        }\r\n\r\n        for (var c = 0; c < range.length; c++)\r\n        {\r\n            var created = this.create(0, 0, range[c].a, range[c].b, visible, active);\r\n\r\n            if (!created)\r\n            {\r\n                break;\r\n            }\r\n\r\n            entries.push(created);\r\n        }\r\n\r\n        //  Post-creation options (applied only to those items created in this call):\r\n\r\n        var x = GetValue(options, 'setXY.x', 0);\r\n        var y = GetValue(options, 'setXY.y', 0);\r\n        var stepX = GetValue(options, 'setXY.stepX', 0);\r\n        var stepY = GetValue(options, 'setXY.stepY', 0);\r\n\r\n        Actions.SetXY(entries, x, y, stepX, stepY);\r\n\r\n        var rotation = GetValue(options, 'setRotation.value', 0);\r\n        var stepRotation = GetValue(options, 'setRotation.step', 0);\r\n\r\n        Actions.SetRotation(entries, rotation, stepRotation);\r\n\r\n        var scaleX = GetValue(options, 'setScale.x', 1);\r\n        var scaleY = GetValue(options, 'setScale.y', scaleX);\r\n        var stepScaleX = GetValue(options, 'setScale.stepX', 0);\r\n        var stepScaleY = GetValue(options, 'setScale.stepY', 0);\r\n\r\n        Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);\r\n\r\n        var originX = GetValue(options, 'setOrigin.x', 0.5);\r\n        var originY = GetValue(options, 'setOrigin.y', originX);\r\n        var stepOriginX = GetValue(options, 'setOrigin.stepX', 0);\r\n        var stepOriginY = GetValue(options, 'setOrigin.stepY', 0);\r\n\r\n        Actions.SetOrigin(entries, originX, originY, stepOriginX, stepOriginY);\r\n\r\n        var alpha = GetValue(options, 'setAlpha.value', 1);\r\n        var stepAlpha = GetValue(options, 'setAlpha.step', 0);\r\n\r\n        Actions.SetAlpha(entries, alpha, stepAlpha);\r\n\r\n        var depth = GetValue(options, 'setDepth.value', 0);\r\n        var stepDepth = GetValue(options, 'setDepth.step', 0);\r\n\r\n        Actions.SetDepth(entries, depth, stepDepth);\r\n\r\n        var scrollFactorX = GetValue(options, 'setScrollFactor.x', 1);\r\n        var scrollFactorY = GetValue(options, 'setScrollFactor.y', scrollFactorX);\r\n        var stepScrollFactorX = GetValue(options, 'setScrollFactor.stepX', 0);\r\n        var stepScrollFactorY = GetValue(options, 'setScrollFactor.stepY', 0);\r\n\r\n        Actions.SetScrollFactor(entries, scrollFactorX, scrollFactorY, stepScrollFactorX, stepScrollFactorY);\r\n\r\n        var hitArea = GetFastValue(options, 'hitArea', null);\r\n        var hitAreaCallback = GetFastValue(options, 'hitAreaCallback', null);\r\n\r\n        if (hitArea)\r\n        {\r\n            Actions.SetHitArea(entries, hitArea, hitAreaCallback);\r\n        }\r\n\r\n        var grid = GetFastValue(options, 'gridAlign', false);\r\n\r\n        if (grid)\r\n        {\r\n            Actions.GridAlign(entries, grid);\r\n        }\r\n\r\n        if (this.createMultipleCallback)\r\n        {\r\n            this.createMultipleCallback.call(this, entries);\r\n        }\r\n\r\n        return entries;\r\n    },\r\n\r\n    /**\r\n     * Updates any group members, if {@link Phaser.GameObjects.Group#runChildUpdate} is enabled.\r\n     *\r\n     * @method Phaser.GameObjects.Group#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time elapsed since the last frame.\r\n     */\r\n    preUpdate: function (time, delta)\r\n    {\r\n        if (!this.runChildUpdate || this.children.size === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Because a Group child may mess with the length of the Group during its update\r\n        var temp = this.children.entries.slice();\r\n\r\n        for (var i = 0; i < temp.length; i++)\r\n        {\r\n            var item = temp[i];\r\n\r\n            if (item.active)\r\n            {\r\n                item.update(time, delta);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a Game Object to this group.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#createCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.\r\n     * @param {boolean} [addToScene=false] - Also add the Game Object to the scene.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    add: function (child, addToScene)\r\n    {\r\n        if (addToScene === undefined) { addToScene = false; }\r\n\r\n        if (this.isFull())\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.children.set(child);\r\n\r\n        if (this.internalCreateCallback)\r\n        {\r\n            this.internalCreateCallback.call(this, child);\r\n        }\r\n\r\n        if (this.createCallback)\r\n        {\r\n            this.createCallback.call(this, child);\r\n        }\r\n\r\n        if (addToScene)\r\n        {\r\n            child.addToDisplayList(this.scene.sys.displayList);\r\n            child.addToUpdateList();\r\n        }\r\n\r\n        child.on(Events.DESTROY, this.remove, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds several Game Objects to this group.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#createCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#addMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} children - The Game Objects to add.\r\n     * @param {boolean} [addToScene=false] - Also add the Game Objects to the scene.\r\n     *\r\n     * @return {this} This group.\r\n     */\r\n    addMultiple: function (children, addToScene)\r\n    {\r\n        if (addToScene === undefined) { addToScene = false; }\r\n\r\n        if (Array.isArray(children))\r\n        {\r\n            for (var i = 0; i < children.length; i++)\r\n            {\r\n                this.add(children[i], addToScene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a member of this Group and optionally removes it from the Scene and / or destroys it.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#removeCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.\r\n     * @param {boolean} [removeFromScene=false] - Optionally remove the Group member from the Scene it belongs to.\r\n     * @param {boolean} [destroyChild=false] - Optionally call destroy on the removed Group member.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    remove: function (child, removeFromScene, destroyChild)\r\n    {\r\n        if (removeFromScene === undefined) { removeFromScene = false; }\r\n        if (destroyChild === undefined) { destroyChild = false; }\r\n\r\n        if (!this.children.contains(child))\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.children.delete(child);\r\n\r\n        if (this.internalRemoveCallback)\r\n        {\r\n            this.internalRemoveCallback.call(this, child);\r\n        }\r\n\r\n        if (this.removeCallback)\r\n        {\r\n            this.removeCallback.call(this, child);\r\n        }\r\n\r\n        child.off(Events.DESTROY, this.remove, this);\r\n\r\n        if (destroyChild)\r\n        {\r\n            child.destroy();\r\n        }\r\n        else if (removeFromScene)\r\n        {\r\n            child.removeFromDisplayList();\r\n            child.removeFromUpdateList();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all members of this Group and optionally removes them from the Scene and / or destroys them.\r\n     *\r\n     * Does not call {@link Phaser.GameObjects.Group#removeCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [removeFromScene=false] - Optionally remove each Group member from the Scene.\r\n     * @param {boolean} [destroyChild=false] - Optionally call destroy on the removed Group members.\r\n     *\r\n     * @return {this} This group.\r\n     */\r\n    clear: function (removeFromScene, destroyChild)\r\n    {\r\n        if (removeFromScene === undefined) { removeFromScene = false; }\r\n        if (destroyChild === undefined) { destroyChild = false; }\r\n\r\n        var children = this.children;\r\n\r\n        for (var i = 0; i < children.size; i++)\r\n        {\r\n            var gameObject = children.entries[i];\r\n\r\n            gameObject.off(Events.DESTROY, this.remove, this);\r\n\r\n            if (destroyChild)\r\n            {\r\n                gameObject.destroy();\r\n            }\r\n            else if (removeFromScene)\r\n            {\r\n                gameObject.removeFromDisplayList();\r\n                gameObject.removeFromUpdateList();\r\n            }\r\n        }\r\n\r\n        this.children.clear();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Tests if a Game Object is a member of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - A Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object is a member of this group.\r\n     */\r\n    contains: function (child)\r\n    {\r\n        return this.children.contains(child);\r\n    },\r\n\r\n    /**\r\n     * All members of the group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getChildren\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The group members.\r\n     */\r\n    getChildren: function ()\r\n    {\r\n        return this.children.entries;\r\n    },\r\n\r\n    /**\r\n     * The number of members of the group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number}\r\n     */\r\n    getLength: function ()\r\n    {\r\n        return this.children.size;\r\n    },\r\n\r\n    /**\r\n     * Returns all children in this Group that match the given criteria based on the `property` and `value` arguments.\r\n     *\r\n     * For example: `getMatching('visible', true)` would return only children that have their `visible` property set.\r\n     *\r\n     * Optionally, you can specify a start and end index. For example if the Group has 100 elements,\r\n     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n     * the first 50.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getMatching\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} [property] - The property to test on each array element.\r\n     * @param {*} [value] - The value to test the property against. Must pass a strict (`===`) comparison check.\r\n     * @param {number} [startIndex] - An optional start index to search from.\r\n     * @param {number} [endIndex] - An optional end index to search to.\r\n     *\r\n     * @return {any[]} An array of matching Group members. The array will be empty if nothing matched.\r\n     */\r\n    getMatching: function (property, value, startIndex, endIndex)\r\n    {\r\n        return GetAll(this.children.entries, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Scans the Group, from top to bottom, for the first member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirst\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getFirst: function (state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getHandler(true, 1, state, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the Group, from top to bottom, for the nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirstNth\r\n     * @since 3.6.0\r\n     *\r\n     * @param {number} nth - The nth matching Group member to search for.\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getFirstNth: function (nth, state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getHandler(true, nth, state, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the Group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getLast\r\n     * @since 3.6.0\r\n     *\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getLast: function (state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getHandler(false, 1, state, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the Group for the last nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getLastNth\r\n     * @since 3.6.0\r\n     *\r\n     * @param {number} nth - The nth matching Group member to search for.\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getLastNth: function (nth, state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getHandler(false, nth, state, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getHandler\r\n     * @private\r\n     * @since 3.6.0\r\n     *\r\n     * @param {boolean} forwards - Search front to back or back to front?\r\n     * @param {number} nth - Stop matching after nth successful matches.\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getHandler: function (forwards, nth, state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        if (state === undefined) { state = false; }\r\n        if (createIfNull === undefined) { createIfNull = false; }\r\n\r\n        var gameObject;\r\n\r\n        var i;\r\n        var total = 0;\r\n        var children = this.children.entries;\r\n\r\n        if (forwards)\r\n        {\r\n            for (i = 0; i < children.length; i++)\r\n            {\r\n                gameObject = children[i];\r\n\r\n                if (gameObject.active === state)\r\n                {\r\n                    total++;\r\n\r\n                    if (total === nth)\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    gameObject = null;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (i = children.length - 1; i >= 0; i--)\r\n            {\r\n                gameObject = children[i];\r\n\r\n                if (gameObject.active === state)\r\n                {\r\n                    total++;\r\n\r\n                    if (total === nth)\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    gameObject = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (gameObject)\r\n        {\r\n            if (typeof(x) === 'number')\r\n            {\r\n                gameObject.x = x;\r\n            }\r\n\r\n            if (typeof(y) === 'number')\r\n            {\r\n                gameObject.y = y;\r\n            }\r\n\r\n            return gameObject;\r\n        }\r\n\r\n        //  Got this far? We need to create or bail\r\n        if (createIfNull)\r\n        {\r\n            return this.create(x, y, key, frame, visible);\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no inactive member is found and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * The new Game Object will have its active state set to `true`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first inactive group member, or a newly created member, or null.\r\n     */\r\n    get: function (x, y, key, frame, visible)\r\n    {\r\n        return this.getFirst(false, true, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `true`,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no active member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirstAlive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {any} The first active group member, or a newly created member, or null.\r\n     */\r\n    getFirstAlive: function (createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getFirst(true, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no inactive member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * The new Game Object will have an active state set to `true`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirstDead\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {any} The first inactive group member, or a newly created member, or null.\r\n     */\r\n    getFirstDead: function (createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getFirst(false, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * {@link Phaser.GameObjects.Components.Animation#play Plays} an animation for all members of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#playAnimation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The string-based key of the animation to play.\r\n     * @param {string} [startFrame=0] - Optionally start the animation playing from this frame index.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    playAnimation: function (key, startFrame)\r\n    {\r\n        Actions.PlayAnimation(this.children.entries, key, startFrame);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Whether this group's size at its {@link Phaser.GameObjects.Group#maxSize maximum}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#isFull\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if the number of members equals {@link Phaser.GameObjects.Group#maxSize}.\r\n     */\r\n    isFull: function ()\r\n    {\r\n        if (this.maxSize === -1)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return (this.children.size >= this.maxSize);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Counts the number of active (or inactive) group members.\r\n     *\r\n     * @method Phaser.GameObjects.Group#countActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - Count active (true) or inactive (false) group members.\r\n     *\r\n     * @return {number} The number of group members with an active state matching the `active` argument.\r\n     */\r\n    countActive: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        var total = 0;\r\n\r\n        for (var i = 0; i < this.children.size; i++)\r\n        {\r\n            if (this.children.entries[i].active === value)\r\n            {\r\n                total++;\r\n            }\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * Counts the number of in-use (active) group members.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getTotalUsed\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The number of group members with an active state of true.\r\n     */\r\n    getTotalUsed: function ()\r\n    {\r\n        return this.countActive();\r\n    },\r\n\r\n    /**\r\n     * The difference of {@link Phaser.GameObjects.Group#maxSize} and the number of active group members.\r\n     *\r\n     * This represents the number of group members that could be created or reactivated before reaching the size limit.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getTotalFree\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} maxSize minus the number of active group numbers; or a large number (if maxSize is -1).\r\n     */\r\n    getTotalFree: function ()\r\n    {\r\n        var used = this.getTotalUsed();\r\n        var capacity = (this.maxSize === -1) ? 999999999999 : this.maxSize;\r\n\r\n        return (capacity - used);\r\n    },\r\n\r\n    /**\r\n     * Sets the `active` property of this Group.\r\n     * When active, this Group runs its `preUpdate` method.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setActive\r\n     * @since 3.24.0\r\n     *\r\n     * @param {boolean} value - True if this Group should be set as active, false if not.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setActive: function (value)\r\n    {\r\n        this.active = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `name` property of this Group.\r\n     * The `name` property is not populated by Phaser and is presented for your own use.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setName\r\n     * @since 3.24.0\r\n     *\r\n     * @param {string} value - The name to be given to this Group.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setName: function (value)\r\n    {\r\n        this.name = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the property as defined in `key` of each group member to the given value.\r\n     *\r\n     * @method Phaser.GameObjects.Group#propertyValueSet\r\n     * @since 3.21.0\r\n     *\r\n     * @param {string} key - The property to be updated.\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n     * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    propertyValueSet: function (key, value, step, index, direction)\r\n    {\r\n        Actions.PropertyValueSet(this.children.entries, key, value, step, index, direction);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given value to the property as defined in `key` of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#propertyValueInc\r\n     * @since 3.21.0\r\n     *\r\n     * @param {string} key - The property to be updated.\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n     * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    propertyValueInc: function (key, value, step, index, direction)\r\n    {\r\n        Actions.PropertyValueInc(this.children.entries, key, value, step, index, direction);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the x of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setX\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setX: function (value, step)\r\n    {\r\n        Actions.SetX(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the y of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setY: function (value, step)\r\n    {\r\n        Actions.SetY(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the x, y of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setXY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} x - The amount to set the `x` property to.\r\n     * @param {number} [y=x] - The amount to set the `y` property to. If `undefined` or `null` it uses the `x` value.\r\n     * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.\r\n     * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setXY: function (x, y, stepX, stepY)\r\n    {\r\n        Actions.SetXY(this.children.entries, x, y, stepX, stepY);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given value to the x of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#incX\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to be added to the `x` property.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    incX: function (value, step)\r\n    {\r\n        Actions.IncX(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given value to the y of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#incY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to be added to the `y` property.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    incY: function (value, step)\r\n    {\r\n        Actions.IncY(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given value to the x, y of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#incXY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} x - The amount to be added to the `x` property.\r\n     * @param {number} [y=x] - The amount to be added to the `y` property. If `undefined` or `null` it uses the `x` value.\r\n     * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.\r\n     * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    incXY: function (x, y, stepX, stepY)\r\n    {\r\n        Actions.IncXY(this.children.entries, x, y, stepX, stepY);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Iterate through the group members changing the position of each element to be that of the element that came before\r\n     * it in the array (or after it if direction = 1)\r\n     *\r\n     * The first group member position is set to x/y.\r\n     *\r\n     * @method Phaser.GameObjects.Group#shiftPosition\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} x - The x coordinate to place the first item in the array at.\r\n     * @param {number} y - The y coordinate to place the first item in the array at.\r\n     * @param {number} [direction=0] - The iteration direction. 0 = first to last and 1 = last to first.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    shiftPosition: function (x, y, direction)\r\n    {\r\n        Actions.ShiftPosition(this.children.entries, x, y, direction);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angle of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#angle\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the angle to, in degrees.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    angle: function (value, step)\r\n    {\r\n        Actions.Angle(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the rotation of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#rotate\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the rotation to, in radians.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    rotate: function (value, step)\r\n    {\r\n        Actions.Rotate(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotates each group member around the given point by the given angle.\r\n     *\r\n     * @method Phaser.GameObjects.Group#rotateAround\r\n     * @since 3.21.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} point - Any object with public `x` and `y` properties.\r\n     * @param {number} angle - The angle to rotate by, in radians.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    rotateAround: function (point, angle)\r\n    {\r\n        Actions.RotateAround(this.children.entries, point, angle);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotates each group member around the given point by the given angle and distance.\r\n     *\r\n     * @method Phaser.GameObjects.Group#rotateAroundDistance\r\n     * @since 3.21.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} point - Any object with public `x` and `y` properties.\r\n     * @param {number} angle - The angle to rotate by, in radians.\r\n     * @param {number} distance - The distance from the point of rotation in pixels.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    rotateAroundDistance: function (point, angle, distance)\r\n    {\r\n        Actions.RotateAroundDistance(this.children.entries, point, angle, distance);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the alpha of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setAlpha\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the alpha to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setAlpha: function (value, step)\r\n    {\r\n        Actions.SetAlpha(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tint of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setTint\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} topLeft - The tint being applied to top-left corner of item. If other parameters are given no value, this tint will be applied to whole item.\r\n     * @param {number} [topRight] - The tint to be applied to top-right corner of item.\r\n     * @param {number} [bottomLeft] - The tint to be applied to the bottom-left corner of item.\r\n     * @param {number} [bottomRight] - The tint to be applied to the bottom-right corner of item.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setTint: function (topLeft, topRight, bottomLeft, bottomRight)\r\n    {\r\n        Actions.SetTint(this.children.entries, topLeft, topRight, bottomLeft, bottomRight);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the originX, originY of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setOrigin\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} originX - The amount to set the `originX` property to.\r\n     * @param {number} [originY] - The amount to set the `originY` property to. If `undefined` or `null` it uses the `originX` value.\r\n     * @param {number} [stepX=0] - This is added to the `originX` amount, multiplied by the iteration counter.\r\n     * @param {number} [stepY=0] - This is added to the `originY` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setOrigin: function (originX, originY, stepX, stepY)\r\n    {\r\n        Actions.SetOrigin(this.children.entries, originX, originY, stepX, stepY);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scaleX of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#scaleX\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    scaleX: function (value, step)\r\n    {\r\n        Actions.ScaleX(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scaleY of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#scaleY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    scaleY: function (value, step)\r\n    {\r\n        Actions.ScaleY(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scaleX, scaleY of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#scaleXY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} scaleX - The amount to be added to the `scaleX` property.\r\n     * @param {number} [scaleY] - The amount to be added to the `scaleY` property. If `undefined` or `null` it uses the `scaleX` value.\r\n     * @param {number} [stepX=0] - This is added to the `scaleX` amount, multiplied by the iteration counter.\r\n     * @param {number} [stepY=0] - This is added to the `scaleY` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    scaleXY: function (scaleX, scaleY, stepX, stepY)\r\n    {\r\n        Actions.ScaleXY(this.children.entries, scaleX, scaleY, stepX, stepY);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the depth of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setDepth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setDepth: function (value, step)\r\n    {\r\n        Actions.SetDepth(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the blendMode of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setBlendMode\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setBlendMode: function (value)\r\n    {\r\n        Actions.SetBlendMode(this.children.entries, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes all group members to the Input Manager to enable them for input with identical areas and callbacks.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setHitArea\r\n     * @since 3.21.0\r\n     *\r\n     * @param {*} hitArea - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} hitAreaCallback - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setHitArea: function (hitArea, hitAreaCallback)\r\n    {\r\n        Actions.SetHitArea(this.children.entries, hitArea, hitAreaCallback);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the group members in place.\r\n     *\r\n     * @method Phaser.GameObjects.Group#shuffle\r\n     * @since 3.21.0\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    shuffle: function ()\r\n    {\r\n        Actions.Shuffle(this.children.entries);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deactivates a member of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#kill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - A member of this group.\r\n     */\r\n    kill: function (gameObject)\r\n    {\r\n        if (this.children.contains(gameObject))\r\n        {\r\n            gameObject.setActive(false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Deactivates and hides a member of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#killAndHide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - A member of this group.\r\n     */\r\n    killAndHide: function (gameObject)\r\n    {\r\n        if (this.children.contains(gameObject))\r\n        {\r\n            gameObject.setActive(false);\r\n            gameObject.setVisible(false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the visible of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setVisible\r\n     * @since 3.21.0\r\n     *\r\n     * @param {boolean} value - The value to set the property to.\r\n     * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n     * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setVisible: function (value, index, direction)\r\n    {\r\n        Actions.SetVisible(this.children.entries, value, index, direction);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Toggles (flips) the visible state of each member of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#toggleVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    toggleVisible: function ()\r\n    {\r\n        Actions.ToggleVisible(this.children.entries);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Empties this Group of all children and removes it from the Scene.\r\n     *\r\n     * Does not call {@link Phaser.GameObjects.Group#removeCallback}.\r\n     *\r\n     * Children of this Group will _not_ be removed from the Scene by calling this method\r\n     * unless you specify the `removeFromScene` parameter.\r\n     *\r\n     * Children of this Group will also _not_ be destroyed by calling this method\r\n     * unless you specify the `destroyChildren` parameter.\r\n     *\r\n     * @method Phaser.GameObjects.Group#destroy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [destroyChildren=false] - Also {@link Phaser.GameObjects.GameObject#destroy} each Group member.\r\n     * @param {boolean} [removeFromScene=false] - Optionally remove each Group member from the Scene.\r\n     */\r\n    destroy: function (destroyChildren, removeFromScene)\r\n    {\r\n        if (destroyChildren === undefined) { destroyChildren = false; }\r\n        if (removeFromScene === undefined) { removeFromScene = false; }\r\n\r\n        //  This Game Object had already been destroyed\r\n        if (!this.scene || this.ignoreDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.emit(Events.DESTROY, this);\r\n\r\n        this.removeAllListeners();\r\n\r\n        this.scene.sys.updateList.remove(this);\r\n\r\n        this.clear(removeFromScene, destroyChildren);\r\n\r\n        this.scene = undefined;\r\n        this.children = undefined;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Group;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar Components = require('../components');\nvar GameObject = require('../GameObject');\nvar ImageRender = require('./ImageRender');\n\n/**\n * @classdesc\n * An Image Game Object.\n *\n * An Image is a light-weight Game Object useful for the display of static images in your game,\n * such as logos, backgrounds, scenery or other non-animated elements. Images can have input\n * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an\n * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.\n *\n * @class Image\n * @extends Phaser.GameObjects.GameObject\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @extends Phaser.GameObjects.Components.Alpha\n * @extends Phaser.GameObjects.Components.BlendMode\n * @extends Phaser.GameObjects.Components.Depth\n * @extends Phaser.GameObjects.Components.Flip\n * @extends Phaser.GameObjects.Components.GetBounds\n * @extends Phaser.GameObjects.Components.Mask\n * @extends Phaser.GameObjects.Components.Origin\n * @extends Phaser.GameObjects.Components.Pipeline\n * @extends Phaser.GameObjects.Components.ScrollFactor\n * @extends Phaser.GameObjects.Components.Size\n * @extends Phaser.GameObjects.Components.TextureCrop\n * @extends Phaser.GameObjects.Components.Tint\n * @extends Phaser.GameObjects.Components.Transform\n * @extends Phaser.GameObjects.Components.Visible\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n */\nvar Image = new Class({\n\n    Extends: GameObject,\n\n    Mixins: [\n        Components.Alpha,\n        Components.BlendMode,\n        Components.Depth,\n        Components.Flip,\n        Components.GetBounds,\n        Components.Mask,\n        Components.Origin,\n        Components.Pipeline,\n        Components.ScrollFactor,\n        Components.Size,\n        Components.TextureCrop,\n        Components.Tint,\n        Components.Transform,\n        Components.Visible,\n        ImageRender\n    ],\n\n    initialize:\n\n    function Image (scene, x, y, texture, frame)\n    {\n        GameObject.call(this, scene, 'Image');\n\n        /**\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\n         *\n         * @name Phaser.GameObjects.Image#_crop\n         * @type {object}\n         * @private\n         * @since 3.11.0\n         */\n        this._crop = this.resetCropObject();\n\n        this.setTexture(texture, frame);\n        this.setPosition(x, y);\n        this.setSizeToFrame();\n        this.setOriginFromFrame();\n        this.initPipeline();\n    }\n\n});\n\nmodule.exports = Image;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Image#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Image} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ImageCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = ImageCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./ImageWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./ImageCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Image#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Image} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ImageWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    this.pipeline.batchSprite(src, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = ImageWebGLRenderer;\r\n"],"names":["Actions","Class","Events","EventEmitter","GetAll","GetFastValue","GetValue","IsPlainObject","Range","Set","Sprite","Group","Extends","initialize","scene","children","config","call","this","Array","isArray","isParent","type","classType","name","active","maxSize","defaultKey","defaultFrame","runChildUpdate","createCallback","removeCallback","createMultipleCallback","internalCreateCallback","internalRemoveCallback","addMultiple","createMultiple","on","ADDED_TO_SCENE","addedToScene","REMOVED_FROM_SCENE","removedFromScene","sys","updateList","add","remove","create","x","y","key","frame","visible","undefined","isFull","child","addToDisplayList","displayList","addToUpdateList","setActive","output","i","length","entries","createFromConfig","concat","options","repeat","randomKey","randomFrame","yoyo","quantity","frameQuantity","max","range","qty","random","randomB","c","created","a","b","push","stepX","stepY","SetXY","rotation","stepRotation","SetRotation","scaleX","scaleY","stepScaleX","stepScaleY","SetScale","originX","originY","stepOriginX","stepOriginY","SetOrigin","alpha","stepAlpha","SetAlpha","depth","stepDepth","SetDepth","scrollFactorX","scrollFactorY","stepScrollFactorX","stepScrollFactorY","SetScrollFactor","hitArea","hitAreaCallback","SetHitArea","grid","GridAlign","preUpdate","time","delta","size","temp","slice","item","update","addToScene","set","DESTROY","removeFromScene","destroyChild","contains","delete","off","destroy","removeFromDisplayList","removeFromUpdateList","clear","gameObject","getChildren","getLength","getMatching","property","value","startIndex","endIndex","getFirst","state","createIfNull","getHandler","getFirstNth","nth","getLast","getLastNth","forwards","total","get","getFirstAlive","getFirstDead","playAnimation","startFrame","PlayAnimation","countActive","getTotalUsed","getTotalFree","used","setName","propertyValueSet","step","index","direction","PropertyValueSet","propertyValueInc","PropertyValueInc","setX","SetX","setY","SetY","setXY","incX","IncX","incY","IncY","incXY","IncXY","shiftPosition","ShiftPosition","angle","Angle","rotate","Rotate","rotateAround","point","RotateAround","rotateAroundDistance","distance","RotateAroundDistance","setAlpha","setTint","topLeft","topRight","bottomLeft","bottomRight","SetTint","setOrigin","ScaleX","ScaleY","scaleXY","ScaleXY","setDepth","setBlendMode","SetBlendMode","setHitArea","shuffle","Shuffle","kill","killAndHide","setVisible","SetVisible","toggleVisible","ToggleVisible","destroyChildren","ignoreDestroy","emit","removeAllListeners","module","exports","Components","GameObject","ImageRender","Image","Mixins","Alpha","BlendMode","Depth","Flip","GetBounds","Mask","Origin","Pipeline","ScrollFactor","Size","TextureCrop","Tint","Transform","Visible","texture","_crop","resetCropObject","setTexture","setPosition","setSizeToFrame","setOriginFromFrame","initPipeline","renderer","src","camera","parentMatrix","addToRenderList","batchSprite","renderWebGL","renderCanvas","pipeline"],"sourceRoot":""}