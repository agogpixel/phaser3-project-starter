{"version":3,"file":"js/590.88bd88d58cf8f6753b10.js","mappings":";2IAMA,IAAIA,EAAiB,EAAQ,OACzBC,EAAQ,EAAQ,OAChBC,EAAa,EAAQ,OACrBC,EAAa,EAAQ,OACrBC,EAAe,EAAQ,OAyCvBC,EAAS,IAAIJ,EAAM,CAEnBK,QAASH,EAETI,OAAQ,CACJL,EAAWM,MACXN,EAAWO,UACXP,EAAWQ,MACXR,EAAWS,KACXT,EAAWU,UACXV,EAAWW,KACXX,EAAWY,OACXZ,EAAWa,SACXb,EAAWc,aACXd,EAAWe,KACXf,EAAWgB,YACXhB,EAAWiB,KACXjB,EAAWkB,UACXlB,EAAWmB,QACXjB,GAGJkB,WAEA,SAAiBC,EAAOC,EAAGC,EAAGC,EAASC,GAEnCxB,EAAWyB,KAAKC,KAAMN,EAAO,UAU7BM,KAAKC,MAAQD,KAAKE,kBAalBF,KAAKG,MAAQ,IAAIhC,EAAe6B,MAEhCA,KAAKI,WAAWP,EAASC,GACzBE,KAAKK,YAAYV,EAAGC,GACpBI,KAAKM,iBACLN,KAAKO,qBACLP,KAAKQ,gBAITC,aAAc,WAEVT,KAAKN,MAAMgB,IAAIC,WAAWC,IAAIZ,OAIlCa,iBAAkB,WAEdb,KAAKN,MAAMgB,IAAIC,WAAWG,OAAOd,OAarCe,UAAW,SAAUC,EAAMC,GAEvBjB,KAAKG,MAAMe,OAAOF,EAAMC,IA+D5BE,KAAM,SAAUC,EAAKC,GAEjB,OAAOrB,KAAKG,MAAMgB,KAAKC,EAAKC,IA+DhCC,YAAa,SAAUF,EAAKC,GAExB,OAAOrB,KAAKG,MAAMmB,YAAYF,EAAKC,IA4BvCE,eAAgB,SAAUH,EAAKI,GAE3B,OAAOxB,KAAKG,MAAMoB,eAAeH,EAAKI,IAyB1CC,gBAAiB,SAAUL,EAAKM,GAE5B,OAAO1B,KAAKG,MAAMsB,gBAAgBL,EAAKM,IA8B3CC,MAAO,SAAUP,GAEb,OAAOpB,KAAKG,MAAMwB,MAAMP,IAgB5BQ,KAAM,WAEF,OAAO5B,KAAKG,MAAMyB,QAqBtBC,eAAgB,SAAUL,GAEtB,OAAOxB,KAAKG,MAAM0B,eAAeL,IAqBrCM,gBAAiB,SAAUJ,GAEvB,OAAO1B,KAAKG,MAAM2B,gBAAgBJ,IAsBtCK,YAAa,SAAUjC,GAEnB,OAAOE,KAAKG,MAAM4B,YAAYjC,IAWlCkC,OAAQ,WAEJ,OAAO3D,EAAW4D,OAAOjC,OAU7BkC,WAAY,WAERlC,KAAKG,MAAMgC,UAEXnC,KAAKG,WAAQiC,KAKrBC,EAAOC,QAAU9D,aC7bjB6D,EAAOC,QAPoB,SAAUC,EAAUC,EAAKC,EAAQC,GAExDD,EAAOE,gBAAgBH,GAEvBD,EAASK,YAAYJ,EAAKA,EAAI1C,MAAO2C,EAAQC,qBClBjD,IAAIG,EAAc,EAAQ,OACtBC,EAAe,EAAQ,OAIvBD,EAAc,EAAQ,OAKtBC,EAAe,EAAQ,OAG3BT,EAAOC,QAAU,CAEbO,YAAaA,EACbC,aAAcA,cCKlBT,EAAOC,QAPmB,SAAUC,EAAUC,EAAKC,EAAQC,GAEvDD,EAAOE,gBAAgBH,GAEvBA,EAAIO,SAASH,YAAYJ,EAAKC,EAAQC","sources":["webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/sprite/Sprite.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/sprite/SpriteCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/sprite/SpriteRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/sprite/SpriteWebGLRenderer.js"],"sourcesContent":["/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar AnimationState = require('../../animations/AnimationState');\nvar Class = require('../../utils/Class');\nvar Components = require('../components');\nvar GameObject = require('../GameObject');\nvar SpriteRender = require('./SpriteRender');\n\n/**\n * @classdesc\n * A Sprite Game Object.\n *\n * A Sprite Game Object is used for the display of both static and animated images in your game.\n * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\n * and animated.\n *\n * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.\n * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\n * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.\n *\n * @class Sprite\n * @extends Phaser.GameObjects.GameObject\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @extends Phaser.GameObjects.Components.Alpha\n * @extends Phaser.GameObjects.Components.BlendMode\n * @extends Phaser.GameObjects.Components.Depth\n * @extends Phaser.GameObjects.Components.Flip\n * @extends Phaser.GameObjects.Components.GetBounds\n * @extends Phaser.GameObjects.Components.Mask\n * @extends Phaser.GameObjects.Components.Origin\n * @extends Phaser.GameObjects.Components.Pipeline\n * @extends Phaser.GameObjects.Components.ScrollFactor\n * @extends Phaser.GameObjects.Components.Size\n * @extends Phaser.GameObjects.Components.TextureCrop\n * @extends Phaser.GameObjects.Components.Tint\n * @extends Phaser.GameObjects.Components.Transform\n * @extends Phaser.GameObjects.Components.Visible\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n */\nvar Sprite = new Class({\n\n    Extends: GameObject,\n\n    Mixins: [\n        Components.Alpha,\n        Components.BlendMode,\n        Components.Depth,\n        Components.Flip,\n        Components.GetBounds,\n        Components.Mask,\n        Components.Origin,\n        Components.Pipeline,\n        Components.ScrollFactor,\n        Components.Size,\n        Components.TextureCrop,\n        Components.Tint,\n        Components.Transform,\n        Components.Visible,\n        SpriteRender\n    ],\n\n    initialize:\n\n    function Sprite (scene, x, y, texture, frame)\n    {\n        GameObject.call(this, scene, 'Sprite');\n\n        /**\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\n         *\n         * @name Phaser.GameObjects.Sprite#_crop\n         * @type {object}\n         * @private\n         * @since 3.11.0\n         */\n        this._crop = this.resetCropObject();\n\n        /**\n         * The Animation State component of this Sprite.\n         *\n         * This component provides features to apply animations to this Sprite.\n         * It is responsible for playing, loading, queuing animations for later playback,\n         * mixing between animations and setting the current animation frame to this Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite#anims\n         * @type {Phaser.Animations.AnimationState}\n         * @since 3.0.0\n         */\n        this.anims = new AnimationState(this);\n\n        this.setTexture(texture, frame);\n        this.setPosition(x, y);\n        this.setSizeToFrame();\n        this.setOriginFromFrame();\n        this.initPipeline();\n    },\n\n    //  Overrides Game Object method\n    addedToScene: function ()\n    {\n        this.scene.sys.updateList.add(this);\n    },\n\n    //  Overrides Game Object method\n    removedFromScene: function ()\n    {\n        this.scene.sys.updateList.remove(this);\n    },\n\n    /**\n     * Update this Sprite's animations.\n     *\n     * @method Phaser.GameObjects.Sprite#preUpdate\n     * @protected\n     * @since 3.0.0\n     *\n     * @param {number} time - The current timestamp.\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\n     */\n    preUpdate: function (time, delta)\n    {\n        this.anims.update(time, delta);\n    },\n\n    /**\n     * Start playing the given animation on this Sprite.\n     *\n     * Animations in Phaser can either belong to the global Animation Manager, or specifically to this Sprite.\n     *\n     * The benefit of a global animation is that multiple Sprites can all play the same animation, without\n     * having to duplicate the data. You can just create it once and then play it on any Sprite.\n     *\n     * The following code shows how to create a global repeating animation. The animation will be created\n     * from all of the frames within the sprite sheet that was loaded with the key 'muybridge':\n     *\n     * ```javascript\n     * var config = {\n     *     key: 'run',\n     *     frames: 'muybridge',\n     *     frameRate: 15,\n     *     repeat: -1\n     * };\n     *\n     * //  This code should be run from within a Scene:\n     * this.anims.create(config);\n     * ```\n     *\n     * However, if you wish to create an animation that is unique to this Sprite, and this Sprite alone,\n     * you can call the `Animation.create` method instead. It accepts the exact same parameters as when\n     * creating a global animation, however the resulting data is kept locally in this Sprite.\n     *\n     * With the animation created, either globally or locally, you can now play it on this Sprite:\n     *\n     * ```javascript\n     * this.add.sprite(x, y).play('run');\n     * ```\n     *\n     * Alternatively, if you wish to run it at a different frame rate, for example, you can pass a config\n     * object instead:\n     *\n     * ```javascript\n     * this.add.sprite(x, y).play({ key: 'run', frameRate: 24 });\n     * ```\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * If you need a Sprite to be able to play both local and global animations, make sure they don't\n     * have conflicting keys.\n     *\n     * See the documentation for the `PlayAnimationConfig` config object for more details about this.\n     *\n     * Also, see the documentation in the Animation Manager for further details on creating animations.\n     *\n     * @method Phaser.GameObjects.Sprite#play\n     * @fires Phaser.Animations.Events#ANIMATION_START\n     * @since 3.0.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\n     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.\n     *\n     * @return {this} This Game Object.\n     */\n    play: function (key, ignoreIfPlaying)\n    {\n        return this.anims.play(key, ignoreIfPlaying);\n    },\n\n    /**\n     * Start playing the given animation on this Sprite, in reverse.\n     *\n     * Animations in Phaser can either belong to the global Animation Manager, or specifically to this Sprite.\n     *\n     * The benefit of a global animation is that multiple Sprites can all play the same animation, without\n     * having to duplicate the data. You can just create it once and then play it on any Sprite.\n     *\n     * The following code shows how to create a global repeating animation. The animation will be created\n     * from all of the frames within the sprite sheet that was loaded with the key 'muybridge':\n     *\n     * ```javascript\n     * var config = {\n     *     key: 'run',\n     *     frames: 'muybridge',\n     *     frameRate: 15,\n     *     repeat: -1\n     * };\n     *\n     * //  This code should be run from within a Scene:\n     * this.anims.create(config);\n     * ```\n     *\n     * However, if you wish to create an animation that is unique to this Sprite, and this Sprite alone,\n     * you can call the `Animation.create` method instead. It accepts the exact same parameters as when\n     * creating a global animation, however the resulting data is kept locally in this Sprite.\n     *\n     * With the animation created, either globally or locally, you can now play it on this Sprite:\n     *\n     * ```javascript\n     * this.add.sprite(x, y).playReverse('run');\n     * ```\n     *\n     * Alternatively, if you wish to run it at a different frame rate, for example, you can pass a config\n     * object instead:\n     *\n     * ```javascript\n     * this.add.sprite(x, y).playReverse({ key: 'run', frameRate: 24 });\n     * ```\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * If you need a Sprite to be able to play both local and global animations, make sure they don't\n     * have conflicting keys.\n     *\n     * See the documentation for the `PlayAnimationConfig` config object for more details about this.\n     *\n     * Also, see the documentation in the Animation Manager for further details on creating animations.\n     *\n     * @method Phaser.GameObjects.Sprite#playReverse\n     * @fires Phaser.Animations.Events#ANIMATION_START\n     * @since 3.50.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\n     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.\n     *\n     * @return {this} This Game Object.\n     */\n    playReverse: function (key, ignoreIfPlaying)\n    {\n        return this.anims.playReverse(key, ignoreIfPlaying);\n    },\n\n    /**\n     * Waits for the specified delay, in milliseconds, then starts playback of the given animation.\n     *\n     * If the animation _also_ has a delay value set in its config, it will be **added** to the delay given here.\n     *\n     * If an animation is already running and a new animation is given to this method, it will wait for\n     * the given delay before starting the new animation.\n     *\n     * If no animation is currently running, the given one begins after the delay.\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * Prior to Phaser 3.50 this method was called 'delayedPlay'.\n     *\n     * @method Phaser.GameObjects.Sprite#playAfterDelay\n     * @fires Phaser.Animations.Events#ANIMATION_START\n     * @since 3.50.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\n     * @param {number} delay - The delay, in milliseconds, to wait before starting the animation playing.\n     *\n     * @return {this} This Game Object.\n     */\n    playAfterDelay: function (key, delay)\n    {\n        return this.anims.playAfterDelay(key, delay);\n    },\n\n    /**\n     * Waits for the current animation to complete the `repeatCount` number of repeat cycles, then starts playback\n     * of the given animation.\n     *\n     * You can use this to ensure there are no harsh jumps between two sets of animations, i.e. going from an\n     * idle animation to a walking animation, by making them blend smoothly into each other.\n     *\n     * If no animation is currently running, the given one will start immediately.\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * @method Phaser.GameObjects.Sprite#playAfterRepeat\n     * @fires Phaser.Animations.Events#ANIMATION_START\n     * @since 3.50.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\n     * @param {number} [repeatCount=1] - How many times should the animation repeat before the next one starts?\n     *\n     * @return {this} This Game Object.\n     */\n    playAfterRepeat: function (key, repeatCount)\n    {\n        return this.anims.playAfterRepeat(key, repeatCount);\n    },\n\n    /**\n     * Sets an animation, or an array of animations, to be played immediately after the current one completes or stops.\n     *\n     * The current animation must enter a 'completed' state for this to happen, i.e. finish all of its repeats, delays, etc,\n     * or have the `stop` method called directly on it.\n     *\n     * An animation set to repeat forever will never enter a completed state.\n     *\n     * You can chain a new animation at any point, including before the current one starts playing, during it,\n     * or when it ends (via its `animationcomplete` event).\n     *\n     * Chained animations are specific to a Game Object, meaning different Game Objects can have different chained\n     * animations without impacting the animation they're playing.\n     *\n     * Call this method with no arguments to reset all currently chained animations.\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * @method Phaser.GameObjects.Sprite#chain\n     * @since 3.50.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig|string[]|Phaser.Animations.Animation[]|Phaser.Types.Animations.PlayAnimationConfig[])} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object, or an array of them.\n     *\n     * @return {this} This Game Object.\n     */\n    chain: function (key)\n    {\n        return this.anims.chain(key);\n    },\n\n    /**\n     * Immediately stops the current animation from playing and dispatches the `ANIMATION_STOP` events.\n     *\n     * If no animation is playing, no event will be dispatched.\n     *\n     * If there is another animation queued (via the `chain` method) then it will start playing immediately.\n     *\n     * @method Phaser.GameObjects.Sprite#stop\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\n     * @since 3.50.0\n     *\n     * @return {this} This Game Object.\n     */\n    stop: function ()\n    {\n        return this.anims.stop();\n    },\n\n    /**\n     * Stops the current animation from playing after the specified time delay, given in milliseconds.\n     *\n     * It then dispatches the `ANIMATION_STOP` event.\n     *\n     * If no animation is running, no events will be dispatched.\n     *\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\n     * when the current one stops.\n     *\n     * @method Phaser.GameObjects.Sprite#stopAfterDelay\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\n     * @since 3.50.0\n     *\n     * @param {number} delay - The number of milliseconds to wait before stopping this animation.\n     *\n     * @return {this} This Game Object.\n     */\n    stopAfterDelay: function (delay)\n    {\n        return this.anims.stopAfterDelay(delay);\n    },\n\n    /**\n     * Stops the current animation from playing after the given number of repeats.\n     *\n     * It then dispatches the `ANIMATION_STOP` event.\n     *\n     * If no animation is running, no events will be dispatched.\n     *\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\n     * when the current one stops.\n     *\n     * @method Phaser.GameObjects.Sprite#stopAfterRepeat\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\n     * @since 3.50.0\n     *\n     * @param {number} [repeatCount=1] - How many times should the animation repeat before stopping?\n     *\n     * @return {this} This Game Object.\n     */\n    stopAfterRepeat: function (repeatCount)\n    {\n        return this.anims.stopAfterRepeat(repeatCount);\n    },\n\n    /**\n     * Stops the current animation from playing when it next sets the given frame.\n     * If this frame doesn't exist within the animation it will not stop it from playing.\n     *\n     * It then dispatches the `ANIMATION_STOP` event.\n     *\n     * If no animation is running, no events will be dispatched.\n     *\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\n     * when the current one stops.\n     *\n     * @method Phaser.GameObjects.Sprite#stopOnFrame\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\n     * @since 3.50.0\n     *\n     * @param {Phaser.Animations.AnimationFrame} frame - The frame to check before stopping this animation.\n     *\n     * @return {this} This Game Object.\n     */\n    stopOnFrame: function (frame)\n    {\n        return this.anims.stopOnFrame(frame);\n    },\n\n    /**\n     * Build a JSON representation of this Sprite.\n     *\n     * @method Phaser.GameObjects.Sprite#toJSON\n     * @since 3.0.0\n     *\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\n     */\n    toJSON: function ()\n    {\n        return Components.ToJSON(this);\n    },\n\n    /**\n     * Handles the pre-destroy step for the Sprite, which removes the Animation component.\n     *\n     * @method Phaser.GameObjects.Sprite#preDestroy\n     * @private\n     * @since 3.14.0\n     */\n    preDestroy: function ()\n    {\n        this.anims.destroy();\n\n        this.anims = undefined;\n    }\n\n});\n\nmodule.exports = Sprite;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Sprite#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Sprite} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar SpriteCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = SpriteCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./SpriteWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./SpriteCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Sprite#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Sprite} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar SpriteWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    src.pipeline.batchSprite(src, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = SpriteWebGLRenderer;\r\n"],"names":["AnimationState","Class","Components","GameObject","SpriteRender","Sprite","Extends","Mixins","Alpha","BlendMode","Depth","Flip","GetBounds","Mask","Origin","Pipeline","ScrollFactor","Size","TextureCrop","Tint","Transform","Visible","initialize","scene","x","y","texture","frame","call","this","_crop","resetCropObject","anims","setTexture","setPosition","setSizeToFrame","setOriginFromFrame","initPipeline","addedToScene","sys","updateList","add","removedFromScene","remove","preUpdate","time","delta","update","play","key","ignoreIfPlaying","playReverse","playAfterDelay","delay","playAfterRepeat","repeatCount","chain","stop","stopAfterDelay","stopAfterRepeat","stopOnFrame","toJSON","ToJSON","preDestroy","destroy","undefined","module","exports","renderer","src","camera","parentMatrix","addToRenderList","batchSprite","renderWebGL","renderCanvas","pipeline"],"sourceRoot":""}