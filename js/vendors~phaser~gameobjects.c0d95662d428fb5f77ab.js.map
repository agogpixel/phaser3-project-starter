{"version":3,"sources":["webpack:///./node_modules/phaser/src/gameobjects/index.js","webpack:///./node_modules/phaser/src/gameobjects/DisplayList.js","webpack:///./node_modules/phaser/src/gameobjects/UpdateList.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/GetBitmapTextSize.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/ParseFromAtlas.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextRender.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/BatchChar.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/blitter/BlitterRender.js","webpack:///./node_modules/phaser/src/gameobjects/blitter/BlitterWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/blitter/BlitterCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/container/ContainerRender.js","webpack:///./node_modules/phaser/src/gameobjects/container/ContainerWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/container/ContainerCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/domelement/DOMElementRender.js","webpack:///./node_modules/phaser/src/gameobjects/domelement/CSSBlendModes.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextRender.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/extern/ExternRender.js","webpack:///./node_modules/phaser/src/gameobjects/extern/ExternWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/graphics/GraphicsRender.js","webpack:///./node_modules/phaser/src/gameobjects/graphics/GraphicsWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/layer/LayerRender.js","webpack:///./node_modules/phaser/src/gameobjects/layer/LayerWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/layer/LayerCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/particles/index.js","webpack:///./node_modules/phaser/src/gameobjects/particles/ParticleManagerRender.js","webpack:///./node_modules/phaser/src/gameobjects/particles/ParticleManagerWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/particles/ParticleManagerCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/particles/zones/index.js","webpack:///./node_modules/phaser/src/gameobjects/rendertexture/RenderTextureRender.js","webpack:///./node_modules/phaser/src/gameobjects/rendertexture/RenderTextureWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/rendertexture/RenderTextureCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/RetroFont.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/const.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/ParseRetroFont.js","webpack:///./node_modules/phaser/src/gameobjects/rope/RopeRender.js","webpack:///./node_modules/phaser/src/gameobjects/rope/RopeWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/rope/RopeCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/text/TextRender.js","webpack:///./node_modules/phaser/src/gameobjects/text/TextWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/text/TextCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/tilesprite/TileSpriteRender.js","webpack:///./node_modules/phaser/src/gameobjects/tilesprite/TileSpriteWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/tilesprite/TileSpriteCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/video/VideoRender.js","webpack:///./node_modules/phaser/src/gameobjects/video/VideoWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/video/VideoCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/arc/ArcRender.js","webpack:///./node_modules/phaser/src/gameobjects/shape/arc/ArcWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/arc/ArcCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/curve/CurveRender.js","webpack:///./node_modules/phaser/src/gameobjects/shape/curve/CurveWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/curve/CurveCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/ellipse/EllipseRender.js","webpack:///./node_modules/phaser/src/gameobjects/shape/ellipse/EllipseWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/ellipse/EllipseCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/grid/GridRender.js","webpack:///./node_modules/phaser/src/gameobjects/shape/grid/GridWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/grid/GridCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/isobox/IsoBoxRender.js","webpack:///./node_modules/phaser/src/gameobjects/shape/isobox/IsoBoxWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/isobox/IsoBoxCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/FillPathWebGL.js","webpack:///./node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangleRender.js","webpack:///./node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangleWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangleCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/line/LineRender.js","webpack:///./node_modules/phaser/src/gameobjects/shape/line/LineWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/line/LineCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/polygon/PolygonRender.js","webpack:///./node_modules/phaser/src/gameobjects/shape/polygon/PolygonWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/polygon/PolygonCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/rectangle/RectangleRender.js","webpack:///./node_modules/phaser/src/gameobjects/shape/rectangle/RectangleWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/rectangle/RectangleCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/star/StarRender.js","webpack:///./node_modules/phaser/src/gameobjects/shape/star/StarWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/star/StarCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/triangle/TriangleRender.js","webpack:///./node_modules/phaser/src/gameobjects/shape/triangle/TriangleWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shape/triangle/TriangleCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/blitter/BlitterFactory.js","webpack:///./node_modules/phaser/src/gameobjects/container/ContainerFactory.js","webpack:///./node_modules/phaser/src/gameobjects/domelement/DOMElementFactory.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextFactory.js","webpack:///./node_modules/phaser/src/gameobjects/extern/ExternFactory.js","webpack:///./node_modules/phaser/src/gameobjects/graphics/GraphicsFactory.js","webpack:///./node_modules/phaser/src/gameobjects/group/GroupFactory.js","webpack:///./node_modules/phaser/src/gameobjects/image/ImageFactory.js","webpack:///./node_modules/phaser/src/gameobjects/layer/LayerFactory.js","webpack:///./node_modules/phaser/src/gameobjects/particles/ParticleManagerFactory.js","webpack:///./node_modules/phaser/src/gameobjects/pathfollower/PathFollowerFactory.js","webpack:///./node_modules/phaser/src/gameobjects/rendertexture/RenderTextureFactory.js","webpack:///./node_modules/phaser/src/gameobjects/rope/RopeFactory.js","webpack:///./node_modules/phaser/src/gameobjects/sprite/SpriteFactory.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextFactory.js","webpack:///./node_modules/phaser/src/gameobjects/text/TextFactory.js","webpack:///./node_modules/phaser/src/gameobjects/tilesprite/TileSpriteFactory.js","webpack:///./node_modules/phaser/src/gameobjects/zone/ZoneFactory.js","webpack:///./node_modules/phaser/src/gameobjects/video/VideoFactory.js","webpack:///./node_modules/phaser/src/gameobjects/shape/arc/ArcFactory.js","webpack:///./node_modules/phaser/src/gameobjects/shape/curve/CurveFactory.js","webpack:///./node_modules/phaser/src/gameobjects/shape/ellipse/EllipseFactory.js","webpack:///./node_modules/phaser/src/gameobjects/shape/grid/GridFactory.js","webpack:///./node_modules/phaser/src/gameobjects/shape/isobox/IsoBoxFactory.js","webpack:///./node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangleFactory.js","webpack:///./node_modules/phaser/src/gameobjects/shape/line/LineFactory.js","webpack:///./node_modules/phaser/src/gameobjects/shape/polygon/PolygonFactory.js","webpack:///./node_modules/phaser/src/gameobjects/shape/rectangle/RectangleFactory.js","webpack:///./node_modules/phaser/src/gameobjects/shape/star/StarFactory.js","webpack:///./node_modules/phaser/src/gameobjects/shape/triangle/TriangleFactory.js","webpack:///./node_modules/phaser/src/gameobjects/blitter/BlitterCreator.js","webpack:///./node_modules/phaser/src/gameobjects/container/ContainerCreator.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextCreator.js","webpack:///./node_modules/phaser/src/gameobjects/graphics/GraphicsCreator.js","webpack:///./node_modules/phaser/src/gameobjects/group/GroupCreator.js","webpack:///./node_modules/phaser/src/gameobjects/image/ImageCreator.js","webpack:///./node_modules/phaser/src/gameobjects/layer/LayerCreator.js","webpack:///./node_modules/phaser/src/gameobjects/particles/ParticleManagerCreator.js","webpack:///./node_modules/phaser/src/gameobjects/rendertexture/RenderTextureCreator.js","webpack:///./node_modules/phaser/src/gameobjects/rope/RopeCreator.js","webpack:///./node_modules/phaser/src/gameobjects/sprite/SpriteCreator.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextCreator.js","webpack:///./node_modules/phaser/src/gameobjects/text/TextCreator.js","webpack:///./node_modules/phaser/src/gameobjects/tilesprite/TileSpriteCreator.js","webpack:///./node_modules/phaser/src/gameobjects/zone/ZoneCreator.js","webpack:///./node_modules/phaser/src/gameobjects/video/VideoCreator.js","webpack:///./node_modules/phaser/src/gameobjects/shader/ShaderRender.js","webpack:///./node_modules/phaser/src/gameobjects/shader/ShaderWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shader/ShaderCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/mesh/MeshRender.js","webpack:///./node_modules/phaser/src/gameobjects/mesh/MeshWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/mesh/MeshCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/pointlight/PointLightRender.js","webpack:///./node_modules/phaser/src/gameobjects/pointlight/PointLightWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/shader/ShaderFactory.js","webpack:///./node_modules/phaser/src/gameobjects/mesh/MeshFactory.js","webpack:///./node_modules/phaser/src/gameobjects/pointlight/PointLightFactory.js","webpack:///./node_modules/phaser/src/gameobjects/shader/ShaderCreator.js","webpack:///./node_modules/phaser/src/gameobjects/mesh/MeshCreator.js","webpack:///./node_modules/phaser/src/gameobjects/pointlight/PointLightCreator.js","webpack:///./node_modules/phaser/src/gameobjects/lights/LightsPlugin.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapText.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/ParseXMLBitmapFont.js","webpack:///./node_modules/phaser/src/gameobjects/pointlight/PointLight.js","webpack:///./node_modules/phaser/src/gameobjects/blitter/Blitter.js","webpack:///./node_modules/phaser/src/gameobjects/container/Container.js","webpack:///./node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapText.js","webpack:///./node_modules/phaser/src/gameobjects/graphics/Graphics.js","webpack:///./node_modules/phaser/src/gameobjects/graphics/Commands.js","webpack:///./node_modules/phaser/src/gameobjects/layer/Layer.js","webpack:///./node_modules/phaser/src/gameobjects/particles/ParticleEmitterManager.js","webpack:///./node_modules/phaser/src/gameobjects/rendertexture/RenderTexture.js","webpack:///./node_modules/phaser/src/gameobjects/rope/Rope.js","webpack:///./node_modules/phaser/src/gameobjects/text/Text.js","webpack:///./node_modules/phaser/src/gameobjects/tilesprite/TileSprite.js","webpack:///./node_modules/phaser/src/gameobjects/video/Video.js","webpack:///./node_modules/phaser/src/gameobjects/shader/Shader.js","webpack:///./node_modules/phaser/src/gameobjects/mesh/Mesh.js","webpack:///./node_modules/phaser/src/gameobjects/BuildGameObject.js","webpack:///./node_modules/phaser/src/gameobjects/shape/Shape.js","webpack:///./node_modules/phaser/src/gameobjects/BuildGameObjectAnimation.js","webpack:///./node_modules/phaser/src/gameobjects/blitter/Bob.js","webpack:///./node_modules/phaser/src/gameobjects/domelement/DOMElement.js","webpack:///./node_modules/phaser/src/gameobjects/domelement/DOMElementCSSRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/extern/Extern.js","webpack:///./node_modules/phaser/src/gameobjects/graphics/GraphicsCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/particles/EmitterOp.js","webpack:///./node_modules/phaser/src/gameobjects/particles/GravityWell.js","webpack:///./node_modules/phaser/src/gameobjects/particles/Particle.js","webpack:///./node_modules/phaser/src/gameobjects/particles/ParticleEmitter.js","webpack:///./node_modules/phaser/src/gameobjects/particles/zones/DeathZone.js","webpack:///./node_modules/phaser/src/gameobjects/particles/zones/EdgeZone.js","webpack:///./node_modules/phaser/src/gameobjects/particles/zones/RandomZone.js","webpack:///./node_modules/phaser/src/gameobjects/pathfollower/PathFollower.js","webpack:///./node_modules/phaser/src/gameobjects/text/GetTextSize.js","webpack:///./node_modules/phaser/src/gameobjects/text/TextStyle.js","webpack:///./node_modules/phaser/src/gameobjects/text/MeasureText.js","webpack:///./node_modules/phaser/src/gameobjects/shape/arc/Arc.js","webpack:///./node_modules/phaser/src/gameobjects/shape/curve/Curve.js","webpack:///./node_modules/phaser/src/gameobjects/shape/ellipse/Ellipse.js","webpack:///./node_modules/phaser/src/gameobjects/shape/grid/Grid.js","webpack:///./node_modules/phaser/src/gameobjects/shape/isobox/IsoBox.js","webpack:///./node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangle.js","webpack:///./node_modules/phaser/src/gameobjects/shape/line/Line.js","webpack:///./node_modules/phaser/src/gameobjects/shape/polygon/Polygon.js","webpack:///./node_modules/phaser/src/gameobjects/shape/rectangle/Rectangle.js","webpack:///./node_modules/phaser/src/gameobjects/shape/star/Star.js","webpack:///./node_modules/phaser/src/gameobjects/shape/triangle/Triangle.js","webpack:///./node_modules/phaser/src/gameobjects/lights/Light.js","webpack:///./node_modules/phaser/src/gameobjects/lights/LightsManager.js","webpack:///./node_modules/phaser/src/gameobjects/shape/FillStyleCanvas.js","webpack:///./node_modules/phaser/src/gameobjects/shape/LineStyleCanvas.js","webpack:///./node_modules/phaser/src/gameobjects/shape/StrokePathWebGL.js"],"names":["GameObjects","Events","DisplayList","GameObjectCreator","GameObjectFactory","UpdateList","Components","GetCalcMatrix","BuildGameObject","BuildGameObjectAnimation","GameObject","BitmapText","Blitter","Bob","Container","DOMElement","DynamicBitmapText","Extern","Graphics","Group","Image","Layer","Particles","PathFollower","RenderTexture","RetroFont","Rope","Sprite","Text","GetTextSize","MeasureText","TextStyle","TileSprite","Zone","Video","Shape","Arc","Curve","Ellipse","Grid","IsoBox","IsoTriangle","Line","Polygon","Rectangle","Star","Triangle","Factories","StaticBitmapText","Creators","Shader","Mesh","PointLight","Light","LightsManager","LightsPlugin","module","exports","Class","List","PluginCache","GameObjectEvents","SceneEvents","StableSort","Extends","initialize","scene","call","this","sortChildrenFlag","systems","sys","events","addCallback","addChildCallback","removeCallback","removeChildCallback","once","BOOT","boot","on","START","start","DESTROY","destroy","gameObject","displayList","removeFromDisplayList","queueDepthSort","emit","ADDED_TO_SCENE","REMOVED_FROM_SCENE","SHUTDOWN","shutdown","depthSort","list","sortByDepth","childA","childB","_depth","getChildren","i","length","off","register","ProcessQueue","checkQueue","eventEmitter","PRE_UPDATE","update","UPDATE","sceneUpdate","time","delta","_active","active","preUpdate","_pending","_destroy","_toProcess","removeAllListeners","src","round","updateOrigin","out","undefined","local","x","y","width","height","global","lines","shortest","longest","lengths","wrappedText","words","characters","scaleX","scaleY","str","index","value","text","textLength","maxWidth","wordWrapCharCode","bx","Number","MAX_VALUE","by","bw","bh","chars","fontData","lineHeight","letterSpacing","xAdvance","yAdvance","charCode","glyph","align","_align","scale","fontSize","size","sx","sy","lastGlyph","lastCharCode","lineWidths","shortestLine","longestLine","currentLine","currentLineWidth","current","charCodeAt","glyphKerningOffset","kerning","push","word","w","h","cr","concat","xOffset","prev","offset","crs","entry","left","right","substr","charIndex","kerningOffset","gw","gh","charWidth","char","code","yOffset","t","r","b","line","c","currentChar","ax1","ax2","_displayOriginX","_displayOriginY","Math","ceil","originX","originY","ParseXMLBitmapFont","fontName","textureKey","frameKey","xmlKey","xSpacing","ySpacing","texture","textures","get","frame","xml","cache","data","bitmapFont","add","fromAtlas","renderWebGL","renderCanvas","BatchChar","Utils","renderer","camera","parentMatrix","_text","addToRenderList","pipeline","pipelines","set","calcMatrix","calc","roundPixels","cameraAlpha","alpha","charColors","tintEffect","tintFill","getTint","getTintAppendFloatAlpha","tintTL","tintTopLeft","_alphaTL","tintTR","tintTopRight","_alphaTR","tintBL","tintBottomLeft","_alphaBL","tintBR","tintBottomRight","_alphaBR","glTexture","textureUnit","setGameObject","getTextBounds","dropShadowX","dropShadowY","dropShadow","preBatch","srcShadowColor","dropShadowColor","srcShadowAlpha","dropShadowAlpha","shadowTL","shadowTR","shadowBL","shadowBR","color","charTintEffect","charTintTL","charTintTR","charTintBL","charTintBR","postBatch","offsetX","offsetY","displayOriginX","displayOriginY","xw","yh","tx0","getXRound","ty0","getYRound","tx1","ty1","tx2","ty2","tx3","ty3","batchQuad","u0","v0","u1","v1","SetTransform","ctx","currentContext","textureFrame","frames","_letterSpacing","glyphX","glyphY","glyphW","glyphH","image","source","textureX","cutX","textureY","cutY","_fontSize","lineOffsetX","bounds","lineData","_bounds","translate","save","drawImage","restore","TransformMatrix","tempMatrix","getRenderList","cameraScrollX","scrollX","scrollFactorX","cameraScrollY","scrollY","scrollFactorY","copyFrom","matrix","multiplyWithOffset","blitterX","blitterY","prevTextureSourceIndex","bob","bobAlpha","flipX","flipY","getX","getY","tint","sourceIndex","globalCompositeOperation","blendModes","blendMode","imageSmoothingEnabled","antialias","scaleMode","copyToContext","flip","cd","canvasData","dx","dy","fx","fy","globalAlpha","container","children","childCount","transformMatrix","localTransform","loadIdentity","multiply","rotate","rotation","applyITRS","containerHasBlendMode","setBlendMode","child","willRender","childAlphaTopLeft","childAlphaTopRight","childAlphaBottomLeft","childAlphaBottomRight","alphaTopLeft","alphaTopRight","alphaBottomLeft","alphaBottomRight","childAlpha","childScrollFactorX","childScrollFactorY","currentBlendMode","mask","preRenderWebGL","type","currentType","newType","nextTypeMatch","setScrollFactor","setAlpha","postRenderWebGL","_alpha","preRenderCanvas","postRenderCanvas","result","spriteMatrix","sprite","fontMatrix","crop","cropWidth","cropHeight","flush","pushScissor","tx","ty","displayCallback","callbackData","topLeft","topRight","bottomLeft","bottomRight","output","e","f","d","a","popScissor","baseScale","beginPath","rect","clip","clear","render","rebind","Commands","Point","Path","points","pointsLength","matrixStack","commandBuffer","currentMatrix","commands","lineWidth","fillTint","strokeTint","ta","PI2","PI","path","pathIndex","pathOpen","lastPath","cmdIndex","BEGIN_PATH","CLOSE_PATH","FILL_PATH","batchFillPath","STROKE_PATH","batchStrokePath","LINE_STYLE","strokeTintColor","TL","TR","BL","BR","FILL_STYLE","fillTintColor","GRADIENT_FILL_STYLE","alphaTL","alphaTR","alphaBL","alphaBR","GRADIENT_LINE_STYLE","gradientLineAlpha","ARC","iteration","radius","startAngle","endAngle","anticlockwise","overshoot","cos","sin","FILL_RECT","batchFillRect","FILL_TRIANGLE","batchFillTriangle","STROKE_TRIANGLE","batchStrokeTriangle","LINE_TO","MOVE_TO","SAVE","copyToArray","RESTORE","copyFromArray","pop","TRANSLATE","SCALE","ROTATE","layer","layerHasBlendMode","EmitterOp","GravityWell","Particle","ParticleEmitter","ParticleEmitterManager","Zones","tempMatrix1","tempMatrix2","tempMatrix3","tempMatrix4","emitterManager","emitters","emittersLength","camMatrix","particleMatrix","managerMatrix","defaultFrame","emitter","particles","alive","particleCount","visible","particle","halfWidth","halfHeight","setToContext","DeathZone","EdgeZone","RandomZone","renderTarget","setTexture2D","batchTexture","resetTextures","batchSprite","RETRO_FONT_CONST","Extend","Parse","TEXT_SET1","TEXT_SET2","TEXT_SET3","TEXT_SET4","TEXT_SET5","TEXT_SET6","TEXT_SET7","TEXT_SET8","TEXT_SET9","TEXT_SET10","TEXT_SET11","GetValue","config","cx","floor","cy","letters","key","getFrame","textureWidth","textureHeight","spacingX","spacingY","lineSpacing","charsPerRow","retroFont","font","centerX","centerY","vertices","uvs","uv","colors","alphas","meshVerticesLength","vertexCount","vertexViewF32","vertexViewU32","vertexOffset","currentShader","vertexComponentCount","colorIndex","dirty","updateVertices","debugCallback","debugVerts","style","resolution","updateCanvas","fillPattern","displayFrame","tileScaleX","tileScaleY","tilePositionX","tilePositionY","videoTexture","FillPathWebGL","StrokePathWebGL","isFilled","isStroked","DegToRad","FillStyleCanvas","LineStyleCanvas","arc","_startAngle","_endAngle","closePath","fill","stroke","_curveBounds","pathData","pathLength","px1","py1","moveTo","px2","py2","lineTo","cellWidth","cellHeight","gridWidth","gridHeight","cellWidthA","cellHeightA","cellWidthB","cellHeightB","showCells","showAltCells","showOutline","cw","ch","fillAlpha","fillColor","altFillAlpha","altFillColor","outlineFillAlpha","outlineFillColor","x1","batchLine","y1","fillRect","x0","y0","x2","y2","x3","y3","sizeA","sizeB","projection","showTop","fillTop","showLeft","fillLeft","showRight","fillRight","pathIndexes","p0","p1","p2","batchTri","reversed","isReversed","strokeColor","strokeAlpha","startWidth","_startWidth","endWidth","_endWidth","geom","element","innerText","extern","updateList","horizontal","curve","innerRadius","outerRadius","GetAdvancedValue","addToScene","blitter","bitmapText","graphics","GetFastValue","manager","renderTexture","rope","content","padding","autoRound","tile","video","shader","renderToTexture","load","_rendererWidth","_rendererHeight","projOrtho","faces","totalFaces","F32","U32","debugFaces","z","viewPosition","hideCCW","totalFacesRendered","face","isInView","shouldFlush","totalFrame","_radius","lightX","lightY","batchPointLight","textureData","indicies","containsZ","normals","intensity","attenuation","mesh","settings","isBooted","Clamp","GetBitmapTextSize","ParseFromAtlas","Render","Mixins","Alpha","BlendMode","Depth","Mask","Origin","Pipeline","ScrollFactor","Texture","Tint","Transform","Visible","console","warn","_dirty","_maxWidth","setTexture","setPosition","setOrigin","initPipeline","setText","setLeftAlign","ALIGN_LEFT","setCenterAlign","ALIGN_CENTER","setRightAlign","ALIGN_RIGHT","setFontSize","setLetterSpacing","spacing","Array","isArray","join","toString","updateDisplayOrigin","setDropShadow","setCharacterTint","len","end","setWordTint","count","wordIsNumber","total","lineword","getCharacterAt","point","getLocalPoint","tempRect","setTo","contains","setFont","setMaxWidth","toJSON","ToJSON","preDestroy","getValue","node","attribute","parseInt","getAttribute","info","getElementsByTagName","common","adjustForTrim","trimmed","top","letter","String","fromCharCode","gx","gy","charFrame","setUVs","kernings","kern","first","second","amount","IntegerToColor","PIPELINES_CONST","AlphaSingle","GetBounds","POINTLIGHT_PIPELINE","BlitterRender","Frame","Size","renderList","create","addAt","createFromCallback","callback","quantity","bobs","createMultiple","name","_this","forEach","singleFrame","childCanRender","filter","removeAll","ArrayUtils","BlendModes","Union","Vector2","ComputedSize","exclusive","maxSize","position","tempTransformMatrix","_sortKey","_sysEvents","clearAlpha","SKIP_CHECK","setExclusive","getBounds","parentContainer","transformedPosition","getBoundsTransformMatrix","transformPoint","hasSetFirst","setEmpty","addHandler","remove","removeHandler","addToDisplayList","pointToContainer","invert","getWorldTransformMatrix","Add","AddAt","getAt","getIndex","indexOf","sort","property","handler","getByName","GetFirst","getRandom","startIndex","GetRandom","getFirst","endIndex","getAll","GetAll","CountAllMatching","swap","child1","child2","Swap","MoveTo","moveAbove","MoveAbove","moveBelow","MoveBelow","destroyChild","removed","Remove","removeAt","RemoveAt","removeBetween","RemoveBetween","bringToTop","BringToTop","sendToBack","SendToBack","moveUp","MoveUp","moveDown","MoveDown","reverse","shuffle","Shuffle","replace","oldChild","newChild","Replace","exists","setAll","SetAll","each","context","args","temp","slice","arguments","apply","iterate","updateChildren","last","next","previous","parent","setSize","setDisplayCallback","setScrollX","setScrollY","BaseCamera","ComponentsAlpha","ComponentsBlendMode","ComponentsDepth","ComponentsMask","ComponentsPipeline","ComponentsScrollFactor","ComponentsTransform","ComponentsVisible","MATH_CONST","options","defaultFillColor","defaultFillAlpha","defaultStrokeWidth","defaultStrokeColor","defaultStrokeAlpha","_lineWidth","setDefaultStyles","lineStyle","fillStyle","fillGradientStyle","lineGradientStyle","fillPath","strokePath","fillCircleShape","circle","fillCircle","strokeCircleShape","strokeCircle","fillRectShape","strokeRectShape","strokeRect","lineWidthHalf","minx","maxx","fillRoundedRect","tl","tr","bl","br","TAU","strokeRoundedRect","fillPointShape","fillPoint","fillTriangleShape","triangle","fillTriangle","strokeTriangleShape","strokeTriangle","strokeLineShape","lineBetween","strokePoints","closeShape","fillPoints","strokeEllipseShape","ellipse","smoothness","getPoints","strokeEllipse","fillEllipseShape","fillEllipse","translateCanvas","scaleCanvas","rotateCanvas","radians","generateTexture","game","TargetCamera","setScene","setViewport","getSourceImage","HTMLCanvasElement","getContext","createCanvas","refresh","ComponentsToJSON","DataManager","EventEmitter","state","tabIndex","renderFlags","cameraFilter","input","body","ignoreDestroy","setActive","setName","setState","setDataEnabled","setData","incData","inc","toggleData","toggle","getData","setInteractive","disableInteractive","removeInteractive","addedToScene","removedFromScene","id","getIndexList","indexes","unshift","resetPostPipeline","timeScale","frameNames","wells","createEmitter","setFrame","getFramesFromTextureSource","names","sourceFrame","setEmitterFrames","addEmitter","removeEmitter","addGravityWell","well","createGravityWell","emitParticle","emitParticleAt","pause","resume","getProcessors","Camera","CanvasPool","CONST","NOOP","PIPELINE_CONST","RenderTarget","UUID","Crop","Flip","textureManager","globalTint","canvas","_crop","resetCropObject","_saved","create2D","addCanvas","cutWidth","cutHeight","_eraseMode","WEBGL","drawGameObject","batchGameObjectWebGL","CANVAS","batchGameObjectCanvas","SINGLE_PIPELINE","resize","isRenderTexture","isGLTexture","baseFrame","customHitArea","hitArea","setGlobalTint","setGlobalAlpha","saveTexture","renameTexture","rgb","g","preRender","bind","tw","th","drawFillRect","getTintFromFloats","unbind","setContext","setTransform","clearRect","erase","entries","draw","beginDraw","batchDraw","endDraw","drawFrame","batchDrawFrame","beginCapture","batchList","batchTextureFrame","canvasTarget","endCapture","setUtility","blitFrame","resetScissor","resetViewport","isParent","batchGroup","batchTextureFrameKey","prevX","prevY","renderDirect","ERASE","snapshotArea","encoderOptions","snapshotFramebuffer","framebuffer","snapshotCanvas","snapshot","snapshotPixel","AnimationState","RopeRender","anims","_flipX","_flipY","_perp","debugGraphic","setSizeToFrame","ROPE_PIPELINE","resizeArrays","setPoints","prevFrame","currentFrame","updateUVs","play","ignoreIfPlaying","startFrame","setDirty","setHorizontal","setVertical","setTintFill","setAlphas","bottomAlpha","currentAlphas","prevAlpha","setColors","currentColors","prevColor","s","frameSegment","segments","currentTotal","currentUVs","partH","partV","uv0","uv1","uv2","uv3","newSize","Float32Array","Uint32Array","perp","nextPoint","lastPoint","frameSize","perpLength","setDebug","graphic","renderDebugVerts","meshLength","verts","px0","py0","AddToDOM","GameEvents","RemoveFromDOM","TextRender","splitRegExp","bottom","gl","deleteTexture","initRTL","setPadding","setLineSpacing","CONTEXT_RESTORED","rtl","dir","direction","display","runWordWrap","wordWrapCallback","wrappedLines","wordWrapCallbackScope","wordWrapWidth","wordWrapUseAdvanced","advancedWordWrap","basicWordWrap","split","linesCount","measureText","j","wordWithSpace","wordWidth","newWord","Error","secondPart","remainder","lastLineIndex","whiteSpaceWidth","spaceLeft","lastWordIndex","wordWidthWithSpace","getWrappedText","syncFont","updateText","setStyle","setFontFamily","family","setFontStyle","setFixedSize","setBackgroundColor","setFill","setColor","setStroke","thickness","setShadow","blur","shadowStroke","shadowFill","setShadowOffset","setShadowColor","setShadowBlur","setShadowStroke","enabled","setShadowFill","setWordWrapWidth","useAdvancedWrap","setWordWrapCallback","scope","setAlign","setResolution","setMaxLines","max","metrics","outputText","textWidth","textSize","fixedWidth","fixedHeight","linePositionX","linePositionY","backgroundColor","syncStyle","textBaseline","strokeThickness","ascent","extraSpace","spaceSize","trimmedLine","trim","array","extraSpaceCharacters","idx","syncShadow","strokeText","fillText","canvasToTexture","getTextMetrics","GetPowerOfTwo","Smoothing","TileSpriteRender","displayTexture","_tilePosition","_tileScale","potWidth","potHeight","fillCanvas","fillContext","setOriginFromFrame","createTexture2D","LINEAR","REPEAT","RGBA","newFrame","updateTileTexture","setTilePosition","setTileScale","fw","fh","createPattern","disable","positionX","positionY","InputEvents","SoundEvents","VideoRender","TextureCrop","videoTextureSource","snapshotTexture","_key","touchLocked","playWhenUnlocked","retryLimit","retry","retryInterval","_retryID","_systemMuted","_codeMuted","_systemPaused","_codePaused","_callbacks","playHandler","error","loadErrorHandler","completeHandler","timeUpdateHandler","seeking","seekingHandler","seeked","seekedHandler","markers","_markerIn","_markerOut","MAX_SAFE_INTEGER","_lastUpdate","_cacheKey","_isSeeking","removeVideoElementOnDestroy","changeSource","PAUSE","globalPause","RESUME","globalResume","sound","GLOBAL_MUTE","globalMute","loop","markerIn","markerOut","isPlaying","mute","setMute","isNaN","callbacks","playPromise","then","playPromiseSuccessHandler","catch","playPromiseErrorHandler","addEventListener","readyState","window","setTimeout","checkVideoProgress","autoplay","stop","newVideo","paused","muted","videoWidth","videoHeight","VIDEO_CREATED","updateTexture","currentTime","addMarker","playMarker","marker","removeMarker","srcWidth","srcHeight","destWidth","destHeight","snap","saveSnapshotTexture","loadURL","url","loadEvent","noAudio","document","createElement","controls","defaultMuted","setAttribute","loadMediaStream","stream","srcObject","URL","createObjectURL","VIDEO_PLAY","POINTER_DOWN","unlockHandler","VIDEO_ERROR","removeEventListener","event","VIDEO_UNLOCKED","VIDEO_COMPLETE","VIDEO_LOOP","VIDEO_TIMEOUT","textureSource","getVideoKey","seekTo","duration","Infinity","seekTime","setCurrentTime","getCurrentTime","op","num","parseFloat","isSeeking","VIDEO_SEEKING","VIDEO_SEEKED","getProgress","now","getDuration","isMuted","soundManager","setPaused","getVolume","volume","setVolume","getPlaybackRate","playbackRate","setPlaybackRate","rate","getLoop","setLoop","ended","isPaused","setFlipY","clearTimeout","VIDEO_STOP","removeVideoElement","parentNode","removeChild","hasChildNodes","firstChild","removeAttribute","SetValue","ShaderRender","vertexData","ArrayBuffer","BYTES_PER_ELEMENT","vertexBuffer","createVertexBuffer","byteLength","STREAM_DRAW","program","bytes","Uint8Array","_tempMatrix1","_tempMatrix2","_tempMatrix3","viewMatrix","projectionMatrix","uniforms","pointer","_textureCount","setShader","RENDER_MASK","setRenderToTexture","createTextureFromSource","createFramebuffer","addGLTexture","has","deleteProgram","createProgram","vertexSrc","fragmentSrc","uniformMatrix4fv","getUniformLocation","uniform2f","Date","defaultUniforms","mouse","date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","sampleRate","iChannel0","repeat","iChannel1","iChannel2","iChannel3","setSampler2D","initUniforms","setPointer","leftRight","bottomTop","pm","setProgram","map","glFuncMap","uniform","uniformLocation","glMatrix","glValueLength","glFunc","func","setSampler2DBuffer","uniformKey","textureIndex","initSampler2D","setUniform","getUniform","setChannel0","setChannel1","setChannel2","setChannel3","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","magFilter","toUpperCase","minFilter","wrapS","wrapT","format","pixelStorei","UNPACK_FLIP_Y_WEBGL","border","texImage2D","UNSIGNED_BYTE","texParameteri","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","uniform1i","syncUniforms","location","textureCount","transpose","matrix2D","vm","useProgram","res","px","py","toFixed","vertexSize","setFramebuffer","clearColor","COLOR_BUFFER_BIT","bindBuffer","ARRAY_BUFFER","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","vf","bufferSubData","subarray","drawArrays","TRIANGLES","deleteBuffer","deleteFramebuffer","Face","GenerateVerts","GenerateObjVerts","Matrix4","MeshRender","Vector3","Vertex","modelPosition","modelScale","modelRotation","dirtyCache","totalRendered","ignoreDirtyCache","setPerspective","addVertices","panX","v","addScale","LEFT","panY","DOWN","panZ","fov","near","far","perspective","setOrtho","getAspectRatio","ortho","addVerticesFromObj","rotateX","rotateY","rotateZ","zIsUp","obj","faceA","faceB","depth","addVertex","u","vert","addFace","vertex1","vertex2","vertex3","getFaceCount","getVertexCount","getFace","getFaceAt","cameras","main","results","renderDebug","isDirty","pz","rx","ry","rz","sz","pxCached","pyCached","pzCached","rxCached","ryCached","rzCached","sxCached","syCached","szCached","fCached","identity","setWorldMatrix","transformCoordinatesLocal","setScale","scrollFactor","angle","origin","ox","oy","NORMAL","_tempLine","setFillStyle","setStrokeStyle","setClosePath","setDisplaySize","displayWidth","displayHeight","animConfig","delay","repeatDelay","yoyo","delayedPlay","playConfig","playAfterDelay","_visible","resetFlip","reset","setFlipX","setFlip","setVisible","setTint","DOMElementRender","IsPlainObject","SCENE_EVENTS","Vector4","domContainer","html","transformOnly","skewX","skewY","rotate3d","rotate3dAngle","pointerEvents","dispatchNativeEvent","setElement","SLEEP","handleSceneEvent","WAKE","setSkew","addListener","removeListener","tagName","target","removeElement","getElementById","nodeType","zIndex","phaser","appendChild","updateSize","createFromCache","createFromHTML","innerHTML","nodeBounds","getBoundingClientRect","clientWidth","clientHeight","getChildByProperty","querySelectorAll","getChildByID","getChildByName","setClassName","className","setHTML","CSSBlendModes","srcMatrix","opacity","mixBlendMode","_blendMode","transform","getCSSMatrix","transformOrigin","ExternRender","renderTargetCtx","allowClip","commandBufferLength","lineAlpha","lineColor","red","green","blue","strokeStyle","LINE_FX_TO","MOVE_FX_TO","FloatBetween","GetEaseFunction","Wrap","defaultValue","emitOnly","propertyKey","propertyValue","steps","counter","ease","onEmit","defaultEmit","onUpdate","defaultUpdate","loadConfig","newKey","setMethods","onChange","staticValueEmit","staticValueUpdate","randomStaticValueEmit","hasBoth","isRandom","randomRangedValueEmit","steppedEmit","easeType","easeParams","easedValueEmit","easeValueUpdate","min","rnd","random","hasEither","object","hasOwnProperty","key1","key2","randomIndex","power","epsilon","gravity","_gravity","_power","_epsilon","dSq","sqrt","factor","velocityX","velocityY","pwr","DistanceBetween","accelerationX","accelerationY","maxVelocityX","maxVelocityY","bounce","life","lifeCurrent","delayCurrent","lifeT","isAlive","resetPosition","fire","emitZone","getPoint","lifespan","speedX","speedY","radial","rad","abs","mx","moveToX","my","moveToY","atan2","speed","acceleration","computeVelocity","step","processors","vx","vy","ax","ay","gravityX","gravityY","checkBounds","collideLeft","collideRight","collideTop","collideBottom","deathZone","willKill","HasAny","HasValue","configFastMap","configOpMap","particleClass","emitCallback","emitCallbackScope","deathCallback","deathCallbackScope","maxParticles","frequency","particleBringToTop","follow","followOffset","trackVisible","randomFrame","frameQuantity","dead","_counter","_frameCounter","fromJSON","callbackScope","setEmitZone","setDeathZone","setBounds","setFromObject","reserve","startFollow","stopFollow","_frameLength","pickRandom","frameConfig","isCycle","setRadial","setSpeedX","setSpeedY","setSpeed","setScaleX","setScaleY","setGravityX","setGravityY","setGravity","setEmitterAngle","setAngle","setLifespan","setQuantity","setFrequency","zoneConfig","stepRate","seamless","killOnEnter","getAliveParticleCount","getDeadParticleCount","getParticleCount","atLimit","onParticleEmit","onParticleDeath","killAll","forEachAlive","forEachDead","depthSortCallback","flow","explode","followX","followY","rip","splice","withinZone","_length","_direction","updateSource","oldLength","_tempVec","vec","getRandomPoint","pathUpdate","maxLineWidth","drawnLines","maxLines","wordWrap","propertyMap","fontFamily","fontStyle","shadowOffsetX","shadowOffsetY","shadowColor","shadowBlur","testString","baselineX","baselineY","_font","descent","setDefaults","lineCap","lineJoin","recalculateMetrics","fontSplit","setTestString","string","textStyle","actualBoundingBoxAscent","actualBoundingBoxDescent","baseline","imagedata","getImageData","pixels","numPixels","ArcRender","Earcut","GeomCircle","_anticlockwise","_iterations","diameter","updateData","iterations","setRadius","setIterations","setStartAngle","setEndAngle","CurveRender","_smoothness","setSmoothness","EllipseRender","GeomEllipse","GridRender","setOutlineStyle","setAltFillStyle","IsoBoxRender","setProjection","setFaces","IsoTriangleRender","setReversed","GeomLine","LineRender","setLineWidth","PolygonRender","GetAABB","GeomPolygon","Smooth","smooth","GeomRectangle","RectangleRender","getLineA","getLineB","getLineC","getLineD","StarRender","_points","_innerRadius","_outerRadius","setInnerRadius","setOuterRadius","rot","GeomTriangle","TriangleRender","tri","Circle","RGB","getFloatsFromUintRGB","setIntensity","CircleToRectangle","SpliceOne","lights","ambientColor","maxLights","visibleLights","addPointLight","enable","getLights","worldView","light","distance","sortByDistance","setAmbientColor","getMaxVisibleLights","getLightCount","addLight","removeLight","altColor","altAlpha","halfLineWidth"],"mappings":"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","file":"js/vendors~phaser~gameobjects.c0d95662d428fb5f77ab.js","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.GameObjects\r\n */\r\n\r\nvar GameObjects = {\r\n\r\n    Events: require('./events'),\r\n\r\n    DisplayList: require('./DisplayList'),\r\n    GameObjectCreator: require('./GameObjectCreator'),\r\n    GameObjectFactory: require('./GameObjectFactory'),\r\n    UpdateList: require('./UpdateList'),\r\n\r\n    Components: require('./components'),\r\n    GetCalcMatrix: require('./GetCalcMatrix'),\r\n\r\n    BuildGameObject: require('./BuildGameObject'),\r\n    BuildGameObjectAnimation: require('./BuildGameObjectAnimation'),\r\n    GameObject: require('./GameObject'),\r\n    BitmapText: require('./bitmaptext/static/BitmapText'),\r\n    Blitter: require('./blitter/Blitter'),\r\n    Bob: require('./blitter/Bob'),\r\n    Container: require('./container/Container'),\r\n    DOMElement: require('./domelement/DOMElement'),\r\n    DynamicBitmapText: require('./bitmaptext/dynamic/DynamicBitmapText'),\r\n    Extern: require('./extern/Extern.js'),\r\n    Graphics: require('./graphics/Graphics.js'),\r\n    Group: require('./group/Group'),\r\n    Image: require('./image/Image'),\r\n    Layer: require('./layer/Layer'),\r\n    Particles: require('./particles'),\r\n    PathFollower: require('./pathfollower/PathFollower'),\r\n    RenderTexture: require('./rendertexture/RenderTexture'),\r\n    RetroFont: require('./bitmaptext/RetroFont'),\r\n    Rope: require('./rope/Rope'),\r\n    Sprite: require('./sprite/Sprite'),\r\n\r\n    Text: require('./text/Text'),\r\n    GetTextSize: require('./text/GetTextSize'),\r\n    MeasureText: require('./text/MeasureText'),\r\n    TextStyle: require('./text/TextStyle'),\r\n\r\n    TileSprite: require('./tilesprite/TileSprite'),\r\n    Zone: require('./zone/Zone'),\r\n    Video: require('./video/Video'),\r\n\r\n    //  Shapes\r\n\r\n    Shape: require('./shape/Shape'),\r\n    Arc: require('./shape/arc/Arc'),\r\n    Curve: require('./shape/curve/Curve'),\r\n    Ellipse: require('./shape/ellipse/Ellipse'),\r\n    Grid: require('./shape/grid/Grid'),\r\n    IsoBox: require('./shape/isobox/IsoBox'),\r\n    IsoTriangle: require('./shape/isotriangle/IsoTriangle'),\r\n    Line: require('./shape/line/Line'),\r\n    Polygon: require('./shape/polygon/Polygon'),\r\n    Rectangle: require('./shape/rectangle/Rectangle'),\r\n    Star: require('./shape/star/Star'),\r\n    Triangle: require('./shape/triangle/Triangle'),\r\n\r\n    //  Game Object Factories\r\n\r\n    Factories: {\r\n        Blitter: require('./blitter/BlitterFactory'),\r\n        Container: require('./container/ContainerFactory'),\r\n        DOMElement: require('./domelement/DOMElementFactory'),\r\n        DynamicBitmapText: require('./bitmaptext/dynamic/DynamicBitmapTextFactory'),\r\n        Extern: require('./extern/ExternFactory'),\r\n        Graphics: require('./graphics/GraphicsFactory'),\r\n        Group: require('./group/GroupFactory'),\r\n        Image: require('./image/ImageFactory'),\r\n        Layer: require('./layer/LayerFactory'),\r\n        Particles: require('./particles/ParticleManagerFactory'),\r\n        PathFollower: require('./pathfollower/PathFollowerFactory'),\r\n        RenderTexture: require('./rendertexture/RenderTextureFactory'),\r\n        Rope: require('./rope/RopeFactory'),\r\n        Sprite: require('./sprite/SpriteFactory'),\r\n        StaticBitmapText: require('./bitmaptext/static/BitmapTextFactory'),\r\n        Text: require('./text/TextFactory'),\r\n        TileSprite: require('./tilesprite/TileSpriteFactory'),\r\n        Zone: require('./zone/ZoneFactory'),\r\n        Video: require('./video/VideoFactory'),\r\n\r\n        //  Shapes\r\n        Arc: require('./shape/arc/ArcFactory'),\r\n        Curve: require('./shape/curve/CurveFactory'),\r\n        Ellipse: require('./shape/ellipse/EllipseFactory'),\r\n        Grid: require('./shape/grid/GridFactory'),\r\n        IsoBox: require('./shape/isobox/IsoBoxFactory'),\r\n        IsoTriangle: require('./shape/isotriangle/IsoTriangleFactory'),\r\n        Line: require('./shape/line/LineFactory'),\r\n        Polygon: require('./shape/polygon/PolygonFactory'),\r\n        Rectangle: require('./shape/rectangle/RectangleFactory'),\r\n        Star: require('./shape/star/StarFactory'),\r\n        Triangle: require('./shape/triangle/TriangleFactory')\r\n    },\r\n\r\n    Creators: {\r\n        Blitter: require('./blitter/BlitterCreator'),\r\n        Container: require('./container/ContainerCreator'),\r\n        DynamicBitmapText: require('./bitmaptext/dynamic/DynamicBitmapTextCreator'),\r\n        Graphics: require('./graphics/GraphicsCreator'),\r\n        Group: require('./group/GroupCreator'),\r\n        Image: require('./image/ImageCreator'),\r\n        Layer: require('./layer/LayerCreator'),\r\n        Particles: require('./particles/ParticleManagerCreator'),\r\n        RenderTexture: require('./rendertexture/RenderTextureCreator'),\r\n        Rope: require('./rope/RopeCreator'),\r\n        Sprite: require('./sprite/SpriteCreator'),\r\n        StaticBitmapText: require('./bitmaptext/static/BitmapTextCreator'),\r\n        Text: require('./text/TextCreator'),\r\n        TileSprite: require('./tilesprite/TileSpriteCreator'),\r\n        Zone: require('./zone/ZoneCreator'),\r\n        Video: require('./video/VideoCreator')\r\n    }\r\n\r\n};\r\n\r\n//  WebGL only Game Objects\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    GameObjects.Shader = require('./shader/Shader');\r\n    GameObjects.Mesh = require('./mesh/Mesh');\r\n    GameObjects.PointLight = require('./pointlight/PointLight');\r\n\r\n    GameObjects.Factories.Shader = require('./shader/ShaderFactory');\r\n    GameObjects.Factories.Mesh = require('./mesh/MeshFactory');\r\n    GameObjects.Factories.PointLight = require('./pointlight/PointLightFactory');\r\n\r\n    GameObjects.Creators.Shader = require('./shader/ShaderCreator');\r\n    GameObjects.Creators.Mesh = require('./mesh/MeshCreator');\r\n    GameObjects.Creators.PointLight = require('./pointlight/PointLightCreator');\r\n\r\n    GameObjects.Light = require('./lights/Light');\r\n    GameObjects.LightsManager = require('./lights/LightsManager');\r\n    GameObjects.LightsPlugin = require('./lights/LightsPlugin');\r\n}\r\n\r\nmodule.exports = GameObjects;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar List = require('../structs/List');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar GameObjectEvents = require('./events');\r\nvar SceneEvents = require('../scene/events');\r\nvar StableSort = require('../utils/array/StableSort');\r\n\r\n/**\r\n * @classdesc\r\n * The Display List plugin.\r\n *\r\n * Display Lists belong to a Scene and maintain the list of Game Objects to render every frame.\r\n *\r\n * Some of these Game Objects may also be part of the Scene's [Update List]{@link Phaser.GameObjects.UpdateList}, for updating.\r\n *\r\n * @class DisplayList\r\n * @extends Phaser.Structs.List.<Phaser.GameObjects.GameObject>\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this Display List belongs to.\r\n */\r\nvar DisplayList = new Class({\r\n\r\n    Extends: List,\r\n\r\n    initialize:\r\n\r\n    function DisplayList (scene)\r\n    {\r\n        List.call(this, scene);\r\n\r\n        /**\r\n         * The flag the determines whether Game Objects should be sorted when `depthSort()` is called.\r\n         *\r\n         * @name Phaser.GameObjects.DisplayList#sortChildrenFlag\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.sortChildrenFlag = false;\r\n\r\n        /**\r\n         * The Scene that this Display List belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.DisplayList#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The Scene's Systems.\r\n         *\r\n         * @name Phaser.GameObjects.DisplayList#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * The Scene's Event Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.DisplayList#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.50.0\r\n         */\r\n        this.events = scene.sys.events;\r\n\r\n        //  Set the List callbacks\r\n        this.addCallback = this.addChildCallback;\r\n        this.removeCallback = this.removeChildCallback;\r\n\r\n        this.events.once(SceneEvents.BOOT, this.boot, this);\r\n        this.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * Internal method called from `List.addCallback`.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#addChildCallback\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#ADDED_TO_SCENE\r\n     * @fires Phaser.GameObjects.Events#ADDED_TO_SCENE\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was added to the list.\r\n     */\r\n    addChildCallback: function (gameObject)\r\n    {\r\n        if (gameObject.displayList && gameObject.displayList !== this)\r\n        {\r\n            gameObject.removeFromDisplayList();\r\n        }\r\n\r\n        if (!gameObject.displayList)\r\n        {\r\n            this.queueDepthSort();\r\n\r\n            gameObject.displayList = this;\r\n\r\n            gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);\r\n\r\n            this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method called from `List.removeCallback`.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#removeChildCallback\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#REMOVED_FROM_SCENE\r\n     * @fires Phaser.GameObjects.Events#REMOVED_FROM_SCENE\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was removed from the list.\r\n     */\r\n    removeChildCallback: function (gameObject)\r\n    {\r\n        this.queueDepthSort();\r\n\r\n        gameObject.displayList = null;\r\n\r\n        gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);\r\n\r\n        this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Force a sort of the display list on the next call to depthSort.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#queueDepthSort\r\n     * @since 3.0.0\r\n     */\r\n    queueDepthSort: function ()\r\n    {\r\n        this.sortChildrenFlag = true;\r\n    },\r\n\r\n    /**\r\n     * Immediately sorts the display list if the flag is set.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#depthSort\r\n     * @since 3.0.0\r\n     */\r\n    depthSort: function ()\r\n    {\r\n        if (this.sortChildrenFlag)\r\n        {\r\n            StableSort(this.list, this.sortByDepth);\r\n\r\n            this.sortChildrenFlag = false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Compare the depth of two Game Objects.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#sortByDepth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - The first Game Object.\r\n     * @param {Phaser.GameObjects.GameObject} childB - The second Game Object.\r\n     *\r\n     * @return {number} The difference between the depths of each Game Object.\r\n     */\r\n    sortByDepth: function (childA, childB)\r\n    {\r\n        return childA._depth - childB._depth;\r\n    },\r\n\r\n    /**\r\n     * Returns an array which contains all objects currently on the Display List.\r\n     * This is a reference to the main list array, not a copy of it, so be careful not to modify it.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#getChildren\r\n     * @since 3.12.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The group members.\r\n     */\r\n    getChildren: function ()\r\n    {\r\n        return this.list;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     *\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var list = this.list;\r\n\r\n        var i = list.length;\r\n\r\n        while (i--)\r\n        {\r\n            list[i].destroy(true);\r\n        }\r\n\r\n        list.length = 0;\r\n\r\n        this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n        this.events = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('DisplayList', DisplayList, 'displayList');\r\n\r\nmodule.exports = DisplayList;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar ProcessQueue = require('../structs/ProcessQueue');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar SceneEvents = require('../scene/events');\r\n\r\n/**\r\n * @classdesc\r\n * The Update List plugin.\r\n *\r\n * Update Lists belong to a Scene and maintain the list Game Objects to be updated every frame.\r\n *\r\n * Some or all of these Game Objects may also be part of the Scene's [Display List]{@link Phaser.GameObjects.DisplayList}, for Rendering.\r\n *\r\n * @class UpdateList\r\n * @extends Phaser.Structs.ProcessQueue.<Phaser.GameObjects.GameObject>\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that the Update List belongs to.\r\n */\r\nvar UpdateList = new Class({\r\n\r\n    Extends: ProcessQueue,\r\n\r\n    initialize:\r\n\r\n    function UpdateList (scene)\r\n    {\r\n        ProcessQueue.call(this);\r\n\r\n        //  No duplicates in this list\r\n        this.checkQueue = true;\r\n\r\n        /**\r\n         * The Scene that the Update List belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The Scene's Systems.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * The `pending` list is a selection of items which are due to be made 'active' in the next update.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_pending\r\n         * @type {Array.<*>}\r\n         * @private\r\n         * @default []\r\n         * @since 3.20.0\r\n         */\r\n\r\n        /**\r\n         * The `active` list is a selection of items which are considered active and should be updated.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_active\r\n         * @type {Array.<*>}\r\n         * @private\r\n         * @default []\r\n         * @since 3.20.0\r\n         */\r\n\r\n        /**\r\n         * The `destroy` list is a selection of items that were active and are awaiting being destroyed in the next update.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_destroy\r\n         * @type {Array.<*>}\r\n         * @private\r\n         * @default []\r\n         * @since 3.20.0\r\n         */\r\n\r\n        /**\r\n         * The total number of items awaiting processing.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_toProcess\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.PRE_UPDATE, this.update, this);\r\n        eventEmitter.on(SceneEvents.UPDATE, this.sceneUpdate, this);\r\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The update step.\r\n     *\r\n     * Pre-updates every active Game Object in the list.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#sceneUpdate\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time elapsed since the last frame.\r\n     */\r\n    sceneUpdate: function (time, delta)\r\n    {\r\n        var list = this._active;\r\n        var length = list.length;\r\n\r\n        for (var i = 0; i < length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            if (gameObject.active)\r\n            {\r\n                gameObject.preUpdate.call(gameObject, time, delta);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     *\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var i = this._active.length;\r\n\r\n        while (i--)\r\n        {\r\n            this._active[i].destroy(true);\r\n        }\r\n\r\n        i = this._pending.length;\r\n\r\n        while (i--)\r\n        {\r\n            this._pending[i].destroy(true);\r\n        }\r\n\r\n        i = this._destroy.length;\r\n\r\n        while (i--)\r\n        {\r\n            this._destroy[i].destroy(true);\r\n        }\r\n\r\n        this._toProcess = 0;\r\n\r\n        this._pending = [];\r\n        this._active = [];\r\n        this._destroy = [];\r\n\r\n        this.removeAllListeners();\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(SceneEvents.PRE_UPDATE, this.update, this);\r\n        eventEmitter.off(SceneEvents.UPDATE, this.sceneUpdate, this);\r\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     *\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.systems.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n    /**\r\n     * Adds a new item to the Update List.\r\n     *\r\n     * The item is added to the pending list and made active in the next update.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} item - The item to add to the queue.\r\n     *\r\n     * @return {*} The item that was added.\r\n     */\r\n\r\n    /**\r\n     * Removes an item from the Update List.\r\n     *\r\n     * The item is added to the pending destroy and fully removed in the next update.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} item - The item to be removed from the queue.\r\n     *\r\n     * @return {*} The item that was removed.\r\n     */\r\n\r\n    /**\r\n     * Removes all active items from this Update List.\r\n     *\r\n     * All the items are marked as 'pending destroy' and fully removed in the next update.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#removeAll\r\n     * @since 3.20.0\r\n     *\r\n     * @return {this} This Update List object.\r\n     */\r\n\r\n    /**\r\n     * Update this queue. First it will process any items awaiting destruction, and remove them.\r\n     *\r\n     * Then it will check to see if there are any items pending insertion, and move them to an\r\n     * active state. Finally, it will return a list of active items for further processing.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#update\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Array.<*>} A list of active items.\r\n     */\r\n\r\n    /**\r\n     * Returns the current list of active items.\r\n     *\r\n     * This method returns a reference to the active list array, not a copy of it.\r\n     * Therefore, be careful to not modify this array outside of the ProcessQueue.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#getActive\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Array.<*>} A list of active items.\r\n     */\r\n\r\n    /**\r\n     * The number of entries in the active list.\r\n     *\r\n     * @name Phaser.GameObjects.UpdateList#length\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.20.0\r\n     */\r\n});\r\n\r\nPluginCache.register('UpdateList', UpdateList, 'updateList');\r\n\r\nmodule.exports = UpdateList;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculate the full bounds, in local and world space, of a BitmapText Game Object.\n *\n * Returns a BitmapTextSize object that contains global and local variants of the Game Objects x and y coordinates and\n * its width and height. Also includes an array of the line lengths and all word positions.\n *\n * The global position and size take into account the Game Object's position and scale.\n *\n * The local position and size just takes into account the font data.\n *\n * @function GetBitmapTextSize\n * @since 3.0.0\n * @private\n *\n * @param {(Phaser.GameObjects.DynamicBitmapText|Phaser.GameObjects.BitmapText)} src - The BitmapText to calculate the bounds values for.\n * @param {boolean} [round=false] - Whether to round the positions to the nearest integer.\n * @param {boolean} [updateOrigin=false] - Whether to update the origin of the BitmapText after bounds calculations?\n * @param {object} [out] - Object to store the results in, to save constant object creation. If not provided an empty object is returned.\n *\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapTextSize} The calculated bounds values of the BitmapText.\n */\nvar GetBitmapTextSize = function (src, round, updateOrigin, out)\n{\n    if (updateOrigin === undefined) { updateOrigin = false; }\n\n    if (out === undefined)\n    {\n        out = {\n            local: {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n            },\n            global: {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n            },\n            lines: {\n                shortest: 0,\n                longest: 0,\n                lengths: null,\n                height: 0\n            },\n            wrappedText: '',\n            words: [],\n            characters: [],\n            scaleX: 0,\n            scaleY: 0\n        };\n\n        return out;\n    }\n\n    var text = src.text;\n    var textLength = text.length;\n    var maxWidth = src.maxWidth;\n    var wordWrapCharCode = src.wordWrapCharCode;\n\n    var bx = Number.MAX_VALUE;\n    var by = Number.MAX_VALUE;\n    var bw = 0;\n    var bh = 0;\n\n    var chars = src.fontData.chars;\n    var lineHeight = src.fontData.lineHeight;\n    var letterSpacing = src.letterSpacing;\n\n    var xAdvance = 0;\n    var yAdvance = 0;\n\n    var charCode = 0;\n\n    var glyph = null;\n\n    var align = src._align;\n\n    var x = 0;\n    var y = 0;\n\n    var scale = (src.fontSize / src.fontData.size);\n    var sx = scale * src.scaleX;\n    var sy = scale * src.scaleY;\n\n    var lastGlyph = null;\n    var lastCharCode = 0;\n    var lineWidths = [];\n    var shortestLine = Number.MAX_VALUE;\n    var longestLine = 0;\n    var currentLine = 0;\n    var currentLineWidth = 0;\n\n    var i;\n    var words = [];\n    var characters = [];\n    var current = null;\n\n    //  Scan for breach of maxWidth and insert carriage-returns\n    if (maxWidth > 0)\n    {\n        for (i = 0; i < textLength; i++)\n        {\n            charCode = text.charCodeAt(i);\n\n            if (charCode === 10)\n            {\n                if (current !== null)\n                {\n                    words.push({\n                        word: current.word,\n                        i: current.i,\n                        x: current.x * sx,\n                        y: current.y * sy,\n                        w: current.w * sx,\n                        h: current.h * sy,\n                        cr: true\n                    });\n\n                    current = null;\n                }\n\n                xAdvance = 0;\n                yAdvance += lineHeight;\n                lastGlyph = null;\n\n                continue;\n            }\n\n            glyph = chars[charCode];\n\n            if (!glyph)\n            {\n                continue;\n            }\n\n            if (lastGlyph !== null)\n            {\n                var glyphKerningOffset = glyph.kerning[lastCharCode];\n            }\n\n            if (charCode === wordWrapCharCode)\n            {\n                if (current !== null)\n                {\n                    words.push({\n                        word: current.word,\n                        i: current.i,\n                        x: current.x * sx,\n                        y: current.y * sy,\n                        w: current.w * sx,\n                        h: current.h * sy,\n                        cr: false\n                    });\n\n                    current = null;\n                }\n            }\n            else\n            {\n                if (current === null)\n                {\n                    //  We're starting a new word, recording the starting index, etc\n                    current = { word: '', i: i, x: xAdvance, y: yAdvance, w: 0, h: lineHeight, cr: false };\n                }\n\n                current.word = current.word.concat(text[i]);\n                current.w += glyph.xOffset + glyph.xAdvance + ((glyphKerningOffset !== undefined) ? glyphKerningOffset : 0);\n            }\n\n            xAdvance += glyph.xAdvance + letterSpacing;\n            lastGlyph = glyph;\n            lastCharCode = charCode;\n        }\n\n        //  Last word\n        if (current !== null)\n        {\n            words.push({\n                word: current.word,\n                i: current.i,\n                x: current.x * sx,\n                y: current.y * sy,\n                w: current.w * sx,\n                h: current.h * sy,\n                cr: false\n            });\n        }\n\n        //  Reset for the next loop\n        xAdvance = 0;\n        yAdvance = 0;\n        lastGlyph = null;\n        lastCharCode = 0;\n\n        //  Loop through the words array and see if we've got any > maxWidth\n        var prev;\n        var offset = 0;\n        var crs = [];\n\n        for (i = 0; i < words.length; i++)\n        {\n            var entry = words[i];\n            var left = entry.x;\n            var right = entry.x + entry.w;\n\n            if (prev)\n            {\n                var diff = left - (prev.x + prev.w);\n\n                offset = left - (diff + prev.w);\n\n                prev = null;\n            }\n\n            var checkLeft = left - offset;\n            var checkRight = right - offset;\n\n            if (checkLeft > maxWidth || checkRight > maxWidth)\n            {\n                crs.push(entry.i - 1);\n\n                if (entry.cr)\n                {\n                    crs.push(entry.i + entry.word.length);\n\n                    offset = 0;\n                    prev = null;\n                }\n                else\n                {\n                    prev = entry;\n                }\n            }\n            else if (entry.cr)\n            {\n                crs.push(entry.i + entry.word.length);\n\n                offset = 0;\n                prev = null;\n            }\n        }\n\n        var stringInsert = function (str, index, value)\n        {\n            return str.substr(0, index) + value + str.substr(index + 1);\n        };\n\n        for (i = crs.length - 1; i >= 0; i--)\n        {\n            // eslint-disable-next-line quotes\n            text = stringInsert(text, crs[i], \"\\n\");\n        }\n\n        out.wrappedText = text;\n\n        textLength = text.length;\n\n        //  Recalculated in the next loop\n        words = [];\n        current = null;\n    }\n\n    var charIndex = 0;\n\n    for (i = 0; i < textLength; i++)\n    {\n        charCode = text.charCodeAt(i);\n\n        if (charCode === 10)\n        {\n            if (current !== null)\n            {\n                words.push({\n                    word: current.word,\n                    i: current.i,\n                    x: current.x * sx,\n                    y: current.y * sy,\n                    w: current.w * sx,\n                    h: current.h * sy\n                });\n\n                current = null;\n            }\n\n            xAdvance = 0;\n            yAdvance += lineHeight;\n            lastGlyph = null;\n\n            lineWidths[currentLine] = currentLineWidth;\n\n            if (currentLineWidth > longestLine)\n            {\n                longestLine = currentLineWidth;\n            }\n\n            if (currentLineWidth < shortestLine)\n            {\n                shortestLine = currentLineWidth;\n            }\n\n            currentLine++;\n            currentLineWidth = 0;\n\n            continue;\n        }\n\n        glyph = chars[charCode];\n\n        if (!glyph)\n        {\n            continue;\n        }\n\n        x = xAdvance;\n        y = yAdvance;\n\n        if (lastGlyph !== null)\n        {\n            var kerningOffset = glyph.kerning[lastCharCode];\n\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\n        }\n\n        if (bx > x)\n        {\n            bx = x;\n        }\n\n        if (by > y)\n        {\n            by = y;\n        }\n\n        var gw = x + glyph.xAdvance;\n        var gh = y + lineHeight;\n\n        if (bw < gw)\n        {\n            bw = gw;\n        }\n\n        if (bh < gh)\n        {\n            bh = gh;\n        }\n\n        var charWidth = glyph.xOffset + glyph.xAdvance + ((kerningOffset !== undefined) ? kerningOffset : 0);\n\n        if (charCode === wordWrapCharCode)\n        {\n            if (current !== null)\n            {\n                words.push({\n                    word: current.word,\n                    i: current.i,\n                    x: current.x * sx,\n                    y: current.y * sy,\n                    w: current.w * sx,\n                    h: current.h * sy\n                });\n\n                current = null;\n            }\n        }\n        else\n        {\n            if (current === null)\n            {\n                //  We're starting a new word, recording the starting index, etc\n                current = { word: '', i: charIndex, x: xAdvance, y: yAdvance, w: 0, h: lineHeight };\n            }\n\n            current.word = current.word.concat(text[i]);\n            current.w += charWidth;\n        }\n\n        characters.push({\n            i: charIndex,\n            char: text[i],\n            code: charCode,\n            x: (glyph.xOffset + xAdvance) * scale,\n            y: (glyph.yOffset + yAdvance) * scale,\n            w: glyph.width * scale,\n            h: glyph.height * scale,\n            t: yAdvance * scale,\n            r: gw * scale,\n            b: lineHeight * scale,\n            line: currentLine,\n            glyph: glyph\n        });\n\n        xAdvance += glyph.xAdvance + letterSpacing;\n        lastGlyph = glyph;\n        lastCharCode = charCode;\n        currentLineWidth = gw * scale;\n        charIndex++;\n    }\n\n    //  Last word\n    if (current !== null)\n    {\n        words.push({\n            word: current.word,\n            i: current.i,\n            x: current.x * sx,\n            y: current.y * sy,\n            w: current.w * sx,\n            h: current.h * sy\n        });\n    }\n\n    lineWidths[currentLine] = currentLineWidth;\n\n    if (currentLineWidth > longestLine)\n    {\n        longestLine = currentLineWidth;\n    }\n\n    if (currentLineWidth < shortestLine)\n    {\n        shortestLine = currentLineWidth;\n    }\n\n    //  Adjust all of the character positions based on alignment\n    if (align > 0)\n    {\n        for (var c = 0; c < characters.length; c++)\n        {\n            var currentChar = characters[c];\n\n            if (align === 1)\n            {\n                var ax1 = ((longestLine - lineWidths[currentChar.line]) / 2);\n\n                currentChar.x += ax1;\n                currentChar.r += ax1;\n            }\n            else if (align === 2)\n            {\n                var ax2 = (longestLine - lineWidths[currentChar.line]);\n\n                currentChar.x += ax2;\n                currentChar.r += ax2;\n            }\n        }\n    }\n\n    var local = out.local;\n    var global = out.global;\n    var lines = out.lines;\n\n    local.x = bx * scale;\n    local.y = by * scale;\n    local.width = bw * scale;\n    local.height = bh * scale;\n\n    global.x = (src.x - src._displayOriginX) + (bx * sx);\n    global.y = (src.y - src._displayOriginY) + (by * sy);\n\n    global.width = bw * sx;\n    global.height = bh * sy;\n\n    lines.shortest = shortestLine;\n    lines.longest = longestLine;\n    lines.lengths = lineWidths;\n\n    if (round)\n    {\n        local.x = Math.ceil(local.x);\n        local.y = Math.ceil(local.y);\n        local.width = Math.ceil(local.width);\n        local.height = Math.ceil(local.height);\n\n        global.x = Math.ceil(global.x);\n        global.y = Math.ceil(global.y);\n        global.width = Math.ceil(global.width);\n        global.height = Math.ceil(global.height);\n\n        lines.shortest = Math.ceil(shortestLine);\n        lines.longest = Math.ceil(longestLine);\n    }\n\n    if (updateOrigin)\n    {\n        src._displayOriginX = (src.originX * local.width);\n        src._displayOriginY = (src.originY * local.height);\n\n        global.x = src.x - (src._displayOriginX * src.scaleX);\n        global.y = src.y - (src._displayOriginY * src.scaleY);\n\n        if (round)\n        {\n            global.x = Math.ceil(global.x);\n            global.y = Math.ceil(global.y);\n        }\n    }\n\n    out.words = words;\n    out.characters = characters;\n    out.lines.height = lineHeight;\n    out.scale = scale;\n    out.scaleX = src.scaleX;\n    out.scaleY = src.scaleY;\n\n    return out;\n};\n\nmodule.exports = GetBitmapTextSize;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ParseXMLBitmapFont = require('./ParseXMLBitmapFont');\r\n\r\n/**\r\n * Parse an XML Bitmap Font from an Atlas.\r\n *\r\n * Adds the parsed Bitmap Font data to the cache with the `fontName` key.\r\n *\r\n * @function ParseFromAtlas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to parse the Bitmap Font for.\r\n * @param {string} fontName - The key of the font to add to the Bitmap Font cache.\r\n * @param {string} textureKey - The key of the BitmapFont's texture.\r\n * @param {string} frameKey - The key of the BitmapFont texture's frame.\r\n * @param {string} xmlKey - The key of the XML data of the font to parse.\r\n * @param {number} [xSpacing] - The x-axis spacing to add between each letter.\r\n * @param {number} [ySpacing] - The y-axis spacing to add to the line height.\r\n *\r\n * @return {boolean} Whether the parsing was successful or not.\r\n */\r\nvar ParseFromAtlas = function (scene, fontName, textureKey, frameKey, xmlKey, xSpacing, ySpacing)\r\n{\r\n    var texture = scene.sys.textures.get(textureKey);\r\n    var frame = texture.get(frameKey);\r\n    var xml = scene.sys.cache.xml.get(xmlKey);\r\n\r\n    if (frame && xml)\r\n    {\r\n        var data = ParseXMLBitmapFont(xml, frame, xSpacing, ySpacing, texture);\r\n\r\n        scene.sys.cache.bitmapFont.add(fontName, { data: data, texture: textureKey, frame: frameKey, fromAtlas: true });\r\n\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = ParseFromAtlas;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar renderWebGL = require('../../../utils/NOOP');\nvar renderCanvas = require('../../../utils/NOOP');\n\nif (typeof WEBGL_RENDERER)\n{\n    renderWebGL = require('./BitmapTextWebGLRenderer');\n}\n\nif (typeof CANVAS_RENDERER)\n{\n    renderCanvas = require('./BitmapTextCanvasRenderer');\n}\n\nmodule.exports = {\n\n    renderWebGL: renderWebGL,\n    renderCanvas: renderCanvas\n\n};\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BatchChar = require('../BatchChar');\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.BitmapText#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.BitmapText} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar BitmapTextWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var text = src._text;\r\n    var textLength = text.length;\r\n\r\n    if (textLength === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    var cameraAlpha = camera.alpha;\r\n\r\n    var charColors = src.charColors;\r\n\r\n    var tintEffect = src.tintFill;\r\n\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    var tintTL = getTint(src.tintTopLeft, cameraAlpha * src._alphaTL);\r\n    var tintTR = getTint(src.tintTopRight, cameraAlpha * src._alphaTR);\r\n    var tintBL = getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL);\r\n    var tintBR = getTint(src.tintBottomRight, cameraAlpha * src._alphaBR);\r\n\r\n    var texture = src.frame.glTexture;\r\n    var textureUnit = pipeline.setGameObject(src);\r\n\r\n    //  Update the bounds - skipped internally if not dirty\r\n    var bounds = src.getTextBounds(false);\r\n\r\n    var i;\r\n    var char;\r\n    var glyph;\r\n\r\n    var characters = bounds.characters;\r\n\r\n    var dropShadowX = src.dropShadowX;\r\n    var dropShadowY = src.dropShadowY;\r\n\r\n    var dropShadow = (dropShadowX !== 0 || dropShadowY !== 0);\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (dropShadow)\r\n    {\r\n        var srcShadowColor = src.dropShadowColor;\r\n        var srcShadowAlpha = src.dropShadowAlpha;\r\n\r\n        var shadowTL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTL);\r\n        var shadowTR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTR);\r\n        var shadowBL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBL);\r\n        var shadowBR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBR);\r\n\r\n        for (i = 0; i < characters.length; i++)\r\n        {\r\n            char = characters[i];\r\n            glyph = char.glyph;\r\n\r\n            if (char.code === 32 || glyph.width === 0 || glyph.height === 0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            BatchChar(pipeline, src, char, glyph, dropShadowX, dropShadowY, calcMatrix, roundPixels, shadowTL, shadowTR, shadowBL, shadowBR, 1, texture, textureUnit);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < characters.length; i++)\r\n    {\r\n        char = characters[i];\r\n        glyph = char.glyph;\r\n\r\n        if (char.code === 32 || glyph.width === 0 || glyph.height === 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (charColors[char.i])\r\n        {\r\n            var color = charColors[char.i];\r\n\r\n            var charTintEffect = color.tintEffect;\r\n            var charTintTL = getTint(color.tintTL, cameraAlpha * src._alphaTL);\r\n            var charTintTR = getTint(color.tintTR, cameraAlpha * src._alphaTR);\r\n            var charTintBL = getTint(color.tintBL, cameraAlpha * src._alphaBL);\r\n            var charTintBR = getTint(color.tintBR, cameraAlpha * src._alphaBR);\r\n\r\n            BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, charTintTL, charTintTR, charTintBL, charTintBR, charTintEffect, texture, textureUnit);\r\n        }\r\n        else\r\n        {\r\n            BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);\r\n        }\r\n\r\n        //  Debug test if the characters are in the correct place when rendered:\r\n        // pipeline.drawFillRect(tx0, ty0, tx2 - tx0, ty2 - ty0, 0x00ff00, 0.5);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = BitmapTextWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders one character of the Bitmap Text to the WebGL Pipeline.\r\n *\r\n * @function BatchChar\r\n * @since 3.50.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The WebGLPipeline. Must have a `batchQuad` method.\r\n * @param {Phaser.GameObjects.BitmapText} src - The BitmapText Game Object.\r\n * @param {Phaser.Types.GameObjects.BitmapText.BitmapTextCharacter} char - The character to render.\r\n * @param {Phaser.Types.GameObjects.BitmapText.BitmapFontCharacterData} glyph - The character glyph.\r\n * @param {number} offsetX - The x offset.\r\n * @param {number} offsetY - The y offset.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} calcMatrix - The transform matrix.\r\n * @param {boolean} roundPixels - Round the transform values or not?\r\n * @param {number} tintTL - Top-left tint value.\r\n * @param {number} tintTR - Top-right tint value.\r\n * @param {number} tintBL - Bottom-left tint value.\r\n * @param {number} tintBR - Bottom-right tint value.\r\n * @param {number} tintEffect - The tint effect mode.\r\n * @param {WebGLTexture} texture - The WebGL texture.\r\n * @param {number} textureUnit - The texture unit.\r\n */\r\nvar BatchChar = function (pipeline, src, char, glyph, offsetX, offsetY, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit)\r\n{\r\n    var x = (char.x - src.displayOriginX) + offsetX;\r\n    var y = (char.y - src.displayOriginY) + offsetY;\r\n\r\n    var xw = x + char.w;\r\n    var yh = y + char.h;\r\n\r\n    var tx0 = calcMatrix.getXRound(x, y, roundPixels);\r\n    var ty0 = calcMatrix.getYRound(x, y, roundPixels);\r\n\r\n    var tx1 = calcMatrix.getXRound(x, yh, roundPixels);\r\n    var ty1 = calcMatrix.getYRound(x, yh, roundPixels);\r\n\r\n    var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);\r\n    var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);\r\n\r\n    var tx3 = calcMatrix.getXRound(xw, y, roundPixels);\r\n    var ty3 = calcMatrix.getYRound(xw, y, roundPixels);\r\n\r\n    pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, glyph.u0, glyph.v0, glyph.u1, glyph.v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);\r\n};\r\n\r\nmodule.exports = BatchChar;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.BitmapText#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.BitmapText} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar BitmapTextCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var text = src._text;\r\n    var textLength = text.length;\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var textureFrame = src.fromAtlas\r\n        ? src.frame\r\n        : src.texture.frames['__BASE'];\r\n\r\n    var chars = src.fontData.chars;\r\n    var lineHeight = src.fontData.lineHeight;\r\n    var letterSpacing = src._letterSpacing;\r\n\r\n    var xAdvance = 0;\r\n    var yAdvance = 0;\r\n\r\n    var charCode = 0;\r\n\r\n    var glyph = null;\r\n    var glyphX = 0;\r\n    var glyphY = 0;\r\n    var glyphW = 0;\r\n    var glyphH = 0;\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n\r\n    var lastGlyph = null;\r\n    var lastCharCode = 0;\r\n\r\n    var image = textureFrame.source.image;\r\n\r\n    var textureX = textureFrame.cutX;\r\n    var textureY = textureFrame.cutY;\r\n\r\n    var scale = (src._fontSize / src.fontData.size);\r\n\r\n    var align = src._align;\r\n    var currentLine = 0;\r\n    var lineOffsetX = 0;\r\n\r\n    //  Update the bounds - skipped internally if not dirty\r\n    var bounds = src.getTextBounds(false);\r\n\r\n    //  In case the method above changed it (word wrapping)\r\n    if (src.maxWidth > 0)\r\n    {\r\n        text = bounds.wrappedText;\r\n        textLength = text.length;\r\n    }\r\n\r\n    var lineData = src._bounds.lines;\r\n\r\n    if (align === 1)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\r\n    }\r\n    else if (align === 2)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]);\r\n    }\r\n\r\n    ctx.translate(-src.displayOriginX, -src.displayOriginY);\r\n\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    for (var i = 0; i < textLength; i++)\r\n    {\r\n        charCode = text.charCodeAt(i);\r\n\r\n        if (charCode === 10)\r\n        {\r\n            currentLine++;\r\n\r\n            if (align === 1)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\r\n            }\r\n            else if (align === 2)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]);\r\n            }\r\n\r\n            xAdvance = 0;\r\n            yAdvance += lineHeight;\r\n            lastGlyph = null;\r\n\r\n            continue;\r\n        }\r\n\r\n        glyph = chars[charCode];\r\n\r\n        if (!glyph)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        glyphX = textureX + glyph.x;\r\n        glyphY = textureY + glyph.y;\r\n\r\n        glyphW = glyph.width;\r\n        glyphH = glyph.height;\r\n\r\n        x = glyph.xOffset + xAdvance;\r\n        y = glyph.yOffset + yAdvance;\r\n\r\n        if (lastGlyph !== null)\r\n        {\r\n            var kerningOffset = glyph.kerning[lastCharCode];\r\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\r\n        }\r\n\r\n        x *= scale;\r\n        y *= scale;\r\n\r\n        x += lineOffsetX;\r\n\r\n        xAdvance += glyph.xAdvance + letterSpacing;\r\n        lastGlyph = glyph;\r\n        lastCharCode = charCode;\r\n\r\n        //  Nothing to render or a space? Then skip to the next glyph\r\n        if (glyphW === 0 || glyphH === 0 || charCode === 32)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (roundPixels)\r\n        {\r\n            x = Math.round(x);\r\n            y = Math.round(y);\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        ctx.translate(x, y);\r\n\r\n        ctx.scale(scale, scale);\r\n\r\n        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = BitmapTextCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./BlitterWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./BlitterCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\nvar tempMatrix = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Blitter#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Blitter} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar BlitterWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var list = src.getRenderList();\r\n\r\n    if (list.length === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (alpha === 0)\r\n    {\r\n        //  Nothing to see, so abort early\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(this.pipeline, src);\r\n\r\n    var cameraScrollX = camera.scrollX * src.scrollFactorX;\r\n    var cameraScrollY = camera.scrollY * src.scrollFactorY;\r\n\r\n    var calcMatrix = tempMatrix.copyFrom(camera.matrix);\r\n\r\n    if (parentMatrix)\r\n    {\r\n        calcMatrix.multiplyWithOffset(parentMatrix, -cameraScrollX, -cameraScrollY);\r\n\r\n        cameraScrollX = 0;\r\n        cameraScrollY = 0;\r\n    }\r\n\r\n    var blitterX = src.x - cameraScrollX;\r\n    var blitterY = src.y - cameraScrollY;\r\n    var prevTextureSourceIndex = -1;\r\n    var tintEffect = false;\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    for (var index = 0; index < list.length; index++)\r\n    {\r\n        var bob = list[index];\r\n        var frame = bob.frame;\r\n        var bobAlpha = bob.alpha * alpha;\r\n\r\n        if (bobAlpha === 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var width = frame.width;\r\n        var height = frame.height;\r\n\r\n        var x = blitterX + bob.x + frame.x;\r\n        var y = blitterY + bob.y + frame.y;\r\n\r\n        if (bob.flipX)\r\n        {\r\n            width *= -1;\r\n            x += frame.width;\r\n        }\r\n\r\n        if (bob.flipY)\r\n        {\r\n            height *= -1;\r\n            y += frame.height;\r\n        }\r\n\r\n        var xw = x + width;\r\n        var yh = y + height;\r\n\r\n        var tx0 = calcMatrix.getX(x, y);\r\n        var ty0 = calcMatrix.getY(x, y);\r\n\r\n        var tx1 = calcMatrix.getX(xw, yh);\r\n        var ty1 = calcMatrix.getY(xw, yh);\r\n\r\n        var tint = Utils.getTintAppendFloatAlpha(bob.tint, bobAlpha);\r\n\r\n        //  Bind texture only if the Texture Source is different from before\r\n        if (frame.sourceIndex !== prevTextureSourceIndex)\r\n        {\r\n            var textureUnit = pipeline.setGameObject(src, frame);\r\n\r\n            prevTextureSourceIndex = frame.sourceIndex;\r\n        }\r\n\r\n        if (roundPixels)\r\n        {\r\n            tx0 = Math.round(tx0);\r\n            ty0 = Math.round(ty0);\r\n\r\n            tx1 = Math.round(tx1);\r\n            ty1 = Math.round(ty1);\r\n        }\r\n\r\n        //  TL x/y, BL x/y, BR x/y, TR x/y\r\n        if (pipeline.batchQuad(src, tx0, ty0, tx0, ty1, tx1, ty1, tx1, ty0, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, frame.glTexture, textureUnit))\r\n        {\r\n            prevTextureSourceIndex = -1;\r\n        }\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = BlitterWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Blitter#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Blitter} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar BlitterCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var list = src.getRenderList();\r\n\r\n    if (list.length === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (alpha === 0)\r\n    {\r\n        //  Nothing to see, so abort early\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    //  Blend Mode + Scale Mode\r\n    ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];\r\n\r\n    ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame.source.scaleMode);\r\n\r\n    var cameraScrollX = src.x - camera.scrollX * src.scrollFactorX;\r\n    var cameraScrollY = src.y - camera.scrollY * src.scrollFactorY;\r\n\r\n    ctx.save();\r\n\r\n    if (parentMatrix)\r\n    {\r\n        parentMatrix.copyToContext(ctx);\r\n    }\r\n\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    //  Render bobs\r\n    for (var i = 0; i < list.length; i++)\r\n    {\r\n        var bob = list[i];\r\n        var flip = (bob.flipX || bob.flipY);\r\n        var frame = bob.frame;\r\n        var cd = frame.canvasData;\r\n        var dx = frame.x;\r\n        var dy = frame.y;\r\n        var fx = 1;\r\n        var fy = 1;\r\n\r\n        var bobAlpha = bob.alpha * alpha;\r\n\r\n        if (bobAlpha === 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        ctx.globalAlpha = bobAlpha;\r\n\r\n        if (!flip)\r\n        {\r\n            if (roundPixels)\r\n            {\r\n                dx = Math.round(dx);\r\n                dy = Math.round(dy);\r\n            }\r\n\r\n            ctx.drawImage(\r\n                frame.source.image,\r\n                cd.x,\r\n                cd.y,\r\n                cd.width,\r\n                cd.height,\r\n                dx + bob.x + cameraScrollX,\r\n                dy + bob.y + cameraScrollY,\r\n                cd.width,\r\n                cd.height\r\n            );\r\n        }\r\n        else\r\n        {\r\n            if (bob.flipX)\r\n            {\r\n                fx = -1;\r\n                dx -= cd.width;\r\n            }\r\n\r\n            if (bob.flipY)\r\n            {\r\n                fy = -1;\r\n                dy -= cd.height;\r\n            }\r\n\r\n            ctx.save();\r\n            ctx.translate(bob.x + cameraScrollX, bob.y + cameraScrollY);\r\n            ctx.scale(fx, fy);\r\n            ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx, dy, cd.width, cd.height);\r\n            ctx.restore();\r\n        }\r\n    }\r\n\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = BlitterCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./ContainerWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./ContainerCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Container#renderWebGL\r\n * @since 3.4.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Container} container - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ContainerWebGLRenderer = function (renderer, container, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(container);\r\n\r\n    var children = container.list;\r\n    var childCount = children.length;\r\n\r\n    if (childCount === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var transformMatrix = container.localTransform;\r\n\r\n    if (parentMatrix)\r\n    {\r\n        transformMatrix.loadIdentity();\r\n        transformMatrix.multiply(parentMatrix);\r\n        transformMatrix.translate(container.x, container.y);\r\n        transformMatrix.rotate(container.rotation);\r\n        transformMatrix.scale(container.scaleX, container.scaleY);\r\n    }\r\n    else\r\n    {\r\n        transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);\r\n    }\r\n\r\n    renderer.pipelines.preBatch(container);\r\n\r\n    var containerHasBlendMode = (container.blendMode !== -1);\r\n\r\n    if (!containerHasBlendMode)\r\n    {\r\n        //  If Container is SKIP_TEST then set blend mode to be Normal\r\n        renderer.setBlendMode(0);\r\n    }\r\n\r\n    var alpha = container.alpha;\r\n\r\n    var scrollFactorX = container.scrollFactorX;\r\n    var scrollFactorY = container.scrollFactorY;\r\n\r\n    for (var i = 0; i < childCount; i++)\r\n    {\r\n        var child = children[i];\r\n\r\n        if (!child.willRender(camera))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var childAlphaTopLeft;\r\n        var childAlphaTopRight;\r\n        var childAlphaBottomLeft;\r\n        var childAlphaBottomRight;\r\n\r\n        if (child.alphaTopLeft !== undefined)\r\n        {\r\n            childAlphaTopLeft = child.alphaTopLeft;\r\n            childAlphaTopRight = child.alphaTopRight;\r\n            childAlphaBottomLeft = child.alphaBottomLeft;\r\n            childAlphaBottomRight = child.alphaBottomRight;\r\n        }\r\n        else\r\n        {\r\n            var childAlpha = child.alpha;\r\n\r\n            childAlphaTopLeft = childAlpha;\r\n            childAlphaTopRight = childAlpha;\r\n            childAlphaBottomLeft = childAlpha;\r\n            childAlphaBottomRight = childAlpha;\r\n        }\r\n\r\n        var childScrollFactorX = child.scrollFactorX;\r\n        var childScrollFactorY = child.scrollFactorY;\r\n\r\n        if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode)\r\n        {\r\n            //  If Container doesn't have its own blend mode, then a child can have one\r\n            renderer.setBlendMode(child.blendMode);\r\n        }\r\n\r\n        var mask = child.mask;\r\n\r\n        if (mask)\r\n        {\r\n            mask.preRenderWebGL(renderer, child, camera);\r\n        }\r\n\r\n        var type = child.type;\r\n\r\n        if (type !== renderer.currentType)\r\n        {\r\n            renderer.newType = true;\r\n            renderer.currentType = type;\r\n        }\r\n\r\n        renderer.nextTypeMatch = (i < childCount - 1) ? (children[i + 1].type === renderer.currentType) : false;\r\n\r\n        //  Set parent values\r\n        child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);\r\n\r\n        child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);\r\n\r\n        //  Render\r\n        child.renderWebGL(renderer, child, camera, transformMatrix);\r\n\r\n        //  Restore original values\r\n\r\n        child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);\r\n\r\n        child.setScrollFactor(childScrollFactorX, childScrollFactorY);\r\n\r\n        if (mask)\r\n        {\r\n            mask.postRenderWebGL(renderer, camera);\r\n        }\r\n\r\n        renderer.newType = false;\r\n    }\r\n\r\n    renderer.pipelines.postBatch(container);\r\n};\r\n\r\nmodule.exports = ContainerWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Container#renderCanvas\r\n * @since 3.4.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Container} container - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ContainerCanvasRenderer = function (renderer, container, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(container);\r\n\r\n    var children = container.list;\r\n\r\n    if (children.length === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var transformMatrix = container.localTransform;\r\n\r\n    if (parentMatrix)\r\n    {\r\n        transformMatrix.loadIdentity();\r\n        transformMatrix.multiply(parentMatrix);\r\n        transformMatrix.translate(container.x, container.y);\r\n        transformMatrix.rotate(container.rotation);\r\n        transformMatrix.scale(container.scaleX, container.scaleY);\r\n    }\r\n    else\r\n    {\r\n        transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);\r\n    }\r\n\r\n    var containerHasBlendMode = (container.blendMode !== -1);\r\n\r\n    if (!containerHasBlendMode)\r\n    {\r\n        //  If Container is SKIP_TEST then set blend mode to be Normal\r\n        renderer.setBlendMode(0);\r\n    }\r\n\r\n    var alpha = container._alpha;\r\n    var scrollFactorX = container.scrollFactorX;\r\n    var scrollFactorY = container.scrollFactorY;\r\n\r\n    if (container.mask)\r\n    {\r\n        container.mask.preRenderCanvas(renderer, null, camera);\r\n    }\r\n\r\n    for (var i = 0; i < children.length; i++)\r\n    {\r\n        var child = children[i];\r\n\r\n        if (!child.willRender(camera))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var childAlpha = child.alpha;\r\n        var childScrollFactorX = child.scrollFactorX;\r\n        var childScrollFactorY = child.scrollFactorY;\r\n\r\n        if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode)\r\n        {\r\n            //  If Container doesn't have its own blend mode, then a child can have one\r\n            renderer.setBlendMode(child.blendMode);\r\n        }\r\n\r\n        //  Set parent values\r\n        child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);\r\n        child.setAlpha(childAlpha * alpha);\r\n\r\n        //  Render\r\n        child.renderCanvas(renderer, child, camera, transformMatrix);\r\n\r\n        //  Restore original values\r\n        child.setAlpha(childAlpha);\r\n        child.setScrollFactor(childScrollFactorX, childScrollFactorY);\r\n    }\r\n\r\n    if (container.mask)\r\n    {\r\n        container.mask.postRenderCanvas(renderer);\r\n    }\r\n};\r\n\r\nmodule.exports = ContainerCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./DOMElementCSSRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./DOMElementCSSRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Blend Modes to CSS Blend Modes Map.\r\n *\r\n * @name Phaser.CSSBlendModes\r\n * @ignore\r\n * @enum {string}\r\n * @memberof Phaser\r\n * @readonly\r\n * @since 3.12.0\r\n */\r\n\r\nmodule.exports = [\r\n    'normal',\r\n    'multiply',\r\n    'multiply',\r\n    'screen',\r\n    'overlay',\r\n    'darken',\r\n    'lighten',\r\n    'color-dodge',\r\n    'color-burn',\r\n    'hard-light',\r\n    'soft-light',\r\n    'difference',\r\n    'exclusion',\r\n    'hue',\r\n    'saturation',\r\n    'color',\r\n    'luminosity'\r\n];\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./DynamicBitmapTextWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./DynamicBitmapTextCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar TransformMatrix = require('../../components/TransformMatrix');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\nvar tempMatrix = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.DynamicBitmapText#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.DynamicBitmapText} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar DynamicBitmapTextWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var text = src.text;\r\n    var textLength = text.length;\r\n\r\n    if (textLength === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var spriteMatrix = result.sprite;\r\n    var calcMatrix = result.calc;\r\n\r\n    var fontMatrix = tempMatrix;\r\n\r\n    var crop = (src.cropWidth > 0 || src.cropHeight > 0);\r\n\r\n    if (crop)\r\n    {\r\n        pipeline.flush();\r\n\r\n        renderer.pushScissor(\r\n            calcMatrix.tx,\r\n            calcMatrix.ty,\r\n            src.cropWidth * calcMatrix.scaleX,\r\n            src.cropHeight * calcMatrix.scaleY\r\n        );\r\n    }\r\n\r\n    var frame = src.frame;\r\n    var texture = frame.glTexture;\r\n\r\n    var tintEffect = src.tintFill;\r\n    var tintTL = Utils.getTintAppendFloatAlpha(src.tintTopLeft, camera.alpha * src._alphaTL);\r\n    var tintTR = Utils.getTintAppendFloatAlpha(src.tintTopRight, camera.alpha * src._alphaTR);\r\n    var tintBL = Utils.getTintAppendFloatAlpha(src.tintBottomLeft, camera.alpha * src._alphaBL);\r\n    var tintBR = Utils.getTintAppendFloatAlpha(src.tintBottomRight, camera.alpha * src._alphaBR);\r\n\r\n    var textureUnit = pipeline.setGameObject(src);\r\n\r\n    var xAdvance = 0;\r\n    var yAdvance = 0;\r\n    var charCode = 0;\r\n    var lastCharCode = 0;\r\n    var letterSpacing = src.letterSpacing;\r\n    var glyph;\r\n    var glyphW = 0;\r\n    var glyphH = 0;\r\n    var lastGlyph;\r\n    var scrollX = src.scrollX;\r\n    var scrollY = src.scrollY;\r\n\r\n    var fontData = src.fontData;\r\n    var chars = fontData.chars;\r\n    var lineHeight = fontData.lineHeight;\r\n    var scale = (src.fontSize / fontData.size);\r\n    var rotation = 0;\r\n\r\n    var align = src._align;\r\n    var currentLine = 0;\r\n    var lineOffsetX = 0;\r\n\r\n    //  Update the bounds - skipped internally if not dirty\r\n    var bounds = src.getTextBounds(false);\r\n\r\n    //  In case the method above changed it (word wrapping)\r\n    if (src.maxWidth > 0)\r\n    {\r\n        text = bounds.wrappedText;\r\n        textLength = text.length;\r\n    }\r\n\r\n    var lineData = src._bounds.lines;\r\n\r\n    if (align === 1)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\r\n    }\r\n    else if (align === 2)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]);\r\n    }\r\n\r\n    var roundPixels = camera.roundPixels;\r\n    var displayCallback = src.displayCallback;\r\n    var callbackData = src.callbackData;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    for (var i = 0; i < textLength; i++)\r\n    {\r\n        charCode = text.charCodeAt(i);\r\n\r\n        //  Carriage-return\r\n        if (charCode === 10)\r\n        {\r\n            currentLine++;\r\n\r\n            if (align === 1)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\r\n            }\r\n            else if (align === 2)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]);\r\n            }\r\n\r\n            xAdvance = 0;\r\n            yAdvance += lineHeight;\r\n            lastGlyph = null;\r\n\r\n            continue;\r\n        }\r\n\r\n        glyph = chars[charCode];\r\n\r\n        if (!glyph)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        glyphW = glyph.width;\r\n        glyphH = glyph.height;\r\n\r\n        var x = (glyph.xOffset + xAdvance) - scrollX;\r\n        var y = (glyph.yOffset + yAdvance) - scrollY;\r\n\r\n        if (lastGlyph !== null)\r\n        {\r\n            var kerningOffset = glyph.kerning[lastCharCode];\r\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\r\n        }\r\n\r\n        xAdvance += glyph.xAdvance + letterSpacing;\r\n        lastGlyph = glyph;\r\n        lastCharCode = charCode;\r\n\r\n        //  Nothing to render or a space? Then skip to the next glyph\r\n        if (glyphW === 0 || glyphH === 0 || charCode === 32)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        scale = (src.fontSize / src.fontData.size);\r\n        rotation = 0;\r\n\r\n        if (displayCallback)\r\n        {\r\n            callbackData.color = 0;\r\n            callbackData.tint.topLeft = tintTL;\r\n            callbackData.tint.topRight = tintTR;\r\n            callbackData.tint.bottomLeft = tintBL;\r\n            callbackData.tint.bottomRight = tintBR;\r\n            callbackData.index = i;\r\n            callbackData.charCode = charCode;\r\n            callbackData.x = x;\r\n            callbackData.y = y;\r\n            callbackData.scale = scale;\r\n            callbackData.rotation = rotation;\r\n            callbackData.data = glyph.data;\r\n\r\n            var output = displayCallback(callbackData);\r\n\r\n            x = output.x;\r\n            y = output.y;\r\n            scale = output.scale;\r\n            rotation = output.rotation;\r\n\r\n            if (output.color)\r\n            {\r\n                tintTL = output.color;\r\n                tintTR = output.color;\r\n                tintBL = output.color;\r\n                tintBR = output.color;\r\n            }\r\n            else\r\n            {\r\n                tintTL = output.tint.topLeft;\r\n                tintTR = output.tint.topRight;\r\n                tintBL = output.tint.bottomLeft;\r\n                tintBR = output.tint.bottomRight;\r\n            }\r\n\r\n            tintTL = Utils.getTintAppendFloatAlpha(tintTL, camera.alpha * src._alphaTL);\r\n            tintTR = Utils.getTintAppendFloatAlpha(tintTR, camera.alpha * src._alphaTR);\r\n            tintBL = Utils.getTintAppendFloatAlpha(tintBL, camera.alpha * src._alphaBL);\r\n            tintBR = Utils.getTintAppendFloatAlpha(tintBR, camera.alpha * src._alphaBR);\r\n        }\r\n\r\n        x *= scale;\r\n        y *= scale;\r\n\r\n        x -= src.displayOriginX;\r\n        y -= src.displayOriginY;\r\n\r\n        x += lineOffsetX;\r\n\r\n        fontMatrix.applyITRS(x, y, rotation, scale, scale);\r\n\r\n        calcMatrix.multiply(fontMatrix, spriteMatrix);\r\n\r\n        var u0 = glyph.u0;\r\n        var v0 = glyph.v0;\r\n        var u1 = glyph.u1;\r\n        var v1 = glyph.v1;\r\n\r\n        var xw = glyphW;\r\n        var yh = glyphH;\r\n\r\n        var tx0 = spriteMatrix.e;\r\n        var ty0 = spriteMatrix.f;\r\n\r\n        var tx1 = yh * spriteMatrix.c + spriteMatrix.e;\r\n        var ty1 = yh * spriteMatrix.d + spriteMatrix.f;\r\n\r\n        var tx2 = xw * spriteMatrix.a + yh * spriteMatrix.c + spriteMatrix.e;\r\n        var ty2 = xw * spriteMatrix.b + yh * spriteMatrix.d + spriteMatrix.f;\r\n\r\n        var tx3 = xw * spriteMatrix.a + spriteMatrix.e;\r\n        var ty3 = xw * spriteMatrix.b + spriteMatrix.f;\r\n\r\n        if (roundPixels)\r\n        {\r\n            tx0 = Math.round(tx0);\r\n            ty0 = Math.round(ty0);\r\n\r\n            tx1 = Math.round(tx1);\r\n            ty1 = Math.round(ty1);\r\n\r\n            tx2 = Math.round(tx2);\r\n            ty2 = Math.round(ty2);\r\n\r\n            tx3 = Math.round(tx3);\r\n            ty3 = Math.round(ty3);\r\n        }\r\n\r\n        pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);\r\n    }\r\n\r\n    if (crop)\r\n    {\r\n        pipeline.flush();\r\n\r\n        renderer.popScissor();\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = DynamicBitmapTextWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.DynamicBitmapText#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.DynamicBitmapText} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar DynamicBitmapTextCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var text = src._text;\r\n    var textLength = text.length;\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var textureFrame = src.fromAtlas\r\n        ? src.frame\r\n        : src.texture.frames['__BASE'];\r\n\r\n    var displayCallback = src.displayCallback;\r\n    var callbackData = src.callbackData;\r\n\r\n    var chars = src.fontData.chars;\r\n    var lineHeight = src.fontData.lineHeight;\r\n    var letterSpacing = src._letterSpacing;\r\n\r\n    var xAdvance = 0;\r\n    var yAdvance = 0;\r\n\r\n    var charCode = 0;\r\n\r\n    var glyph = null;\r\n    var glyphX = 0;\r\n    var glyphY = 0;\r\n    var glyphW = 0;\r\n    var glyphH = 0;\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n\r\n    var lastGlyph = null;\r\n    var lastCharCode = 0;\r\n\r\n    var image = src.frame.source.image;\r\n\r\n    var textureX = textureFrame.cutX;\r\n    var textureY = textureFrame.cutY;\r\n\r\n    var rotation = 0;\r\n    var scale = 0;\r\n    var baseScale = (src._fontSize / src.fontData.size);\r\n\r\n    var align = src._align;\r\n    var currentLine = 0;\r\n    var lineOffsetX = 0;\r\n\r\n    //  Update the bounds - skipped internally if not dirty\r\n    src.getTextBounds(false);\r\n\r\n    var lineData = src._bounds.lines;\r\n\r\n    if (align === 1)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\r\n    }\r\n    else if (align === 2)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]);\r\n    }\r\n\r\n    ctx.translate(-src.displayOriginX, -src.displayOriginY);\r\n\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    if (src.cropWidth > 0 && src.cropHeight > 0)\r\n    {\r\n        ctx.beginPath();\r\n        ctx.rect(0, 0, src.cropWidth, src.cropHeight);\r\n        ctx.clip();\r\n    }\r\n\r\n    for (var i = 0; i < textLength; i++)\r\n    {\r\n        //  Reset the scale (in case the callback changed it)\r\n        scale = baseScale;\r\n        rotation = 0;\r\n\r\n        charCode = text.charCodeAt(i);\r\n\r\n        if (charCode === 10)\r\n        {\r\n            currentLine++;\r\n\r\n            if (align === 1)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\r\n            }\r\n            else if (align === 2)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]);\r\n            }\r\n\r\n            xAdvance = 0;\r\n            yAdvance += lineHeight;\r\n            lastGlyph = null;\r\n\r\n            continue;\r\n        }\r\n\r\n        glyph = chars[charCode];\r\n\r\n        if (!glyph)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        glyphX = textureX + glyph.x;\r\n        glyphY = textureY + glyph.y;\r\n\r\n        glyphW = glyph.width;\r\n        glyphH = glyph.height;\r\n\r\n        x = (glyph.xOffset + xAdvance) - src.scrollX;\r\n        y = (glyph.yOffset + yAdvance) - src.scrollY;\r\n\r\n        if (lastGlyph !== null)\r\n        {\r\n            var kerningOffset = glyph.kerning[lastCharCode];\r\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\r\n        }\r\n\r\n        if (displayCallback)\r\n        {\r\n            callbackData.index = i;\r\n            callbackData.charCode = charCode;\r\n            callbackData.x = x;\r\n            callbackData.y = y;\r\n            callbackData.scale = scale;\r\n            callbackData.rotation = rotation;\r\n            callbackData.data = glyph.data;\r\n\r\n            var output = displayCallback(callbackData);\r\n\r\n            x = output.x;\r\n            y = output.y;\r\n            scale = output.scale;\r\n            rotation = output.rotation;\r\n        }\r\n\r\n        x *= scale;\r\n        y *= scale;\r\n\r\n        x += lineOffsetX;\r\n\r\n        xAdvance += glyph.xAdvance + letterSpacing;\r\n        lastGlyph = glyph;\r\n        lastCharCode = charCode;\r\n\r\n        //  Nothing to render or a space? Then skip to the next glyph\r\n        if (glyphW === 0 || glyphH === 0 || charCode === 32)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (roundPixels)\r\n        {\r\n            x = Math.round(x);\r\n            y = Math.round(y);\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        ctx.translate(x, y);\r\n\r\n        ctx.rotate(rotation);\r\n\r\n        ctx.scale(scale, scale);\r\n\r\n        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = DynamicBitmapTextCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./ExternWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./ExternCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Extern#renderWebGL\r\n * @since 3.16.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Extern} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ExternWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    renderer.pipelines.clear();\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    src.render.call(src, renderer, camera, calcMatrix);\r\n\r\n    renderer.pipelines.rebind();\r\n};\r\n\r\nmodule.exports = ExternWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./GraphicsWebGLRenderer');\r\n\r\n    //  Needed for Graphics.generateTexture\r\n    renderCanvas = require('./GraphicsCanvasRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./GraphicsCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Commands = require('./Commands');\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\nvar Point = function (x, y, width)\r\n{\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n};\r\n\r\nvar Path = function (x, y, width)\r\n{\r\n    this.points = [];\r\n    this.pointsLength = 1;\r\n    this.points[0] = new Point(x, y, width);\r\n};\r\n\r\nvar matrixStack = [];\r\nvar tempMatrix = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Graphics#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Graphics} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar GraphicsWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (src.commandBuffer.length === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    var currentMatrix = tempMatrix.loadIdentity();\r\n\r\n    var commands = src.commandBuffer;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    var lineWidth = 1;\r\n    var fillTint = pipeline.fillTint;\r\n    var strokeTint = pipeline.strokeTint;\r\n\r\n    var tx = 0;\r\n    var ty = 0;\r\n    var ta = 0;\r\n    var iterStep = 0.01;\r\n    var PI2 = Math.PI * 2;\r\n\r\n    var cmd;\r\n\r\n    var path = [];\r\n    var pathIndex = 0;\r\n    var pathOpen = true;\r\n    var lastPath = null;\r\n\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++)\r\n    {\r\n        cmd = commands[cmdIndex];\r\n\r\n        switch (cmd)\r\n        {\r\n            case Commands.BEGIN_PATH:\r\n            {\r\n                path.length = 0;\r\n                lastPath = null;\r\n                pathOpen = true;\r\n                break;\r\n            }\r\n\r\n            case Commands.CLOSE_PATH:\r\n            {\r\n                pathOpen = false;\r\n\r\n                if (lastPath && lastPath.points.length)\r\n                {\r\n                    lastPath.points.push(lastPath.points[0]);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case Commands.FILL_PATH:\r\n            {\r\n                for (pathIndex = 0; pathIndex < path.length; pathIndex++)\r\n                {\r\n                    pipeline.batchFillPath(\r\n                        path[pathIndex].points,\r\n                        currentMatrix,\r\n                        calcMatrix\r\n                    );\r\n                }\r\n                break;\r\n            }\r\n\r\n            case Commands.STROKE_PATH:\r\n            {\r\n                for (pathIndex = 0; pathIndex < path.length; pathIndex++)\r\n                {\r\n                    pipeline.batchStrokePath(\r\n                        path[pathIndex].points,\r\n                        lineWidth,\r\n                        pathOpen,\r\n                        currentMatrix,\r\n                        calcMatrix\r\n                    );\r\n                }\r\n                break;\r\n            }\r\n\r\n            case Commands.LINE_STYLE:\r\n            {\r\n                lineWidth = commands[++cmdIndex];\r\n                var strokeColor = commands[++cmdIndex];\r\n                var strokeAlpha = commands[++cmdIndex] * alpha;\r\n                var strokeTintColor = getTint(strokeColor, strokeAlpha);\r\n                strokeTint.TL = strokeTintColor;\r\n                strokeTint.TR = strokeTintColor;\r\n                strokeTint.BL = strokeTintColor;\r\n                strokeTint.BR = strokeTintColor;\r\n                break;\r\n            }\r\n\r\n            case Commands.FILL_STYLE:\r\n            {\r\n                var fillColor = commands[++cmdIndex];\r\n                var fillAlpha = commands[++cmdIndex] * alpha;\r\n                var fillTintColor = getTint(fillColor, fillAlpha);\r\n                fillTint.TL = fillTintColor;\r\n                fillTint.TR = fillTintColor;\r\n                fillTint.BL = fillTintColor;\r\n                fillTint.BR = fillTintColor;\r\n                break;\r\n            }\r\n\r\n            case Commands.GRADIENT_FILL_STYLE:\r\n            {\r\n                var alphaTL = commands[++cmdIndex] * alpha;\r\n                var alphaTR = commands[++cmdIndex] * alpha;\r\n                var alphaBL = commands[++cmdIndex] * alpha;\r\n                var alphaBR = commands[++cmdIndex] * alpha;\r\n\r\n                fillTint.TL = getTint(commands[++cmdIndex], alphaTL);\r\n                fillTint.TR = getTint(commands[++cmdIndex], alphaTR);\r\n                fillTint.BL = getTint(commands[++cmdIndex], alphaBL);\r\n                fillTint.BR = getTint(commands[++cmdIndex], alphaBR);\r\n                break;\r\n            }\r\n\r\n            case Commands.GRADIENT_LINE_STYLE:\r\n            {\r\n                lineWidth = commands[++cmdIndex];\r\n                var gradientLineAlpha = commands[++cmdIndex] * alpha;\r\n                strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                break;\r\n            }\r\n\r\n            case Commands.ARC:\r\n            {\r\n                var iteration = 0;\r\n                var x = commands[++cmdIndex];\r\n                var y = commands[++cmdIndex];\r\n                var radius = commands[++cmdIndex];\r\n                var startAngle = commands[++cmdIndex];\r\n                var endAngle = commands[++cmdIndex];\r\n                var anticlockwise = commands[++cmdIndex];\r\n                var overshoot = commands[++cmdIndex];\r\n\r\n                endAngle -= startAngle;\r\n\r\n                if (anticlockwise)\r\n                {\r\n                    if (endAngle < -PI2)\r\n                    {\r\n                        endAngle = -PI2;\r\n                    }\r\n                    else if (endAngle > 0)\r\n                    {\r\n                        endAngle = -PI2 + endAngle % PI2;\r\n                    }\r\n                }\r\n                else if (endAngle > PI2)\r\n                {\r\n                    endAngle = PI2;\r\n                }\r\n                else if (endAngle < 0)\r\n                {\r\n                    endAngle = PI2 + endAngle % PI2;\r\n                }\r\n\r\n                if (lastPath === null)\r\n                {\r\n                    lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth);\r\n                    path.push(lastPath);\r\n                    iteration += iterStep;\r\n                }\r\n\r\n                while (iteration < 1 + overshoot)\r\n                {\r\n                    ta = endAngle * iteration + startAngle;\r\n                    tx = x + Math.cos(ta) * radius;\r\n                    ty = y + Math.sin(ta) * radius;\r\n\r\n                    lastPath.points.push(new Point(tx, ty, lineWidth));\r\n\r\n                    iteration += iterStep;\r\n                }\r\n\r\n                ta = endAngle + startAngle;\r\n                tx = x + Math.cos(ta) * radius;\r\n                ty = y + Math.sin(ta) * radius;\r\n\r\n                lastPath.points.push(new Point(tx, ty, lineWidth));\r\n\r\n                break;\r\n            }\r\n\r\n            case Commands.FILL_RECT:\r\n            {\r\n                pipeline.batchFillRect(\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    currentMatrix,\r\n                    calcMatrix\r\n                );\r\n                break;\r\n            }\r\n\r\n            case Commands.FILL_TRIANGLE:\r\n            {\r\n                pipeline.batchFillTriangle(\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    currentMatrix,\r\n                    calcMatrix\r\n                );\r\n                break;\r\n            }\r\n\r\n            case Commands.STROKE_TRIANGLE:\r\n            {\r\n                pipeline.batchStrokeTriangle(\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    lineWidth,\r\n                    currentMatrix,\r\n                    calcMatrix\r\n                );\r\n                break;\r\n            }\r\n\r\n            case Commands.LINE_TO:\r\n            {\r\n                if (lastPath !== null)\r\n                {\r\n                    lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));\r\n                }\r\n                else\r\n                {\r\n                    lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);\r\n                    path.push(lastPath);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case Commands.MOVE_TO:\r\n            {\r\n                lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);\r\n                path.push(lastPath);\r\n                break;\r\n            }\r\n\r\n            case Commands.SAVE:\r\n            {\r\n                matrixStack.push(currentMatrix.copyToArray());\r\n                break;\r\n            }\r\n\r\n            case Commands.RESTORE:\r\n            {\r\n                currentMatrix.copyFromArray(matrixStack.pop());\r\n                break;\r\n            }\r\n\r\n            case Commands.TRANSLATE:\r\n            {\r\n                x = commands[++cmdIndex];\r\n                y = commands[++cmdIndex];\r\n                currentMatrix.translate(x, y);\r\n                break;\r\n            }\r\n\r\n            case Commands.SCALE:\r\n            {\r\n                x = commands[++cmdIndex];\r\n                y = commands[++cmdIndex];\r\n                currentMatrix.scale(x, y);\r\n                break;\r\n            }\r\n\r\n            case Commands.ROTATE:\r\n            {\r\n                currentMatrix.rotate(commands[++cmdIndex]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = GraphicsWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./LayerWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./LayerCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Layer#renderWebGL\r\n * @since 3.50.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Layer} layer - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */\r\nvar LayerWebGLRenderer = function (renderer, layer, camera)\r\n{\r\n    var children = layer.list;\r\n    var childCount = children.length;\r\n\r\n    if (childCount === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    layer.depthSort();\r\n\r\n    renderer.pipelines.preBatch(layer);\r\n\r\n    var layerHasBlendMode = (layer.blendMode !== -1);\r\n\r\n    if (!layerHasBlendMode)\r\n    {\r\n        //  If Layer is SKIP_TEST then set blend mode to be Normal\r\n        renderer.setBlendMode(0);\r\n    }\r\n\r\n    var alpha = layer.alpha;\r\n\r\n    for (var i = 0; i < childCount; i++)\r\n    {\r\n        var child = children[i];\r\n\r\n        if (!child.willRender(camera))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var childAlphaTopLeft;\r\n        var childAlphaTopRight;\r\n        var childAlphaBottomLeft;\r\n        var childAlphaBottomRight;\r\n\r\n        if (child.alphaTopLeft !== undefined)\r\n        {\r\n            childAlphaTopLeft = child.alphaTopLeft;\r\n            childAlphaTopRight = child.alphaTopRight;\r\n            childAlphaBottomLeft = child.alphaBottomLeft;\r\n            childAlphaBottomRight = child.alphaBottomRight;\r\n        }\r\n        else\r\n        {\r\n            var childAlpha = child.alpha;\r\n\r\n            childAlphaTopLeft = childAlpha;\r\n            childAlphaTopRight = childAlpha;\r\n            childAlphaBottomLeft = childAlpha;\r\n            childAlphaBottomRight = childAlpha;\r\n        }\r\n\r\n        if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode)\r\n        {\r\n            //  If Layer doesn't have its own blend mode, then a child can have one\r\n            renderer.setBlendMode(child.blendMode);\r\n        }\r\n\r\n        var mask = child.mask;\r\n\r\n        if (mask)\r\n        {\r\n            mask.preRenderWebGL(renderer, child, camera);\r\n        }\r\n\r\n        var type = child.type;\r\n\r\n        if (type !== renderer.currentType)\r\n        {\r\n            renderer.newType = true;\r\n            renderer.currentType = type;\r\n        }\r\n\r\n        renderer.nextTypeMatch = (i < childCount - 1) ? (children[i + 1].type === renderer.currentType) : false;\r\n\r\n        child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);\r\n\r\n        //  Render\r\n        child.renderWebGL(renderer, child, camera);\r\n\r\n        //  Restore original values\r\n        child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);\r\n\r\n        if (mask)\r\n        {\r\n            mask.postRenderWebGL(renderer, camera);\r\n        }\r\n\r\n        renderer.newType = false;\r\n    }\r\n\r\n    renderer.pipelines.postBatch(layer);\r\n};\r\n\r\nmodule.exports = LayerWebGLRenderer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Renders this Game Object with the Canvas Renderer to the given Camera.\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\n * This method should not be called directly. It is a utility function of the Render module.\n *\n * @method Phaser.GameObjects.Layer#renderCanvas\n * @since 3.50.0\n * @private\n *\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\n * @param {Phaser.GameObjects.Layer} layer - The Game Object being rendered in this call.\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\n */\nvar LayerCanvasRenderer = function (renderer, layer, camera)\n{\n    var children = layer.list;\n\n    if (children.length === 0)\n    {\n        return;\n    }\n\n    layer.depthSort();\n\n    var layerHasBlendMode = (layer.blendMode !== -1);\n\n    if (!layerHasBlendMode)\n    {\n        //  If Layer is SKIP_TEST then set blend mode to be Normal\n        renderer.setBlendMode(0);\n    }\n\n    var alpha = layer._alpha;\n\n    if (layer.mask)\n    {\n        layer.mask.preRenderCanvas(renderer, null, camera);\n    }\n\n    for (var i = 0; i < children.length; i++)\n    {\n        var child = children[i];\n\n        if (!child.willRender(camera))\n        {\n            continue;\n        }\n\n        var childAlpha = child.alpha;\n\n        if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode)\n        {\n            //  If Layer doesn't have its own blend mode, then a child can have one\n            renderer.setBlendMode(child.blendMode);\n        }\n\n        //  Set parent values\n        child.setAlpha(childAlpha * alpha);\n\n        //  Render\n        child.renderCanvas(renderer, child, camera);\n\n        //  Restore original values\n        child.setAlpha(childAlpha);\n    }\n\n    if (layer.mask)\n    {\n        layer.mask.postRenderCanvas(renderer);\n    }\n};\n\nmodule.exports = LayerCanvasRenderer;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.GameObjects.Particles\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    EmitterOp: require('./EmitterOp'),\r\n    GravityWell: require('./GravityWell'),\r\n    Particle: require('./Particle'),\r\n    ParticleEmitter: require('./ParticleEmitter'),\r\n    ParticleEmitterManager: require('./ParticleEmitterManager'),\r\n    Zones: require('./zones')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./ParticleManagerWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./ParticleManagerCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\nvar tempMatrix1 = new TransformMatrix();\r\nvar tempMatrix2 = new TransformMatrix();\r\nvar tempMatrix3 = new TransformMatrix();\r\nvar tempMatrix4 = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Particles.EmitterManager#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ParticleManagerWebGLRenderer = function (renderer, emitterManager, camera, parentMatrix)\r\n{\r\n    var emitters = emitterManager.emitters.list;\r\n    var emittersLength = emitters.length;\r\n\r\n    if (emittersLength === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var pipeline = renderer.pipelines.set(emitterManager.pipeline);\r\n\r\n    var camMatrix = tempMatrix1;\r\n    var calcMatrix = tempMatrix2;\r\n    var particleMatrix = tempMatrix3;\r\n    var managerMatrix = tempMatrix4;\r\n\r\n    if (parentMatrix)\r\n    {\r\n        managerMatrix.loadIdentity();\r\n        managerMatrix.multiply(parentMatrix);\r\n        managerMatrix.translate(emitterManager.x, emitterManager.y);\r\n        managerMatrix.rotate(emitterManager.rotation);\r\n        managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY);\r\n    }\r\n    else\r\n    {\r\n        managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);\r\n    }\r\n\r\n    var roundPixels = camera.roundPixels;\r\n    var texture = emitterManager.defaultFrame.glTexture;\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    var textureUnit = pipeline.setGameObject(emitterManager, emitterManager.defaultFrame);\r\n\r\n    renderer.pipelines.preBatch(emitterManager);\r\n\r\n    for (var e = 0; e < emittersLength; e++)\r\n    {\r\n        var emitter = emitters[e];\r\n        var particles = emitter.alive;\r\n        var particleCount = particles.length;\r\n\r\n        if (!emitter.visible || particleCount === 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        camera.addToRenderList(emitter);\r\n\r\n        var scrollFactorX = emitter.scrollFactorX;\r\n        var scrollFactorY = emitter.scrollFactorY;\r\n\r\n        renderer.setBlendMode(emitter.blendMode);\r\n\r\n        if (emitter.mask)\r\n        {\r\n            emitter.mask.preRenderWebGL(renderer, emitter, camera);\r\n\r\n            renderer.pipelines.set(emitterManager.pipeline);\r\n        }\r\n\r\n        var tintEffect = 0;\r\n\r\n        for (var i = 0; i < particleCount; i++)\r\n        {\r\n            var particle = particles[i];\r\n\r\n            var alpha = particle.alpha * camera.alpha;\r\n\r\n            if (alpha <= 0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);\r\n\r\n            camMatrix.copyFrom(camera.matrix);\r\n\r\n            camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);\r\n\r\n            //  Undo the camera scroll\r\n            particleMatrix.e = particle.x;\r\n            particleMatrix.f = particle.y;\r\n\r\n            //  Multiply by the particle matrix, store result in calcMatrix\r\n            camMatrix.multiply(particleMatrix, calcMatrix);\r\n\r\n            var frame = particle.frame;\r\n\r\n            var x = -frame.halfWidth;\r\n            var y = -frame.halfHeight;\r\n            var xw = x + frame.width;\r\n            var yh = y + frame.height;\r\n\r\n            var tx0 = calcMatrix.getXRound(x, y, roundPixels);\r\n            var ty0 = calcMatrix.getYRound(x, y, roundPixels);\r\n\r\n            var tx1 = calcMatrix.getXRound(x, yh, roundPixels);\r\n            var ty1 = calcMatrix.getYRound(x, yh, roundPixels);\r\n\r\n            var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);\r\n            var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);\r\n\r\n            var tx3 = calcMatrix.getXRound(xw, y, roundPixels);\r\n            var ty3 = calcMatrix.getYRound(xw, y, roundPixels);\r\n\r\n            var tint = getTint(particle.tint, alpha);\r\n\r\n            pipeline.batchQuad(emitter, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, texture, textureUnit);\r\n        }\r\n\r\n        if (emitter.mask)\r\n        {\r\n            emitter.mask.postRenderWebGL(renderer, camera);\r\n        }\r\n    }\r\n\r\n    renderer.pipelines.postBatch(emitterManager);\r\n};\r\n\r\nmodule.exports = ParticleManagerWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\n\r\nvar tempMatrix1 = new TransformMatrix();\r\nvar tempMatrix2 = new TransformMatrix();\r\nvar tempMatrix3 = new TransformMatrix();\r\nvar tempMatrix4 = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Particles.EmitterManager#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ParticleManagerCanvasRenderer = function (renderer, emitterManager, camera, parentMatrix)\r\n{\r\n    var emitters = emitterManager.emitters.list;\r\n    var emittersLength = emitters.length;\r\n\r\n    if (emittersLength === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var camMatrix = tempMatrix1.copyFrom(camera.matrix);\r\n    var calcMatrix = tempMatrix2;\r\n    var particleMatrix = tempMatrix3;\r\n    var managerMatrix = tempMatrix4;\r\n\r\n    if (parentMatrix)\r\n    {\r\n        managerMatrix.loadIdentity();\r\n        managerMatrix.multiply(parentMatrix);\r\n        managerMatrix.translate(emitterManager.x, emitterManager.y);\r\n        managerMatrix.rotate(emitterManager.rotation);\r\n        managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY);\r\n    }\r\n    else\r\n    {\r\n        managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);\r\n    }\r\n\r\n    var ctx = renderer.currentContext;\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    for (var e = 0; e < emittersLength; e++)\r\n    {\r\n        var emitter = emitters[e];\r\n        var particles = emitter.alive;\r\n        var particleCount = particles.length;\r\n\r\n        if (!emitter.visible || particleCount === 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        camera.addToRenderList(emitter);\r\n\r\n        var scrollFactorX = emitter.scrollFactorX;\r\n        var scrollFactorY = emitter.scrollFactorY;\r\n\r\n        ctx.save();\r\n\r\n        ctx.globalCompositeOperation = renderer.blendModes[emitter.blendMode];\r\n\r\n        for (var i = 0; i < particleCount; i++)\r\n        {\r\n            var particle = particles[i];\r\n\r\n            var alpha = particle.alpha * camera.alpha;\r\n\r\n            if (alpha <= 0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);\r\n\r\n            camMatrix.copyFrom(camera.matrix);\r\n\r\n            camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);\r\n\r\n            //  Undo the camera scroll\r\n            particleMatrix.e = particle.x;\r\n            particleMatrix.f = particle.y;\r\n\r\n            //  Multiply by the particle matrix, store result in calcMatrix\r\n            camMatrix.multiply(particleMatrix, calcMatrix);\r\n\r\n            var frame = particle.frame;\r\n            var cd = frame.canvasData;\r\n\r\n            var x = -(frame.halfWidth);\r\n            var y = -(frame.halfHeight);\r\n\r\n            ctx.globalAlpha = alpha;\r\n\r\n            ctx.save();\r\n\r\n            calcMatrix.setToContext(ctx);\r\n\r\n            if (roundPixels)\r\n            {\r\n                x = Math.round(x);\r\n                y = Math.round(y);\r\n            }\r\n\r\n            ctx.imageSmoothingEnabled = !(!renderer.antialias || frame.source.scaleMode);\r\n\r\n            ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);\r\n\r\n            ctx.restore();\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = ParticleManagerCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.GameObjects.Particles.Zones\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    DeathZone: require('./DeathZone'),\r\n    EdgeZone: require('./EdgeZone'),\r\n    RandomZone: require('./RandomZone')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./RenderTextureWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./RenderTextureCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.RenderTexture#renderWebGL\r\n * @since 3.2.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.RenderTexture} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar RenderTextureWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var cameraAlpha = camera.alpha;\r\n\r\n    var renderTarget = src.renderTarget;\r\n    var width = renderTarget.width;\r\n    var height = renderTarget.height;\r\n\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var textureUnit = pipeline.setTexture2D(renderTarget.texture);\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    pipeline.batchTexture(\r\n        src,\r\n        renderTarget.texture,\r\n        width, height,\r\n        src.x, src.y,\r\n        width, height,\r\n        src.scaleX, src.scaleY,\r\n        src.rotation,\r\n        src.flipX, !src.flipY,\r\n        src.scrollFactorX, src.scrollFactorY,\r\n        src.displayOriginX, src.displayOriginY,\r\n        0, 0, width, height,\r\n        getTint(src.tintTopLeft, cameraAlpha * src._alphaTL),\r\n        getTint(src.tintTopRight, cameraAlpha * src._alphaTR),\r\n        getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL),\r\n        getTint(src.tintBottomRight, cameraAlpha * src._alphaBR),\r\n        src.tintFill,\r\n        0, 0,\r\n        camera,\r\n        parentMatrix,\r\n        true,\r\n        textureUnit\r\n    );\r\n\r\n    renderer.resetTextures();\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = RenderTextureWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.RenderTexture#renderCanvas\r\n * @since 3.2.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.RenderTexture} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar RenderTextureCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = RenderTextureCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RETRO_FONT_CONST = require('./const');\r\nvar Extend = require('../../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.GameObjects.RetroFont\r\n * @since 3.6.0\r\n */\r\n\r\nvar RetroFont = { Parse: require('./ParseRetroFont') };\r\n\r\n//   Merge in the consts\r\nRetroFont = Extend(false, RetroFont, RETRO_FONT_CONST);\r\n\r\nmodule.exports = RetroFont;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RETRO_FONT_CONST = {\r\n\r\n    /**\r\n     * Text Set 1 =  !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET1\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET1: ' !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~',\r\n\r\n    /**\r\n     * Text Set 2 =  !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET2\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET2: ' !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ',\r\n\r\n    /**\r\n     * Text Set 3 = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET3\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET3: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ',\r\n\r\n    /**\r\n     * Text Set 4 = ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET4\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET4: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789',\r\n\r\n    /**\r\n     * Text Set 5 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET5\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET5: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() \\'!?-*:0123456789',\r\n\r\n    /**\r\n     * Text Set 6 = ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' \r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET6\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET6: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.\\' ',\r\n\r\n    /**\r\n     * Text Set 7 = AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET7\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET7: 'AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-\\'39',\r\n\r\n    /**\r\n     * Text Set 8 = 0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET8\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET8: '0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ',\r\n\r\n    /**\r\n     * Text Set 9 = ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET9\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET9: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,\\'\"?!',\r\n\r\n    /**\r\n     * Text Set 10 = ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET10\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET10: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\r\n\r\n    /**\r\n     * Text Set 11 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET11\r\n     * @since 3.6.0\r\n     * @type {string}\r\n     */\r\n    TEXT_SET11: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()\\':;0123456789'\r\n\r\n};\r\n\r\nmodule.exports = RETRO_FONT_CONST;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetValue = require('../../utils/object/GetValue');\r\n\r\n/**\r\n * Parses a Retro Font configuration object so you can pass it to the BitmapText constructor\r\n * and create a BitmapText object using a fixed-width retro font.\r\n *\r\n * @function Phaser.GameObjects.RetroFont.Parse\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Phaser Scene.\r\n * @param {Phaser.Types.GameObjects.BitmapText.RetroFontConfig} config - The font configuration object.\r\n *\r\n * @return {object} A parsed Bitmap Font data entry for the Bitmap Font cache.\r\n */\r\nvar ParseRetroFont = function (scene, config)\r\n{\r\n    var w = config.width;\r\n    var h = config.height;\r\n\r\n    var cx = Math.floor(w / 2);\r\n    var cy = Math.floor(h / 2);\r\n\r\n    var letters = GetValue(config, 'chars', '');\r\n\r\n    if (letters === '')\r\n    {\r\n        return;\r\n    }\r\n\r\n    var key = GetValue(config, 'image', '');\r\n\r\n    var frame = scene.sys.textures.getFrame(key);\r\n    var textureX = frame.cutX;\r\n    var textureY = frame.cutY;\r\n    var textureWidth = frame.source.width;\r\n    var textureHeight = frame.source.height;\r\n\r\n    var offsetX = GetValue(config, 'offset.x', 0);\r\n    var offsetY = GetValue(config, 'offset.y', 0);\r\n    var spacingX = GetValue(config, 'spacing.x', 0);\r\n    var spacingY = GetValue(config, 'spacing.y', 0);\r\n    var lineSpacing = GetValue(config, 'lineSpacing', 0);\r\n\r\n    var charsPerRow = GetValue(config, 'charsPerRow', null);\r\n\r\n    if (charsPerRow === null)\r\n    {\r\n        charsPerRow = textureWidth / w;\r\n\r\n        if (charsPerRow > letters.length)\r\n        {\r\n            charsPerRow = letters.length;\r\n        }\r\n    }\r\n\r\n    var x = offsetX;\r\n    var y = offsetY;\r\n\r\n    var data = {\r\n        retroFont: true,\r\n        font: key,\r\n        size: w,\r\n        lineHeight: h + lineSpacing,\r\n        chars: {}\r\n    };\r\n\r\n    var r = 0;\r\n\r\n    for (var i = 0; i < letters.length; i++)\r\n    {\r\n        var charCode = letters.charCodeAt(i);\r\n\r\n        var u0 = (textureX + x) / textureWidth;\r\n        var v0 = (textureY + y) / textureHeight;\r\n        var u1 = (textureX + x + w) / textureWidth;\r\n        var v1 = (textureY + y + h) / textureHeight;\r\n\r\n        data.chars[charCode] =\r\n        {\r\n            x: x,\r\n            y: y,\r\n            width: w,\r\n            height: h,\r\n            centerX: cx,\r\n            centerY: cy,\r\n            xOffset: 0,\r\n            yOffset: 0,\r\n            xAdvance: w,\r\n            data: {},\r\n            kerning: {},\r\n            u0: u0,\r\n            v0: v0,\r\n            u1: u1,\r\n            v1: v1\r\n        };\r\n\r\n        r++;\r\n\r\n        if (r === charsPerRow)\r\n        {\r\n            r = 0;\r\n            x = offsetX;\r\n            y += h + spacingY;\r\n        }\r\n        else\r\n        {\r\n            x += w + spacingX;\r\n        }\r\n    }\r\n\r\n    var entry = {\r\n        data: data,\r\n        frame: null,\r\n        texture: key\r\n    };\r\n\r\n    return entry;\r\n};\r\n\r\nmodule.exports = ParseRetroFont;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./RopeWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./RopeCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Rope#renderWebGL\r\n * @since 3.23.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Rope} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar RopeWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    var vertices = src.vertices;\r\n    var uvs = src.uv;\r\n    var colors = src.colors;\r\n    var alphas = src.alphas;\r\n    var alpha = src.alpha;\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    var meshVerticesLength = vertices.length;\r\n    var vertexCount = Math.floor(meshVerticesLength * 0.5);\r\n\r\n    //  Because it's a triangle strip and we don't want lots of degenerate triangles joining things up\r\n    pipeline.flush();\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    var textureUnit = pipeline.setGameObject(src);\r\n\r\n    var vertexViewF32 = pipeline.vertexViewF32;\r\n    var vertexViewU32 = pipeline.vertexViewU32;\r\n\r\n    var vertexOffset = (pipeline.vertexCount * pipeline.currentShader.vertexComponentCount) - 1;\r\n\r\n    var colorIndex = 0;\r\n\r\n    var tintEffect = src.tintFill;\r\n\r\n    if (src.dirty)\r\n    {\r\n        src.updateVertices();\r\n    }\r\n\r\n    var debugCallback = src.debugCallback;\r\n    var debugVerts = [];\r\n\r\n    for (var i = 0; i < meshVerticesLength; i += 2)\r\n    {\r\n        var x = vertices[i + 0];\r\n        var y = vertices[i + 1];\r\n\r\n        var tx = x * calcMatrix.a + y * calcMatrix.c + calcMatrix.e;\r\n        var ty = x * calcMatrix.b + y * calcMatrix.d + calcMatrix.f;\r\n\r\n        if (roundPixels)\r\n        {\r\n            tx = Math.round(tx);\r\n            ty = Math.round(ty);\r\n        }\r\n\r\n        vertexViewF32[++vertexOffset] = tx;\r\n        vertexViewF32[++vertexOffset] = ty;\r\n        vertexViewF32[++vertexOffset] = uvs[i + 0];\r\n        vertexViewF32[++vertexOffset] = uvs[i + 1];\r\n        vertexViewF32[++vertexOffset] = textureUnit;\r\n        vertexViewF32[++vertexOffset] = tintEffect;\r\n        vertexViewU32[++vertexOffset] = getTint(colors[colorIndex], camera.alpha * (alphas[colorIndex] * alpha));\r\n\r\n        colorIndex++;\r\n\r\n        if (debugCallback)\r\n        {\r\n            debugVerts[i + 0] = tx;\r\n            debugVerts[i + 1] = ty;\r\n        }\r\n    }\r\n\r\n    if (debugCallback)\r\n    {\r\n        debugCallback.call(src, src, meshVerticesLength, debugVerts);\r\n    }\r\n\r\n    pipeline.vertexCount += vertexCount;\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = RopeWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * This is a stub function for Rope.Render. There is no Canvas renderer for Rope objects.\r\n *\r\n * @method Phaser.GameObjects.Rope#renderCanvas\r\n * @since 3.23.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Rope} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */\r\nvar RopeCanvasRenderer = function ()\r\n{\r\n};\r\n\r\nmodule.exports = RopeCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./TextWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./TextCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Text#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TextWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (src.width === 0 || src.height === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var frame = src.frame;\r\n    var width = frame.width;\r\n    var height = frame.height;\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var textureUnit = pipeline.setTexture2D(frame.glTexture, src);\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    pipeline.batchTexture(\r\n        src,\r\n        frame.glTexture,\r\n        width, height,\r\n        src.x, src.y,\r\n        width / src.style.resolution, height / src.style.resolution,\r\n        src.scaleX, src.scaleY,\r\n        src.rotation,\r\n        src.flipX, src.flipY,\r\n        src.scrollFactorX, src.scrollFactorY,\r\n        src.displayOriginX, src.displayOriginY,\r\n        0, 0, width, height,\r\n        getTint(src.tintTopLeft, camera.alpha * src._alphaTL),\r\n        getTint(src.tintTopRight, camera.alpha * src._alphaTR),\r\n        getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),\r\n        getTint(src.tintBottomRight, camera.alpha * src._alphaBR),\r\n        src.tintFill,\r\n        0, 0,\r\n        camera,\r\n        parentMatrix,\r\n        false,\r\n        textureUnit\r\n    );\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = TextWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Text#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TextCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (src.width === 0 || src.height === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = TextCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./TileSpriteWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./TileSpriteCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.TileSprite#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.TileSprite} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TileSpriteWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    src.updateCanvas();\r\n\r\n    var width = src.width;\r\n    var height = src.height;\r\n\r\n    if (width === 0 || height === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var textureUnit = pipeline.setTexture2D(src.fillPattern, src);\r\n\r\n    pipeline.batchTexture(\r\n        src,\r\n        src.fillPattern,\r\n        src.displayFrame.width * src.tileScaleX, src.displayFrame.height * src.tileScaleY,\r\n        src.x, src.y,\r\n        width, height,\r\n        src.scaleX, src.scaleY,\r\n        src.rotation,\r\n        src.flipX, src.flipY,\r\n        src.scrollFactorX, src.scrollFactorY,\r\n        src.originX * width, src.originY * height,\r\n        0, 0, width, height,\r\n        getTint(src.tintTopLeft, camera.alpha * src._alphaTL),\r\n        getTint(src.tintTopRight, camera.alpha * src._alphaTR),\r\n        getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),\r\n        getTint(src.tintBottomRight, camera.alpha * src._alphaBR),\r\n        src.tintFill,\r\n        (src.tilePositionX % src.displayFrame.width) / src.displayFrame.width,\r\n        (src.tilePositionY % src.displayFrame.height) / src.displayFrame.height,\r\n        camera,\r\n        parentMatrix,\r\n        false,\r\n        textureUnit\r\n    );\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = TileSpriteWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.TileSprite#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.TileSprite} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TileSpriteCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    src.updateCanvas();\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = TileSpriteCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./VideoWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./VideoCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Video#renderWebGL\r\n * @since 3.20.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Video} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar VideoWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (src.videoTexture)\r\n    {\r\n        camera.addToRenderList(src);\r\n\r\n        src.pipeline.batchSprite(src, camera, parentMatrix);\r\n    }\r\n};\r\n\r\nmodule.exports = VideoWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Video#renderCanvas\r\n * @since 3.20.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Video} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar VideoCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (src.videoTexture)\r\n    {\r\n        camera.addToRenderList(src);\r\n\r\n        renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n    }\r\n};\r\n\r\nmodule.exports = VideoCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./ArcWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./ArcCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar FillPathWebGL = require('../FillPathWebGL');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Arc#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Arc} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ArcWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = ArcWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar DegToRad = require('../../../math/DegToRad');\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Arc#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Arc} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ArcCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var radius = src.radius;\r\n\r\n        ctx.beginPath();\r\n\r\n        ctx.arc(\r\n            (radius) - src.originX * (radius * 2),\r\n            (radius) - src.originY * (radius * 2),\r\n            radius,\r\n            DegToRad(src._startAngle),\r\n            DegToRad(src._endAngle),\r\n            src.anticlockwise\r\n        );\r\n\r\n        if (src.closePath)\r\n        {\r\n            ctx.closePath();\r\n        }\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = ArcCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./CurveWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./CurveCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillPathWebGL = require('../FillPathWebGL');\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Curve#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Curve} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar CurveWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX + src._curveBounds.x;\r\n    var dy = src._displayOriginY + src._curveBounds.y;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = CurveWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Curve#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Curve} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar CurveCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX + src._curveBounds.x;\r\n        var dy = src._displayOriginY + src._curveBounds.y;\r\n\r\n        var path = src.pathData;\r\n        var pathLength = path.length - 1;\r\n\r\n        var px1 = path[0] - dx;\r\n        var py1 = path[1] - dy;\r\n\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(px1, py1);\r\n\r\n        if (!src.closePath)\r\n        {\r\n            pathLength -= 2;\r\n        }\r\n\r\n        for (var i = 2; i < pathLength; i += 2)\r\n        {\r\n            var px2 = path[i] - dx;\r\n            var py2 = path[i + 1] - dy;\r\n\r\n            ctx.lineTo(px2, py2);\r\n        }\r\n\r\n        if (src.closePath)\r\n        {\r\n            ctx.closePath();\r\n        }\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = CurveCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./EllipseWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./EllipseCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillPathWebGL = require('../FillPathWebGL');\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Ellipse#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Ellipse} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar EllipseWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = EllipseWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Ellipse#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Ellipse} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar EllipseCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX;\r\n        var dy = src._displayOriginY;\r\n\r\n        var path = src.pathData;\r\n        var pathLength = path.length - 1;\r\n\r\n        var px1 = path[0] - dx;\r\n        var py1 = path[1] - dy;\r\n\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(px1, py1);\r\n\r\n        if (!src.closePath)\r\n        {\r\n            pathLength -= 2;\r\n        }\r\n\r\n        for (var i = 2; i < pathLength; i += 2)\r\n        {\r\n            var px2 = path[i] - dx;\r\n            var py2 = path[i + 1] - dy;\r\n\r\n            ctx.lineTo(px2, py2);\r\n        }\r\n\r\n        ctx.closePath();\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = EllipseCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./GridWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./GridCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Grid#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Grid} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar GridWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    calcMatrix.translate(-src._displayOriginX, -src._displayOriginY);\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    //  Work out the grid size\r\n\r\n    var width = src.width;\r\n    var height = src.height;\r\n\r\n    var cellWidth = src.cellWidth;\r\n    var cellHeight = src.cellHeight;\r\n\r\n    var gridWidth = Math.ceil(width / cellWidth);\r\n    var gridHeight = Math.ceil(height / cellHeight);\r\n\r\n    var cellWidthA = cellWidth;\r\n    var cellHeightA = cellHeight;\r\n\r\n    var cellWidthB = cellWidth - ((gridWidth * cellWidth) - width);\r\n    var cellHeightB = cellHeight - ((gridHeight * cellHeight) - height);\r\n\r\n    var fillTint;\r\n    var fillTintColor;\r\n\r\n    var showCells = src.showCells;\r\n    var showAltCells = src.showAltCells;\r\n    var showOutline = src.showOutline;\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n    var r = 0;\r\n    var cw = 0;\r\n    var ch = 0;\r\n\r\n    if (showOutline)\r\n    {\r\n        //  To make room for the grid lines (in case alpha < 1)\r\n        cellWidthA--;\r\n        cellHeightA--;\r\n\r\n        if (cellWidthB === cellWidth)\r\n        {\r\n            cellWidthB--;\r\n        }\r\n\r\n        if (cellHeightB === cellHeight)\r\n        {\r\n            cellHeightB--;\r\n        }\r\n    }\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (showCells && src.fillAlpha > 0)\r\n    {\r\n        fillTint = pipeline.fillTint;\r\n        fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);\r\n\r\n        fillTint.TL = fillTintColor;\r\n        fillTint.TR = fillTintColor;\r\n        fillTint.BL = fillTintColor;\r\n        fillTint.BR = fillTintColor;\r\n\r\n        for (y = 0; y < gridHeight; y++)\r\n        {\r\n            if (showAltCells)\r\n            {\r\n                r = y % 2;\r\n            }\r\n\r\n            for (x = 0; x < gridWidth; x++)\r\n            {\r\n                if (showAltCells && r)\r\n                {\r\n                    r = 0;\r\n                    continue;\r\n                }\r\n\r\n                r++;\r\n\r\n                cw = (x < gridWidth - 1) ? cellWidthA : cellWidthB;\r\n                ch = (y < gridHeight - 1) ? cellHeightA : cellHeightB;\r\n\r\n                pipeline.batchFillRect(\r\n                    x * cellWidth,\r\n                    y * cellHeight,\r\n                    cw,\r\n                    ch\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    if (showAltCells && src.altFillAlpha > 0)\r\n    {\r\n        fillTint = pipeline.fillTint;\r\n        fillTintColor = Utils.getTintAppendFloatAlpha(src.altFillColor, src.altFillAlpha * alpha);\r\n\r\n        fillTint.TL = fillTintColor;\r\n        fillTint.TR = fillTintColor;\r\n        fillTint.BL = fillTintColor;\r\n        fillTint.BR = fillTintColor;\r\n\r\n        for (y = 0; y < gridHeight; y++)\r\n        {\r\n            if (showAltCells)\r\n            {\r\n                r = y % 2;\r\n            }\r\n\r\n            for (x = 0; x < gridWidth; x++)\r\n            {\r\n                if (showAltCells && !r)\r\n                {\r\n                    r = 1;\r\n                    continue;\r\n                }\r\n\r\n                r = 0;\r\n\r\n                cw = (x < gridWidth - 1) ? cellWidthA : cellWidthB;\r\n                ch = (y < gridHeight - 1) ? cellHeightA : cellHeightB;\r\n\r\n                pipeline.batchFillRect(\r\n                    x * cellWidth,\r\n                    y * cellHeight,\r\n                    cw,\r\n                    ch\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    if (showOutline && src.outlineFillAlpha > 0)\r\n    {\r\n        var strokeTint = pipeline.strokeTint;\r\n        var color = Utils.getTintAppendFloatAlpha(src.outlineFillColor, src.outlineFillAlpha * alpha);\r\n\r\n        strokeTint.TL = color;\r\n        strokeTint.TR = color;\r\n        strokeTint.BL = color;\r\n        strokeTint.BR = color;\r\n\r\n        for (x = 1; x < gridWidth; x++)\r\n        {\r\n            var x1 = x * cellWidth;\r\n\r\n            pipeline.batchLine(x1, 0, x1, height, 1, 1, 1, 0, false);\r\n        }\r\n\r\n        for (y = 1; y < gridHeight; y++)\r\n        {\r\n            var y1 = y * cellHeight;\r\n\r\n            pipeline.batchLine(0, y1, width, y1, 1, 1, 1, 0, false);\r\n        }\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = GridWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Grid#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Grid} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar GridCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = -src._displayOriginX;\r\n        var dy = -src._displayOriginY;\r\n\r\n        var alpha = camera.alpha * src.alpha;\r\n\r\n        //  Work out the grid size\r\n\r\n        var width = src.width;\r\n        var height = src.height;\r\n\r\n        var cellWidth = src.cellWidth;\r\n        var cellHeight = src.cellHeight;\r\n\r\n        var gridWidth = Math.ceil(width / cellWidth);\r\n        var gridHeight = Math.ceil(height / cellHeight);\r\n\r\n        var cellWidthA = cellWidth;\r\n        var cellHeightA = cellHeight;\r\n\r\n        var cellWidthB = cellWidth - ((gridWidth * cellWidth) - width);\r\n        var cellHeightB = cellHeight - ((gridHeight * cellHeight) - height);\r\n\r\n        var showCells = src.showCells;\r\n        var showAltCells = src.showAltCells;\r\n        var showOutline = src.showOutline;\r\n\r\n        var x = 0;\r\n        var y = 0;\r\n        var r = 0;\r\n        var cw = 0;\r\n        var ch = 0;\r\n\r\n        if (showOutline)\r\n        {\r\n            //  To make room for the grid lines (in case alpha < 1)\r\n            cellWidthA--;\r\n            cellHeightA--;\r\n\r\n            if (cellWidthB === cellWidth)\r\n            {\r\n                cellWidthB--;\r\n            }\r\n\r\n            if (cellHeightB === cellHeight)\r\n            {\r\n                cellHeightB--;\r\n            }\r\n        }\r\n\r\n        if (showCells && src.fillAlpha > 0)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            for (y = 0; y < gridHeight; y++)\r\n            {\r\n                if (showAltCells)\r\n                {\r\n                    r = y % 2;\r\n                }\r\n\r\n                for (x = 0; x < gridWidth; x++)\r\n                {\r\n                    if (showAltCells && r)\r\n                    {\r\n                        r = 0;\r\n                        continue;\r\n                    }\r\n\r\n                    r++;\r\n\r\n                    cw = (x < gridWidth - 1) ? cellWidthA : cellWidthB;\r\n                    ch = (y < gridHeight - 1) ? cellHeightA : cellHeightB;\r\n\r\n                    ctx.fillRect(\r\n                        dx + x * cellWidth,\r\n                        dy + y * cellHeight,\r\n                        cw,\r\n                        ch\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        if (showAltCells && src.altFillAlpha > 0)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.altFillColor, src.altFillAlpha * alpha);\r\n\r\n            for (y = 0; y < gridHeight; y++)\r\n            {\r\n                if (showAltCells)\r\n                {\r\n                    r = y % 2;\r\n                }\r\n\r\n                for (x = 0; x < gridWidth; x++)\r\n                {\r\n                    if (showAltCells && !r)\r\n                    {\r\n                        r = 1;\r\n                        continue;\r\n                    }\r\n\r\n                    r = 0;\r\n\r\n                    cw = (x < gridWidth - 1) ? cellWidthA : cellWidthB;\r\n                    ch = (y < gridHeight - 1) ? cellHeightA : cellHeightB;\r\n\r\n                    ctx.fillRect(\r\n                        dx + x * cellWidth,\r\n                        dy + y * cellHeight,\r\n                        cw,\r\n                        ch\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        if (showOutline && src.outlineFillAlpha > 0)\r\n        {\r\n            LineStyleCanvas(ctx, src, src.outlineFillColor, src.outlineFillAlpha * alpha);\r\n\r\n            for (x = 1; x < gridWidth; x++)\r\n            {\r\n                var x1 = x * cellWidth;\r\n\r\n                ctx.beginPath();\r\n\r\n                ctx.moveTo(x1 + dx, dy);\r\n                ctx.lineTo(x1 + dx, height + dy);\r\n\r\n                ctx.stroke();\r\n            }\r\n\r\n            for (y = 1; y < gridHeight; y++)\r\n            {\r\n                var y1 = y * cellHeight;\r\n\r\n                ctx.beginPath();\r\n\r\n                ctx.moveTo(dx, y1 + dy);\r\n                ctx.lineTo(dx + width, y1 + dy);\r\n\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = GridCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./IsoBoxWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./IsoBoxCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.IsoBox#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.IsoBox} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar IsoBoxWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var size = src.width;\r\n    var height = src.height;\r\n\r\n    var sizeA = size / 2;\r\n    var sizeB = size / src.projection;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (!src.isFilled)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var tint;\r\n\r\n    var x0;\r\n    var y0;\r\n\r\n    var x1;\r\n    var y1;\r\n\r\n    var x2;\r\n    var y2;\r\n\r\n    var x3;\r\n    var y3;\r\n\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    //  Top Face\r\n\r\n    if (src.showTop)\r\n    {\r\n        tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);\r\n\r\n        x0 = calcMatrix.getX(-sizeA, -height);\r\n        y0 = calcMatrix.getY(-sizeA, -height);\r\n\r\n        x1 = calcMatrix.getX(0, -sizeB - height);\r\n        y1 = calcMatrix.getY(0, -sizeB - height);\r\n\r\n        x2 = calcMatrix.getX(sizeA, -height);\r\n        y2 = calcMatrix.getY(sizeA, -height);\r\n\r\n        x3 = calcMatrix.getX(0, sizeB - height);\r\n        y3 = calcMatrix.getY(0, sizeB - height);\r\n\r\n        pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);\r\n    }\r\n\r\n    //  Left Face\r\n\r\n    if (src.showLeft)\r\n    {\r\n        tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);\r\n\r\n        x0 = calcMatrix.getX(-sizeA, 0);\r\n        y0 = calcMatrix.getY(-sizeA, 0);\r\n\r\n        x1 = calcMatrix.getX(0, sizeB);\r\n        y1 = calcMatrix.getY(0, sizeB);\r\n\r\n        x2 = calcMatrix.getX(0, sizeB - height);\r\n        y2 = calcMatrix.getY(0, sizeB - height);\r\n\r\n        x3 = calcMatrix.getX(-sizeA, -height);\r\n        y3 = calcMatrix.getY(-sizeA, -height);\r\n\r\n        pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);\r\n    }\r\n\r\n    //  Right Face\r\n\r\n    if (src.showRight)\r\n    {\r\n        tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);\r\n\r\n        x0 = calcMatrix.getX(sizeA, 0);\r\n        y0 = calcMatrix.getY(sizeA, 0);\r\n\r\n        x1 = calcMatrix.getX(0, sizeB);\r\n        y1 = calcMatrix.getY(0, sizeB);\r\n\r\n        x2 = calcMatrix.getX(0, sizeB - height);\r\n        y2 = calcMatrix.getY(0, sizeB - height);\r\n\r\n        x3 = calcMatrix.getX(sizeA, -height);\r\n        y3 = calcMatrix.getY(sizeA, -height);\r\n\r\n        pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = IsoBoxWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.IsoBox#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.IsoBox} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar IsoBoxCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled)\r\n    {\r\n        var size = src.width;\r\n        var height = src.height;\r\n\r\n        var sizeA = size / 2;\r\n        var sizeB = size / src.projection;\r\n\r\n        //  Top Face\r\n\r\n        if (src.showTop)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.fillTop);\r\n\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(-sizeA, -height);\r\n            ctx.lineTo(0, -sizeB - height);\r\n            ctx.lineTo(sizeA, -height);\r\n            ctx.lineTo(sizeA, -1);\r\n            ctx.lineTo(0, sizeB - 1);\r\n            ctx.lineTo(-sizeA, -1);\r\n            ctx.lineTo(-sizeA, -height);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        //  Left Face\r\n\r\n        if (src.showLeft)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.fillLeft);\r\n\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(-sizeA, 0);\r\n            ctx.lineTo(0, sizeB);\r\n            ctx.lineTo(0, sizeB - height);\r\n            ctx.lineTo(-sizeA, -height);\r\n            ctx.lineTo(-sizeA, 0);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        //  Right Face\r\n\r\n        if (src.showRight)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.fillRight);\r\n\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(sizeA, 0);\r\n            ctx.lineTo(0, sizeB);\r\n            ctx.lineTo(0, sizeB - height);\r\n            ctx.lineTo(sizeA, -height);\r\n            ctx.lineTo(sizeA, 0);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = IsoBoxCanvasRenderer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Utils = require('../../renderer/webgl/Utils');\n\n/**\n * Renders a filled path for the given Shape.\n *\n * @method Phaser.GameObjects.Shape#FillPathWebGL\n * @since 3.13.0\n * @private\n *\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The WebGL Pipeline used to render this Shape.\n * @param {Phaser.GameObjects.Components.TransformMatrix} calcMatrix - The transform matrix used to get the position values.\n * @param {Phaser.GameObjects.Shape} src - The Game Object shape being rendered in this call.\n * @param {number} alpha - The base alpha value.\n * @param {number} dx - The source displayOriginX.\n * @param {number} dy - The source displayOriginY.\n */\nvar FillPathWebGL = function (pipeline, calcMatrix, src, alpha, dx, dy)\n{\n    var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);\n\n    var path = src.pathData;\n    var pathIndexes = src.pathIndexes;\n\n    for (var i = 0; i < pathIndexes.length; i += 3)\n    {\n        var p0 = pathIndexes[i] * 2;\n        var p1 = pathIndexes[i + 1] * 2;\n        var p2 = pathIndexes[i + 2] * 2;\n\n        var x0 = path[p0 + 0] - dx;\n        var y0 = path[p0 + 1] - dy;\n        var x1 = path[p1 + 0] - dx;\n        var y1 = path[p1 + 1] - dy;\n        var x2 = path[p2 + 0] - dx;\n        var y2 = path[p2 + 1] - dy;\n\n        var tx0 = calcMatrix.getX(x0, y0);\n        var ty0 = calcMatrix.getY(x0, y0);\n\n        var tx1 = calcMatrix.getX(x1, y1);\n        var ty1 = calcMatrix.getY(x1, y1);\n\n        var tx2 = calcMatrix.getX(x2, y2);\n        var ty2 = calcMatrix.getY(x2, y2);\n\n        pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);\n    }\n};\n\nmodule.exports = FillPathWebGL;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./IsoTriangleWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./IsoTriangleCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.IsoTriangle#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.IsoTriangle} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar IsoTriangleWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var size = src.width;\r\n    var height = src.height;\r\n\r\n    var sizeA = size / 2;\r\n    var sizeB = size / src.projection;\r\n\r\n    var reversed = src.isReversed;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (!src.isFilled)\r\n    {\r\n        return;\r\n    }\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    var tint;\r\n\r\n    var x0;\r\n    var y0;\r\n\r\n    var x1;\r\n    var y1;\r\n\r\n    var x2;\r\n    var y2;\r\n\r\n    //  Top Face\r\n\r\n    if (src.showTop && reversed)\r\n    {\r\n        tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);\r\n\r\n        x0 = calcMatrix.getX(-sizeA, -height);\r\n        y0 = calcMatrix.getY(-sizeA, -height);\r\n\r\n        x1 = calcMatrix.getX(0, -sizeB - height);\r\n        y1 = calcMatrix.getY(0, -sizeB - height);\r\n\r\n        x2 = calcMatrix.getX(sizeA, -height);\r\n        y2 = calcMatrix.getY(sizeA, -height);\r\n\r\n        var x3 = calcMatrix.getX(0, sizeB - height);\r\n        var y3 = calcMatrix.getY(0, sizeB - height);\r\n\r\n        pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);\r\n    }\r\n\r\n    //  Left Face\r\n\r\n    if (src.showLeft)\r\n    {\r\n        tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);\r\n\r\n        if (reversed)\r\n        {\r\n            x0 = calcMatrix.getX(-sizeA, -height);\r\n            y0 = calcMatrix.getY(-sizeA, -height);\r\n\r\n            x1 = calcMatrix.getX(0, sizeB);\r\n            y1 = calcMatrix.getY(0, sizeB);\r\n\r\n            x2 = calcMatrix.getX(0, sizeB - height);\r\n            y2 = calcMatrix.getY(0, sizeB - height);\r\n        }\r\n        else\r\n        {\r\n            x0 = calcMatrix.getX(-sizeA, 0);\r\n            y0 = calcMatrix.getY(-sizeA, 0);\r\n\r\n            x1 = calcMatrix.getX(0, sizeB);\r\n            y1 = calcMatrix.getY(0, sizeB);\r\n\r\n            x2 = calcMatrix.getX(0, sizeB - height);\r\n            y2 = calcMatrix.getY(0, sizeB - height);\r\n        }\r\n\r\n        pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);\r\n    }\r\n\r\n    //  Right Face\r\n\r\n    if (src.showRight)\r\n    {\r\n        tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);\r\n\r\n        if (reversed)\r\n        {\r\n            x0 = calcMatrix.getX(sizeA, -height);\r\n            y0 = calcMatrix.getY(sizeA, -height);\r\n\r\n            x1 = calcMatrix.getX(0, sizeB);\r\n            y1 = calcMatrix.getY(0, sizeB);\r\n\r\n            x2 = calcMatrix.getX(0, sizeB - height);\r\n            y2 = calcMatrix.getY(0, sizeB - height);\r\n        }\r\n        else\r\n        {\r\n            x0 = calcMatrix.getX(sizeA, 0);\r\n            y0 = calcMatrix.getY(sizeA, 0);\r\n\r\n            x1 = calcMatrix.getX(0, sizeB);\r\n            y1 = calcMatrix.getY(0, sizeB);\r\n\r\n            x2 = calcMatrix.getX(0, sizeB - height);\r\n            y2 = calcMatrix.getY(0, sizeB - height);\r\n        }\r\n\r\n        pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = IsoTriangleWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.IsoTriangle#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.IsoTriangle} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar IsoTriangleCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled)\r\n    {\r\n        var size = src.width;\r\n        var height = src.height;\r\n\r\n        var sizeA = size / 2;\r\n        var sizeB = size / src.projection;\r\n\r\n        var reversed = src.isReversed;\r\n\r\n        //  Top Face\r\n\r\n        if (src.showTop && reversed)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.fillTop);\r\n\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(-sizeA, -height);\r\n            ctx.lineTo(0, -sizeB - height);\r\n            ctx.lineTo(sizeA, -height);\r\n            ctx.lineTo(0, sizeB - height);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        //  Left Face\r\n\r\n        if (src.showLeft)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.fillLeft);\r\n\r\n            ctx.beginPath();\r\n\r\n            if (reversed)\r\n            {\r\n                ctx.moveTo(-sizeA, -height);\r\n                ctx.lineTo(0, sizeB);\r\n                ctx.lineTo(0, sizeB - height);\r\n            }\r\n            else\r\n            {\r\n                ctx.moveTo(-sizeA, 0);\r\n                ctx.lineTo(0, sizeB);\r\n                ctx.lineTo(0, sizeB - height);\r\n            }\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        //  Right Face\r\n\r\n        if (src.showRight)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.fillRight);\r\n\r\n            ctx.beginPath();\r\n\r\n            if (reversed)\r\n            {\r\n                ctx.moveTo(sizeA, -height);\r\n                ctx.lineTo(0, sizeB);\r\n                ctx.lineTo(0, sizeB - height);\r\n            }\r\n            else\r\n            {\r\n                ctx.moveTo(sizeA, 0);\r\n                ctx.lineTo(0, sizeB);\r\n                ctx.lineTo(0, sizeB - height);\r\n            }\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = IsoTriangleCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./LineWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./LineCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Line#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Line} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar LineWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isStroked)\r\n    {\r\n        var strokeTint = pipeline.strokeTint;\r\n        var color = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);\r\n\r\n        strokeTint.TL = color;\r\n        strokeTint.TR = color;\r\n        strokeTint.BL = color;\r\n        strokeTint.BR = color;\r\n\r\n        var startWidth = src._startWidth;\r\n        var endWidth = src._endWidth;\r\n\r\n        pipeline.batchLine(\r\n            src.geom.x1 - dx,\r\n            src.geom.y1 - dy,\r\n            src.geom.x2 - dx,\r\n            src.geom.y2 - dy,\r\n            startWidth,\r\n            endWidth,\r\n            1,\r\n            0,\r\n            false,\r\n            result.sprite,\r\n            result.camera\r\n        );\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = LineWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Line#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Line} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar LineCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX;\r\n        var dy = src._displayOriginY;\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(src.geom.x1 - dx, src.geom.y1 - dy);\r\n            ctx.lineTo(src.geom.x2 - dx, src.geom.y2 - dy);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = LineCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./PolygonWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./PolygonCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillPathWebGL = require('../FillPathWebGL');\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Polygon#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Polygon} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar PolygonWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = PolygonWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Polygon#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Polygon} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar PolygonCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX;\r\n        var dy = src._displayOriginY;\r\n\r\n        var path = src.pathData;\r\n        var pathLength = path.length - 1;\r\n\r\n        var px1 = path[0] - dx;\r\n        var py1 = path[1] - dy;\r\n\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(px1, py1);\r\n\r\n        if (!src.closePath)\r\n        {\r\n            pathLength -= 2;\r\n        }\r\n\r\n        for (var i = 2; i < pathLength; i += 2)\r\n        {\r\n            var px2 = path[i] - dx;\r\n            var py2 = path[i + 1] - dy;\r\n\r\n            ctx.lineTo(px2, py2);\r\n        }\r\n\r\n        ctx.closePath();\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = PolygonCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./RectangleWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./RectangleCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Rectangle#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Rectangle} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar RectangleWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        var fillTint = pipeline.fillTint;\r\n        var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);\r\n\r\n        fillTint.TL = fillTintColor;\r\n        fillTint.TR = fillTintColor;\r\n        fillTint.BL = fillTintColor;\r\n        fillTint.BR = fillTintColor;\r\n\r\n        pipeline.batchFillRect(\r\n            -dx,\r\n            -dy,\r\n            src.width,\r\n            src.height\r\n        );\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = RectangleWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Rectangle#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Rectangle} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar RectangleCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX;\r\n        var dy = src._displayOriginY;\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fillRect(\r\n                -dx,\r\n                -dy,\r\n                src.width,\r\n                src.height\r\n            );\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.beginPath();\r\n\r\n            ctx.rect(\r\n                -dx,\r\n                -dy,\r\n                src.width,\r\n                src.height\r\n            );\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = RectangleCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./StarWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./StarCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillPathWebGL = require('../FillPathWebGL');\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Star#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Star} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar StarWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = StarWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Star#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Star} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar StarCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX;\r\n        var dy = src._displayOriginY;\r\n\r\n        var path = src.pathData;\r\n        var pathLength = path.length - 1;\r\n\r\n        var px1 = path[0] - dx;\r\n        var py1 = path[1] - dy;\r\n\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(px1, py1);\r\n\r\n        if (!src.closePath)\r\n        {\r\n            pathLength -= 2;\r\n        }\r\n\r\n        for (var i = 2; i < pathLength; i += 2)\r\n        {\r\n            var px2 = path[i] - dx;\r\n            var py2 = path[i + 1] - dy;\r\n\r\n            ctx.lineTo(px2, py2);\r\n        }\r\n\r\n        ctx.closePath();\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = StarCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./TriangleWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./TriangleCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Triangle#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Triangle} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TriangleWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        var fillTint = pipeline.fillTint;\r\n        var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);\r\n\r\n        fillTint.TL = fillTintColor;\r\n        fillTint.TR = fillTintColor;\r\n        fillTint.BL = fillTintColor;\r\n        fillTint.BR = fillTintColor;\r\n\r\n        var x1 = src.geom.x1 - dx;\r\n        var y1 = src.geom.y1 - dy;\r\n        var x2 = src.geom.x2 - dx;\r\n        var y2 = src.geom.y2 - dy;\r\n        var x3 = src.geom.x3 - dx;\r\n        var y3 = src.geom.y3 - dy;\r\n\r\n        pipeline.batchFillTriangle(\r\n            x1,\r\n            y1,\r\n            x2,\r\n            y2,\r\n            x3,\r\n            y3,\r\n            result.sprite,\r\n            result.camera\r\n        );\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = TriangleWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Triangle#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Triangle} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TriangleCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX;\r\n        var dy = src._displayOriginY;\r\n\r\n        var x1 = src.geom.x1 - dx;\r\n        var y1 = src.geom.y1 - dy;\r\n        var x2 = src.geom.x2 - dx;\r\n        var y2 = src.geom.y2 - dy;\r\n        var x3 = src.geom.x3 - dx;\r\n        var y3 = src.geom.y3 - dy;\r\n\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(x1, y1);\r\n        ctx.lineTo(x2, y2);\r\n        ctx.lineTo(x3, y3);\r\n\r\n        ctx.closePath();\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = TriangleCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Blitter = require('./Blitter');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Blitter Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Blitter Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#blitter\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x position of the Game Object.\r\n * @param {number} y - The y position of the Game Object.\r\n * @param {string} key - The key of the Texture the Blitter object will use.\r\n * @param {(string|number)} [frame] - The default Frame children of the Blitter will use.\r\n *\r\n * @return {Phaser.GameObjects.Blitter} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('blitter', function (x, y, key, frame)\r\n{\r\n    return this.displayList.add(new Blitter(this.scene, x, y, key, frame));\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Container = require('./Container');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Container Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Container Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#container\r\n * @since 3.4.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Container.\r\n *\r\n * @return {Phaser.GameObjects.Container} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('container', function (x, y, children)\r\n{\r\n    return this.displayList.add(new Container(this.scene, x, y, children));\r\n});\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar DOMElement = require('./DOMElement');\nvar GameObjectFactory = require('../GameObjectFactory');\n\n/**\n * DOM Element Game Objects are a way to control and manipulate HTML Elements over the top of your game.\n *\n * In order for DOM Elements to display you have to enable them by adding the following to your game\n * configuration object:\n *\n * ```javascript\n * dom {\n *   createContainer: true\n * }\n * ```\n *\n * When this is added, Phaser will automatically create a DOM Container div that is positioned over the top\n * of the game canvas. This div is sized to match the canvas, and if the canvas size changes, as a result of\n * settings within the Scale Manager, the dom container is resized accordingly.\n *\n * You can create a DOM Element by either passing in DOMStrings, or by passing in a reference to an existing\n * Element that you wish to be placed under the control of Phaser. For example:\n *\n * ```javascript\n * this.add.dom(x, y, 'div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');\n * ```\n *\n * The above code will insert a div element into the DOM Container at the given x/y coordinate. The DOMString in\n * the 4th argument sets the initial CSS style of the div and the final argument is the inner text. In this case,\n * it will create a lime colored div that is 220px by 100px in size with the text Phaser in it, in an Arial font.\n *\n * You should nearly always, without exception, use explicitly sized HTML Elements, in order to fully control\n * alignment and positioning of the elements next to regular game content.\n *\n * Rather than specify the CSS and HTML directly you can use the `load.html` File Loader to load it into the\n * cache and then use the `createFromCache` method instead. You can also use `createFromHTML` and various other\n * methods available in this class to help construct your elements.\n *\n * Once the element has been created you can then control it like you would any other Game Object. You can set its\n * position, scale, rotation, alpha and other properties. It will move as the main Scene Camera moves and be clipped\n * at the edge of the canvas. It's important to remember some limitations of DOM Elements: The obvious one is that\n * they appear above or below your game canvas. You cannot blend them into the display list, meaning you cannot have\n * a DOM Element, then a Sprite, then another DOM Element behind it.\n *\n * They also cannot be enabled for input. To do that, you have to use the `addListener` method to add native event\n * listeners directly. The final limitation is to do with cameras. The DOM Container is sized to match the game canvas\n * entirely and clipped accordingly. DOM Elements respect camera scrolling and scrollFactor settings, but if you\n * change the size of the camera so it no longer matches the size of the canvas, they won't be clipped accordingly.\n *\n * Also, all DOM Elements are inserted into the same DOM Container, regardless of which Scene they are created in.\n *\n * DOM Elements are a powerful way to align native HTML with your Phaser Game Objects. For example, you can insert\n * a login form for a multiplayer game directly into your title screen. Or a text input box for a highscore table.\n * Or a banner ad from a 3rd party service. Or perhaps you'd like to use them for high resolution text display and\n * UI. The choice is up to you, just remember that you're dealing with standard HTML and CSS floating over the top\n * of your game, and should treat it accordingly.\n *\n * Note: This method will only be available if the DOM Element Game Object has been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectFactory#dom\n * @since 3.17.0\n *\n * @param {number} x - The horizontal position of this DOM Element in the world.\n * @param {number} y - The vertical position of this DOM Element in the world.\n * @param {(HTMLElement|string)} [element] - An existing DOM element, or a string. If a string starting with a # it will do a `getElementById` look-up on the string (minus the hash). Without a hash, it represents the type of element to create, i.e. 'div'.\n * @param {(string|any)} [style] - If a string, will be set directly as the elements `style` property value. If a plain object, will be iterated and the values transferred. In both cases the values replacing whatever CSS styles may have been previously set.\n * @param {string} [innerText] - If given, will be set directly as the elements `innerText` property value, replacing whatever was there before.\n *\n * @return {Phaser.GameObjects.DOMElement} The Game Object that was created.\n */\nGameObjectFactory.register('dom', function (x, y, element, style, innerText)\n{\n    var gameObject = new DOMElement(this.scene, x, y, element, style, innerText);\n\n    this.displayList.add(gameObject);\n\n    return gameObject;\n});\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar DynamicBitmapText = require('./DynamicBitmapText');\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Dynamic Bitmap Text Game Object and adds it to the Scene.\r\n * \r\n * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\r\n * \r\n * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\r\n * match the font structure.\r\n * \r\n * Dynamic Bitmap Text objects are different from Static Bitmap Text in that they invoke a callback for each\r\n * letter being rendered during the render pass. This callback allows you to manipulate the properties of\r\n * each letter being rendered, such as its position, scale or tint, allowing you to create interesting effects\r\n * like jiggling text, which can't be done with Static text. This means that Dynamic Text takes more processing\r\n * time, so only use them if you require the callback ability they have.\r\n *\r\n * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\r\n * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\r\n * processing the font texture in an image editor, applying fills and any other effects required.\r\n *\r\n * To create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\r\n *\r\n * To create a BitmapText data files you need a 3rd party app such as:\r\n *\r\n * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/\r\n * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner\r\n * Littera (Web-based, free): http://kvazars.com/littera/\r\n *\r\n * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\r\n * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson\r\n *\r\n * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#dynamicBitmapText\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x position of the Game Object.\r\n * @param {number} y - The y position of the Game Object.\r\n * @param {string} font - The key of the font to use from the BitmapFont cache.\r\n * @param {(string|string[])} [text] - The string, or array of strings, to be set as the content of this Bitmap Text.\r\n * @param {number} [size] - The font size to set.\r\n *\r\n * @return {Phaser.GameObjects.DynamicBitmapText} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('dynamicBitmapText', function (x, y, font, text, size)\r\n{\r\n    return this.displayList.add(new DynamicBitmapText(this.scene, x, y, font, text, size));\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Extern = require('./Extern');\nvar GameObjectFactory = require('../GameObjectFactory');\n\n/**\n * Creates a new Extern Game Object and adds it to the Scene.\n *\n * Note: This method will only be available if the Extern Game Object has been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectFactory#extern\n * @since 3.16.0\n *\n * @return {Phaser.GameObjects.Extern} The Game Object that was created.\n */\nGameObjectFactory.register('extern', function ()\n{\n    var extern = new Extern(this.scene);\n\n    this.displayList.add(extern);\n\n    return extern;\n});\n\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Graphics = require('./Graphics');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Graphics Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Graphics Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#graphics\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Graphics.Options} [config] - The Graphics configuration.\r\n *\r\n * @return {Phaser.GameObjects.Graphics} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('graphics', function (config)\r\n{\r\n    return this.displayList.add(new Graphics(this.scene, config));\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Group = require('./Group');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Group Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Group Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#group\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupConfig[])} [children] - Game Objects to add to this Group; or the `config` argument.\r\n * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - A Group Configuration object.\r\n *\r\n * @return {Phaser.GameObjects.Group} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('group', function (children, config)\r\n{\r\n    return this.updateList.add(new Group(this.scene, children, config));\r\n});\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Image = require('./Image');\nvar GameObjectFactory = require('../GameObjectFactory');\n\n/**\n * Creates a new Image Game Object and adds it to the Scene.\n *\n * Note: This method will only be available if the Image Game Object has been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectFactory#image\n * @since 3.0.0\n *\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n *\n * @return {Phaser.GameObjects.Image} The Game Object that was created.\n */\nGameObjectFactory.register('image', function (x, y, key, frame)\n{\n    return this.displayList.add(new Image(this.scene, x, y, key, frame));\n});\n\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Layer = require('./Layer');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Layer Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Layer Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#layer\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Layer.\r\n *\r\n * @return {Phaser.GameObjects.Layer} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('layer', function (children)\r\n{\r\n    return this.displayList.add(new Layer(this.scene, children));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\nvar ParticleEmitterManager = require('./ParticleEmitterManager');\r\n\r\n/**\r\n * Creates a new Particle Emitter Manager Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Particles Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#particles\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|number|object)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig|Phaser.Types.GameObjects.Particles.ParticleEmitterConfig[]} [emitters] - Configuration settings for one or more emitters to create.\r\n *\r\n * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('particles', function (key, frame, emitters)\r\n{\r\n    return this.displayList.add(new ParticleEmitterManager(this.scene, key, frame, emitters));\r\n});\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar GameObjectFactory = require('../GameObjectFactory');\nvar PathFollower = require('./PathFollower');\n\n/**\n * Creates a new PathFollower Game Object and adds it to the Scene.\n *\n * Note: This method will only be available if the PathFollower Game Object has been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectFactory#follower\n * @since 3.0.0\n *\n * @param {Phaser.Curves.Path} path - The Path this PathFollower is connected to.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n *\n * @return {Phaser.GameObjects.PathFollower} The Game Object that was created.\n */\nGameObjectFactory.register('follower', function (path, x, y, key, frame)\n{\n    var sprite = new PathFollower(this.scene, path, x, y, key, frame);\n\n    this.displayList.add(sprite);\n    this.updateList.add(sprite);\n\n    return sprite;\n});\n\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\nvar RenderTexture = require('./RenderTexture');\r\n\r\n/**\r\n * Creates a new Render Texture Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.\r\n * \r\n * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and\r\n * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic\r\n * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#renderTexture\r\n * @since 3.2.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {number} [width=32] - The width of the Render Texture.\r\n * @param {number} [height=32] - The height of the Render Texture.\r\n * @property {string} [key] - The texture key to make the RenderTexture from.\r\n * @property {string} [frame] - the frame to make the RenderTexture from.\r\n * \r\n * @return {Phaser.GameObjects.RenderTexture} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('renderTexture', function (x, y, width, height, key, frame)\r\n{\r\n    return this.displayList.add(new RenderTexture(this.scene, x, y, width, height, key, frame));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rope = require('./Rope');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Rope Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Rope Game Object and WebGL support have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#rope\r\n * @webglOnly\r\n * @since 3.23.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * @param {Phaser.Types.Math.Vector2Like[]} [points] - An array containing the vertices data for this Rope. If none is provided a simple quad is created. See `setPoints` to set this post-creation.\r\n * @param {boolean} [horizontal=true] - Should the vertices of this Rope be aligned horizontally (`true`), or vertically (`false`)?\r\n * @param {number[]} [colors] - An optional array containing the color data for this Rope. You should provide one color value per pair of vertices.\r\n * @param {number[]} [alphas] - An optional array containing the alpha data for this Rope. You should provide one alpha value per pair of vertices.\r\n *\r\n * @return {Phaser.GameObjects.Rope} The Game Object that was created.\r\n */\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    GameObjectFactory.register('rope', function (x, y, texture, frame, points, horizontal, colors, alphas)\r\n    {\r\n        return this.displayList.add(new Rope(this.scene, x, y, texture, frame, points, horizontal, colors, alphas));\r\n    });\r\n}\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\nvar Sprite = require('./Sprite');\r\n\r\n/**\r\n * Creates a new Sprite Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Sprite Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#sprite\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n *\r\n * @return {Phaser.GameObjects.Sprite} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('sprite', function (x, y, key, frame)\r\n{\r\n    var sprite = new Sprite(this.scene, x, y, key, frame);\r\n\r\n    this.displayList.add(sprite);\r\n\r\n    return sprite;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BitmapText = require('./BitmapText');\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Bitmap Text Game Object and adds it to the Scene.\r\n * \r\n * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\r\n * \r\n * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\r\n * match the font structure.\r\n * \r\n * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\r\n * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\r\n * processing the font texture in an image editor, applying fills and any other effects required.\r\n *\r\n * To create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\r\n *\r\n * To create a BitmapText data files you need a 3rd party app such as:\r\n *\r\n * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/\r\n * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner\r\n * Littera (Web-based, free): http://kvazars.com/littera/\r\n *\r\n * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\r\n * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson\r\n *\r\n * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#bitmapText\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x position of the Game Object.\r\n * @param {number} y - The y position of the Game Object.\r\n * @param {string} font - The key of the font to use from the BitmapFont cache.\r\n * @param {(string|string[])} [text] - The string, or array of strings, to be set as the content of this Bitmap Text.\r\n * @param {number} [size] - The font size to set.\r\n * @param {number} [align=0] - The alignment of the text in a multi-line BitmapText object.\r\n *\r\n * @return {Phaser.GameObjects.BitmapText} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('bitmapText', function (x, y, font, text, size, align)\r\n{\r\n    return this.displayList.add(new BitmapText(this.scene, x, y, font, text, size, align));\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Text = require('./Text');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Text Game Object and adds it to the Scene.\r\n *\r\n * A Text Game Object.\r\n *\r\n * Text objects work by creating their own internal hidden Canvas and then renders text to it using\r\n * the standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered\r\n * to your game during the render pass.\r\n *\r\n * Because it uses the Canvas API you can take advantage of all the features this offers, such as\r\n * applying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts\r\n * loaded externally, such as Google or TypeKit Web fonts.\r\n *\r\n * You can only display fonts that are currently loaded and available to the browser: therefore fonts must\r\n * be pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,\r\n * or have the fonts ready available in the CSS on the page in which your Phaser game resides.\r\n *\r\n * See {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts\r\n * across mobile browsers.\r\n *\r\n * A note on performance: Every time the contents of a Text object changes, i.e. changing the text being\r\n * displayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the\r\n * new texture to the GPU. This can be an expensive operation if used often, or with large quantities of\r\n * Text objects in your game. If you run into performance issues you would be better off using Bitmap Text\r\n * instead, as it benefits from batching and avoids expensive Canvas API calls.\r\n *\r\n * Note: This method will only be available if the Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#text\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|string[])} text - The text this Text object will display.\r\n * @param {Phaser.Types.GameObjects.Text.TextStyle} [style] - The Text style configuration object.\r\n *\r\n * @return {Phaser.GameObjects.Text} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('text', function (x, y, text, style)\r\n{\r\n    return this.displayList.add(new Text(this.scene, x, y, text, style));\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar TileSprite = require('./TileSprite');\nvar GameObjectFactory = require('../GameObjectFactory');\n\n/**\n * Creates a new TileSprite Game Object and adds it to the Scene.\n *\n * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectFactory#tileSprite\n * @since 3.0.0\n *\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {number} width - The width of the Game Object. If zero it will use the size of the texture frame.\n * @param {number} height - The height of the Game Object. If zero it will use the size of the texture frame.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n *\n * @return {Phaser.GameObjects.TileSprite} The Game Object that was created.\n */\nGameObjectFactory.register('tileSprite', function (x, y, width, height, key, frame)\n{\n    return this.displayList.add(new TileSprite(this.scene, x, y, width, height, key, frame));\n});\n\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Zone = require('./Zone');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Zone Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Zone Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#zone\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {number} width - The width of the Game Object.\r\n * @param {number} height - The height of the Game Object.\r\n * \r\n * @return {Phaser.GameObjects.Zone} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('zone', function (x, y, width, height)\r\n{\r\n    return this.displayList.add(new Zone(this.scene, x, y, width, height));\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//  \r\n//  There are several properties available to use:\r\n//  \r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Video = require('./Video');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Video Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Video Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#video\r\n * @since 3.20.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} [key] - Optional key of the Video this Game Object will play, as stored in the Video Cache.\r\n *\r\n * @return {Phaser.GameObjects.Video} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('video', function (x, y, key)\r\n{\r\n    return this.displayList.add(new Video(this.scene, x, y, key));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Arc = require('./Arc');\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Arc Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Arc Game Object has been built into Phaser.\r\n * \r\n * The Arc Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * When it renders it displays an arc shape. You can control the start and end angles of the arc,\r\n * as well as if the angles are winding clockwise or anti-clockwise. With the default settings\r\n * it renders as a complete circle. By changing the angles you can create other arc shapes,\r\n * such as half-circles.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#arc\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [radius=128] - The radius of the arc.\r\n * @param {number} [startAngle=0] - The start angle of the arc, in degrees.\r\n * @param {number} [endAngle=360] - The end angle of the arc, in degrees.\r\n * @param {boolean} [anticlockwise=false] - The winding order of the start and end angles.\r\n * @param {number} [fillColor] - The color the arc will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the arc will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Arc} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('arc', function (x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Arc(this.scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha));\r\n});\r\n\r\n/**\r\n * Creates a new Circle Shape Game Object and adds it to the Scene.\r\n * \r\n * A Circle is an Arc with no defined start and end angle, making it render as a complete circle.\r\n *\r\n * Note: This method will only be available if the Arc Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#circle\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [radius=128] - The radius of the circle.\r\n * @param {number} [fillColor] - The color the circle will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the circle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Arc} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('circle', function (x, y, radius, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Arc(this.scene, x, y, radius, 0, 360, false, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar Curve = require('./Curve');\r\n\r\n/**\r\n * Creates a new Curve Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Curve Game Object has been built into Phaser.\r\n * \r\n * The Curve Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * To render a Curve Shape you must first create a `Phaser.Curves.Curve` object, then pass it to\r\n * the Curve Shape in the constructor.\r\n * \r\n * The Curve shape also has a `smoothness` property and corresponding `setSmoothness` method.\r\n * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations\r\n * that take place during construction. Increase and decrease the default value for smoother, or more\r\n * jagged, shapes.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#curve\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {Phaser.Curves.Curve} [curve] - The Curve object to use to create the Shape.\r\n * @param {number} [fillColor] - The color the curve will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the curve will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Curve} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('curve', function (x, y, curve, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Curve(this.scene, x, y, curve, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Ellipse = require('./Ellipse');\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Ellipse Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Ellipse Game Object has been built into Phaser.\r\n * \r\n * The Ellipse Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * When it renders it displays an ellipse shape. You can control the width and height of the ellipse.\r\n * If the width and height match it will render as a circle. If the width is less than the height,\r\n * it will look more like an egg shape.\r\n * \r\n * The Ellipse shape also has a `smoothness` property and corresponding `setSmoothness` method.\r\n * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations\r\n * that take place during construction. Increase and decrease the default value for smoother, or more\r\n * jagged, shapes.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#ellipse\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the ellipse. An ellipse with equal width and height renders as a circle.\r\n * @param {number} [height=128] - The height of the ellipse. An ellipse with equal width and height renders as a circle.\r\n * @param {number} [fillColor] - The color the ellipse will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the ellipse will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Ellipse} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('ellipse', function (x, y, width, height, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Ellipse(this.scene, x, y, width, height, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar Grid = require('./Grid');\r\n\r\n/**\r\n * Creates a new Grid Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Grid Game Object has been built into Phaser.\r\n * \r\n * The Grid Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports only fill colors and cannot be stroked.\r\n * \r\n * A Grid Shape allows you to display a grid in your game, where you can control the size of the\r\n * grid as well as the width and height of the grid cells. You can set a fill color for each grid\r\n * cell as well as an alternate fill color. When the alternate fill color is set then the grid\r\n * cells will alternate the fill colors as they render, creating a chess-board effect. You can\r\n * also optionally have an outline fill color. If set, this draws lines between the grid cells\r\n * in the given color. If you specify an outline color with an alpha of zero, then it will draw\r\n * the cells spaced out, but without the lines between them.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#grid\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the grid.\r\n * @param {number} [height=128] - The height of the grid.\r\n * @param {number} [cellWidth=32] - The width of one cell in the grid.\r\n * @param {number} [cellHeight=32] - The height of one cell in the grid.\r\n * @param {number} [fillColor] - The color the grid cells will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n * @param {number} [outlineFillColor] - The color of the lines between the grid cells.\r\n * @param {number} [outlineFillAlpha] - The alpha of the lines between the grid cells.\r\n *\r\n * @return {Phaser.GameObjects.Grid} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('grid', function (x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha)\r\n{\r\n    return this.displayList.add(new Grid(this.scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar IsoBox = require('./IsoBox');\r\n\r\n/**\r\n * Creates a new IsoBox Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the IsoBox Game Object has been built into Phaser.\r\n * \r\n * The IsoBox Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports only fill colors and cannot be stroked.\r\n * \r\n * An IsoBox is an 'isometric' rectangle. Each face of it has a different fill color. You can set\r\n * the color of the top, left and right faces of the rectangle respectively. You can also choose\r\n * which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.\r\n * \r\n * You cannot view an IsoBox from under-neath, however you can change the 'angle' by setting\r\n * the `projection` property.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#isobox\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [size=48] - The width of the iso box in pixels. The left and right faces will be exactly half this value.\r\n * @param {number} [height=32] - The height of the iso box. The left and right faces will be this tall. The overall height of the isobox will be this value plus half the `size` value.\r\n * @param {number} [fillTop=0xeeeeee] - The fill color of the top face of the iso box.\r\n * @param {number} [fillLeft=0x999999] - The fill color of the left face of the iso box.\r\n * @param {number} [fillRight=0xcccccc] - The fill color of the right face of the iso box.\r\n *\r\n * @return {Phaser.GameObjects.IsoBox} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('isobox', function (x, y, size, height, fillTop, fillLeft, fillRight)\r\n{\r\n    return this.displayList.add(new IsoBox(this.scene, x, y, size, height, fillTop, fillLeft, fillRight));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar IsoTriangle = require('./IsoTriangle');\r\n\r\n/**\r\n * Creates a new IsoTriangle Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the IsoTriangle Game Object has been built into Phaser.\r\n * \r\n * The IsoTriangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports only fill colors and cannot be stroked.\r\n * \r\n * An IsoTriangle is an 'isometric' triangle. Think of it like a pyramid. Each face has a different\r\n * fill color. You can set the color of the top, left and right faces of the triangle respectively\r\n * You can also choose which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.\r\n * \r\n * You cannot view an IsoTriangle from under-neath, however you can change the 'angle' by setting\r\n * the `projection` property. The `reversed` property controls if the IsoTriangle is rendered upside\r\n * down or not.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#isotriangle\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [size=48] - The width of the iso triangle in pixels. The left and right faces will be exactly half this value.\r\n * @param {number} [height=32] - The height of the iso triangle. The left and right faces will be this tall. The overall height of the iso triangle will be this value plus half the `size` value.\r\n * @param {boolean} [reversed=false] - Is the iso triangle upside down?\r\n * @param {number} [fillTop=0xeeeeee] - The fill color of the top face of the iso triangle.\r\n * @param {number} [fillLeft=0x999999] - The fill color of the left face of the iso triangle.\r\n * @param {number} [fillRight=0xcccccc] - The fill color of the right face of the iso triangle.\r\n *\r\n * @return {Phaser.GameObjects.IsoTriangle} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('isotriangle', function (x, y, size, height, reversed, fillTop, fillLeft, fillRight)\r\n{\r\n    return this.displayList.add(new IsoTriangle(this.scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar Line = require('./Line');\r\n\r\n/**\r\n * Creates a new Line Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Line Game Object has been built into Phaser.\r\n * \r\n * The Line Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports only stroke colors and cannot be filled.\r\n * \r\n * A Line Shape allows you to draw a line between two points in your game. You can control the\r\n * stroke color and thickness of the line. In WebGL only you can also specify a different\r\n * thickness for the start and end of the line, allowing you to render lines that taper-off.\r\n * \r\n * If you need to draw multiple lines in a sequence you may wish to use the Polygon Shape instead.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#line\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [x1=0] - The horizontal position of the start of the line.\r\n * @param {number} [y1=0] - The vertical position of the start of the line.\r\n * @param {number} [x2=128] - The horizontal position of the end of the line.\r\n * @param {number} [y2=0] - The vertical position of the end of the line.\r\n * @param {number} [strokeColor] - The color the line will be drawn in, i.e. 0xff0000 for red.\r\n * @param {number} [strokeAlpha] - The alpha the line will be drawn in. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Line} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('line', function (x, y, x1, y1, x2, y2, strokeColor, strokeAlpha)\r\n{\r\n    return this.displayList.add(new Line(this.scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar Polygon = require('./Polygon');\r\n\r\n/**\r\n * Creates a new Polygon Shape Game Object and adds it to the Scene.\r\n * \r\n * Note: This method will only be available if the Polygon Game Object has been built into Phaser.\r\n * \r\n * The Polygon Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * The Polygon Shape is created by providing a list of points, which are then used to create an\r\n * internal Polygon geometry object. The points can be set from a variety of formats:\r\n *\r\n * - An array of Point or Vector2 objects: `[new Phaser.Math.Vector2(x1, y1), ...]`\r\n * - An array of objects with public x/y properties: `[obj1, obj2, ...]`\r\n * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\r\n * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`\r\n * \r\n * By default the `x` and `y` coordinates of this Shape refer to the center of it. However, depending\r\n * on the coordinates of the points provided, the final shape may be rendered offset from its origin.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#polygon\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {any} [points] - The points that make up the polygon.\r\n * @param {number} [fillColor] - The color the polygon will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the polygon will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Polygon} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('polygon', function (x, y, points, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Polygon(this.scene, x, y, points, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar Rectangle = require('./Rectangle');\r\n\r\n/**\r\n * Creates a new Rectangle Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Rectangle Game Object has been built into Phaser.\r\n * \r\n * The Rectangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * You can change the size of the rectangle by changing the `width` and `height` properties.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#rectangle\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the rectangle.\r\n * @param {number} [height=128] - The height of the rectangle.\r\n * @param {number} [fillColor] - The color the rectangle will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the rectangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Rectangle} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('rectangle', function (x, y, width, height, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Rectangle(this.scene, x, y, width, height, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Star = require('./Star');\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Star Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Star Game Object has been built into Phaser.\r\n * \r\n * The Star Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * As the name implies, the Star shape will display a star in your game. You can control several\r\n * aspects of it including the number of points that constitute the star. The default is 5. If\r\n * you change it to 4 it will render as a diamond. If you increase them, you'll get a more spiky\r\n * star shape.\r\n * \r\n * You can also control the inner and outer radius, which is how 'long' each point of the star is.\r\n * Modify these values to create more interesting shapes.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#star\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [points=5] - The number of points on the star.\r\n * @param {number} [innerRadius=32] - The inner radius of the star.\r\n * @param {number} [outerRadius=64] - The outer radius of the star.\r\n * @param {number} [fillColor] - The color the star will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the star will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Star} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('star', function (x, y, points, innerRadius, outerRadius, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Star(this.scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar Triangle = require('./Triangle');\r\n\r\n/**\r\n * Creates a new Triangle Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Triangle Game Object has been built into Phaser.\r\n * \r\n * The Triangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * The Triangle consists of 3 lines, joining up to form a triangular shape. You can control the\r\n * position of each point of these lines. The triangle is always closed and cannot have an open\r\n * face. If you require that, consider using a Polygon instead.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#triangle\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [x1=0] - The horizontal position of the first point in the triangle.\r\n * @param {number} [y1=128] - The vertical position of the first point in the triangle.\r\n * @param {number} [x2=64] - The horizontal position of the second point in the triangle.\r\n * @param {number} [y2=0] - The vertical position of the second point in the triangle.\r\n * @param {number} [x3=128] - The horizontal position of the third point in the triangle.\r\n * @param {number} [y3=128] - The vertical position of the third point in the triangle.\r\n * @param {number} [fillColor] - The color the triangle will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the triangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Triangle} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('triangle', function (x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Triangle(this.scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Blitter = require('./Blitter');\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\n\r\n/**\r\n * Creates a new Blitter Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Blitter Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#blitter\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Blitter} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('blitter', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var key = GetAdvancedValue(config, 'key', null);\r\n    var frame = GetAdvancedValue(config, 'frame', null);\r\n\r\n    var blitter = new Blitter(this.scene, 0, 0, key, frame);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, blitter, config);\r\n\r\n    return blitter;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar Container = require('./Container');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\n\r\n/**\r\n * Creates a new Container Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Container Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#container\r\n * @since 3.4.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Container} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('container', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var x = GetAdvancedValue(config, 'x', 0);\r\n    var y = GetAdvancedValue(config, 'y', 0);\r\n    var children = GetAdvancedValue(config, 'children', null);\r\n\r\n    var container = new Container(this.scene, x, y, children);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, container, config);\r\n\r\n    return container;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BitmapText = require('./DynamicBitmapText');\r\nvar BuildGameObject = require('../../BuildGameObject');\r\nvar GameObjectCreator = require('../../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../../utils/object/GetAdvancedValue');\r\n\r\n/**\r\n * Creates a new Dynamic Bitmap Text Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#dynamicBitmapText\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.BitmapText.BitmapTextConfig} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.DynamicBitmapText} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('dynamicBitmapText', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var font = GetAdvancedValue(config, 'font', '');\r\n    var text = GetAdvancedValue(config, 'text', '');\r\n    var size = GetAdvancedValue(config, 'size', false);\r\n\r\n    var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, bitmapText, config);\r\n\r\n    return bitmapText;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar Graphics = require('./Graphics');\r\n\r\n/**\r\n * Creates a new Graphics Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Graphics Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#graphics\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Graphics} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('graphics', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    var graphics = new Graphics(this.scene, config);\r\n\r\n    if (config.add)\r\n    {\r\n        this.scene.sys.displayList.add(graphics);\r\n    }\r\n    \r\n    return graphics;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar Group = require('./Group');\r\n\r\n/**\r\n * Creates a new Group Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Group Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#group\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} config - The configuration object this Game Object will use to create itself.\r\n *\r\n * @return {Phaser.GameObjects.Group} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('group', function (config)\r\n{\r\n    return new Group(this.scene, null, config);\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar Image = require('./Image');\r\n\r\n/**\r\n * Creates a new Image Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Image Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#image\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Image} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('image', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var key = GetAdvancedValue(config, 'key', null);\r\n    var frame = GetAdvancedValue(config, 'frame', null);\r\n\r\n    var image = new Image(this.scene, 0, 0, key, frame);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, image, config);\r\n\r\n    return image;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar Layer = require('./Layer');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\n\r\n/**\r\n * Creates a new Layer Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Layer Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#layer\r\n * @since 3.50.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Layer} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('layer', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var children = GetAdvancedValue(config, 'children', null);\r\n\r\n    var layer = new Layer(this.scene, children);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, layer, config);\r\n\r\n    return layer;\r\n});\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar GameObjectCreator = require('../GameObjectCreator');\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\nvar GetFastValue = require('../../utils/object/GetFastValue');\nvar ParticleEmitterManager = require('./ParticleEmitterManager');\n\n/**\n * Creates a new Particle Emitter Manager Game Object and returns it.\n *\n * Note: This method will only be available if the Particles Game Object has been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectCreator#particles\n * @since 3.0.0\n *\n * @param {object} config - The configuration object this Game Object will use to create itself.\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\n *\n * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} The Game Object that was created.\n */\nGameObjectCreator.register('particles', function (config, addToScene)\n{\n    if (config === undefined) { config = {}; }\n\n    var key = GetAdvancedValue(config, 'key', null);\n    var frame = GetAdvancedValue(config, 'frame', null);\n    var emitters = GetFastValue(config, 'emitters', null);\n\n    //  frame is optional and can contain the emitters array or object if skipped\n    var manager = new ParticleEmitterManager(this.scene, key, frame, emitters);\n\n    if (addToScene !== undefined)\n    {\n        config.add = addToScene;\n    }\n\n    var add = GetFastValue(config, 'add', false);\n\n    if (add)\n    {\n        this.displayList.add(manager);\n    }\n    else\n    {\n        this.updateList.add(manager);\n    }\n\n    return manager;\n});\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar RenderTexture = require('./RenderTexture');\r\n\r\n/**\r\n * Creates a new Render Texture Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#renderTexture\r\n * @since 3.2.0\r\n *\r\n * @param {Phaser.Types.GameObjects.RenderTexture.RenderTextureConfig} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.RenderTexture} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('renderTexture', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var x = GetAdvancedValue(config, 'x', 0);\r\n    var y = GetAdvancedValue(config, 'y', 0);\r\n    var width = GetAdvancedValue(config, 'width', 32);\r\n    var height = GetAdvancedValue(config, 'height', 32);\r\n    var key = GetAdvancedValue(config, 'key', undefined);\r\n    var frame = GetAdvancedValue(config, 'frame', undefined);\r\n\r\n    var renderTexture = new RenderTexture(this.scene, x, y, width, height, key, frame);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, renderTexture, config);\r\n\r\n    return renderTexture;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar Rope = require('./Rope');\r\n\r\n/**\r\n * Creates a new Rope Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Rope Game Object and WebGL support have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#rope\r\n * @since 3.23.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Rope} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('rope', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var key = GetAdvancedValue(config, 'key', null);\r\n    var frame = GetAdvancedValue(config, 'frame', null);\r\n    var horizontal = GetAdvancedValue(config, 'horizontal', true);\r\n    var points = GetValue(config, 'points', undefined);\r\n    var colors = GetValue(config, 'colors', undefined);\r\n    var alphas = GetValue(config, 'alphas', undefined);\r\n\r\n    var rope = new Rope(this.scene, 0, 0, key, frame, points, horizontal, colors, alphas);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, rope, config);\r\n\r\n    if (!config.add)\r\n    {\r\n        this.updateList.add(rope);\r\n    }\r\n\r\n    return rope;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar BuildGameObjectAnimation = require('../BuildGameObjectAnimation');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar Sprite = require('./Sprite');\r\n\r\n/**\r\n * Creates a new Sprite Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Sprite Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#sprite\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Sprite} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('sprite', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var key = GetAdvancedValue(config, 'key', null);\r\n    var frame = GetAdvancedValue(config, 'frame', null);\r\n\r\n    var sprite = new Sprite(this.scene, 0, 0, key, frame);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, sprite, config);\r\n\r\n    //  Sprite specific config options:\r\n\r\n    BuildGameObjectAnimation(sprite, config);\r\n\r\n    return sprite;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BitmapText = require('./BitmapText');\r\nvar BuildGameObject = require('../../BuildGameObject');\r\nvar GameObjectCreator = require('../../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../../utils/object/GetAdvancedValue');\r\nvar GetValue = require('../../../utils/object/GetValue');\r\n\r\n/**\r\n * Creates a new Bitmap Text Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#bitmapText\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.BitmapText.BitmapTextConfig} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n * \r\n * @return {Phaser.GameObjects.BitmapText} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('bitmapText', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var font = GetValue(config, 'font', '');\r\n    var text = GetAdvancedValue(config, 'text', '');\r\n    var size = GetAdvancedValue(config, 'size', false);\r\n    var align = GetValue(config, 'align', 0);\r\n\r\n    var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size, align);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, bitmapText, config);\r\n\r\n    return bitmapText;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar Text = require('./Text');\r\n\r\n/**\r\n * Creates a new Text Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#text\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Text.TextConfig} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Text} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('text', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    // style Object = {\r\n    //     font: [ 'font', '16px Courier' ],\r\n    //     backgroundColor: [ 'backgroundColor', null ],\r\n    //     fill: [ 'fill', '#fff' ],\r\n    //     stroke: [ 'stroke', '#fff' ],\r\n    //     strokeThickness: [ 'strokeThickness', 0 ],\r\n    //     shadowOffsetX: [ 'shadow.offsetX', 0 ],\r\n    //     shadowOffsetY: [ 'shadow.offsetY', 0 ],\r\n    //     shadowColor: [ 'shadow.color', '#000' ],\r\n    //     shadowBlur: [ 'shadow.blur', 0 ],\r\n    //     shadowStroke: [ 'shadow.stroke', false ],\r\n    //     shadowFill: [ 'shadow.fill', false ],\r\n    //     align: [ 'align', 'left' ],\r\n    //     maxLines: [ 'maxLines', 0 ],\r\n    //     fixedWidth: [ 'fixedWidth', false ],\r\n    //     fixedHeight: [ 'fixedHeight', false ],\r\n    //     rtl: [ 'rtl', false ]\r\n    // }\r\n\r\n    var content = GetAdvancedValue(config, 'text', '');\r\n    var style = GetAdvancedValue(config, 'style', null);\r\n\r\n    //  Padding\r\n    //      { padding: 2 }\r\n    //      { padding: { x: , y: }}\r\n    //      { padding: { left: , top: }}\r\n    //      { padding: { left: , right: , top: , bottom: }}\r\n\r\n    var padding = GetAdvancedValue(config, 'padding', null);\r\n\r\n    if (padding !== null)\r\n    {\r\n        style.padding = padding;\r\n    }\r\n\r\n    var text = new Text(this.scene, 0, 0, content, style);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, text, config);\r\n\r\n    //  Text specific config options:\r\n\r\n    text.autoRound = GetAdvancedValue(config, 'autoRound', true);\r\n    text.resolution = GetAdvancedValue(config, 'resolution', 1);\r\n\r\n    return text;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar TileSprite = require('./TileSprite');\r\n\r\n/**\r\n * Creates a new TileSprite Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#tileSprite\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.TileSprite.TileSpriteConfig} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.TileSprite} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('tileSprite', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var x = GetAdvancedValue(config, 'x', 0);\r\n    var y = GetAdvancedValue(config, 'y', 0);\r\n    var width = GetAdvancedValue(config, 'width', 512);\r\n    var height = GetAdvancedValue(config, 'height', 512);\r\n    var key = GetAdvancedValue(config, 'key', '');\r\n    var frame = GetAdvancedValue(config, 'frame', '');\r\n\r\n    var tile = new TileSprite(this.scene, x, y, width, height, key, frame);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, tile, config);\r\n\r\n    return tile;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar Zone = require('./Zone');\r\n\r\n/**\r\n * Creates a new Zone Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Zone Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#zone\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n *\r\n * @return {Phaser.GameObjects.Zone} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('zone', function (config)\r\n{\r\n    var x = GetAdvancedValue(config, 'x', 0);\r\n    var y = GetAdvancedValue(config, 'y', 0);\r\n    var width = GetAdvancedValue(config, 'width', 1);\r\n    var height = GetAdvancedValue(config, 'height', width);\r\n\r\n    return new Zone(this.scene, x, y, width, height);\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar Video = require('./Video');\r\n\r\n/**\r\n * Creates a new Video Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Video Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#video\r\n * @since 3.20.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Video} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('video', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var key = GetAdvancedValue(config, 'key', null);\r\n\r\n    var video = new Video(this.scene, 0, 0, key);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, video, config);\r\n\r\n    if (!config.add)\r\n    {\r\n        this.updateList.add(video);\r\n    }\r\n\r\n    return video;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./ShaderWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./ShaderCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Shader#renderWebGL\r\n * @since 3.17.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Shader} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ShaderWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (!src.shader)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.pipelines.clear();\r\n\r\n    if (src.renderToTexture)\r\n    {\r\n        src.load();\r\n        src.flush();\r\n    }\r\n    else\r\n    {\r\n        var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n        //  Renderer size changed?\r\n        if (renderer.width !== src._rendererWidth || renderer.height !== src._rendererHeight)\r\n        {\r\n            src.projOrtho(0, renderer.width, renderer.height, 0);\r\n        }\r\n\r\n        src.load(calcMatrix.matrix);\r\n        src.flush();\r\n    }\r\n\r\n    renderer.pipelines.rebind();\r\n};\r\n\r\nmodule.exports = ShaderWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * This is a stub function for Shader.Render. There is no Canvas renderer for Shader objects.\r\n *\r\n * @method Phaser.GameObjects.Shader#renderCanvas\r\n * @since 3.17.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Shader} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */\r\nvar ShaderCanvasRenderer = function ()\r\n{\r\n};\r\n\r\nmodule.exports = ShaderCanvasRenderer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar renderWebGL = require('../../utils/NOOP');\nvar renderCanvas = require('../../utils/NOOP');\n\nif (typeof WEBGL_RENDERER)\n{\n    renderWebGL = require('./MeshWebGLRenderer');\n}\n\nif (typeof CANVAS_RENDERER)\n{\n    renderCanvas = require('./MeshCanvasRenderer');\n}\n\nmodule.exports = {\n\n    renderWebGL: renderWebGL,\n    renderCanvas: renderCanvas\n\n};\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Mesh#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Mesh} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar MeshWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var faces = src.faces;\r\n    var totalFaces = faces.length;\r\n\r\n    if (totalFaces === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    var textureUnit = pipeline.setGameObject(src);\r\n\r\n    var F32 = pipeline.vertexViewF32;\r\n    var U32 = pipeline.vertexViewU32;\r\n\r\n    var vertexOffset = (pipeline.vertexCount * pipeline.currentShader.vertexComponentCount) - 1;\r\n\r\n    var tintEffect = src.tintFill;\r\n\r\n    var debugFaces = [];\r\n    var debugCallback = src.debugCallback;\r\n\r\n    var a = calcMatrix.a;\r\n    var b = calcMatrix.b;\r\n    var c = calcMatrix.c;\r\n    var d = calcMatrix.d;\r\n    var e = calcMatrix.e;\r\n    var f = calcMatrix.f;\r\n\r\n    var z = src.viewPosition.z;\r\n\r\n    var hideCCW = src.hideCCW;\r\n    var roundPixels = camera.roundPixels;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    var totalFacesRendered = 0;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    for (var i = 0; i < totalFaces; i++)\r\n    {\r\n        var face = faces[i];\r\n\r\n        //  If face has alpha <= 0, or hideCCW + clockwise, or isn't in camera view, then don't draw it\r\n        if (!face.isInView(camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (pipeline.shouldFlush(3))\r\n        {\r\n            pipeline.flush();\r\n\r\n            vertexOffset = 0;\r\n        }\r\n\r\n        vertexOffset = face.load(F32, U32, vertexOffset, textureUnit, tintEffect);\r\n\r\n        totalFacesRendered++;\r\n        pipeline.vertexCount += 3;\r\n\r\n        if (debugCallback)\r\n        {\r\n            debugFaces.push(face);\r\n        }\r\n    }\r\n\r\n    src.totalFrame += totalFacesRendered;\r\n\r\n    if (debugCallback)\r\n    {\r\n        debugCallback.call(src, src, debugFaces);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = MeshWebGLRenderer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * This is a stub function for Mesh.Render. There is no Canvas renderer for Mesh objects.\n *\n * @method Phaser.GameObjects.Mesh#renderCanvas\n * @since 3.0.0\n * @private\n *\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\n * @param {Phaser.GameObjects.Mesh} src - The Game Object being rendered in this call.\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\n */\nvar MeshCanvasRenderer = function ()\n{\n};\n\nmodule.exports = MeshCanvasRenderer;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./PointLightWebGLRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.PointLight#renderWebGL\r\n * @since 3.50.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.PointLight} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar PointLightWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    var width = src.width;\r\n    var height = src.height;\r\n\r\n    var x = -src._radius;\r\n    var y = -src._radius;\r\n\r\n    var xw = x + width;\r\n    var yh = y + height;\r\n\r\n    var lightX = calcMatrix.getX(0, 0);\r\n    var lightY = calcMatrix.getY(0, 0);\r\n\r\n    var tx0 = calcMatrix.getX(x, y);\r\n    var ty0 = calcMatrix.getY(x, y);\r\n\r\n    var tx1 = calcMatrix.getX(x, yh);\r\n    var ty1 = calcMatrix.getY(x, yh);\r\n\r\n    var tx2 = calcMatrix.getX(xw, yh);\r\n    var ty2 = calcMatrix.getY(xw, yh);\r\n\r\n    var tx3 = calcMatrix.getX(xw, y);\r\n    var ty3 = calcMatrix.getY(xw, y);\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    pipeline.batchPointLight(src, camera, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, lightX, lightY);\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = PointLightWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Shader = require('./Shader');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Shader Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Shader Game Object and WebGL support have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#shader\r\n * @webglOnly\r\n * @since 3.17.0\r\n *\r\n * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the Game Object.\r\n * @param {number} [height=128] - The height of the Game Object.\r\n * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n * @param {object} [textureData] - Optional additional texture data.\r\n *\r\n * @return {Phaser.GameObjects.Shader} The Game Object that was created.\r\n */\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    GameObjectFactory.register('shader', function (key, x, y, width, height, textures, textureData)\r\n    {\r\n        return this.displayList.add(new Shader(this.scene, key, x, y, width, height, textures, textureData));\r\n    });\r\n}\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Mesh = require('./Mesh');\nvar GameObjectFactory = require('../GameObjectFactory');\n\n/**\n * Creates a new Mesh Game Object and adds it to the Scene.\n *\n * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectFactory#mesh\n * @webglOnly\n * @since 3.0.0\n *\n * @param {number} [x] - The horizontal position of this Game Object in the world.\n * @param {number} [y] - The vertical position of this Game Object in the world.\n * @param {string|Phaser.Textures.Texture} [texture] - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {string|number} [frame] - An optional frame from the Texture this Game Object is rendering with.\n * @param {number[]} [vertices] - The vertices array. Either `xy` pairs, or `xyz` if the `containsZ` parameter is `true`.\n * @param {number[]} [uvs] - The UVs pairs array.\n * @param {number[]} [indicies] - Optional vertex indicies array. If you don't have one, pass `null` or an empty array.\n * @param {boolean} [containsZ=false] - Does the vertices data include a `z` component?\n * @param {number[]} [normals] - Optional vertex normals array. If you don't have one, pass `null` or an empty array.\n * @param {number|number[]} [colors=0xffffff] - An array of colors, one per vertex, or a single color value applied to all vertices.\n * @param {number|number[]} [alphas=1] - An array of alpha values, one per vertex, or a single alpha value applied to all vertices.\n *\n * @return {Phaser.GameObjects.Mesh} The Game Object that was created.\n */\nif (typeof WEBGL_RENDERER)\n{\n    GameObjectFactory.register('mesh', function (x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas)\n    {\n        return this.displayList.add(new Mesh(this.scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas));\n    });\n}\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\nvar PointLight = require('./PointLight');\r\n\r\n/**\r\n * Creates a new Point Light Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Point Light Game Object has been built into Phaser.\r\n *\r\n * The Point Light Game Object provides a way to add a point light effect into your game,\r\n * without the expensive shader processing requirements of the traditional Light Game Object.\r\n *\r\n * The difference is that the Point Light renders using a custom shader, designed to give the\r\n * impression of a point light source, of variable radius, intensity and color, in your game.\r\n * However, unlike the Light Game Object, it does not impact any other Game Objects, or use their\r\n * normal maps for calcuations. This makes them extremely fast to render compared to Lights\r\n * and perfect for special effects, such as flickering torches or muzzle flashes.\r\n *\r\n * For maximum performance you should batch Point Light Game Objects together. This means\r\n * ensuring they follow each other consecutively on the display list. Ideally, use a Layer\r\n * Game Object and then add just Point Lights to it, so that it can batch together the rendering\r\n * of the lights. You don't _have_ to do this, and if you've only a handful of Point Lights in\r\n * your game then it's perfectly safe to mix them into the dislay list as normal. However, if\r\n * you're using a large number of them, please consider how they are mixed into the display list.\r\n *\r\n * The renderer will automatically cull Point Lights. Those with a radius that does not intersect\r\n * with the Camera will be skipped in the rendering list. This happens automatically and the\r\n * culled state is refreshed every frame, for every camera.\r\n *\r\n * The origin of a Point Light is always 0.5 and it cannot be changed.\r\n *\r\n * Point Lights are a WebGL only feature and do not have a Canvas counterpart.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#pointlight\r\n * @since 3.50.0\r\n *\r\n * @param {number} x - The horizontal position of this Point Light in the world.\r\n * @param {number} y - The vertical position of this Point Light in the world.\r\n * @param {number} [color=0xffffff] - The color of the Point Light, given as a hex value.\r\n * @param {number} [radius=128] - The radius of the Point Light.\r\n * @param {number} [intensity=1] - The intensity, or colr blend, of the Point Light.\r\n * @param {number} [attenuation=0.1] - The attenuation  of the Point Light. This is the reduction of light from the center point.\r\n *\r\n * @return {Phaser.GameObjects.PointLight} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('pointlight', function (x, y, color, radius, intensity, attenuation)\r\n{\r\n    return this.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar Shader = require('./Shader');\r\n\r\n/**\r\n * Creates a new Shader Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Shader Game Object and WebGL support have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#shader\r\n * @since 3.17.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Shader} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('shader', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var key = GetAdvancedValue(config, 'key', null);\r\n    var x = GetAdvancedValue(config, 'x', 0);\r\n    var y = GetAdvancedValue(config, 'y', 0);\r\n    var width = GetAdvancedValue(config, 'width', 128);\r\n    var height = GetAdvancedValue(config, 'height', 128);\r\n\r\n    var shader = new Shader(this.scene, key, x, y, width, height);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, shader, config);\r\n\r\n    return shader;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar BuildGameObject = require('../BuildGameObject');\nvar GameObjectCreator = require('../GameObjectCreator');\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\nvar GetValue = require('../../utils/object/GetValue');\nvar Mesh = require('./Mesh');\n\n/**\n * Creates a new Mesh Game Object and returns it.\n *\n * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectCreator#mesh\n * @since 3.0.0\n *\n * @param {object} config - The configuration object this Game Object will use to create itself.\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\n *\n * @return {Phaser.GameObjects.Mesh} The Game Object that was created.\n */\nGameObjectCreator.register('mesh', function (config, addToScene)\n{\n    if (config === undefined) { config = {}; }\n\n    var key = GetAdvancedValue(config, 'key', null);\n    var frame = GetAdvancedValue(config, 'frame', null);\n    var vertices = GetValue(config, 'vertices', []);\n    var uvs = GetValue(config, 'uvs', []);\n    var indicies = GetValue(config, 'indicies', []);\n    var containsZ = GetValue(config, 'containsZ', false);\n    var normals = GetValue(config, 'normals', []);\n    var colors = GetValue(config, 'colors', 0xffffff);\n    var alphas = GetValue(config, 'alphas', 1);\n\n    var mesh = new Mesh(this.scene, 0, 0, key, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas);\n\n    if (addToScene !== undefined)\n    {\n        config.add = addToScene;\n    }\n\n    BuildGameObject(this.scene, mesh, config);\n\n    return mesh;\n});\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar PointLight = require('./PointLight');\r\n\r\n/**\r\n * Creates a new Point Light Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Point Light Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#pointlight\r\n * @since 3.50.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.PointLight} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('pointlight', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var color = GetAdvancedValue(config, 'color', 0xffffff);\r\n    var radius = GetAdvancedValue(config, 'radius', 128);\r\n    var intensity = GetAdvancedValue(config, 'intensity', 1);\r\n    var attenuation = GetAdvancedValue(config, 'attenuation', 0.1);\r\n\r\n    var layer = new PointLight(this.scene, 0, 0, color, radius, intensity, attenuation);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, layer, config);\r\n\r\n    return layer;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar LightsManager = require('./LightsManager');\r\nvar PluginCache = require('../../plugins/PluginCache');\r\nvar SceneEvents = require('../../scene/events');\r\n\r\n/**\r\n * @classdesc\r\n * A Scene plugin that provides a {@link Phaser.GameObjects.LightsManager} for the Light2D pipeline.\r\n *\r\n * Available from within a Scene via `this.lights`.\r\n *\r\n * Add Lights using the {@link Phaser.GameObjects.LightsManager#addLight} method:\r\n *\r\n * ```javascript\r\n * // Enable the Lights Manager because it is disabled by default\r\n * this.lights.enable();\r\n *\r\n * // Create a Light at [400, 300] with a radius of 200\r\n * this.lights.addLight(400, 300, 200);\r\n * ```\r\n *\r\n * For Game Objects to be affected by the Lights when rendered, you will need to set them to use the `Light2D` pipeline like so:\r\n *\r\n * ```javascript\r\n * sprite.setPipeline('Light2D');\r\n * ```\r\n *\r\n * Note that you cannot use this pipeline on Graphics Game Objects or Shape Game Objects.\r\n *\r\n * @class LightsPlugin\r\n * @extends Phaser.GameObjects.LightsManager\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this Lights Plugin belongs to.\r\n */\r\nvar LightsPlugin = new Class({\r\n\r\n    Extends: LightsManager,\r\n\r\n    initialize:\r\n\r\n    function LightsPlugin (scene)\r\n    {\r\n        /**\r\n         * A reference to the Scene that this Lights Plugin belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.LightsPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene's systems.\r\n         *\r\n         * @name Phaser.GameObjects.LightsPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        if (!scene.sys.settings.isBooted)\r\n        {\r\n            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        }\r\n\r\n        LightsManager.call(this);\r\n    },\r\n\r\n    /**\r\n     * Boot the Lights Plugin.\r\n     *\r\n     * @method Phaser.GameObjects.LightsPlugin#boot\r\n     * @since 3.0.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n        eventEmitter.on(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * Destroy the Lights Plugin.\r\n     *\r\n     * Cleans up all references.\r\n     *\r\n     * @method Phaser.GameObjects.LightsPlugin#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene = undefined;\r\n        this.systems = undefined;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('LightsPlugin', LightsPlugin, 'lights');\r\n\r\nmodule.exports = LightsPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Clamp = require('../../../math/Clamp');\r\nvar Components = require('../../components');\r\nvar GameObject = require('../../GameObject');\r\nvar GetBitmapTextSize = require('../GetBitmapTextSize');\r\nvar ParseFromAtlas = require('../ParseFromAtlas');\r\nvar ParseXMLBitmapFont = require('../ParseXMLBitmapFont');\r\nvar Rectangle = require('../../../geom/rectangle/Rectangle');\r\nvar Render = require('./BitmapTextRender');\r\n\r\n/**\r\n * @classdesc\r\n * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\r\n *\r\n * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\r\n * match the font structure.\r\n *\r\n * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\r\n * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\r\n * processing the font texture in an image editor, applying fills and any other effects required.\r\n *\r\n * To create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\r\n *\r\n * To create a BitmapText data files you need a 3rd party app such as:\r\n *\r\n * BMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}\r\n * Glyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}\r\n * Littera (Web-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}\r\n *\r\n * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\r\n * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}\r\n *\r\n * @class BitmapText\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.\r\n * @param {number} x - The x coordinate of this Game Object in world space.\r\n * @param {number} y - The y coordinate of this Game Object in world space.\r\n * @param {string} font - The key of the font to use from the Bitmap Font cache.\r\n * @param {(string|string[])} [text] - The string, or array of strings, to be set as the content of this Bitmap Text.\r\n * @param {number} [size] - The font size of this Bitmap Text.\r\n * @param {number} [align=0] - The alignment of the text in a multi-line BitmapText object.\r\n */\r\nvar BitmapText = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Texture,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function BitmapText (scene, x, y, font, text, size, align)\r\n    {\r\n        if (text === undefined) { text = ''; }\r\n        if (align === undefined) { align = 0; }\r\n\r\n        GameObject.call(this, scene, 'BitmapText');\r\n\r\n        /**\r\n         * The key of the Bitmap Font used by this Bitmap Text.\r\n         * To change the font after creation please use `setFont`.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#font\r\n         * @type {string}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.font = font;\r\n\r\n        var entry = this.scene.sys.cache.bitmapFont.get(font);\r\n\r\n        if (!entry)\r\n        {\r\n            console.warn('Invalid BitmapText key: ' + font);\r\n        }\r\n\r\n        /**\r\n         * The data of the Bitmap Font used by this Bitmap Text.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#fontData\r\n         * @type {Phaser.Types.GameObjects.BitmapText.BitmapFontData}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.fontData = entry.data;\r\n\r\n        /**\r\n         * The text that this Bitmap Text object displays.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_text\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._text = '';\r\n\r\n        /**\r\n         * The font size of this Bitmap Text.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_fontSize\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._fontSize = size || this.fontData.size;\r\n\r\n        /**\r\n         * Adds / Removes spacing between characters.\r\n         *\r\n         * Can be a negative or positive number.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_letterSpacing\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._letterSpacing = 0;\r\n\r\n        /**\r\n         * Controls the alignment of each line of text in this BitmapText object.\r\n         * Only has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.\r\n         * Has no effect with single-lines of text.\r\n         *\r\n         * See the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.\r\n         *\r\n         * 0 = Left aligned (default)\r\n         * 1 = Middle aligned\r\n         * 2 = Right aligned\r\n         *\r\n         * The alignment position is based on the longest line of text.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_align\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._align = align;\r\n\r\n        /**\r\n         * An object that describes the size of this Bitmap Text.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_bounds\r\n         * @type {Phaser.Types.GameObjects.BitmapText.BitmapTextSize}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._bounds = GetBitmapTextSize();\r\n\r\n        /**\r\n         * An internal dirty flag for bounds calculation.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_dirty\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._dirty = true;\r\n\r\n        /**\r\n         * Internal cache var holding the maxWidth.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_maxWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.21.0\r\n         */\r\n        this._maxWidth = 0;\r\n\r\n        /**\r\n         * The character code used to detect for word wrapping.\r\n         * Defaults to 32 (a space character).\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#wordWrapCharCode\r\n         * @type {number}\r\n         * @since 3.21.0\r\n         */\r\n        this.wordWrapCharCode = 32;\r\n\r\n        /**\r\n         * Internal array holding the character tint color data.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#charColors\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.charColors = [];\r\n\r\n        /**\r\n         * The horizontal offset of the drop shadow.\r\n         *\r\n         * You can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#dropShadowX\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.dropShadowX = 0;\r\n\r\n        /**\r\n         * The vertical offset of the drop shadow.\r\n         *\r\n         * You can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#dropShadowY\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.dropShadowY = 0;\r\n\r\n        /**\r\n         * The color of the drop shadow.\r\n         *\r\n         * You can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#dropShadowColor\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.dropShadowColor = 0x000000;\r\n\r\n        /**\r\n         * The alpha value of the drop shadow.\r\n         *\r\n         * You can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#dropShadowAlpha\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.dropShadowAlpha = 0.5;\r\n\r\n        /**\r\n         * Indicates whether the font texture is from an atlas or not.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#fromAtlas\r\n         * @type {boolean}\r\n         * @since 3.54.0\r\n         * @readonly\r\n         */\r\n        this.fromAtlas = entry.fromAtlas;\r\n\r\n        this.setTexture(entry.texture, entry.frame);\r\n        this.setPosition(x, y);\r\n        this.setOrigin(0, 0);\r\n        this.initPipeline();\r\n\r\n        this.setText(text);\r\n    },\r\n\r\n    /**\r\n     * Set the lines of text in this BitmapText to be left-aligned.\r\n     * This only has any effect if this BitmapText contains more than one line of text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setLeftAlign\r\n     * @since 3.11.0\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setLeftAlign: function ()\r\n    {\r\n        this._align = BitmapText.ALIGN_LEFT;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the lines of text in this BitmapText to be center-aligned.\r\n     * This only has any effect if this BitmapText contains more than one line of text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setCenterAlign\r\n     * @since 3.11.0\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setCenterAlign: function ()\r\n    {\r\n        this._align = BitmapText.ALIGN_CENTER;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the lines of text in this BitmapText to be right-aligned.\r\n     * This only has any effect if this BitmapText contains more than one line of text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setRightAlign\r\n     * @since 3.11.0\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setRightAlign: function ()\r\n    {\r\n        this._align = BitmapText.ALIGN_RIGHT;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the font size of this Bitmap Text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setFontSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} size - The font size to set.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setFontSize: function (size)\r\n    {\r\n        this._fontSize = size;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the letter spacing between each character of this Bitmap Text.\r\n     * Can be a positive value to increase the space, or negative to reduce it.\r\n     * Spacing is applied after the kerning values have been set.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setLetterSpacing\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [spacing=0] - The amount of horizontal space to add between each character.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setLetterSpacing: function (spacing)\r\n    {\r\n        if (spacing === undefined) { spacing = 0; }\r\n\r\n        this._letterSpacing = spacing;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the textual content of this BitmapText.\r\n     *\r\n     * An array of strings will be converted into multi-line text. Use the align methods to change multi-line alignment.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this BitmapText.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setText: function (value)\r\n    {\r\n        if (!value && value !== 0)\r\n        {\r\n            value = '';\r\n        }\r\n\r\n        if (Array.isArray(value))\r\n        {\r\n            value = value.join('\\n');\r\n        }\r\n\r\n        if (value !== this.text)\r\n        {\r\n            this._text = value.toString();\r\n\r\n            this._dirty = true;\r\n\r\n            this.updateDisplayOrigin();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a drop shadow effect on this Bitmap Text.\r\n     *\r\n     * This is a WebGL only feature and only works with Static Bitmap Text, not Dynamic.\r\n     *\r\n     * You can set the vertical and horizontal offset of the shadow, as well as the color and alpha.\r\n     *\r\n     * Once a shadow has been enabled you can modify the `dropShadowX` and `dropShadowY` properties of this\r\n     * Bitmap Text directly to adjust the position of the shadow in real-time.\r\n     *\r\n     * If you wish to clear the shadow, call this method with no parameters specified.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setDropShadow\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal offset of the drop shadow.\r\n     * @param {number} [y=0] - The vertical offset of the drop shadow.\r\n     * @param {number} [color=0x000000] - The color of the drop shadow, given as a hex value, i.e. `0x000000` for black.\r\n     * @param {number} [alpha=0.5] - The alpha of the drop shadow, given as a float between 0 and 1. This is combined with the Bitmap Text alpha as well.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setDropShadow: function (x, y, color, alpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (color === undefined) { color = 0x000000; }\r\n        if (alpha === undefined) { alpha = 0.5; }\r\n\r\n        this.dropShadowX = x;\r\n        this.dropShadowY = y;\r\n        this.dropShadowColor = color;\r\n        this.dropShadowAlpha = alpha;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a tint on a range of characters in this Bitmap Text, starting from the `start` parameter index\r\n     * and running for `length` quantity of characters.\r\n     *\r\n     * The `start` parameter can be negative. In this case, it starts at the end of the text and counts\r\n     * backwards `start` places.\r\n     *\r\n     * You can also pass in -1 as the `length` and it will tint all characters from `start`\r\n     * up until the end of the string.\r\n\r\n     * Remember that spaces and punctuation count as characters.\r\n     *\r\n     * This is a WebGL only feature and only works with Static Bitmap Text, not Dynamic.\r\n     *\r\n     * The tint works by taking the pixel color values from the Bitmap Text texture, and then\r\n     * multiplying it by the color value of the tint. You can provide either one color value,\r\n     * in which case the whole character will be tinted in that color. Or you can provide a color\r\n     * per corner. The colors are blended together across the extent of the character range.\r\n     *\r\n     * To swap this from being an additive tint to a fill based tint, set the `tintFill` parameter to `true`.\r\n     *\r\n     * To modify the tint color once set, call this method again with new color values.\r\n     *\r\n     * Using `setWordTint` can override tints set by this function, and vice versa.\r\n     *\r\n     * To remove a tint call this method with just the `start`, and optionally, the `length` parameters defined.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setCharacterTint\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [start=0] - The starting character to begin the tint at. If negative, it counts back from the end of the text.\r\n     * @param {number} [length=1] - The number of characters to tint. Remember that spaces count as a character too. Pass -1 to tint all characters from `start` onwards.\r\n     * @param {boolean} [tintFill=false] - Use a fill-based tint (true), or an additive tint (false)\r\n     * @param {number} [topLeft=0xffffff] - The tint being applied to the top-left of the character. If not other values are given this value is applied evenly, tinting the whole character.\r\n     * @param {number} [topRight] - The tint being applied to the top-right of the character.\r\n     * @param {number} [bottomLeft] - The tint being applied to the bottom-left of the character.\r\n     * @param {number} [bottomRight] - The tint being applied to the bottom-right of the character.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setCharacterTint: function (start, length, tintFill, topLeft, topRight, bottomLeft, bottomRight)\r\n    {\r\n        if (start === undefined) { start = 0; }\r\n        if (length === undefined) { length = 1; }\r\n        if (tintFill === undefined) { tintFill = false; }\r\n        if (topLeft === undefined) { topLeft = -1; }\r\n\r\n        if (topRight === undefined)\r\n        {\r\n            topRight = topLeft;\r\n            bottomLeft = topLeft;\r\n            bottomRight = topLeft;\r\n        }\r\n\r\n        var len = this.text.length;\r\n\r\n        if (length === -1)\r\n        {\r\n            length = len;\r\n        }\r\n\r\n        if (start < 0)\r\n        {\r\n            start = len + start;\r\n        }\r\n\r\n        start = Clamp(start, 0, len - 1);\r\n\r\n        var end = Clamp(start + length, start, len);\r\n\r\n        var charColors = this.charColors;\r\n\r\n        for (var i = start; i < end; i++)\r\n        {\r\n            var color = charColors[i];\r\n\r\n            if (topLeft === -1)\r\n            {\r\n                charColors[i] = null;\r\n            }\r\n            else\r\n            {\r\n                var tintEffect = (tintFill) ? 1 : 0;\r\n\r\n                if (color)\r\n                {\r\n                    color.tintEffect = tintEffect;\r\n                    color.tintTL = topLeft;\r\n                    color.tintTR = topRight;\r\n                    color.tintBL = bottomLeft;\r\n                    color.tintBR = bottomRight;\r\n                }\r\n                else\r\n                {\r\n                    charColors[i] = {\r\n                        tintEffect: tintEffect,\r\n                        tintTL: topLeft,\r\n                        tintTR: topRight,\r\n                        tintBL: bottomLeft,\r\n                        tintBR: bottomRight\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a tint on a matching word within this Bitmap Text.\r\n     *\r\n     * The `word` parameter can be either a string or a number.\r\n     *\r\n     * If a string, it will run a string comparison against the text contents, and if matching,\r\n     * it will tint the whole word.\r\n     *\r\n     * If a number, if till that word, based on its offset within the text contents.\r\n     *\r\n     * The `count` parameter controls how many words are replaced. Pass in -1 to replace them all.\r\n     *\r\n     * This parameter is ignored if you pass a number as the `word` to be searched for.\r\n     *\r\n     * This is a WebGL only feature and only works with Static Bitmap Text, not Dynamic.\r\n     *\r\n     * The tint works by taking the pixel color values from the Bitmap Text texture, and then\r\n     * multiplying it by the color value of the tint. You can provide either one color value,\r\n     * in which case the whole character will be tinted in that color. Or you can provide a color\r\n     * per corner. The colors are blended together across the extent of the character range.\r\n     *\r\n     * To swap this from being an additive tint to a fill based tint, set the `tintFill` parameter to `true`.\r\n     *\r\n     * To modify the tint color once set, call this method again with new color values.\r\n     *\r\n     * Using `setCharacterTint` can override tints set by this function, and vice versa.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setWordTint\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|number)} word - The word to search for. Either a string, or an index of the word in the words array.\r\n     * @param {number} [count=1] - The number of matching words to tint. Pass -1 to tint all matching words.\r\n     * @param {boolean} [tintFill=false] - Use a fill-based tint (true), or an additive tint (false)\r\n     * @param {number} [topLeft=0xffffff] - The tint being applied to the top-left of the word. If not other values are given this value is applied evenly, tinting the whole word.\r\n     * @param {number} [topRight] - The tint being applied to the top-right of the word.\r\n     * @param {number} [bottomLeft] - The tint being applied to the bottom-left of the word.\r\n     * @param {number} [bottomRight] - The tint being applied to the bottom-right of the word.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setWordTint: function (word, count, tintFill, topLeft, topRight, bottomLeft, bottomRight)\r\n    {\r\n        if (count === undefined) { count = 1; }\r\n\r\n        var bounds = this.getTextBounds();\r\n\r\n        var words = bounds.words;\r\n\r\n        var wordIsNumber = (typeof(word) === 'number');\r\n\r\n        var total = 0;\r\n\r\n        for (var i = 0; i < words.length; i++)\r\n        {\r\n            var lineword = words[i];\r\n\r\n            if ((wordIsNumber && i === word) || (!wordIsNumber && lineword.word === word))\r\n            {\r\n                this.setCharacterTint(lineword.i, lineword.word.length, tintFill, topLeft, topRight, bottomLeft, bottomRight);\r\n\r\n                total++;\r\n\r\n                if (total === count)\r\n                {\r\n                    return this;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the bounds of this Bitmap Text.\r\n     *\r\n     * An object is returned that contains the position, width and height of the Bitmap Text in local and global\r\n     * contexts.\r\n     *\r\n     * Local size is based on just the font size and a [0, 0] position.\r\n     *\r\n     * Global size takes into account the Game Object's scale, world position and display origin.\r\n     *\r\n     * Also in the object is data regarding the length of each line, should this be a multi-line BitmapText.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#getTextBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [round=false] - Whether to round the results up to the nearest integer.\r\n     *\r\n     * @return {Phaser.Types.GameObjects.BitmapText.BitmapTextSize} An object that describes the size of this Bitmap Text.\r\n     */\r\n    getTextBounds: function (round)\r\n    {\r\n        //  local = The BitmapText based on fontSize and 0x0 coords\r\n        //  global = The BitmapText, taking into account scale and world position\r\n        //  lines = The BitmapText line data\r\n\r\n        var bounds = this._bounds;\r\n\r\n        if (this._dirty || round || this.scaleX !== bounds.scaleX || this.scaleY !== bounds.scaleY)\r\n        {\r\n            GetBitmapTextSize(this, round, true, bounds);\r\n\r\n            this._dirty = false;\r\n        }\r\n\r\n        return bounds;\r\n    },\r\n\r\n    /**\r\n     * Gets the character located at the given x/y coordinate within this Bitmap Text.\r\n     *\r\n     * The coordinates you pass in are translated into the local space of the\r\n     * Bitmap Text, however, it is up to you to first translate the input coordinates to world space.\r\n     *\r\n     * If you wish to use this in combination with an input event, be sure\r\n     * to pass in `Pointer.worldX` and `worldY` so they are in world space.\r\n     *\r\n     * In some cases, based on kerning, characters can overlap. When this happens,\r\n     * the first character in the word is returned.\r\n     *\r\n     * Note that this does not work for DynamicBitmapText if you have changed the\r\n     * character positions during render. It will only scan characters in their un-translated state.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#getCharacterAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The x position to check.\r\n     * @param {number} y - The y position to check.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera which is being tested against. If not given will use the Scene default camera.\r\n     *\r\n     * @return {Phaser.Types.GameObjects.BitmapText.BitmapTextCharacter} The character object at the given position, or `null`.\r\n     */\r\n    getCharacterAt: function (x, y, camera)\r\n    {\r\n        var point = this.getLocalPoint(x, y, null, camera);\r\n\r\n        var bounds = this.getTextBounds();\r\n\r\n        var chars = bounds.characters;\r\n\r\n        var tempRect = new Rectangle();\r\n\r\n        for (var i = 0; i < chars.length; i++)\r\n        {\r\n            var char = chars[i];\r\n\r\n            tempRect.setTo(char.x, char.t, char.r - char.x, char.b);\r\n\r\n            if (tempRect.contains(point.x, point.y))\r\n            {\r\n                return char;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Updates the Display Origin cached values internally stored on this Game Object.\r\n     * You don't usually call this directly, but it is exposed for edge-cases where you may.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#updateDisplayOrigin\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateDisplayOrigin: function ()\r\n    {\r\n        this._dirty = true;\r\n\r\n        this.getTextBounds(false);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Changes the font this BitmapText is using to render.\r\n     *\r\n     * The new texture is loaded and applied to the BitmapText. The existing test, size and alignment are preserved,\r\n     * unless overridden via the arguments.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setFont\r\n     * @since 3.11.0\r\n     *\r\n     * @param {string} font - The key of the font to use from the Bitmap Font cache.\r\n     * @param {number} [size] - The font size of this Bitmap Text. If not specified the current size will be used.\r\n     * @param {number} [align=0] - The alignment of the text in a multi-line BitmapText object. If not specified the current alignment will be used.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setFont: function (key, size, align)\r\n    {\r\n        if (size === undefined) { size = this._fontSize; }\r\n        if (align === undefined) { align = this._align; }\r\n\r\n        if (key !== this.font)\r\n        {\r\n            var entry = this.scene.sys.cache.bitmapFont.get(key);\r\n\r\n            if (entry)\r\n            {\r\n                this.font = key;\r\n                this.fontData = entry.data;\r\n                this._fontSize = size;\r\n                this._align = align;\r\n                this.fromAtlas = entry.fromAtlas === true;\r\n\r\n                this.setTexture(entry.texture, entry.frame);\r\n\r\n                GetBitmapTextSize(this, false, true, this._bounds);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the maximum display width of this BitmapText in pixels.\r\n     *\r\n     * If `BitmapText.text` is longer than `maxWidth` then the lines will be automatically wrapped\r\n     * based on the previous whitespace character found in the line.\r\n     *\r\n     * If no whitespace was found then no wrapping will take place and consequently the `maxWidth` value will not be honored.\r\n     *\r\n     * Disable maxWidth by setting the value to 0.\r\n     *\r\n     * You can set the whitespace character to be searched for by setting the `wordWrapCharCode` parameter or property.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setMaxWidth\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The maximum display width of this BitmapText in pixels. Set to zero to disable.\r\n     * @param {number} [wordWrapCharCode] - The character code to check for when word wrapping. Defaults to 32 (the space character).\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setMaxWidth: function (value, wordWrapCharCode)\r\n    {\r\n        this._maxWidth = value;\r\n\r\n        this._dirty = true;\r\n\r\n        if (wordWrapCharCode !== undefined)\r\n        {\r\n            this.wordWrapCharCode = wordWrapCharCode;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Controls the alignment of each line of text in this BitmapText object.\r\n     *\r\n     * Only has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.\r\n     * Has no effect with single-lines of text.\r\n     *\r\n     * See the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.\r\n     *\r\n     * 0 = Left aligned (default)\r\n     * 1 = Middle aligned\r\n     * 2 = Right aligned\r\n     *\r\n     * The alignment position is based on the longest line of text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#align\r\n     * @type {number}\r\n     * @since 3.11.0\r\n     */\r\n    align: {\r\n\r\n        set: function (value)\r\n        {\r\n            this._align = value;\r\n            this._dirty = true;\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._align;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The text that this Bitmap Text object displays.\r\n     *\r\n     * You can also use the method `setText` if you want a chainable way to change the text content.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#text\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\r\n    text: {\r\n\r\n        set: function (value)\r\n        {\r\n            this.setText(value);\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._text;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The font size of this Bitmap Text.\r\n     *\r\n     * You can also use the method `setFontSize` if you want a chainable way to change the font size.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#fontSize\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    fontSize: {\r\n\r\n        set: function (value)\r\n        {\r\n            this._fontSize = value;\r\n            this._dirty = true;\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._fontSize;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Adds / Removes spacing between characters.\r\n     *\r\n     * Can be a negative or positive number.\r\n     *\r\n     * You can also use the method `setLetterSpacing` if you want a chainable way to change the letter spacing.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#letterSpacing\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    letterSpacing: {\r\n\r\n        set: function (value)\r\n        {\r\n            this._letterSpacing = value;\r\n            this._dirty = true;\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._letterSpacing;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The maximum display width of this BitmapText in pixels.\r\n     *\r\n     * If BitmapText.text is longer than maxWidth then the lines will be automatically wrapped\r\n     * based on the last whitespace character found in the line.\r\n     *\r\n     * If no whitespace was found then no wrapping will take place and consequently the maxWidth value will not be honored.\r\n     *\r\n     * Disable maxWidth by setting the value to 0.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#maxWidth\r\n     * @type {number}\r\n     * @since 3.21.0\r\n     */\r\n    maxWidth: {\r\n\r\n        set: function (value)\r\n        {\r\n            this._maxWidth = value;\r\n            this._dirty = true;\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._maxWidth;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The width of this Bitmap Text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#width\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    width: {\r\n\r\n        get: function ()\r\n        {\r\n            this.getTextBounds(false);\r\n\r\n            return this._bounds.global.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The height of this bitmap text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#height\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    height: {\r\n\r\n        get: function ()\r\n        {\r\n            this.getTextBounds(false);\r\n\r\n            return this._bounds.global.height;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Build a JSON representation of this Bitmap Text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.BitmapText.JSONBitmapText} A JSON representation of this Bitmap Text.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        var out = Components.ToJSON(this);\r\n\r\n        //  Extra data is added here\r\n\r\n        var data = {\r\n            font: this.font,\r\n            text: this.text,\r\n            fontSize: this.fontSize,\r\n            letterSpacing: this.letterSpacing,\r\n            align: this.align\r\n        };\r\n\r\n        out.data = data;\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#preDestroy\r\n     * @protected\r\n     * @since 3.50.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.charColors.length = 0;\r\n        this._bounds = null;\r\n        this.fontData = null;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Left align the text characters in a multi-line BitmapText object.\r\n *\r\n * @name Phaser.GameObjects.BitmapText.ALIGN_LEFT\r\n * @type {number}\r\n * @since 3.11.0\r\n */\r\nBitmapText.ALIGN_LEFT = 0;\r\n\r\n/**\r\n * Center align the text characters in a multi-line BitmapText object.\r\n *\r\n * @name Phaser.GameObjects.BitmapText.ALIGN_CENTER\r\n * @type {number}\r\n * @since 3.11.0\r\n */\r\nBitmapText.ALIGN_CENTER = 1;\r\n\r\n/**\r\n * Right align the text characters in a multi-line BitmapText object.\r\n *\r\n * @name Phaser.GameObjects.BitmapText.ALIGN_RIGHT\r\n * @type {number}\r\n * @since 3.11.0\r\n */\r\nBitmapText.ALIGN_RIGHT = 2;\r\n\r\n/**\r\n * Parse an XML Bitmap Font from an Atlas.\r\n *\r\n * Adds the parsed Bitmap Font data to the cache with the `fontName` key.\r\n *\r\n * @method Phaser.GameObjects.BitmapText.ParseFromAtlas\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to parse the Bitmap Font for.\r\n * @param {string} fontName - The key of the font to add to the Bitmap Font cache.\r\n * @param {string} textureKey - The key of the BitmapFont's texture.\r\n * @param {string} frameKey - The key of the BitmapFont texture's frame.\r\n * @param {string} xmlKey - The key of the XML data of the font to parse.\r\n * @param {number} [xSpacing] - The x-axis spacing to add between each letter.\r\n * @param {number} [ySpacing] - The y-axis spacing to add to the line height.\r\n *\r\n * @return {boolean} Whether the parsing was successful or not.\r\n */\r\nBitmapText.ParseFromAtlas = ParseFromAtlas;\r\n\r\n/**\r\n * Parse an XML font to Bitmap Font data for the Bitmap Font cache.\r\n *\r\n * @method Phaser.GameObjects.BitmapText.ParseXMLBitmapFont\r\n * @since 3.17.0\r\n *\r\n * @param {XMLDocument} xml - The XML Document to parse the font from.\r\n * @param {Phaser.Textures.Frame} frame - The texture frame to take into account when creating the uv data.\r\n * @param {number} [xSpacing=0] - The x-axis spacing to add between each letter.\r\n * @param {number} [ySpacing=0] - The y-axis spacing to add to the line height.\r\n *\r\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapFontData} The parsed Bitmap Font data.\r\n */\r\nBitmapText.ParseXMLBitmapFont = ParseXMLBitmapFont;\r\n\r\nmodule.exports = BitmapText;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Read an integer value from an XML Node.\n *\n * @function getValue\n * @since 3.0.0\n * @private\n *\n * @param {Node} node - The XML Node.\n * @param {string} attribute - The attribute to read.\n *\n * @return {number} The parsed value.\n */\nfunction getValue (node, attribute)\n{\n    return parseInt(node.getAttribute(attribute), 10);\n}\n\n/**\n * Parse an XML font to Bitmap Font data for the Bitmap Font cache.\n *\n * @function ParseXMLBitmapFont\n * @since 3.0.0\n * @private\n *\n * @param {XMLDocument} xml - The XML Document to parse the font from.\n * @param {Phaser.Textures.Frame} frame - The texture frame to take into account when creating the uv data.\n * @param {number} [xSpacing=0] - The x-axis spacing to add between each letter.\n * @param {number} [ySpacing=0] - The y-axis spacing to add to the line height.\n * @param {Phaser.Textures.Texture} [texture] - If provided, each glyph in the Bitmap Font will be added to this texture as a frame.\n *\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapFontData} The parsed Bitmap Font data.\n */\nvar ParseXMLBitmapFont = function (xml, frame, xSpacing, ySpacing, texture)\n{\n    if (xSpacing === undefined) { xSpacing = 0; }\n    if (ySpacing === undefined) { ySpacing = 0; }\n\n    var textureX = frame.cutX;\n    var textureY = frame.cutY;\n    var textureWidth = frame.source.width;\n    var textureHeight = frame.source.height;\n    var sourceIndex = frame.sourceIndex;\n\n    var data = {};\n    var info = xml.getElementsByTagName('info')[0];\n    var common = xml.getElementsByTagName('common')[0];\n\n    data.font = info.getAttribute('face');\n    data.size = getValue(info, 'size');\n    data.lineHeight = getValue(common, 'lineHeight') + ySpacing;\n    data.chars = {};\n\n    var letters = xml.getElementsByTagName('char');\n\n    var adjustForTrim = (frame !== undefined && frame.trimmed);\n\n    if (adjustForTrim)\n    {\n        var top = frame.height;\n        var left = frame.width;\n    }\n\n    for (var i = 0; i < letters.length; i++)\n    {\n        var node = letters[i];\n\n        var charCode = getValue(node, 'id');\n        var letter = String.fromCharCode(charCode);\n        var gx = getValue(node, 'x');\n        var gy = getValue(node, 'y');\n        var gw = getValue(node, 'width');\n        var gh = getValue(node, 'height');\n\n        //  Handle frame trim issues\n\n        if (adjustForTrim)\n        {\n            if (gx < left)\n            {\n                left = gx;\n            }\n\n            if (gy < top)\n            {\n                top = gy;\n            }\n        }\n\n        if (adjustForTrim && top !== 0 && left !== 0)\n        {\n            //  Now we know the top and left coordinates of the glyphs in the original data\n            //  so we can work out how much to adjust the glyphs by\n\n            gx -= frame.x;\n            gy -= frame.y;\n        }\n\n        var u0 = (textureX + gx) / textureWidth;\n        var v0 = (textureY + gy) / textureHeight;\n        var u1 = (textureX + gx + gw) / textureWidth;\n        var v1 = (textureY + gy + gh) / textureHeight;\n\n        data.chars[charCode] =\n        {\n            x: gx,\n            y: gy,\n            width: gw,\n            height: gh,\n            centerX: Math.floor(gw / 2),\n            centerY: Math.floor(gh / 2),\n            xOffset: getValue(node, 'xoffset'),\n            yOffset: getValue(node, 'yoffset'),\n            xAdvance: getValue(node, 'xadvance') + xSpacing,\n            data: {},\n            kerning: {},\n            u0: u0,\n            v0: v0,\n            u1: u1,\n            v1: v1\n        };\n\n        if (texture && gw !== 0 && gh !== 0)\n        {\n            var charFrame = texture.add(letter, sourceIndex, gx, gy, gw, gh);\n\n            if (charFrame)\n            {\n                charFrame.setUVs(gw, gh, u0, v0, u1, v1);\n            }\n        }\n    }\n\n    var kernings = xml.getElementsByTagName('kerning');\n\n    for (i = 0; i < kernings.length; i++)\n    {\n        var kern = kernings[i];\n\n        var first = getValue(kern, 'first');\n        var second = getValue(kern, 'second');\n        var amount = getValue(kern, 'amount');\n\n        data.chars[second].kerning[first] = amount;\n    }\n\n    return data;\n};\n\nmodule.exports = ParseXMLBitmapFont;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar IntegerToColor = require('../../display/color/IntegerToColor');\r\nvar PIPELINES_CONST = require('../../renderer/webgl/pipelines/const');\r\nvar Render = require('./PointLightRender');\r\n\r\n/**\r\n * @classdesc\r\n * The Point Light Game Object provides a way to add a point light effect into your game,\r\n * without the expensive shader processing requirements of the traditional Light Game Object.\r\n *\r\n * The difference is that the Point Light renders using a custom shader, designed to give the\r\n * impression of a point light source, of variable radius, intensity and color, in your game.\r\n * However, unlike the Light Game Object, it does not impact any other Game Objects, or use their\r\n * normal maps for calcuations. This makes them extremely fast to render compared to Lights\r\n * and perfect for special effects, such as flickering torches or muzzle flashes.\r\n *\r\n * For maximum performance you should batch Point Light Game Objects together. This means\r\n * ensuring they follow each other consecutively on the display list. Ideally, use a Layer\r\n * Game Object and then add just Point Lights to it, so that it can batch together the rendering\r\n * of the lights. You don't _have_ to do this, and if you've only a handful of Point Lights in\r\n * your game then it's perfectly safe to mix them into the dislay list as normal. However, if\r\n * you're using a large number of them, please consider how they are mixed into the display list.\r\n *\r\n * The renderer will automatically cull Point Lights. Those with a radius that does not intersect\r\n * with the Camera will be skipped in the rendering list. This happens automatically and the\r\n * culled state is refreshed every frame, for every camera.\r\n *\r\n * The origin of a Point Light is always 0.5 and it cannot be changed.\r\n *\r\n * Point Lights are a WebGL only feature and do not have a Canvas counterpart.\r\n *\r\n * @class PointLight\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Point Light belongs. A Point Light can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Point Light in the world.\r\n * @param {number} y - The vertical position of this Point Light in the world.\r\n * @param {number} [color=0xffffff] - The color of the Point Light, given as a hex value.\r\n * @param {number} [radius=128] - The radius of the Point Light.\r\n * @param {number} [intensity=1] - The intensity, or colr blend, of the Point Light.\r\n * @param {number} [attenuation=0.1] - The attenuation  of the Point Light. This is the reduction of light from the center point.\r\n */\r\nvar PointLight = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function PointLight (scene, x, y, color, radius, intensity, attenuation)\r\n    {\r\n        if (color === undefined) { color = 0xffffff; }\r\n        if (radius === undefined) { radius = 128; }\r\n        if (intensity === undefined) { intensity = 1; }\r\n        if (attenuation === undefined) { attenuation = 0.1; }\r\n\r\n        GameObject.call(this, scene, 'PointLight');\r\n\r\n        this.initPipeline(PIPELINES_CONST.POINTLIGHT_PIPELINE);\r\n\r\n        this.setPosition(x, y);\r\n\r\n        /**\r\n         * The color of this Point Light. This property is an instance of a\r\n         * Color object, so you can use the methods within it, such as `setTo(r, g, b)`\r\n         * to change the color value.\r\n         *\r\n         * @name Phaser.GameObjects.PointLight#color\r\n         * @type {Phaser.Display.Color}\r\n         * @since 3.50.0\r\n         */\r\n        this.color = IntegerToColor(color);\r\n\r\n        /**\r\n         * The intensity of the Point Light.\r\n         *\r\n         * The colors of the light are multiplied by this value during rendering.\r\n         *\r\n         * @name Phaser.GameObjects.PointLight#intensity\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.intensity = intensity;\r\n\r\n        /**\r\n         * The attenuation of the Point Light.\r\n         *\r\n         * This value controls the force with which the light falls-off from the center of the light.\r\n         *\r\n         * Use small float-based values, i.e. 0.1.\r\n         *\r\n         * @name Phaser.GameObjects.PointLight#attenuation\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.attenuation = attenuation;\r\n\r\n        //  read only:\r\n        this.width = radius * 2;\r\n        this.height = radius * 2;\r\n\r\n        this._radius = radius;\r\n    },\r\n\r\n    /**\r\n     * The radius of the Point Light.\r\n     *\r\n     * @name Phaser.GameObjects.PointLight#radius\r\n     * @type {number}\r\n     * @since 3.50.0\r\n     */\r\n    radius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._radius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._radius = value;\r\n            this.width = value * 2;\r\n            this.height = value * 2;\r\n        }\r\n\r\n    },\r\n\r\n    originX: {\r\n\r\n        get: function ()\r\n        {\r\n            return 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    originY: {\r\n\r\n        get: function ()\r\n        {\r\n            return 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    displayOriginX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._radius;\r\n        }\r\n\r\n    },\r\n\r\n    displayOriginY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._radius;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = PointLight;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlitterRender = require('./BlitterRender');\r\nvar Bob = require('./Bob');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar Frame = require('../../textures/Frame');\r\nvar GameObject = require('../GameObject');\r\nvar List = require('../../structs/List');\r\n\r\n/**\r\n * @callback CreateCallback\r\n *\r\n * @param {Phaser.GameObjects.Bob} bob - The Bob that was created by the Blitter.\r\n * @param {number} index - The position of the Bob within the Blitter display list.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Blitter Game Object.\r\n *\r\n * The Blitter Game Object is a special kind of container that creates, updates and manages Bob objects.\r\n * Bobs are designed for rendering speed rather than flexibility. They consist of a texture, or frame from a texture,\r\n * a position and an alpha value. You cannot scale or rotate them. They use a batched drawing method for speed\r\n * during rendering.\r\n *\r\n * A Blitter Game Object has one texture bound to it. Bobs created by the Blitter can use any Frame from this\r\n * Texture to render with, but they cannot use any other Texture. It is this single texture-bind that allows\r\n * them their speed.\r\n *\r\n * If you have a need to blast a large volume of frames around the screen then Blitter objects are well worth\r\n * investigating. They are especially useful for using as a base for your own special effects systems.\r\n *\r\n * @class Blitter\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.\r\n * @param {number} [x=0] - The x coordinate of this Game Object in world space.\r\n * @param {number} [y=0] - The y coordinate of this Game Object in world space.\r\n * @param {string} [texture='__DEFAULT'] - The key of the texture this Game Object will use for rendering. The Texture must already exist in the Texture Manager.\r\n * @param {(string|number)} [frame=0] - The Frame of the Texture that this Game Object will use. Only set if the Texture has multiple frames, such as a Texture Atlas or Sprite Sheet.\r\n */\r\nvar Blitter = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Size,\r\n        Components.Texture,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        BlitterRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Blitter (scene, x, y, texture, frame)\r\n    {\r\n        GameObject.call(this, scene, 'Blitter');\r\n\r\n        this.setTexture(texture, frame);\r\n        this.setPosition(x, y);\r\n        this.initPipeline();\r\n\r\n        /**\r\n         * The children of this Blitter.\r\n         * This List contains all of the Bob objects created by the Blitter.\r\n         *\r\n         * @name Phaser.GameObjects.Blitter#children\r\n         * @type {Phaser.Structs.List.<Phaser.GameObjects.Bob>}\r\n         * @since 3.0.0\r\n         */\r\n        this.children = new List();\r\n\r\n        /**\r\n         * A transient array that holds all of the Bobs that will be rendered this frame.\r\n         * The array is re-populated whenever the dirty flag is set.\r\n         *\r\n         * @name Phaser.GameObjects.Blitter#renderList\r\n         * @type {Phaser.GameObjects.Bob[]}\r\n         * @default []\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.renderList = [];\r\n\r\n        /**\r\n         * Is the Blitter considered dirty?\r\n         * A 'dirty' Blitter has had its child count changed since the last frame.\r\n         *\r\n         * @name Phaser.GameObjects.Blitter#dirty\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.dirty = false;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Bob in this Blitter.\r\n     *\r\n     * The Bob is created at the given coordinates, relative to the Blitter and uses the given frame.\r\n     * A Bob can use any frame belonging to the texture bound to the Blitter.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     * @param {number} y - The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     * @param {(string|number|Phaser.Textures.Frame)} [frame] - The Frame the Bob will use. It _must_ be part of the Texture the parent Blitter object is using.\r\n     * @param {boolean} [visible=true] - Should the created Bob render or not?\r\n     * @param {number} [index] - The position in the Blitters Display List to add the new Bob at. Defaults to the top of the list.\r\n     *\r\n     * @return {Phaser.GameObjects.Bob} The newly created Bob object.\r\n     */\r\n    create: function (x, y, frame, visible, index)\r\n    {\r\n        if (visible === undefined) { visible = true; }\r\n        if (index === undefined) { index = this.children.length; }\r\n\r\n        if (frame === undefined)\r\n        {\r\n            frame = this.frame;\r\n        }\r\n        else if (!(frame instanceof Frame))\r\n        {\r\n            frame = this.texture.get(frame);\r\n        }\r\n\r\n        var bob = new Bob(this, x, y, frame, visible);\r\n\r\n        this.children.addAt(bob, index, false);\r\n\r\n        this.dirty = true;\r\n\r\n        return bob;\r\n    },\r\n\r\n    /**\r\n     * Creates multiple Bob objects within this Blitter and then passes each of them to the specified callback.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#createFromCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {CreateCallback} callback - The callback to invoke after creating a bob. It will be sent two arguments: The Bob and the index of the Bob.\r\n     * @param {number} quantity - The quantity of Bob objects to create.\r\n     * @param {(string|number|Phaser.Textures.Frame|string[]|number[]|Phaser.Textures.Frame[])} [frame] - The Frame the Bobs will use. It must be part of the Blitter Texture.\r\n     * @param {boolean} [visible=true] - Should the created Bob render or not?\r\n     *\r\n     * @return {Phaser.GameObjects.Bob[]} An array of Bob objects that were created.\r\n     */\r\n    createFromCallback: function (callback, quantity, frame, visible)\r\n    {\r\n        var bobs = this.createMultiple(quantity, frame, visible);\r\n\r\n        for (var i = 0; i < bobs.length; i++)\r\n        {\r\n            var bob = bobs[i];\r\n\r\n            callback.call(this, bob, i);\r\n        }\r\n\r\n        return bobs;\r\n    },\r\n\r\n    /**\r\n     * Creates multiple Bobs in one call.\r\n     *\r\n     * The amount created is controlled by a combination of the `quantity` argument and the number of frames provided.\r\n     *\r\n     * If the quantity is set to 10 and you provide 2 frames, then 20 Bobs will be created. 10 with the first\r\n     * frame and 10 with the second.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#createMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} quantity - The quantity of Bob objects to create.\r\n     * @param {(string|number|Phaser.Textures.Frame|string[]|number[]|Phaser.Textures.Frame[])} [frame] - The Frame the Bobs will use. It must be part of the Blitter Texture.\r\n     * @param {boolean} [visible=true] - Should the created Bob render or not?\r\n     *\r\n     * @return {Phaser.GameObjects.Bob[]} An array of Bob objects that were created.\r\n     */\r\n    createMultiple: function (quantity, frame, visible)\r\n    {\r\n        if (frame === undefined) { frame = this.frame.name; }\r\n        if (visible === undefined) { visible = true; }\r\n\r\n        if (!Array.isArray(frame))\r\n        {\r\n            frame = [ frame ];\r\n        }\r\n\r\n        var bobs = [];\r\n        var _this = this;\r\n\r\n        frame.forEach(function (singleFrame)\r\n        {\r\n            for (var i = 0; i < quantity; i++)\r\n            {\r\n                bobs.push(_this.create(0, 0, singleFrame, visible));\r\n            }\r\n        });\r\n\r\n        return bobs;\r\n    },\r\n\r\n    /**\r\n     * Checks if the given child can render or not, by checking its `visible` and `alpha` values.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#childCanRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Bob} child - The Bob to check for rendering.\r\n     *\r\n     * @return {boolean} Returns `true` if the given child can render, otherwise `false`.\r\n     */\r\n    childCanRender: function (child)\r\n    {\r\n        return (child.visible && child.alpha > 0);\r\n    },\r\n\r\n    /**\r\n     * Returns an array of Bobs to be rendered.\r\n     * If the Blitter is dirty then a new list is generated and stored in `renderList`.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#getRenderList\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Bob[]} An array of Bob objects that will be rendered this frame.\r\n     */\r\n    getRenderList: function ()\r\n    {\r\n        if (this.dirty)\r\n        {\r\n            this.renderList = this.children.list.filter(this.childCanRender, this);\r\n            this.dirty = false;\r\n        }\r\n\r\n        return this.renderList;\r\n    },\r\n\r\n    /**\r\n     * Removes all Bobs from the children List and clears the dirty flag.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#clear\r\n     * @since 3.0.0\r\n     */\r\n    clear: function ()\r\n    {\r\n        this.children.removeAll();\r\n        this.dirty = true;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.children.destroy();\r\n\r\n        this.renderList = [];\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Blitter;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ArrayUtils = require('../../utils/array');\r\nvar BlendModes = require('../../renderer/BlendModes');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar Events = require('../events');\r\nvar GameObject = require('../GameObject');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar Render = require('./ContainerRender');\r\nvar Union = require('../../geom/rectangle/Union');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Container Game Object.\r\n *\r\n * A Container, as the name implies, can 'contain' other types of Game Object.\r\n * When a Game Object is added to a Container, the Container becomes responsible for the rendering of it.\r\n * By default it will be removed from the Display List and instead added to the Containers own internal list.\r\n *\r\n * The position of the Game Object automatically becomes relative to the position of the Container.\r\n *\r\n * The transform point of a Container is 0x0 (in local space) and that cannot be changed. The children you add to the\r\n * Container should be positioned with this value in mind. I.e. you should treat 0x0 as being the center of\r\n * the Container, and position children positively and negative around it as required.\r\n *\r\n * When the Container is rendered, all of its children are rendered as well, in the order in which they exist\r\n * within the Container. Container children can be repositioned using methods such as `MoveUp`, `MoveDown` and `SendToBack`.\r\n *\r\n * If you modify a transform property of the Container, such as `Container.x` or `Container.rotation` then it will\r\n * automatically influence all children as well.\r\n *\r\n * Containers can include other Containers for deeply nested transforms.\r\n *\r\n * Containers can have masks set on them and can be used as a mask too. However, Container children cannot be masked.\r\n * The masks do not 'stack up'. Only a Container on the root of the display list will use its mask.\r\n *\r\n * Containers can be enabled for input. Because they do not have a texture you need to provide a shape for them\r\n * to use as their hit area. Container children can also be enabled for input, independent of the Container.\r\n *\r\n * If input enabling a _child_ you should not set both the `origin` and a **negative** scale factor on the child,\r\n * or the input area will become misaligned.\r\n *\r\n * Containers can be given a physics body for either Arcade Physics, Impact Physics or Matter Physics. However,\r\n * if Container _children_ are enabled for physics you may get unexpected results, such as offset bodies,\r\n * if the Container itself, or any of its ancestors, is positioned anywhere other than at 0 x 0. Container children\r\n * with physics do not factor in the Container due to the excessive extra calculations needed. Please structure\r\n * your game to work around this.\r\n *\r\n * It's important to understand the impact of using Containers. They add additional processing overhead into\r\n * every one of their children. The deeper you nest them, the more the cost escalates. This is especially true\r\n * for input events. You also loose the ability to set the display depth of Container children in the same\r\n * flexible manner as those not within them. In short, don't use them for the sake of it. You pay a small cost\r\n * every time you create one, try to structure your game around avoiding that where possible.\r\n *\r\n * @class Container\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.4.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Container.\r\n */\r\nvar Container = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Container (scene, x, y, children)\r\n    {\r\n        GameObject.call(this, scene, 'Container');\r\n\r\n        /**\r\n         * An array holding the children of this Container.\r\n         *\r\n         * @name Phaser.GameObjects.Container#list\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @since 3.4.0\r\n         */\r\n        this.list = [];\r\n\r\n        /**\r\n         * Does this Container exclusively manage its children?\r\n         *\r\n         * The default is `true` which means a child added to this Container cannot\r\n         * belong in another Container, which includes the Scene display list.\r\n         *\r\n         * If you disable this then this Container will no longer exclusively manage its children.\r\n         * This allows you to create all kinds of interesting graphical effects, such as replicating\r\n         * Game Objects without reparenting them all over the Scene.\r\n         * However, doing so will prevent children from receiving any kind of input event or have\r\n         * their physics bodies work by default, as they're no longer a single entity on the\r\n         * display list, but are being replicated where-ever this Container is.\r\n         *\r\n         * @name Phaser.GameObjects.Container#exclusive\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.4.0\r\n         */\r\n        this.exclusive = true;\r\n\r\n        /**\r\n         * Containers can have an optional maximum size. If set to anything above 0 it\r\n         * will constrict the addition of new Game Objects into the Container, capping off\r\n         * the maximum limit the Container can grow in size to.\r\n         *\r\n         * @name Phaser.GameObjects.Container#maxSize\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.4.0\r\n         */\r\n        this.maxSize = -1;\r\n\r\n        /**\r\n         * The cursor position.\r\n         *\r\n         * @name Phaser.GameObjects.Container#position\r\n         * @type {number}\r\n         * @since 3.4.0\r\n         */\r\n        this.position = 0;\r\n\r\n        /**\r\n         * Internal Transform Matrix used for local space conversion.\r\n         *\r\n         * @name Phaser.GameObjects.Container#localTransform\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.4.0\r\n         */\r\n        this.localTransform = new Components.TransformMatrix();\r\n\r\n        /**\r\n         * Internal temporary Transform Matrix used to avoid object creation.\r\n         *\r\n         * @name Phaser.GameObjects.Container#tempTransformMatrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this.tempTransformMatrix = new Components.TransformMatrix();\r\n\r\n        /**\r\n         * The property key to sort by.\r\n         *\r\n         * @name Phaser.GameObjects.Container#_sortKey\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._sortKey = '';\r\n\r\n        /**\r\n         * A reference to the Scene Systems Event Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Container#_sysEvents\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @private\r\n         * @since 3.9.0\r\n         */\r\n        this._sysEvents = scene.sys.events;\r\n\r\n        /**\r\n         * The horizontal scroll factor of this Container.\r\n         *\r\n         * The scroll factor controls the influence of the movement of a Camera upon this Container.\r\n         *\r\n         * When a camera scrolls it will change the location at which this Container is rendered on-screen.\r\n         * It does not change the Containers actual position values.\r\n         *\r\n         * For a Container, setting this value will only update the Container itself, not its children.\r\n         * If you wish to change the scrollFactor of the children as well, use the `setScrollFactor` method.\r\n         *\r\n         * A value of 1 means it will move exactly in sync with a camera.\r\n         * A value of 0 means it will not move at all, even if the camera moves.\r\n         * Other values control the degree to which the camera movement is mapped to this Container.\r\n         *\r\n         * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n         * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n         * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n         * them from physics bodies if not accounted for in your code.\r\n         *\r\n         * @name Phaser.GameObjects.Container#scrollFactorX\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.4.0\r\n         */\r\n        this.scrollFactorX = 1;\r\n\r\n        /**\r\n         * The vertical scroll factor of this Container.\r\n         *\r\n         * The scroll factor controls the influence of the movement of a Camera upon this Container.\r\n         *\r\n         * When a camera scrolls it will change the location at which this Container is rendered on-screen.\r\n         * It does not change the Containers actual position values.\r\n         *\r\n         * For a Container, setting this value will only update the Container itself, not its children.\r\n         * If you wish to change the scrollFactor of the children as well, use the `setScrollFactor` method.\r\n         *\r\n         * A value of 1 means it will move exactly in sync with a camera.\r\n         * A value of 0 means it will not move at all, even if the camera moves.\r\n         * Other values control the degree to which the camera movement is mapped to this Container.\r\n         *\r\n         * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n         * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n         * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n         * them from physics bodies if not accounted for in your code.\r\n         *\r\n         * @name Phaser.GameObjects.Container#scrollFactorY\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.4.0\r\n         */\r\n        this.scrollFactorY = 1;\r\n\r\n        this.initPipeline();\r\n\r\n        this.setPosition(x, y);\r\n\r\n        this.clearAlpha();\r\n\r\n        this.setBlendMode(BlendModes.SKIP_CHECK);\r\n\r\n        if (children)\r\n        {\r\n            this.add(children);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#originX\r\n     * @type {number}\r\n     * @readonly\r\n     * @override\r\n     * @since 3.4.0\r\n     */\r\n    originX: {\r\n\r\n        get: function ()\r\n        {\r\n            return 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#originY\r\n     * @type {number}\r\n     * @readonly\r\n     * @override\r\n     * @since 3.4.0\r\n     */\r\n    originY: {\r\n\r\n        get: function ()\r\n        {\r\n            return 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#displayOriginX\r\n     * @type {number}\r\n     * @readonly\r\n     * @override\r\n     * @since 3.4.0\r\n     */\r\n    displayOriginX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.width * 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#displayOriginY\r\n     * @type {number}\r\n     * @readonly\r\n     * @override\r\n     * @since 3.4.0\r\n     */\r\n    displayOriginY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.height * 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Does this Container exclusively manage its children?\r\n     *\r\n     * The default is `true` which means a child added to this Container cannot\r\n     * belong in another Container, which includes the Scene display list.\r\n     *\r\n     * If you disable this then this Container will no longer exclusively manage its children.\r\n     * This allows you to create all kinds of interesting graphical effects, such as replicating\r\n     * Game Objects without reparenting them all over the Scene.\r\n     * However, doing so will prevent children from receiving any kind of input event or have\r\n     * their physics bodies work by default, as they're no longer a single entity on the\r\n     * display list, but are being replicated where-ever this Container is.\r\n     *\r\n     * @method Phaser.GameObjects.Container#setExclusive\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} [value=true] - The exclusive state of this Container.\r\n     *\r\n     * @return {this} This Container.\r\n     */\r\n    setExclusive: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.exclusive = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the bounds of this Container. It works by iterating all children of the Container,\r\n     * getting their respective bounds, and then working out a min-max rectangle from that.\r\n     * It does not factor in if the children render or not, all are included.\r\n     *\r\n     * Some children are unable to return their bounds, such as Graphics objects, in which case\r\n     * they are skipped.\r\n     *\r\n     * Depending on the quantity of children in this Container it could be a really expensive call,\r\n     * so cache it and only poll it as needed.\r\n     *\r\n     * The values are stored and returned in a Rectangle object.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getBounds\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [output] - A Geom.Rectangle object to store the values in. If not provided a new Rectangle will be created.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} The values stored in the output object.\r\n     */\r\n    getBounds: function (output)\r\n    {\r\n        if (output === undefined) { output = new Rectangle(); }\r\n\r\n        output.setTo(this.x, this.y, 0, 0);\r\n\r\n        if (this.parentContainer)\r\n        {\r\n            var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\r\n            var transformedPosition = parentMatrix.transformPoint(this.x, this.y);\r\n\r\n            output.setTo(transformedPosition.x, transformedPosition.y, 0, 0);\r\n        }\r\n\r\n        if (this.list.length > 0)\r\n        {\r\n            var children = this.list;\r\n            var tempRect = new Rectangle();\r\n            var hasSetFirst = false;\r\n\r\n            output.setEmpty();\r\n\r\n            for (var i = 0; i < children.length; i++)\r\n            {\r\n                var entry = children[i];\r\n\r\n                if (entry.getBounds)\r\n                {\r\n                    entry.getBounds(tempRect);\r\n\r\n                    if (!hasSetFirst)\r\n                    {\r\n                        output.setTo(tempRect.x, tempRect.y, tempRect.width, tempRect.height);\r\n                        hasSetFirst = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        Union(tempRect, output, output);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Internal add handler.\r\n     *\r\n     * @method Phaser.GameObjects.Container#addHandler\r\n     * @private\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just added to this Container.\r\n     */\r\n    addHandler: function (gameObject)\r\n    {\r\n        gameObject.once(Events.DESTROY, this.remove, this);\r\n\r\n        if (this.exclusive)\r\n        {\r\n            if (gameObject.parentContainer)\r\n            {\r\n                gameObject.parentContainer.remove(gameObject);\r\n            }\r\n\r\n            gameObject.removeFromDisplayList();\r\n\r\n            gameObject.parentContainer = this;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal remove handler.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeHandler\r\n     * @private\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just removed from this Container.\r\n     */\r\n    removeHandler: function (gameObject)\r\n    {\r\n        gameObject.off(Events.DESTROY, this.remove);\r\n\r\n        if (this.exclusive)\r\n        {\r\n            gameObject.parentContainer = null;\r\n\r\n            gameObject.addToDisplayList();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes a Point-like object, such as a Vector2, Geom.Point or object with public x and y properties,\r\n     * and transforms it into the space of this Container, then returns it in the output object.\r\n     *\r\n     * @method Phaser.GameObjects.Container#pointToContainer\r\n     * @since 3.4.0\r\n     *\r\n     * @param {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} source - The Source Point to be transformed.\r\n     * @param {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} [output] - A destination object to store the transformed point in. If none given a Vector2 will be created and returned.\r\n     *\r\n     * @return {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} The transformed point.\r\n     */\r\n    pointToContainer: function (source, output)\r\n    {\r\n        if (output === undefined) { output = new Vector2(); }\r\n\r\n        if (this.parentContainer)\r\n        {\r\n            this.parentContainer.pointToContainer(source, output);\r\n        }\r\n        else\r\n        {\r\n            output = new Vector2(source.x, source.y);\r\n        }\r\n\r\n        var tempMatrix = this.tempTransformMatrix;\r\n\r\n        //  No need to loadIdentity because applyITRS overwrites every value anyway\r\n        tempMatrix.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY);\r\n\r\n        tempMatrix.invert();\r\n\r\n        tempMatrix.transformPoint(source.x, source.y, output);\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns the world transform matrix as used for Bounds checks.\r\n     *\r\n     * The returned matrix is temporal and shouldn't be stored.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getBoundsTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The world transform matrix.\r\n     */\r\n    getBoundsTransformMatrix: function ()\r\n    {\r\n        return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform);\r\n    },\r\n\r\n    /**\r\n     * Adds the given Game Object, or array of Game Objects, to this Container.\r\n     *\r\n     * Each Game Object must be unique within the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#add\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to add to the Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    add: function (child)\r\n    {\r\n        ArrayUtils.Add(this.list, child, this.maxSize, this.addHandler, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given Game Object, or array of Game Objects, to this Container at the specified position.\r\n     *\r\n     * Existing Game Objects in the Container are shifted up.\r\n     *\r\n     * Each Game Object must be unique within the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#addAt\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to add to the Container.\r\n     * @param {number} [index=0] - The position to insert the Game Object/s at.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    addAt: function (child, index)\r\n    {\r\n        ArrayUtils.AddAt(this.list, child, index, this.maxSize, this.addHandler, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the Game Object at the given position in this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getAt\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} index - The position to get the Game Object from.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} The Game Object at the specified index, or `null` if none found.\r\n     */\r\n    getAt: function (index)\r\n    {\r\n        return this.list[index];\r\n    },\r\n\r\n    /**\r\n     * Returns the index of the given Game Object in this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getIndex\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to search for in this Container.\r\n     *\r\n     * @return {number} The index of the Game Object in this Container, or -1 if not found.\r\n     */\r\n    getIndex: function (child)\r\n    {\r\n        return this.list.indexOf(child);\r\n    },\r\n\r\n    /**\r\n     * Sort the contents of this Container so the items are in order based on the given property.\r\n     * For example: `sort('alpha')` would sort the elements based on the value of their `alpha` property.\r\n     *\r\n     * @method Phaser.GameObjects.Container#sort\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property to lexically sort by.\r\n     * @param {function} [handler] - Provide your own custom handler function. Will receive 2 children which it should compare and return a boolean.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    sort: function (property, handler)\r\n    {\r\n        if (!property)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (handler === undefined)\r\n        {\r\n            handler = function (childA, childB)\r\n            {\r\n                return childA[property] - childB[property];\r\n            };\r\n        }\r\n\r\n        ArrayUtils.StableSort(this.list, handler);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Searches for the first instance of a child with its `name` property matching the given argument.\r\n     * Should more than one child have the same name only the first is returned.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getByName\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} name - The name to search for.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} The first child with a matching name, or `null` if none were found.\r\n     */\r\n    getByName: function (name)\r\n    {\r\n        return ArrayUtils.GetFirst(this.list, 'name', name);\r\n    },\r\n\r\n    /**\r\n     * Returns a random Game Object from this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getRandom\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [startIndex=0] - An optional start index.\r\n     * @param {number} [length] - An optional length, the total number of elements (from the startIndex) to choose from.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} A random child from the Container, or `null` if the Container is empty.\r\n     */\r\n    getRandom: function (startIndex, length)\r\n    {\r\n        return ArrayUtils.GetRandom(this.list, startIndex, length);\r\n    },\r\n\r\n    /**\r\n     * Gets the first Game Object in this Container.\r\n     *\r\n     * You can also specify a property and value to search for, in which case it will return the first\r\n     * Game Object in this Container with a matching property and / or value.\r\n     *\r\n     * For example: `getFirst('visible', true)` would return the first Game Object that had its `visible` property set.\r\n     *\r\n     * You can limit the search to the `startIndex` - `endIndex` range.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getFirst\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property to test on each Game Object in the Container.\r\n     * @param {*} value - The value to test the property against. Must pass a strict (`===`) comparison check.\r\n     * @param {number} [startIndex=0] - An optional start index to search from.\r\n     * @param {number} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} The first matching Game Object, or `null` if none was found.\r\n     */\r\n    getFirst: function (property, value, startIndex, endIndex)\r\n    {\r\n        return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Returns all Game Objects in this Container.\r\n     *\r\n     * You can optionally specify a matching criteria using the `property` and `value` arguments.\r\n     *\r\n     * For example: `getAll('body')` would return only Game Objects that have a body property.\r\n     *\r\n     * You can also specify a value to compare the property to:\r\n     *\r\n     * `getAll('visible', true)` would return only Game Objects that have their visible property set to `true`.\r\n     *\r\n     * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,\r\n     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n     * the first 50 Game Objects.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getAll\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} [property] - The property to test on each Game Object in the Container.\r\n     * @param {any} [value] - If property is set then the `property` must strictly equal this value to be included in the results.\r\n     * @param {number} [startIndex=0] - An optional start index to search from.\r\n     * @param {number} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array of matching Game Objects from this Container.\r\n     */\r\n    getAll: function (property, value, startIndex, endIndex)\r\n    {\r\n        return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Returns the total number of Game Objects in this Container that have a property\r\n     * matching the given value.\r\n     *\r\n     * For example: `count('visible', true)` would count all the elements that have their visible property set.\r\n     *\r\n     * You can optionally limit the operation to the `startIndex` - `endIndex` range.\r\n     *\r\n     * @method Phaser.GameObjects.Container#count\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property to check.\r\n     * @param {any} value - The value to check.\r\n     * @param {number} [startIndex=0] - An optional start index to search from.\r\n     * @param {number} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {number} The total number of Game Objects in this Container with a property matching the given value.\r\n     */\r\n    count: function (property, value, startIndex, endIndex)\r\n    {\r\n        return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Swaps the position of two Game Objects in this Container.\r\n     * Both Game Objects must belong to this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#swap\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child1 - The first Game Object to swap.\r\n     * @param {Phaser.GameObjects.GameObject} child2 - The second Game Object to swap.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    swap: function (child1, child2)\r\n    {\r\n        ArrayUtils.Swap(this.list, child1, child2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Game Object to a new position within this Container.\r\n     *\r\n     * The Game Object must already be a child of this Container.\r\n     *\r\n     * The Game Object is removed from its old position and inserted into the new one.\r\n     * Therefore the Container size does not change. Other children will change position accordingly.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveTo\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to move.\r\n     * @param {number} index - The new position of the Game Object in this Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    moveTo: function (child, index)\r\n    {\r\n        ArrayUtils.MoveTo(this.list, child, index);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Game Object above another one within this Container.\r\n     *\r\n     * These 2 Game Objects must already be children of this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveAbove\r\n     * @since 3.55.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child1 - The Game Object to move above base Game Object.\r\n     * @param {Phaser.GameObjects.GameObject} child2 - The base Game Object.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    moveAbove: function (child1, child2)\r\n    {\r\n        ArrayUtils.MoveAbove(this.list, child1, child2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Game Object below another one within this Container.\r\n     *\r\n     * These 2 Game Objects must already be children of this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveBelow\r\n     * @since 3.55.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child1 - The Game Object to move below base Game Object.\r\n     * @param {Phaser.GameObjects.GameObject} child2 - The base Game Object.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    moveBelow: function (child1, child2)\r\n    {\r\n        ArrayUtils.MoveBelow(this.list, child1, child2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the given Game Object, or array of Game Objects, from this Container.\r\n     *\r\n     * The Game Objects must already be children of this Container.\r\n     *\r\n     * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#remove\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to be removed from the Container.\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each child successfully removed from this Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    remove: function (child, destroyChild)\r\n    {\r\n        var removed = ArrayUtils.Remove(this.list, child, this.removeHandler, this);\r\n\r\n        if (destroyChild && removed)\r\n        {\r\n            if (!Array.isArray(removed))\r\n            {\r\n                removed = [ removed ];\r\n            }\r\n\r\n            for (var i = 0; i < removed.length; i++)\r\n            {\r\n                removed[i].destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the Game Object at the given position in this Container.\r\n     *\r\n     * You can also optionally call `destroy` on the Game Object, if one is found.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeAt\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} index - The index of the Game Object to be removed.\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on the Game Object if successfully removed from this Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    removeAt: function (index, destroyChild)\r\n    {\r\n        var removed = ArrayUtils.RemoveAt(this.list, index, this.removeHandler, this);\r\n\r\n        if (destroyChild && removed)\r\n        {\r\n            removed.destroy();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the Game Objects between the given positions in this Container.\r\n     *\r\n     * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeBetween\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [startIndex=0] - An optional start index to search from.\r\n     * @param {number} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each Game Object successfully removed from this Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    removeBetween: function (startIndex, endIndex, destroyChild)\r\n    {\r\n        var removed = ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeHandler, this);\r\n\r\n        if (destroyChild)\r\n        {\r\n            for (var i = 0; i < removed.length; i++)\r\n            {\r\n                removed[i].destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all Game Objects from this Container.\r\n     *\r\n     * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeAll\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each Game Object successfully removed from this Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    removeAll: function (destroyChild)\r\n    {\r\n        var removed = ArrayUtils.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this);\r\n\r\n        if (destroyChild)\r\n        {\r\n            for (var i = 0; i < removed.length; i++)\r\n            {\r\n                removed[i].destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Brings the given Game Object to the top of this Container.\r\n     * This will cause it to render on-top of any other objects in the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#bringToTop\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to bring to the top of the Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    bringToTop: function (child)\r\n    {\r\n        ArrayUtils.BringToTop(this.list, child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sends the given Game Object to the bottom of this Container.\r\n     * This will cause it to render below any other objects in the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#sendToBack\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to send to the bottom of the Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    sendToBack: function (child)\r\n    {\r\n        ArrayUtils.SendToBack(this.list, child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves the given Game Object up one place in this Container, unless it's already at the top.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveUp\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to be moved in the Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    moveUp: function (child)\r\n    {\r\n        ArrayUtils.MoveUp(this.list, child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves the given Game Object down one place in this Container, unless it's already at the bottom.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveDown\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to be moved in the Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    moveDown: function (child)\r\n    {\r\n        ArrayUtils.MoveDown(this.list, child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reverses the order of all Game Objects in this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#reverse\r\n     * @since 3.4.0\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    reverse: function ()\r\n    {\r\n        this.list.reverse();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the all Game Objects in this Container using the Fisher-Yates implementation.\r\n     *\r\n     * @method Phaser.GameObjects.Container#shuffle\r\n     * @since 3.4.0\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    shuffle: function ()\r\n    {\r\n        ArrayUtils.Shuffle(this.list);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Replaces a Game Object in this Container with the new Game Object.\r\n     * The new Game Object cannot already be a child of this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#replace\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} oldChild - The Game Object in this Container that will be replaced.\r\n     * @param {Phaser.GameObjects.GameObject} newChild - The Game Object to be added to this Container.\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on the Game Object if successfully removed from this Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    replace: function (oldChild, newChild, destroyChild)\r\n    {\r\n        var moved = ArrayUtils.Replace(this.list, oldChild, newChild);\r\n\r\n        if (moved)\r\n        {\r\n            this.addHandler(newChild);\r\n            this.removeHandler(oldChild);\r\n\r\n            if (destroyChild)\r\n            {\r\n                oldChild.destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if the given Game Object is a direct child of this Container.\r\n     *\r\n     * This check does not scan nested Containers.\r\n     *\r\n     * @method Phaser.GameObjects.Container#exists\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to check for within this Container.\r\n     *\r\n     * @return {boolean} True if the Game Object is an immediate child of this Container, otherwise false.\r\n     */\r\n    exists: function (child)\r\n    {\r\n        return (this.list.indexOf(child) > -1);\r\n    },\r\n\r\n    /**\r\n     * Sets the property to the given value on all Game Objects in this Container.\r\n     *\r\n     * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,\r\n     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n     * the first 50 Game Objects.\r\n     *\r\n     * @method Phaser.GameObjects.Container#setAll\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property that must exist on the Game Object.\r\n     * @param {any} value - The value to get the property to.\r\n     * @param {number} [startIndex=0] - An optional start index to search from.\r\n     * @param {number} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    setAll: function (property, value, startIndex, endIndex)\r\n    {\r\n        ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * @callback EachContainerCallback\r\n     * @generic I - [item]\r\n     *\r\n     * @param {*} item - The child Game Object of the Container.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     */\r\n\r\n    /**\r\n     * Passes all Game Objects in this Container to the given callback.\r\n     *\r\n     * A copy of the Container is made before passing each entry to your callback.\r\n     * This protects against the callback itself modifying the Container.\r\n     *\r\n     * If you know for sure that the callback will not change the size of this Container\r\n     * then you can use the more performant `Container.iterate` method instead.\r\n     *\r\n     * @method Phaser.GameObjects.Container#each\r\n     * @since 3.4.0\r\n     *\r\n     * @param {function} callback - The function to call.\r\n     * @param {object} [context] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    each: function (callback, context)\r\n    {\r\n        var args = [ null ];\r\n        var i;\r\n        var temp = this.list.slice();\r\n        var len = temp.length;\r\n\r\n        for (i = 2; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            args[0] = temp[i];\r\n\r\n            callback.apply(context, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes all Game Objects in this Container to the given callback.\r\n     *\r\n     * Only use this method when you absolutely know that the Container will not be modified during\r\n     * the iteration, i.e. by removing or adding to its contents.\r\n     *\r\n     * @method Phaser.GameObjects.Container#iterate\r\n     * @since 3.4.0\r\n     *\r\n     * @param {function} callback - The function to call.\r\n     * @param {object} [context] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    iterate: function (callback, context)\r\n    {\r\n        var args = [ null ];\r\n        var i;\r\n\r\n        for (i = 2; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        for (i = 0; i < this.list.length; i++)\r\n        {\r\n            args[0] = this.list[i];\r\n\r\n            callback.apply(context, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scroll factor of this Container and optionally all of its children.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     *\r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @method Phaser.GameObjects.Container#setScrollFactor\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - The horizontal scroll factor of this Game Object.\r\n     * @param {number} [y=x] - The vertical scroll factor of this Game Object. If not set it will use the `x` value.\r\n     * @param {boolean} [updateChildren=false] - Apply this scrollFactor to all Container children as well?\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setScrollFactor: function (x, y, updateChildren)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n        if (updateChildren === undefined) { updateChildren = false; }\r\n\r\n        this.scrollFactorX = x;\r\n        this.scrollFactorY = y;\r\n\r\n        if (updateChildren)\r\n        {\r\n            ArrayUtils.SetAll(this.list, 'scrollFactorX', x);\r\n            ArrayUtils.SetAll(this.list, 'scrollFactorY', y);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The number of Game Objects inside this Container.\r\n     *\r\n     * @name Phaser.GameObjects.Container#length\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    length: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.list.length;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the first Game Object within the Container, or `null` if it is empty.\r\n     *\r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#first\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    first: {\r\n\r\n        get: function ()\r\n        {\r\n            this.position = 0;\r\n\r\n            if (this.list.length > 0)\r\n            {\r\n                return this.list[0];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the last Game Object within the Container, or `null` if it is empty.\r\n     *\r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#last\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    last: {\r\n\r\n        get: function ()\r\n        {\r\n            if (this.list.length > 0)\r\n            {\r\n                this.position = this.list.length - 1;\r\n\r\n                return this.list[this.position];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the next Game Object within the Container, or `null` if it is empty.\r\n     *\r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#next\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    next: {\r\n\r\n        get: function ()\r\n        {\r\n            if (this.position < this.list.length)\r\n            {\r\n                this.position++;\r\n\r\n                return this.list[this.position];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the previous Game Object within the Container, or `null` if it is empty.\r\n     *\r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#previous\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    previous: {\r\n\r\n        get: function ()\r\n        {\r\n            if (this.position > 0)\r\n            {\r\n                this.position--;\r\n\r\n                return this.list[this.position];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Container#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.removeAll(!!this.exclusive);\r\n\r\n        this.localTransform.destroy();\r\n        this.tempTransformMatrix.destroy();\r\n\r\n        this.list = [];\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Container;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar BitmapText = require('../static/BitmapText');\nvar Class = require('../../../utils/Class');\nvar Render = require('./DynamicBitmapTextRender');\n\n/**\n * @classdesc\n * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\n *\n * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\n * match the font structure.\n *\n * Dynamic Bitmap Text objects are different from Static Bitmap Text in that they invoke a callback for each\n * letter being rendered during the render pass. This callback allows you to manipulate the properties of\n * each letter being rendered, such as its position, scale or tint, allowing you to create interesting effects\n * like jiggling text, which can't be done with Static text. This means that Dynamic Text takes more processing\n * time, so only use them if you require the callback ability they have.\n *\n * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\n * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\n * processing the font texture in an image editor, applying fills and any other effects required.\n *\n * To create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\n *\n * To create a BitmapText data files you need a 3rd party app such as:\n *\n * BMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}\n * Glyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}\n * Littera (Web-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}\n *\n * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\n * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}\n *\n * @class DynamicBitmapText\n * @extends Phaser.GameObjects.BitmapText\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.\n * @param {number} x - The x coordinate of this Game Object in world space.\n * @param {number} y - The y coordinate of this Game Object in world space.\n * @param {string} font - The key of the font to use from the Bitmap Font cache.\n * @param {(string|string[])} [text] - The string, or array of strings, to be set as the content of this Bitmap Text.\n * @param {number} [size] - The font size of this Bitmap Text.\n * @param {number} [align=0] - The alignment of the text in a multi-line BitmapText object.\n */\nvar DynamicBitmapText = new Class({\n\n    Extends: BitmapText,\n\n    Mixins: [\n        Render\n    ],\n\n    initialize:\n\n    function DynamicBitmapText (scene, x, y, font, text, size, align)\n    {\n        BitmapText.call(this, scene, x, y, font, text, size, align);\n\n        this.type = 'DynamicBitmapText';\n\n        /**\n         * The horizontal scroll position of the Bitmap Text.\n         *\n         * @name Phaser.GameObjects.DynamicBitmapText#scrollX\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.scrollX = 0;\n\n        /**\n         * The vertical scroll position of the Bitmap Text.\n         *\n         * @name Phaser.GameObjects.DynamicBitmapText#scrollY\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.scrollY = 0;\n\n        /**\n         * The crop width of the Bitmap Text.\n         *\n         * @name Phaser.GameObjects.DynamicBitmapText#cropWidth\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.cropWidth = 0;\n\n        /**\n         * The crop height of the Bitmap Text.\n         *\n         * @name Phaser.GameObjects.DynamicBitmapText#cropHeight\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.cropHeight = 0;\n\n        /**\n         * A callback that alters how each character of the Bitmap Text is rendered.\n         *\n         * @name Phaser.GameObjects.DynamicBitmapText#displayCallback\n         * @type {Phaser.Types.GameObjects.BitmapText.DisplayCallback}\n         * @since 3.0.0\n         */\n        this.displayCallback;\n\n        /**\n         * The data object that is populated during rendering, then passed to the displayCallback.\n         * You should modify this object then return it back from the callback. It's updated values\n         * will be used to render the specific glyph.\n         *\n         * Please note that if you need a reference to this object locally in your game code then you\n         * should shallow copy it, as it's updated and re-used for every glyph in the text.\n         *\n         * @name Phaser.GameObjects.DynamicBitmapText#callbackData\n         * @type {Phaser.Types.GameObjects.BitmapText.DisplayCallbackConfig}\n         * @since 3.11.0\n         */\n        this.callbackData = {\n            parent: this,\n            color: 0,\n            tint: {\n                topLeft: 0,\n                topRight: 0,\n                bottomLeft: 0,\n                bottomRight: 0\n            },\n            index: 0,\n            charCode: 0,\n            x: 0,\n            y: 0,\n            scale: 0,\n            rotation: 0,\n            data: 0\n        };\n    },\n\n    /**\n     * Set the crop size of this Bitmap Text.\n     *\n     * @method Phaser.GameObjects.DynamicBitmapText#setSize\n     * @since 3.0.0\n     *\n     * @param {number} width - The width of the crop.\n     * @param {number} height - The height of the crop.\n     *\n     * @return {this} This Game Object.\n     */\n    setSize: function (width, height)\n    {\n        this.cropWidth = width;\n        this.cropHeight = height;\n\n        return this;\n    },\n\n    /**\n     * Set a callback that alters how each character of the Bitmap Text is rendered.\n     *\n     * The callback receives a {@link Phaser.Types.GameObjects.BitmapText.DisplayCallbackConfig} object that contains information about the character that's\n     * about to be rendered.\n     *\n     * It should return an object with `x`, `y`, `scale` and `rotation` properties that will be used instead of the\n     * usual values when rendering.\n     *\n     * @method Phaser.GameObjects.DynamicBitmapText#setDisplayCallback\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.GameObjects.BitmapText.DisplayCallback} callback - The display callback to set.\n     *\n     * @return {this} This Game Object.\n     */\n    setDisplayCallback: function (callback)\n    {\n        this.displayCallback = callback;\n\n        return this;\n    },\n\n    /**\n     * Set the horizontal scroll position of this Bitmap Text.\n     *\n     * @method Phaser.GameObjects.DynamicBitmapText#setScrollX\n     * @since 3.0.0\n     *\n     * @param {number} value - The horizontal scroll position to set.\n     *\n     * @return {this} This Game Object.\n     */\n    setScrollX: function (value)\n    {\n        this.scrollX = value;\n\n        return this;\n    },\n\n    /**\n     * Set the vertical scroll position of this Bitmap Text.\n     *\n     * @method Phaser.GameObjects.DynamicBitmapText#setScrollY\n     * @since 3.0.0\n     *\n     * @param {number} value - The vertical scroll position to set.\n     *\n     * @return {this} This Game Object.\n     */\n    setScrollY: function (value)\n    {\n        this.scrollY = value;\n\n        return this;\n    }\n\n});\n\nmodule.exports = DynamicBitmapText;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BaseCamera = require('../../cameras/2d/BaseCamera.js');\r\nvar Class = require('../../utils/Class');\r\nvar Commands = require('./Commands');\r\nvar ComponentsAlpha = require('../components/AlphaSingle');\r\nvar ComponentsBlendMode = require('../components/BlendMode');\r\nvar ComponentsDepth = require('../components/Depth');\r\nvar ComponentsMask = require('../components/Mask');\r\nvar ComponentsPipeline = require('../components/Pipeline');\r\nvar ComponentsScrollFactor = require('../components/ScrollFactor');\r\nvar ComponentsTransform = require('../components/Transform');\r\nvar ComponentsVisible = require('../components/Visible');\r\nvar Ellipse = require('../../geom/ellipse/Ellipse');\r\nvar GameObject = require('../GameObject');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar MATH_CONST = require('../../math/const');\r\nvar Render = require('./GraphicsRender');\r\n\r\n/**\r\n * @classdesc\r\n * A Graphics object is a way to draw primitive shapes to your game. Primitives include forms of geometry, such as\r\n * Rectangles, Circles, and Polygons. They also include lines, arcs and curves. When you initially create a Graphics\r\n * object it will be empty.\r\n *\r\n * To draw to it you must first specify a line style or fill style (or both), draw shapes using paths, and finally\r\n * fill or stroke them. For example:\r\n *\r\n * ```javascript\r\n * graphics.lineStyle(5, 0xFF00FF, 1.0);\r\n * graphics.beginPath();\r\n * graphics.moveTo(100, 100);\r\n * graphics.lineTo(200, 200);\r\n * graphics.closePath();\r\n * graphics.strokePath();\r\n * ```\r\n *\r\n * There are also many helpful methods that draw and fill/stroke common shapes for you.\r\n *\r\n * ```javascript\r\n * graphics.lineStyle(5, 0xFF00FF, 1.0);\r\n * graphics.fillStyle(0xFFFFFF, 1.0);\r\n * graphics.fillRect(50, 50, 400, 200);\r\n * graphics.strokeRect(50, 50, 400, 200);\r\n * ```\r\n *\r\n * When a Graphics object is rendered it will render differently based on if the game is running under Canvas or WebGL.\r\n * Under Canvas it will use the HTML Canvas context drawing operations to draw the path.\r\n * Under WebGL the graphics data is decomposed into polygons. Both of these are expensive processes, especially with\r\n * complex shapes.\r\n *\r\n * If your Graphics object doesn't change much (or at all) once you've drawn your shape to it, then you will help\r\n * performance by calling {@link Phaser.GameObjects.Graphics#generateTexture}. This will 'bake' the Graphics object into\r\n * a Texture, and return it. You can then use this Texture for Sprites or other display objects. If your Graphics object\r\n * updates frequently then you should avoid doing this, as it will constantly generate new textures, which will consume\r\n * memory.\r\n *\r\n * As you can tell, Graphics objects are a bit of a trade-off. While they are extremely useful, you need to be careful\r\n * in their complexity and quantity of them in your game.\r\n *\r\n * @class Graphics\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Graphics object belongs.\r\n * @param {Phaser.Types.GameObjects.Graphics.Options} [options] - Options that set the position and default style of this Graphics object.\r\n */\r\nvar Graphics = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        ComponentsAlpha,\r\n        ComponentsBlendMode,\r\n        ComponentsDepth,\r\n        ComponentsMask,\r\n        ComponentsPipeline,\r\n        ComponentsTransform,\r\n        ComponentsVisible,\r\n        ComponentsScrollFactor,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Graphics (scene, options)\r\n    {\r\n        var x = GetValue(options, 'x', 0);\r\n        var y = GetValue(options, 'y', 0);\r\n\r\n        GameObject.call(this, scene, 'Graphics');\r\n\r\n        this.setPosition(x, y);\r\n        this.initPipeline();\r\n\r\n        /**\r\n         * The horizontal display origin of the Graphics.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#displayOriginX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.displayOriginX = 0;\r\n\r\n        /**\r\n         * The vertical display origin of the Graphics.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#displayOriginY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.displayOriginY = 0;\r\n\r\n        /**\r\n         * The array of commands used to render the Graphics.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#commandBuffer\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.commandBuffer = [];\r\n\r\n        /**\r\n         * The default fill color for shapes rendered by this Graphics object.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultFillColor\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultFillColor = -1;\r\n\r\n        /**\r\n         * The default fill alpha for shapes rendered by this Graphics object.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultFillAlpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultFillAlpha = 1;\r\n\r\n        /**\r\n         * The default stroke width for shapes rendered by this Graphics object.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultStrokeWidth\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultStrokeWidth = 1;\r\n\r\n        /**\r\n         * The default stroke color for shapes rendered by this Graphics object.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultStrokeColor\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultStrokeColor = -1;\r\n\r\n        /**\r\n         * The default stroke alpha for shapes rendered by this Graphics object.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultStrokeAlpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultStrokeAlpha = 1;\r\n\r\n        /**\r\n         * Internal property that keeps track of the line width style setting.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#_lineWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._lineWidth = 1.0;\r\n\r\n        this.setDefaultStyles(options);\r\n    },\r\n\r\n    /**\r\n     * Set the default style settings for this Graphics object.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#setDefaultStyles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Graphics.Styles} options - The styles to set as defaults.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setDefaultStyles: function (options)\r\n    {\r\n        if (GetValue(options, 'lineStyle', null))\r\n        {\r\n            this.defaultStrokeWidth = GetValue(options, 'lineStyle.width', 1);\r\n            this.defaultStrokeColor = GetValue(options, 'lineStyle.color', 0xffffff);\r\n            this.defaultStrokeAlpha = GetValue(options, 'lineStyle.alpha', 1);\r\n\r\n            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);\r\n        }\r\n\r\n        if (GetValue(options, 'fillStyle', null))\r\n        {\r\n            this.defaultFillColor = GetValue(options, 'fillStyle.color', 0xffffff);\r\n            this.defaultFillAlpha = GetValue(options, 'fillStyle.alpha', 1);\r\n\r\n            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the current line style.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#lineStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} lineWidth - The stroke width.\r\n     * @param {number} color - The stroke color.\r\n     * @param {number} [alpha=1] - The stroke alpha.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    lineStyle: function (lineWidth, color, alpha)\r\n    {\r\n        if (alpha === undefined) { alpha = 1; }\r\n\r\n        this.commandBuffer.push(\r\n            Commands.LINE_STYLE,\r\n            lineWidth, color, alpha\r\n        );\r\n\r\n        this._lineWidth = lineWidth;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the current fill style.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} color - The fill color.\r\n     * @param {number} [alpha=1] - The fill alpha.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillStyle: function (color, alpha)\r\n    {\r\n        if (alpha === undefined) { alpha = 1; }\r\n\r\n        this.commandBuffer.push(\r\n            Commands.FILL_STYLE,\r\n            color, alpha\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a gradient fill style. This is a WebGL only feature.\r\n     *\r\n     * The gradient color values represent the 4 corners of an untransformed rectangle.\r\n     * The gradient is used to color all filled shapes and paths drawn after calling this method.\r\n     * If you wish to turn a gradient off, call `fillStyle` and provide a new single fill color.\r\n     *\r\n     * When filling a triangle only the first 3 color values provided are used for the 3 points of a triangle.\r\n     *\r\n     * This feature is best used only on rectangles and triangles. All other shapes will give strange results.\r\n     *\r\n     * Note that for objects such as arcs or ellipses, or anything which is made out of triangles, each triangle used\r\n     * will be filled with a gradient on its own. There is no ability to gradient fill a shape or path as a single\r\n     * entity at this time.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillGradientStyle\r\n     * @webglOnly\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} topLeft - The top left fill color.\r\n     * @param {number} topRight - The top right fill color.\r\n     * @param {number} bottomLeft - The bottom left fill color.\r\n     * @param {number} bottomRight - The bottom right fill color. Not used when filling triangles.\r\n     * @param {number} [alphaTopLeft=1] - The top left alpha value. If you give only this value, it's used for all corners.\r\n     * @param {number} [alphaTopRight=1] - The top right alpha value.\r\n     * @param {number} [alphaBottomLeft=1] - The bottom left alpha value.\r\n     * @param {number} [alphaBottomRight=1] - The bottom right alpha value.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillGradientStyle: function (topLeft, topRight, bottomLeft, bottomRight, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight)\r\n    {\r\n        if (alphaTopLeft === undefined) { alphaTopLeft = 1; }\r\n        if (alphaTopRight === undefined) { alphaTopRight = alphaTopLeft; }\r\n        if (alphaBottomLeft === undefined) { alphaBottomLeft = alphaTopLeft; }\r\n        if (alphaBottomRight === undefined) { alphaBottomRight = alphaTopLeft; }\r\n\r\n        this.commandBuffer.push(\r\n            Commands.GRADIENT_FILL_STYLE,\r\n            alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight,\r\n            topLeft, topRight, bottomLeft, bottomRight\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a gradient line style. This is a WebGL only feature.\r\n     *\r\n     * The gradient color values represent the 4 corners of an untransformed rectangle.\r\n     * The gradient is used to color all stroked shapes and paths drawn after calling this method.\r\n     * If you wish to turn a gradient off, call `lineStyle` and provide a new single line color.\r\n     *\r\n     * This feature is best used only on single lines. All other shapes will give strange results.\r\n     *\r\n     * Note that for objects such as arcs or ellipses, or anything which is made out of triangles, each triangle used\r\n     * will be filled with a gradient on its own. There is no ability to gradient stroke a shape or path as a single\r\n     * entity at this time.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#lineGradientStyle\r\n     * @webglOnly\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} lineWidth - The stroke width.\r\n     * @param {number} topLeft - The tint being applied to the top-left of the Game Object.\r\n     * @param {number} topRight - The tint being applied to the top-right of the Game Object.\r\n     * @param {number} bottomLeft - The tint being applied to the bottom-left of the Game Object.\r\n     * @param {number} bottomRight - The tint being applied to the bottom-right of the Game Object.\r\n     * @param {number} [alpha=1] - The fill alpha.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    lineGradientStyle: function (lineWidth, topLeft, topRight, bottomLeft, bottomRight, alpha)\r\n    {\r\n        if (alpha === undefined) { alpha = 1; }\r\n\r\n        this.commandBuffer.push(\r\n            Commands.GRADIENT_LINE_STYLE,\r\n            lineWidth, alpha, topLeft, topRight, bottomLeft, bottomRight\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Start a new shape path.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#beginPath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    beginPath: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.BEGIN_PATH\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Close the current path.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#closePath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    closePath: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.CLOSE_PATH\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the current path.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillPath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillPath: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.FILL_PATH\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the current path.\r\n     *\r\n     * This is an alias for `Graphics.fillPath` and does the same thing.\r\n     * It was added to match the CanvasRenderingContext 2D API.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fill\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fill: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.FILL_PATH\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke the current path.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokePath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokePath: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.STROKE_PATH\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke the current path.\r\n     *\r\n     * This is an alias for `Graphics.strokePath` and does the same thing.\r\n     * It was added to match the CanvasRenderingContext 2D API.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#stroke\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    stroke: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.STROKE_PATH\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the given circle.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillCircleShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Circle} circle - The circle to fill.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillCircleShape: function (circle)\r\n    {\r\n        return this.fillCircle(circle.x, circle.y, circle.radius);\r\n    },\r\n\r\n    /**\r\n     * Stroke the given circle.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeCircleShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Circle} circle - The circle to stroke.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeCircleShape: function (circle)\r\n    {\r\n        return this.strokeCircle(circle.x, circle.y, circle.radius);\r\n    },\r\n\r\n    /**\r\n     * Fill a circle with the given position and radius.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the center of the circle.\r\n     * @param {number} y - The y coordinate of the center of the circle.\r\n     * @param {number} radius - The radius of the circle.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillCircle: function (x, y, radius)\r\n    {\r\n        this.beginPath();\r\n        this.arc(x, y, radius, 0, MATH_CONST.PI2);\r\n        this.fillPath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke a circle with the given position and radius.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the center of the circle.\r\n     * @param {number} y - The y coordinate of the center of the circle.\r\n     * @param {number} radius - The radius of the circle.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeCircle: function (x, y, radius)\r\n    {\r\n        this.beginPath();\r\n        this.arc(x, y, radius, 0, MATH_CONST.PI2);\r\n        this.strokePath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the given rectangle.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillRectShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} rect - The rectangle to fill.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillRectShape: function (rect)\r\n    {\r\n        return this.fillRect(rect.x, rect.y, rect.width, rect.height);\r\n    },\r\n\r\n    /**\r\n     * Stroke the given rectangle.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeRectShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} rect - The rectangle to stroke.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeRectShape: function (rect)\r\n    {\r\n        return this.strokeRect(rect.x, rect.y, rect.width, rect.height);\r\n    },\r\n\r\n    /**\r\n     * Fill a rectangle with the given position and size.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillRect\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the top-left of the rectangle.\r\n     * @param {number} y - The y coordinate of the top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillRect: function (x, y, width, height)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.FILL_RECT,\r\n            x, y, width, height\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke a rectangle with the given position and size.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeRect\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the top-left of the rectangle.\r\n     * @param {number} y - The y coordinate of the top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeRect: function (x, y, width, height)\r\n    {\r\n        var lineWidthHalf = this._lineWidth / 2;\r\n        var minx = x - lineWidthHalf;\r\n        var maxx = x + lineWidthHalf;\r\n\r\n        this.beginPath();\r\n        this.moveTo(x, y);\r\n        this.lineTo(x, y + height);\r\n        this.strokePath();\r\n\r\n        this.beginPath();\r\n        this.moveTo(x + width, y);\r\n        this.lineTo(x + width, y + height);\r\n        this.strokePath();\r\n\r\n        this.beginPath();\r\n        this.moveTo(minx, y);\r\n        this.lineTo(maxx + width, y);\r\n        this.strokePath();\r\n\r\n        this.beginPath();\r\n        this.moveTo(minx, y + height);\r\n        this.lineTo(maxx + width, y + height);\r\n        this.strokePath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill a rounded rectangle with the given position, size and radius.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillRoundedRect\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} x - The x coordinate of the top-left of the rectangle.\r\n     * @param {number} y - The y coordinate of the top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     * @param {(Phaser.Types.GameObjects.Graphics.RoundedRectRadius|number)} [radius=20] - The corner radius; It can also be an object to specify different radii for corners.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillRoundedRect: function (x, y, width, height, radius)\r\n    {\r\n        if (radius === undefined) { radius = 20; }\r\n\r\n        var tl = radius;\r\n        var tr = radius;\r\n        var bl = radius;\r\n        var br = radius;\r\n\r\n        if (typeof radius !== 'number')\r\n        {\r\n            tl = GetFastValue(radius, 'tl', 20);\r\n            tr = GetFastValue(radius, 'tr', 20);\r\n            bl = GetFastValue(radius, 'bl', 20);\r\n            br = GetFastValue(radius, 'br', 20);\r\n        }\r\n\r\n        this.beginPath();\r\n        this.moveTo(x + tl, y);\r\n        this.lineTo(x + width - tr, y);\r\n        this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);\r\n        this.lineTo(x + width, y + height - br);\r\n        this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);\r\n        this.lineTo(x + bl, y + height);\r\n        this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);\r\n        this.lineTo(x, y + tl);\r\n        this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);\r\n        this.fillPath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke a rounded rectangle with the given position, size and radius.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeRoundedRect\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} x - The x coordinate of the top-left of the rectangle.\r\n     * @param {number} y - The y coordinate of the top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     * @param {(Phaser.Types.GameObjects.Graphics.RoundedRectRadius|number)} [radius=20] - The corner radius; It can also be an object to specify different radii for corners.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeRoundedRect: function (x, y, width, height, radius)\r\n    {\r\n        if (radius === undefined) { radius = 20; }\r\n\r\n        var tl = radius;\r\n        var tr = radius;\r\n        var bl = radius;\r\n        var br = radius;\r\n\r\n        if (typeof radius !== 'number')\r\n        {\r\n            tl = GetFastValue(radius, 'tl', 20);\r\n            tr = GetFastValue(radius, 'tr', 20);\r\n            bl = GetFastValue(radius, 'bl', 20);\r\n            br = GetFastValue(radius, 'br', 20);\r\n        }\r\n\r\n        this.beginPath();\r\n        this.moveTo(x + tl, y);\r\n        this.lineTo(x + width - tr, y);\r\n        this.moveTo(x + width - tr, y);\r\n        this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);\r\n        this.lineTo(x + width, y + height - br);\r\n        this.moveTo(x + width, y + height - br);\r\n        this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);\r\n        this.lineTo(x + bl, y + height);\r\n        this.moveTo(x + bl, y + height);\r\n        this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);\r\n        this.lineTo(x, y + tl);\r\n        this.moveTo(x, y + tl);\r\n        this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);\r\n        this.strokePath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the given point.\r\n     *\r\n     * Draws a square at the given position, 1 pixel in size by default.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillPointShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} point - The point to fill.\r\n     * @param {number} [size=1] - The size of the square to draw.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillPointShape: function (point, size)\r\n    {\r\n        return this.fillPoint(point.x, point.y, size);\r\n    },\r\n\r\n    /**\r\n     * Fill a point at the given position.\r\n     *\r\n     * Draws a square at the given position, 1 pixel in size by default.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the point.\r\n     * @param {number} y - The y coordinate of the point.\r\n     * @param {number} [size=1] - The size of the square to draw.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillPoint: function (x, y, size)\r\n    {\r\n        if (!size || size < 1)\r\n        {\r\n            size = 1;\r\n        }\r\n        else\r\n        {\r\n            x -= (size / 2);\r\n            y -= (size / 2);\r\n        }\r\n\r\n        this.commandBuffer.push(\r\n            Commands.FILL_RECT,\r\n            x, y, size, size\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the given triangle.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillTriangleShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Triangle} triangle - The triangle to fill.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillTriangleShape: function (triangle)\r\n    {\r\n        return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);\r\n    },\r\n\r\n    /**\r\n     * Stroke the given triangle.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeTriangleShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Triangle} triangle - The triangle to stroke.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeTriangleShape: function (triangle)\r\n    {\r\n        return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);\r\n    },\r\n\r\n    /**\r\n     * Fill a triangle with the given points.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x0 - The x coordinate of the first point.\r\n     * @param {number} y0 - The y coordinate of the first point.\r\n     * @param {number} x1 - The x coordinate of the second point.\r\n     * @param {number} y1 - The y coordinate of the second point.\r\n     * @param {number} x2 - The x coordinate of the third point.\r\n     * @param {number} y2 - The y coordinate of the third point.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillTriangle: function (x0, y0, x1, y1, x2, y2)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.FILL_TRIANGLE,\r\n            x0, y0, x1, y1, x2, y2\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke a triangle with the given points.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x0 - The x coordinate of the first point.\r\n     * @param {number} y0 - The y coordinate of the first point.\r\n     * @param {number} x1 - The x coordinate of the second point.\r\n     * @param {number} y1 - The y coordinate of the second point.\r\n     * @param {number} x2 - The x coordinate of the third point.\r\n     * @param {number} y2 - The y coordinate of the third point.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeTriangle: function (x0, y0, x1, y1, x2, y2)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.STROKE_TRIANGLE,\r\n            x0, y0, x1, y1, x2, y2\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draw the given line.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeLineShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Line} line - The line to stroke.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeLineShape: function (line)\r\n    {\r\n        return this.lineBetween(line.x1, line.y1, line.x2, line.y2);\r\n    },\r\n\r\n    /**\r\n     * Draw a line between the given points.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#lineBetween\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x1 - The x coordinate of the start point of the line.\r\n     * @param {number} y1 - The y coordinate of the start point of the line.\r\n     * @param {number} x2 - The x coordinate of the end point of the line.\r\n     * @param {number} y2 - The y coordinate of the end point of the line.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    lineBetween: function (x1, y1, x2, y2)\r\n    {\r\n        this.beginPath();\r\n        this.moveTo(x1, y1);\r\n        this.lineTo(x2, y2);\r\n        this.strokePath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draw a line from the current drawing position to the given position.\r\n     *\r\n     * Moves the current drawing position to the given position.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#lineTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to draw the line to.\r\n     * @param {number} y - The y coordinate to draw the line to.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    lineTo: function (x, y)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.LINE_TO,\r\n            x, y\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Move the current drawing position to the given position.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#moveTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to move to.\r\n     * @param {number} y - The y coordinate to move to.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    moveTo: function (x, y)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.MOVE_TO,\r\n            x, y\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke the shape represented by the given array of points.\r\n     *\r\n     * Pass `closeShape` to automatically close the shape by joining the last to the first point.\r\n     *\r\n     * Pass `closePath` to automatically close the path before it is stroked.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokePoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(array|Phaser.Geom.Point[])} points - The points to stroke.\r\n     * @param {boolean} [closeShape=false] - When `true`, the shape is closed by joining the last point to the first point.\r\n     * @param {boolean} [closePath=false] - When `true`, the path is closed before being stroked.\r\n     * @param {number} [endIndex] - The index of `points` to stop drawing at. Defaults to `points.length`.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokePoints: function (points, closeShape, closePath, endIndex)\r\n    {\r\n        if (closeShape === undefined) { closeShape = false; }\r\n        if (closePath === undefined) { closePath = false; }\r\n        if (endIndex === undefined) { endIndex = points.length; }\r\n\r\n        this.beginPath();\r\n\r\n        this.moveTo(points[0].x, points[0].y);\r\n\r\n        for (var i = 1; i < endIndex; i++)\r\n        {\r\n            this.lineTo(points[i].x, points[i].y);\r\n        }\r\n\r\n        if (closeShape)\r\n        {\r\n            this.lineTo(points[0].x, points[0].y);\r\n        }\r\n\r\n        if (closePath)\r\n        {\r\n            this.closePath();\r\n        }\r\n\r\n        this.strokePath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the shape represented by the given array of points.\r\n     *\r\n     * Pass `closeShape` to automatically close the shape by joining the last to the first point.\r\n     *\r\n     * Pass `closePath` to automatically close the path before it is filled.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(array|Phaser.Geom.Point[])} points - The points to fill.\r\n     * @param {boolean} [closeShape=false] - When `true`, the shape is closed by joining the last point to the first point.\r\n     * @param {boolean} [closePath=false] - When `true`, the path is closed before being stroked.\r\n     * @param {number} [endIndex] - The index of `points` to stop at. Defaults to `points.length`.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillPoints: function (points, closeShape, closePath, endIndex)\r\n    {\r\n        if (closeShape === undefined) { closeShape = false; }\r\n        if (closePath === undefined) { closePath = false; }\r\n        if (endIndex === undefined) { endIndex = points.length; }\r\n\r\n        this.beginPath();\r\n\r\n        this.moveTo(points[0].x, points[0].y);\r\n\r\n        for (var i = 1; i < endIndex; i++)\r\n        {\r\n            this.lineTo(points[i].x, points[i].y);\r\n        }\r\n\r\n        if (closeShape)\r\n        {\r\n            this.lineTo(points[0].x, points[0].y);\r\n        }\r\n\r\n        if (closePath)\r\n        {\r\n            this.closePath();\r\n        }\r\n\r\n        this.fillPath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke the given ellipse.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeEllipseShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Ellipse} ellipse - The ellipse to stroke.\r\n     * @param {number} [smoothness=32] - The number of points to draw the ellipse with.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeEllipseShape: function (ellipse, smoothness)\r\n    {\r\n        if (smoothness === undefined) { smoothness = 32; }\r\n\r\n        var points = ellipse.getPoints(smoothness);\r\n\r\n        return this.strokePoints(points, true);\r\n    },\r\n\r\n    /**\r\n     * Stroke an ellipse with the given position and size.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeEllipse\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the center of the ellipse.\r\n     * @param {number} y - The y coordinate of the center of the ellipse.\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     * @param {number} [smoothness=32] - The number of points to draw the ellipse with.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeEllipse: function (x, y, width, height, smoothness)\r\n    {\r\n        if (smoothness === undefined) { smoothness = 32; }\r\n\r\n        var ellipse = new Ellipse(x, y, width, height);\r\n\r\n        var points = ellipse.getPoints(smoothness);\r\n\r\n        return this.strokePoints(points, true);\r\n    },\r\n\r\n    /**\r\n     * Fill the given ellipse.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillEllipseShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Ellipse} ellipse - The ellipse to fill.\r\n     * @param {number} [smoothness=32] - The number of points to draw the ellipse with.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillEllipseShape: function (ellipse, smoothness)\r\n    {\r\n        if (smoothness === undefined) { smoothness = 32; }\r\n\r\n        var points = ellipse.getPoints(smoothness);\r\n\r\n        return this.fillPoints(points, true);\r\n    },\r\n\r\n    /**\r\n     * Fill an ellipse with the given position and size.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillEllipse\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the center of the ellipse.\r\n     * @param {number} y - The y coordinate of the center of the ellipse.\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     * @param {number} [smoothness=32] - The number of points to draw the ellipse with.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillEllipse: function (x, y, width, height, smoothness)\r\n    {\r\n        if (smoothness === undefined) { smoothness = 32; }\r\n\r\n        var ellipse = new Ellipse(x, y, width, height);\r\n\r\n        var points = ellipse.getPoints(smoothness);\r\n\r\n        return this.fillPoints(points, true);\r\n    },\r\n\r\n    /**\r\n     * Draw an arc.\r\n     *\r\n     * This method can be used to create circles, or parts of circles.\r\n     *\r\n     * Make sure you call `beginPath` before starting the arc unless you wish for the arc to automatically\r\n     * close when filled or stroked.\r\n     *\r\n     * Use the optional `overshoot` argument increase the number of iterations that take place when\r\n     * the arc is rendered in WebGL. This is useful if you're drawing an arc with an especially thick line,\r\n     * as it will allow the arc to fully join-up. Try small values at first, i.e. 0.01.\r\n     *\r\n     * Call {@link Phaser.GameObjects.Graphics#fillPath} or {@link Phaser.GameObjects.Graphics#strokePath} after calling\r\n     * this method to draw the arc.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#arc\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the center of the circle.\r\n     * @param {number} y - The y coordinate of the center of the circle.\r\n     * @param {number} radius - The radius of the circle.\r\n     * @param {number} startAngle - The starting angle, in radians.\r\n     * @param {number} endAngle - The ending angle, in radians.\r\n     * @param {boolean} [anticlockwise=false] - Whether the drawing should be anticlockwise or clockwise.\r\n     * @param {number} [overshoot=0] - This value allows you to increase the segment iterations in WebGL rendering. Useful if the arc has a thick stroke and needs to overshoot to join-up cleanly. Use small numbers such as 0.01 to start with and increase as needed.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    arc: function (x, y, radius, startAngle, endAngle, anticlockwise, overshoot)\r\n    {\r\n        if (anticlockwise === undefined) { anticlockwise = false; }\r\n        if (overshoot === undefined) { overshoot = 0; }\r\n\r\n        this.commandBuffer.push(\r\n            Commands.ARC,\r\n            x, y, radius, startAngle, endAngle, anticlockwise, overshoot\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a pie-chart slice shape centered at `x`, `y` with the given radius.\r\n     * You must define the start and end angle of the slice.\r\n     *\r\n     * Setting the `anticlockwise` argument to `true` creates a shape similar to Pacman.\r\n     * Setting it to `false` creates a shape like a slice of pie.\r\n     *\r\n     * This method will begin a new path and close the path at the end of it.\r\n     * To display the actual slice you need to call either `strokePath` or `fillPath` after it.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#slice\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - The horizontal center of the slice.\r\n     * @param {number} y - The vertical center of the slice.\r\n     * @param {number} radius - The radius of the slice.\r\n     * @param {number} startAngle - The start angle of the slice, given in radians.\r\n     * @param {number} endAngle - The end angle of the slice, given in radians.\r\n     * @param {boolean} [anticlockwise=false] - Whether the drawing should be anticlockwise or clockwise.\r\n     * @param {number} [overshoot=0] - This value allows you to overshoot the endAngle by this amount. Useful if the arc has a thick stroke and needs to overshoot to join-up cleanly.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    slice: function (x, y, radius, startAngle, endAngle, anticlockwise, overshoot)\r\n    {\r\n        if (anticlockwise === undefined) { anticlockwise = false; }\r\n        if (overshoot === undefined) { overshoot = 0; }\r\n\r\n        this.commandBuffer.push(Commands.BEGIN_PATH);\r\n\r\n        this.commandBuffer.push(Commands.MOVE_TO, x, y);\r\n\r\n        this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);\r\n\r\n        this.commandBuffer.push(Commands.CLOSE_PATH);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Saves the state of the Graphics by pushing the current state onto a stack.\r\n     *\r\n     * The most recently saved state can then be restored with {@link Phaser.GameObjects.Graphics#restore}.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#save\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    save: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.SAVE\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Restores the most recently saved state of the Graphics by popping from the state stack.\r\n     *\r\n     * Use {@link Phaser.GameObjects.Graphics#save} to save the current state, and call this afterwards to restore that state.\r\n     *\r\n     * If there is no saved state, this command does nothing.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#restore\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    restore: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.RESTORE\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Inserts a translation command into this Graphics objects command buffer.\r\n     *\r\n     * All objects drawn _after_ calling this method will be translated\r\n     * by the given amount.\r\n     *\r\n     * This does not change the position of the Graphics object itself,\r\n     * only of the objects drawn by it after calling this method.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#translateCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal translation to apply.\r\n     * @param {number} y - The vertical translation to apply.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    translateCanvas: function (x, y)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.TRANSLATE,\r\n            x, y\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Inserts a scale command into this Graphics objects command buffer.\r\n     *\r\n     * All objects drawn _after_ calling this method will be scaled\r\n     * by the given amount.\r\n     *\r\n     * This does not change the scale of the Graphics object itself,\r\n     * only of the objects drawn by it after calling this method.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#scaleCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scale to apply.\r\n     * @param {number} y - The vertical scale to apply.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    scaleCanvas: function (x, y)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.SCALE,\r\n            x, y\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Inserts a rotation command into this Graphics objects command buffer.\r\n     *\r\n     * All objects drawn _after_ calling this method will be rotated\r\n     * by the given amount.\r\n     *\r\n     * This does not change the rotation of the Graphics object itself,\r\n     * only of the objects drawn by it after calling this method.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#rotateCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radians - The rotation angle, in radians.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    rotateCanvas: function (radians)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.ROTATE,\r\n            radians\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clear the command buffer and reset the fill style and line style to their defaults.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    clear: function ()\r\n    {\r\n        this.commandBuffer.length = 0;\r\n\r\n        if (this.defaultFillColor > -1)\r\n        {\r\n            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);\r\n        }\r\n\r\n        if (this.defaultStrokeColor > -1)\r\n        {\r\n            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a texture from this Graphics object.\r\n     *\r\n     * If `key` is a string it'll generate a new texture using it and add it into the\r\n     * Texture Manager (assuming no key conflict happens).\r\n     *\r\n     * If `key` is a Canvas it will draw the texture to that canvas context. Note that it will NOT\r\n     * automatically upload it to the GPU in WebGL mode.\r\n     *\r\n     * Please understand that the texture is created via the Canvas API of the browser, therefore some\r\n     * Graphics features, such as `fillGradientStyle`, will not appear on the resulting texture,\r\n     * as they're unsupported by the Canvas API.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#generateTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|HTMLCanvasElement)} key - The key to store the texture with in the Texture Manager, or a Canvas to draw to.\r\n     * @param {number} [width] - The width of the graphics to generate.\r\n     * @param {number} [height] - The height of the graphics to generate.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    generateTexture: function (key, width, height)\r\n    {\r\n        var sys = this.scene.sys;\r\n        var renderer = sys.game.renderer;\r\n\r\n        if (width === undefined) { width = sys.scale.width; }\r\n        if (height === undefined) { height = sys.scale.height; }\r\n\r\n        Graphics.TargetCamera.setScene(this.scene);\r\n        Graphics.TargetCamera.setViewport(0, 0, width, height);\r\n        Graphics.TargetCamera.scrollX = this.x;\r\n        Graphics.TargetCamera.scrollY = this.y;\r\n\r\n        var texture;\r\n        var ctx;\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            if (sys.textures.exists(key))\r\n            {\r\n                //  Key is a string, it DOES exist in the Texture Manager AND is a canvas, so draw to it\r\n\r\n                texture = sys.textures.get(key);\r\n\r\n                var src = texture.getSourceImage();\r\n\r\n                if (src instanceof HTMLCanvasElement)\r\n                {\r\n                    ctx = src.getContext('2d');\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Key is a string and doesn't exist in the Texture Manager, so generate and save it\r\n\r\n                texture = sys.textures.createCanvas(key, width, height);\r\n\r\n                ctx = texture.getSourceImage().getContext('2d');\r\n            }\r\n        }\r\n        else if (key instanceof HTMLCanvasElement)\r\n        {\r\n            //  Key is a Canvas, so draw to it\r\n\r\n            ctx = key.getContext('2d');\r\n        }\r\n\r\n        if (ctx)\r\n        {\r\n            // var GraphicsCanvasRenderer = function (renderer, src, camera, parentMatrix, renderTargetCtx, allowClip)\r\n            this.renderCanvas(renderer, this, Graphics.TargetCamera, null, ctx, false);\r\n\r\n            if (texture)\r\n            {\r\n                texture.refresh();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.commandBuffer = [];\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * A Camera used specifically by the Graphics system for rendering to textures.\r\n *\r\n * @name Phaser.GameObjects.Graphics.TargetCamera\r\n * @type {Phaser.Cameras.Scene2D.Camera}\r\n * @since 3.1.0\r\n */\r\nGraphics.TargetCamera = new BaseCamera();\r\n\r\nmodule.exports = Graphics;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ARC: 0,\r\n    BEGIN_PATH: 1,\r\n    CLOSE_PATH: 2,\r\n    FILL_RECT: 3,\r\n    LINE_TO: 4,\r\n    MOVE_TO: 5,\r\n    LINE_STYLE: 6,\r\n    FILL_STYLE: 7,\r\n    FILL_PATH: 8,\r\n    STROKE_PATH: 9,\r\n    FILL_TRIANGLE: 10,\r\n    STROKE_TRIANGLE: 11,\r\n    SAVE: 14,\r\n    RESTORE: 15,\r\n    TRANSLATE: 16,\r\n    SCALE: 17,\r\n    ROTATE: 18,\r\n    GRADIENT_FILL_STYLE: 21,\r\n    GRADIENT_LINE_STYLE: 22\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../../renderer/BlendModes');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar ComponentsToJSON = require('../components/ToJSON');\r\nvar DataManager = require('../../data/DataManager');\r\nvar EventEmitter = require('eventemitter3');\r\nvar GameObjectEvents = require('../events');\r\nvar List = require('../../structs/List');\r\nvar Render = require('./LayerRender');\r\nvar SceneEvents = require('../../scene/events');\r\nvar StableSort = require('../../utils/array/StableSort');\r\n\r\n/**\r\n * @classdesc\r\n * A Layer Game Object.\r\n *\r\n * A Layer is a special type of Game Object that acts as a Display List. You can add any type of Game Object\r\n * to a Layer, just as you would to a Scene. Layers can be used to visually group together 'layers' of Game\r\n * Objects:\r\n *\r\n * ```javascript\r\n * const spaceman = this.add.sprite(150, 300, 'spaceman');\r\n * const bunny = this.add.sprite(400, 300, 'bunny');\r\n * const elephant = this.add.sprite(650, 300, 'elephant');\r\n *\r\n * const layer = this.add.layer();\r\n *\r\n * layer.add([ spaceman, bunny, elephant ]);\r\n * ```\r\n *\r\n * The 3 sprites in the example above will now be managed by the Layer they were added to. Therefore,\r\n * if you then set `layer.setVisible(false)` they would all vanish from the display.\r\n *\r\n * You can also control the depth of the Game Objects within the Layer. For example, calling the\r\n * `setDepth` method of a child of a Layer will allow you to adjust the depth of that child _within the\r\n * Layer itself_, rather than the whole Scene. The Layer, too, can have its depth set as well.\r\n *\r\n * The Layer class also offers many different methods for manipulating the list, such as the\r\n * methods `moveUp`, `moveDown`, `sendToBack`, `bringToTop` and so on. These allow you to change the\r\n * display list position of the Layers children, causing it to adjust the order in which they are\r\n * rendered. Using `setDepth` on a child allows you to override this.\r\n *\r\n * Layers can have Post FX Pipelines set, which allows you to easily enable a post pipeline across\r\n * a whole range of children, which, depending on the effect, can often be far more efficient that doing so\r\n * on a per-child basis.\r\n *\r\n * Layers have no position or size within the Scene. This means you cannot enable a Layer for\r\n * physics or input, or change the position, rotation or scale of a Layer. They also have no scroll\r\n * factor, texture, tint, origin, crop or bounds.\r\n *\r\n * If you need those kind of features then you should use a Container instead. Containers can be added\r\n * to Layers, but Layers cannot be added to Containers.\r\n *\r\n * However, you can set the Alpha, Blend Mode, Depth, Mask and Visible state of a Layer. These settings\r\n * will impact all children being rendered by the Layer.\r\n *\r\n * @class Layer\r\n * @extends Phaser.Structs.List.<Phaser.GameObjects.GameObject>\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Layer.\r\n */\r\nvar Layer = new Class({\r\n\r\n    Extends: List,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.Visible,\r\n        EventEmitter,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Layer (scene, children)\r\n    {\r\n        List.call(this, scene);\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Scene to which this Game Object belongs.\r\n         *\r\n         * Game Objects can only belong to one Scene.\r\n         *\r\n         * You should consider this property as being read-only. You cannot move a\r\n         * Game Object to another Scene by simply changing it.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.50.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Holds a reference to the Display List that contains this Game Object.\r\n         *\r\n         * This is set automatically when this Game Object is added to a Scene or Layer.\r\n         *\r\n         * You should treat this property as being read-only.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#displayList\r\n         * @type {(Phaser.GameObjects.DisplayList|Phaser.GameObjects.Layer)}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.displayList = null;\r\n\r\n        /**\r\n         * A textual representation of this Game Object, i.e. `sprite`.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#type\r\n         * @type {string}\r\n         * @since 3.50.0\r\n         */\r\n        this.type = 'Layer';\r\n\r\n        /**\r\n         * The current state of this Game Object.\r\n         *\r\n         * Phaser itself will never modify this value, although plugins may do so.\r\n         *\r\n         * Use this property to track the state of a Game Object during its lifetime. For example, it could change from\r\n         * a state of 'moving', to 'attacking', to 'dead'. The state value should be an integer (ideally mapped to a constant\r\n         * in your game code), or a string. These are recommended to keep it light and simple, with fast comparisons.\r\n         * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#state\r\n         * @type {(number|string)}\r\n         * @since 3.50.0\r\n         */\r\n        this.state = 0;\r\n\r\n        /**\r\n         * A Layer cannot be placed inside a Container.\r\n         *\r\n         * This property is kept purely so a Layer has the same\r\n         * shape as a Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#parentContainer\r\n         * @type {Phaser.GameObjects.Container}\r\n         * @since 3.51.0\r\n         */\r\n        this.parentContainer = null;\r\n\r\n        /**\r\n         * The name of this Game Object.\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.50.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * The active state of this Game Object.\r\n         * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.\r\n         * An active object is one which is having its logic and internal systems updated.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.50.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * The Tab Index of the Game Object.\r\n         * Reserved for future use by plugins and the Input Manager.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#tabIndex\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.51.0\r\n         */\r\n        this.tabIndex = -1;\r\n\r\n        /**\r\n         * A Data Manager.\r\n         * It allows you to store, query and get key/value paired information specific to this Game Object.\r\n         * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#data\r\n         * @type {Phaser.Data.DataManager}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.data = null;\r\n\r\n        /**\r\n         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.\r\n         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.\r\n         * If those components are not used by your custom class then you can use this bitmask as you wish.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#renderFlags\r\n         * @type {number}\r\n         * @default 15\r\n         * @since 3.50.0\r\n         */\r\n        this.renderFlags = 15;\r\n\r\n        /**\r\n         * A bitmask that controls if this Game Object is drawn by a Camera or not.\r\n         * Not usually set directly, instead call `Camera.ignore`, however you can\r\n         * set this property directly using the Camera.id property:\r\n         *\r\n         * @example\r\n         * this.cameraFilter |= camera.id\r\n         *\r\n         * @name Phaser.GameObjects.Layer#cameraFilter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.50.0\r\n         */\r\n        this.cameraFilter = 0;\r\n\r\n        /**\r\n         * This property is kept purely so a Layer has the same\r\n         * shape as a Game Object. You cannot input enable a Layer.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#input\r\n         * @type {?Phaser.Types.Input.InteractiveObject}\r\n         * @default null\r\n         * @since 3.51.0\r\n         */\r\n        this.input = null;\r\n\r\n        /**\r\n         * This property is kept purely so a Layer has the same\r\n         * shape as a Game Object. You cannot give a Layer a physics body.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#body\r\n         * @type {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|MatterJS.BodyType)}\r\n         * @default null\r\n         * @since 3.51.0\r\n         */\r\n        this.body = null;\r\n\r\n        /**\r\n         * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.\r\n         * This includes calls that may come from a Group, Container or the Scene itself.\r\n         * While it allows you to persist a Game Object across Scenes, please understand you are entirely\r\n         * responsible for managing references to and from this Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#ignoreDestroy\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.50.0\r\n         */\r\n        this.ignoreDestroy = false;\r\n\r\n        /**\r\n         * A reference to the Scene Systems.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.50.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A reference to the Scene Event Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.50.0\r\n         */\r\n        this.events = scene.sys.events;\r\n\r\n        /**\r\n         * The flag the determines whether Game Objects should be sorted when `depthSort()` is called.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#sortChildrenFlag\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.50.0\r\n         */\r\n        this.sortChildrenFlag = false;\r\n\r\n        //  Set the List callbacks\r\n        this.addCallback = this.addChildCallback;\r\n        this.removeCallback = this.removeChildCallback;\r\n\r\n        this.initPipeline();\r\n\r\n        this.clearAlpha();\r\n\r\n        this.setBlendMode(BlendModes.SKIP_CHECK);\r\n\r\n        if (children)\r\n        {\r\n            this.add(children);\r\n        }\r\n\r\n        //  Tell the Scene to re-sort the children\r\n        scene.sys.queueDepthSort();\r\n    },\r\n\r\n    /**\r\n     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.\r\n     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#setActive\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} value - True if this Game Object should be set as active, false if not.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setActive: function (value)\r\n    {\r\n        this.active = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.\r\n     * The `name` property is not populated by Phaser and is presented for your own use.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#setName\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} value - The name to be given to this Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setName: function (value)\r\n    {\r\n        this.name = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current state of this Game Object.\r\n     *\r\n     * Phaser itself will never modify the State of a Game Object, although plugins may do so.\r\n     *\r\n     * For example, a Game Object could change from a state of 'moving', to 'attacking', to 'dead'.\r\n     * The state value should typically be an integer (ideally mapped to a constant\r\n     * in your game code), but could also be a string. It is recommended to keep it light and simple.\r\n     * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#setState\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|string)} value - The state of the Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setState: function (value)\r\n    {\r\n        this.state = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a Data Manager component to this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#setDataEnabled\r\n     * @since 3.50.0\r\n     * @see Phaser.Data.DataManager\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setDataEnabled: function ()\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Allows you to store a key value pair within this Game Objects Data Manager.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * ```javascript\r\n     * sprite.setData('name', 'Red Gem Stone');\r\n     * ```\r\n     *\r\n     * You can also pass in an object of key value pairs as the first argument:\r\n     *\r\n     * ```javascript\r\n     * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\r\n     * ```\r\n     *\r\n     * To get a value back again you can call `getData`:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or you can access the value directly via the `values` property, where it works like any other variable:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold += 50;\r\n     * ```\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\r\n     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.\r\n     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\r\n     *\r\n     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#setData\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|object)} key - The key to set the value for. Or an object of key value pairs. If an object the `data` argument is ignored.\r\n     * @param {*} [data] - The value to set for the given key. If an object is provided as the key this argument is ignored.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setData: function (key, value)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.set(key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Increase a value for the given key within this Game Objects Data Manager. If the key doesn't already exist in the Data Manager then it is increased from 0.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#incData\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|object)} key - The key to increase the value for.\r\n     * @param {*} [data] - The value to increase for the given key.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    incData: function (key, value)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.inc(key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Toggle a boolean value for the given key within this Game Objects Data Manager. If the key doesn't already exist in the Data Manager then it is toggled from false.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#toggleData\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|object)} key - The key to toggle the value for.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    toggleData: function (key)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.toggle(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.\r\n     *\r\n     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or access the value directly:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold;\r\n     * ```\r\n     *\r\n     * You can also pass in an array of keys, in which case an array of values will be returned:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * This approach is useful for destructuring arrays in ES6.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#getData\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\r\n     *\r\n     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\r\n     */\r\n    getData: function (key)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this.data.get(key);\r\n    },\r\n\r\n    /**\r\n     * A Layer cannot be enabled for input.\r\n     *\r\n     * This method does nothing and is kept to ensure\r\n     * the Layer has the same shape as a Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#setInteractive\r\n     * @since 3.51.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setInteractive: function ()\r\n    {\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * A Layer cannot be enabled for input.\r\n     *\r\n     * This method does nothing and is kept to ensure\r\n     * the Layer has the same shape as a Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#disableInteractive\r\n     * @since 3.51.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    disableInteractive: function ()\r\n    {\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * A Layer cannot be enabled for input.\r\n     *\r\n     * This method does nothing and is kept to ensure\r\n     * the Layer has the same shape as a Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#removeInteractive\r\n     * @since 3.51.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    removeInteractive: function ()\r\n    {\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This callback is invoked when this Game Object is added to a Scene.\r\n     *\r\n     * Can be overriden by custom Game Objects, but be aware of some Game Objects that\r\n     * will use this, such as Sprites, to add themselves into the Update List.\r\n     *\r\n     * You can also listen for the `ADDED_TO_SCENE` event from this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#addedToScene\r\n     * @since 3.50.0\r\n     */\r\n    addedToScene: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * This callback is invoked when this Game Object is removed from a Scene.\r\n     *\r\n     * Can be overriden by custom Game Objects, but be aware of some Game Objects that\r\n     * will use this, such as Sprites, to removed themselves from the Update List.\r\n     *\r\n     * You can also listen for the `REMOVED_FROM_SCENE` event from this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#removedFromScene\r\n     * @since 3.50.0\r\n     */\r\n    removedFromScene: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#update\r\n     * @since 3.50.0\r\n     *\r\n     * @param {...*} [args] - args\r\n     */\r\n    update: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Returns a JSON representation of the Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#toJSON\r\n     * @since 3.50.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return ComponentsToJSON(this);\r\n    },\r\n\r\n    /**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     * Also checks the Game Object against the given Cameras exclusion list.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#willRender\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n     */\r\n    willRender: function (camera)\r\n    {\r\n        return !(this.renderFlags !== 15 || this.list.length === 0 || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the display list index of either this Game Object, or if it has one,\r\n     * its parent Container. It then iterates up through all of the parent containers until it hits the\r\n     * root of the display list (which is index 0 in the returned array).\r\n     *\r\n     * Used internally by the InputPlugin but also useful if you wish to find out the display depth of\r\n     * this Game Object and all of its ancestors.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#getIndexList\r\n     * @since 3.51.0\r\n     *\r\n     * @return {number[]} An array of display list position indexes.\r\n     */\r\n    getIndexList: function ()\r\n    {\r\n        // eslint-disable-next-line consistent-this\r\n        var child = this;\r\n        var parent = this.parentContainer;\r\n\r\n        var indexes = [];\r\n\r\n        while (parent)\r\n        {\r\n            indexes.unshift(parent.getIndex(child));\r\n\r\n            child = parent;\r\n\r\n            if (!parent.parentContainer)\r\n            {\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                parent = parent.parentContainer;\r\n            }\r\n        }\r\n\r\n        indexes.unshift(this.displayList.getIndex(child));\r\n\r\n        return indexes;\r\n    },\r\n\r\n    /**\r\n     * Internal method called from `List.addCallback`.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#addChildCallback\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#ADDED_TO_SCENE\r\n     * @fires Phaser.GameObjects.Events#ADDED_TO_SCENE\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was added to the list.\r\n     */\r\n    addChildCallback: function (gameObject)\r\n    {\r\n        if (gameObject.displayList && gameObject.displayList !== this)\r\n        {\r\n            gameObject.removeFromDisplayList();\r\n        }\r\n\r\n        if (!gameObject.displayList)\r\n        {\r\n            this.queueDepthSort();\r\n\r\n            gameObject.displayList = this;\r\n\r\n            gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);\r\n\r\n            this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method called from `List.removeCallback`.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#removeChildCallback\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#REMOVED_FROM_SCENE\r\n     * @fires Phaser.GameObjects.Events#REMOVED_FROM_SCENE\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was removed from the list.\r\n     */\r\n    removeChildCallback: function (gameObject)\r\n    {\r\n        this.queueDepthSort();\r\n\r\n        gameObject.displayList = null;\r\n\r\n        gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);\r\n\r\n        this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);\r\n    },\r\n\r\n    /**\r\n     * Force a sort of the display list on the next call to depthSort.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#queueDepthSort\r\n     * @since 3.50.0\r\n     */\r\n    queueDepthSort: function ()\r\n    {\r\n        this.sortChildrenFlag = true;\r\n    },\r\n\r\n    /**\r\n     * Immediately sorts the display list if the flag is set.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#depthSort\r\n     * @since 3.50.0\r\n     */\r\n    depthSort: function ()\r\n    {\r\n        if (this.sortChildrenFlag)\r\n        {\r\n            StableSort(this.list, this.sortByDepth);\r\n\r\n            this.sortChildrenFlag = false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Compare the depth of two Game Objects.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#sortByDepth\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - The first Game Object.\r\n     * @param {Phaser.GameObjects.GameObject} childB - The second Game Object.\r\n     *\r\n     * @return {number} The difference between the depths of each Game Object.\r\n     */\r\n    sortByDepth: function (childA, childB)\r\n    {\r\n        return childA._depth - childB._depth;\r\n    },\r\n\r\n    /**\r\n     * Returns an array which contains all Game Objects within this Layer.\r\n     *\r\n     * This is a reference to the main list array, not a copy of it, so be careful not to modify it.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#getChildren\r\n     * @since 3.50.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The group members.\r\n     */\r\n    getChildren: function ()\r\n    {\r\n        return this.list;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Layer removing it from the Display List and Update List and\r\n     * severing all ties to parent resources.\r\n     *\r\n     * Also destroys all children of this Layer. If you do not wish for the\r\n     * children to be destroyed, you should move them from this Layer first.\r\n     *\r\n     * Use this to remove this Layer from your game if you don't ever plan to use it again.\r\n     * As long as no reference to it exists within your own code it should become free for\r\n     * garbage collection by the browser.\r\n     *\r\n     * If you just want to temporarily disable an object then look at using the\r\n     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#destroy\r\n     * @fires Phaser.GameObjects.Events#DESTROY\r\n     * @since 3.50.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        //  This Game Object has already been destroyed\r\n        if (!this.scene || this.ignoreDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.emit(GameObjectEvents.DESTROY, this);\r\n\r\n        var i = this.list.length;\r\n\r\n        while (i--)\r\n        {\r\n            this.list[i].destroy();\r\n        }\r\n\r\n        this.removeAllListeners();\r\n\r\n        this.resetPostPipeline(true);\r\n\r\n        if (this.displayList)\r\n        {\r\n            this.displayList.remove(this, true);\r\n\r\n            this.displayList.queueDepthSort();\r\n        }\r\n\r\n        if (this.data)\r\n        {\r\n            this.data.destroy();\r\n\r\n            this.data = undefined;\r\n        }\r\n\r\n        this.active = false;\r\n        this.visible = false;\r\n\r\n        this.list = undefined;\r\n        this.scene = undefined;\r\n        this.displayList = undefined;\r\n        this.systems = undefined;\r\n        this.events = undefined;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Layer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar GravityWell = require('./GravityWell');\r\nvar List = require('../../structs/List');\r\nvar ParticleEmitter = require('./ParticleEmitter');\r\nvar Render = require('./ParticleManagerRender');\r\n\r\n/**\r\n * @classdesc\r\n * A Particle Emitter Manager creates and controls {@link Phaser.GameObjects.Particles.ParticleEmitter Particle Emitters} and {@link Phaser.GameObjects.Particles.GravityWell Gravity Wells}.\r\n *\r\n * @class ParticleEmitterManager\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Emitter Manager belongs.\r\n * @param {string} texture - The key of the Texture this Emitter Manager will use to render particles, as stored in the Texture Manager.\r\n * @param {(string|number)} [frame] - An optional frame from the Texture this Emitter Manager will use to render particles.\r\n * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig|Phaser.Types.GameObjects.Particles.ParticleEmitterConfig[]} [emitters] - Configuration settings for one or more emitters to create.\r\n */\r\nvar ParticleEmitterManager = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    //  frame is optional and can contain the emitters array or object if skipped\r\n    function ParticleEmitterManager (scene, texture, frame, emitters)\r\n    {\r\n        GameObject.call(this, scene, 'ParticleEmitterManager');\r\n\r\n        /**\r\n         * The blend mode applied to all emitters and particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#blendMode\r\n         * @type {number}\r\n         * @default -1\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.blendMode = -1;\r\n\r\n        /**\r\n         * The time scale applied to all emitters and particles, affecting flow rate, lifespan, and movement.\r\n         * Values larger than 1 are faster than normal.\r\n         * This is multiplied with any timeScale set on each individual emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.timeScale = 1;\r\n\r\n        /**\r\n         * The texture used to render this Emitter Manager's particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.texture = null;\r\n\r\n        /**\r\n         * The texture frame used to render this Emitter Manager's particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.frame = null;\r\n\r\n        /**\r\n         * Names of this Emitter Manager's texture frames.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#frameNames\r\n         * @type {string[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.frameNames = [];\r\n\r\n        //  frame is optional and can contain the emitters array or object if skipped\r\n        if (frame !== null && (typeof frame === 'object' || Array.isArray(frame)))\r\n        {\r\n            emitters = frame;\r\n            frame = null;\r\n        }\r\n\r\n        this.setTexture(texture, frame);\r\n\r\n        this.initPipeline();\r\n\r\n        /**\r\n         * A list of Emitters being managed by this Emitter Manager.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#emitters\r\n         * @type {Phaser.Structs.List.<Phaser.GameObjects.Particles.ParticleEmitter>}\r\n         * @since 3.0.0\r\n         */\r\n        this.emitters = new List(this);\r\n\r\n        /**\r\n         * A list of Gravity Wells being managed by this Emitter Manager.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#wells\r\n         * @type {Phaser.Structs.List.<Phaser.GameObjects.Particles.GravityWell>}\r\n         * @since 3.0.0\r\n         */\r\n        this.wells = new List(this);\r\n\r\n        if (emitters)\r\n        {\r\n            //  An array of emitter configs?\r\n            if (!Array.isArray(emitters))\r\n            {\r\n                emitters = [ emitters ];\r\n            }\r\n\r\n            for (var i = 0; i < emitters.length; i++)\r\n            {\r\n                this.createEmitter(emitters[i]);\r\n            }\r\n        }\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * Sets the texture and frame this Emitter Manager will use to render with.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    setTexture: function (key, frame)\r\n    {\r\n        this.texture = this.scene.sys.textures.get(key);\r\n\r\n        return this.setFrame(frame);\r\n    },\r\n\r\n    /**\r\n     * Sets the frame this Emitter Manager will use to render with.\r\n     *\r\n     * The Frame has to belong to the current Texture being used.\r\n     *\r\n     * It can be either a string or an index.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    setFrame: function (frame)\r\n    {\r\n        this.frame = this.texture.get(frame);\r\n\r\n        var frames = this.texture.getFramesFromTextureSource(this.frame.sourceIndex);\r\n\r\n        var names = [];\r\n\r\n        frames.forEach(function (sourceFrame)\r\n        {\r\n            names.push(sourceFrame.name);\r\n        });\r\n\r\n        this.frameNames = names;\r\n\r\n        this.defaultFrame = this.frame;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Assigns texture frames to an emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setEmitterFrames\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Textures.Frame|Phaser.Textures.Frame[])} frames - The texture frames.\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The particle emitter to modify.\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    setEmitterFrames: function (frames, emitter)\r\n    {\r\n        if (!Array.isArray(frames))\r\n        {\r\n            frames = [ frames ];\r\n        }\r\n\r\n        var out = emitter.frames;\r\n\r\n        out.length = 0;\r\n\r\n        for (var i = 0; i < frames.length; i++)\r\n        {\r\n            var frame = frames[i];\r\n\r\n            if (this.frameNames.indexOf(frame) !== -1)\r\n            {\r\n                out.push(this.texture.get(frame));\r\n            }\r\n        }\r\n\r\n        if (out.length > 0)\r\n        {\r\n            emitter.defaultFrame = out[0];\r\n        }\r\n        else\r\n        {\r\n            emitter.defaultFrame = this.defaultFrame;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds an existing Particle Emitter to this Emitter Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#addEmitter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Particle Emitter to add to this Emitter Manager.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} The Particle Emitter that was added to this Emitter Manager.\r\n     */\r\n    addEmitter: function (emitter)\r\n    {\r\n        return this.emitters.add(emitter);\r\n    },\r\n\r\n    /**\r\n     * Creates a new Particle Emitter object, adds it to this Emitter Manager and returns a reference to it.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#createEmitter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} config - Configuration settings for the Particle Emitter to create.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} The Particle Emitter that was created.\r\n     */\r\n    createEmitter: function (config)\r\n    {\r\n        return this.addEmitter(new ParticleEmitter(this, config));\r\n    },\r\n\r\n    /**\r\n     * Removes a Particle Emitter from this Emitter Manager, if the Emitter belongs to this Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#removeEmitter\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter\r\n     *\r\n     * @return {?Phaser.GameObjects.Particles.ParticleEmitter} The Particle Emitter if it was removed or null if it was not.\r\n     */\r\n    removeEmitter: function (emitter)\r\n    {\r\n        return this.emitters.remove(emitter, true);\r\n    },\r\n\r\n    /**\r\n     * Adds an existing Gravity Well object to this Emitter Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#addGravityWell\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.GravityWell} well - The Gravity Well to add to this Emitter Manager.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.GravityWell} The Gravity Well that was added to this Emitter Manager.\r\n     */\r\n    addGravityWell: function (well)\r\n    {\r\n        return this.wells.add(well);\r\n    },\r\n\r\n    /**\r\n     * Creates a new Gravity Well, adds it to this Emitter Manager and returns a reference to it.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#createGravityWell\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.GravityWellConfig} config - Configuration settings for the Gravity Well to create.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.GravityWell} The Gravity Well that was created.\r\n     */\r\n    createGravityWell: function (config)\r\n    {\r\n        return this.addGravityWell(new GravityWell(config));\r\n    },\r\n\r\n    /**\r\n     * Emits particles from each active emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#emitParticle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [count] - The number of particles to release from each emitter. The default is the emitter's own {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.\r\n     * @param {number} [x] - The x-coordinate to to emit particles from. The default is the x-coordinate of the emitter's current location.\r\n     * @param {number} [y] - The y-coordinate to to emit particles from. The default is the y-coordinate of the emitter's current location.\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    emitParticle: function (count, x, y)\r\n    {\r\n        var emitters = this.emitters.list;\r\n\r\n        for (var i = 0; i < emitters.length; i++)\r\n        {\r\n            var emitter = emitters[i];\r\n\r\n            if (emitter.active)\r\n            {\r\n                emitter.emitParticle(count, x, y);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Emits particles from each active emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#emitParticleAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x] - The x-coordinate to to emit particles from. The default is the x-coordinate of the emitter's current location.\r\n     * @param {number} [y] - The y-coordinate to to emit particles from. The default is the y-coordinate of the emitter's current location.\r\n     * @param {number} [count] - The number of particles to release from each emitter. The default is the emitter's own {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    emitParticleAt: function (x, y, count)\r\n    {\r\n        return this.emitParticle(count, x, y);\r\n    },\r\n\r\n    /**\r\n     * Pauses this Emitter Manager.\r\n     *\r\n     * This has the effect of pausing all emitters, and all particles of those emitters, currently under its control.\r\n     *\r\n     * The particles will still render, but they will not have any of their logic updated.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    pause: function ()\r\n    {\r\n        this.active = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes this Emitter Manager, should it have been previously paused.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    resume: function ()\r\n    {\r\n        this.active = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets all active particle processors (gravity wells).\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#getProcessors\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.GravityWell[]} - The active gravity wells.\r\n     */\r\n    getProcessors: function ()\r\n    {\r\n        return this.wells.getAll('active', true);\r\n    },\r\n\r\n    /**\r\n     * Updates all active emitters.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    preUpdate: function (time, delta)\r\n    {\r\n        //  Scale the delta\r\n        delta *= this.timeScale;\r\n\r\n        var emitters = this.emitters.list;\r\n\r\n        for (var i = 0; i < emitters.length; i++)\r\n        {\r\n            var emitter = emitters[i];\r\n\r\n            if (emitter.active)\r\n            {\r\n                emitter.preUpdate(time, delta);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass an EmitterManager to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setAlpha\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    setAlpha: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass an EmitterManager to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setScrollFactor\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    setScrollFactor: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass an EmitterManager to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setBlendMode\r\n     * @private\r\n     * @since 3.15.0\r\n     */\r\n    setBlendMode: function ()\r\n    {\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ParticleEmitterManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../../renderer/BlendModes');\r\nvar Camera = require('../../cameras/2d/BaseCamera');\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar CONST = require('../../const');\r\nvar Frame = require('../../textures/Frame');\r\nvar GameObject = require('../GameObject');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar PIPELINE_CONST = require('../../renderer/webgl/pipelines/const');\r\nvar Render = require('./RenderTextureRender');\r\nvar RenderTarget = require('../../renderer/webgl/RenderTarget');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\nvar UUID = require('../../utils/string/UUID');\r\n\r\n/**\r\n * @classdesc\r\n * A Render Texture.\r\n *\r\n * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and\r\n * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic\r\n * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.\r\n *\r\n * Note that under WebGL a FrameBuffer, which is what the Render Texture uses internally, cannot be anti-aliased. This means\r\n * that when drawing objects such as Shapes to a Render Texture they will appear to be drawn with no aliasing, however this\r\n * is a technical limitation of WebGL. To get around it, create your shape as a texture in an art package, then draw that\r\n * to the Render Texture.\r\n *\r\n * @class RenderTexture\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.2.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=32] - The width of the Render Texture.\r\n * @param {number} [height=32] - The height of the Render Texture.\r\n * @param {string} [key] - The texture key to make the RenderTexture from.\r\n * @param {string} [frame] - The frame to make the RenderTexture from.\r\n */\r\nvar RenderTexture = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Crop,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function RenderTexture (scene, x, y, width, height, key, frame)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = 32; }\r\n        if (height === undefined) { height = 32; }\r\n\r\n        GameObject.call(this, scene, 'RenderTexture');\r\n\r\n        /**\r\n         * A reference to either the Canvas or WebGL Renderer that the Game instance is using.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.2.0\r\n         */\r\n        this.renderer = scene.sys.renderer;\r\n\r\n        /**\r\n         * A reference to the Texture Manager.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#textureManager\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.12.0\r\n         */\r\n        this.textureManager = scene.sys.textures;\r\n\r\n        /**\r\n         * The tint of the Render Texture when rendered.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#globalTint\r\n         * @type {number}\r\n         * @default 0xffffff\r\n         * @since 3.2.0\r\n         */\r\n        this.globalTint = 0xffffff;\r\n\r\n        /**\r\n         * The alpha of the Render Texture when rendered.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#globalAlpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.2.0\r\n         */\r\n        this.globalAlpha = 1;\r\n\r\n        /**\r\n         * The HTML Canvas Element that the Render Texture is drawing to when using the Canvas Renderer.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.2.0\r\n         */\r\n        this.canvas = null;\r\n\r\n        /**\r\n         * Is this Render Texture dirty or not? If not it won't spend time clearing or filling itself.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#dirty\r\n         * @type {boolean}\r\n         * @since 3.12.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        /**\r\n         * The Texture corresponding to this Render Texture.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.12.0\r\n         */\r\n        this.texture = null;\r\n\r\n        /**\r\n         * The Frame corresponding to this Render Texture.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @since 3.12.0\r\n         */\r\n        this.frame = null;\r\n\r\n        /**\r\n         * Internal saved texture flag.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#_saved\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._saved = false;\r\n\r\n        if (key === undefined)\r\n        {\r\n            this.canvas = CanvasPool.create2D(this, width, height);\r\n\r\n            //  Create a new Texture for this RenderTexture object\r\n            this.texture = scene.sys.textures.addCanvas(UUID(), this.canvas);\r\n\r\n            //  Get the frame\r\n            this.frame = this.texture.get();\r\n        }\r\n        else\r\n        {\r\n            this.texture = scene.sys.textures.get(key);\r\n\r\n            //  Get the frame\r\n            this.frame = this.texture.get(frame);\r\n\r\n            this.canvas = this.frame.source.image;\r\n            this._saved = true;\r\n\r\n            this.dirty = true;\r\n\r\n            this.width = this.frame.cutWidth;\r\n            this.height = this.frame.cutHeight;\r\n        }\r\n\r\n        /**\r\n         * A reference to the Rendering Context belonging to the Canvas Element this Render Texture is drawing to.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.2.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * Internal erase mode flag.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#_eraseMode\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._eraseMode = false;\r\n\r\n        /**\r\n         * An internal Camera that can be used to move around the Render Texture.\r\n         * Control it just like you would any Scene Camera. The difference is that it only impacts the placement of what\r\n         * is drawn to the Render Texture. You can scroll, zoom and rotate this Camera.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#camera\r\n         * @type {Phaser.Cameras.Scene2D.BaseCamera}\r\n         * @since 3.12.0\r\n         */\r\n        this.camera = new Camera(0, 0, width, height);\r\n\r\n        /**\r\n         * The Render Target that belongs to this Render Texture.\r\n         *\r\n         * A Render Target encapsulates a framebuffer and texture for the WebGL Renderer.\r\n         *\r\n         * This property remains `null` under Canvas.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#renderTarget\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @since 3.50.0\r\n         */\r\n        this.renderTarget = null;\r\n\r\n        var renderer = this.renderer;\r\n\r\n        if (!renderer)\r\n        {\r\n            this.drawGameObject = NOOP;\r\n        }\r\n        else if (renderer.type === CONST.WEBGL)\r\n        {\r\n            this.drawGameObject = this.batchGameObjectWebGL;\r\n\r\n            this.renderTarget = new RenderTarget(renderer, width, height, 1, 0, false);\r\n        }\r\n        else if (renderer.type === CONST.CANVAS)\r\n        {\r\n            this.drawGameObject = this.batchGameObjectCanvas;\r\n        }\r\n\r\n        this.camera.setScene(scene);\r\n\r\n        this.setPosition(x, y);\r\n\r\n        if (key === undefined)\r\n        {\r\n            this.setSize(width, height);\r\n        }\r\n\r\n        this.setOrigin(0, 0);\r\n\r\n        this.initPipeline(PIPELINE_CONST.SINGLE_PIPELINE);\r\n    },\r\n\r\n    /**\r\n     * Sets the size of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        return this.resize(width, height);\r\n    },\r\n\r\n    /**\r\n     * Resizes the Render Texture to the new dimensions given.\r\n     *\r\n     * If Render Texture was created from specific frame, only the size of the frame will be changed. The size of the source\r\n     * texture will not change.\r\n     *\r\n     * If Render Texture was not created from specific frame, the following will happen:\r\n     *\r\n     * In WebGL it will destroy and then re-create the frame buffer being used by the Render Texture.\r\n     * In Canvas it will resize the underlying canvas element.\r\n     *\r\n     * Both approaches will erase everything currently drawn to the Render Texture.\r\n     *\r\n     * If the dimensions given are the same as those already being used, calling this method will do nothing.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#resize\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} width - The new width of the Render Texture.\r\n     * @param {number} [height=width] - The new height of the Render Texture. If not specified, will be set the same as the `width`.\r\n     *\r\n     * @return {this} This Render Texture.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        if (height === undefined) { height = width; }\r\n\r\n        var frame = this.frame;\r\n\r\n        if (width !== this.width || height !== this.height)\r\n        {\r\n            if (frame.name === '__BASE')\r\n            {\r\n                //  Resize the texture\r\n\r\n                this.canvas.width = width;\r\n                this.canvas.height = height;\r\n\r\n                this.texture.width = width;\r\n                this.texture.height = height;\r\n\r\n                var renderTarget = this.renderTarget;\r\n\r\n                if (renderTarget)\r\n                {\r\n                    renderTarget.resize(width, height);\r\n\r\n                    frame.glTexture = renderTarget.texture;\r\n\r\n                    frame.source.isRenderTexture = true;\r\n                    frame.source.isGLTexture = true;\r\n                    frame.source.glTexture = renderTarget.texture;\r\n                }\r\n\r\n                this.camera.setSize(width, height);\r\n\r\n                frame.source.width = width;\r\n                frame.source.height = height;\r\n\r\n                frame.setSize(width, height);\r\n\r\n                this.width = width;\r\n                this.height = height;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  Resize the frame\r\n\r\n            var baseFrame = this.texture.getSourceImage();\r\n\r\n            if (frame.cutX + width > baseFrame.width)\r\n            {\r\n                width = baseFrame.width - frame.cutX;\r\n            }\r\n\r\n            if (frame.cutY + height > baseFrame.height)\r\n            {\r\n                height = baseFrame.height - frame.cutY;\r\n            }\r\n\r\n            frame.setSize(width, height, frame.cutX, frame.cutY);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n\r\n        var input = this.input;\r\n\r\n        if (input && !input.customHitArea)\r\n        {\r\n            input.hitArea.width = width;\r\n            input.hitArea.height = height;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the tint to use when rendering this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#setGlobalTint\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} tint - The tint value.\r\n     *\r\n     * @return {this} This Render Texture.\r\n     */\r\n    setGlobalTint: function (tint)\r\n    {\r\n        this.globalTint = tint;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the alpha to use when rendering this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#setGlobalAlpha\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} alpha - The alpha value.\r\n     *\r\n     * @return {this} This Render Texture.\r\n     */\r\n    setGlobalAlpha: function (alpha)\r\n    {\r\n        this.globalAlpha = alpha;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stores a copy of this Render Texture in the Texture Manager using the given key.\r\n     *\r\n     * After doing this, any texture based Game Object, such as a Sprite, can use the contents of this\r\n     * Render Texture by using the texture key:\r\n     *\r\n     * ```javascript\r\n     * var rt = this.add.renderTexture(0, 0, 128, 128);\r\n     *\r\n     * // Draw something to the Render Texture\r\n     *\r\n     * rt.saveTexture('doodle');\r\n     *\r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     *\r\n     * Updating the contents of this Render Texture will automatically update _any_ Game Object\r\n     * that is using it as a texture. Calling `saveTexture` again will not save another copy\r\n     * of the same texture, it will just rename the key of the existing copy.\r\n     *\r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame from a Render Texture.\r\n     *\r\n     * If you destroy this Render Texture, any Game Object using it via the Texture Manager will\r\n     * stop rendering. Ensure you remove the texture from the Texture Manager and any Game Objects\r\n     * using it first, before destroying this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#saveTexture\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was saved.\r\n     */\r\n    saveTexture: function (key)\r\n    {\r\n        this.textureManager.renameTexture(this.texture.key, key);\r\n\r\n        this._saved = true;\r\n\r\n        return this.texture;\r\n    },\r\n\r\n    /**\r\n     * Fills the Render Texture with the given color.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#fill\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} rgb - The color to fill the Render Texture with.\r\n     * @param {number} [alpha=1] - The alpha value used by the fill.\r\n     * @param {number} [x=0] - The left coordinate of the fill rectangle.\r\n     * @param {number} [y=0] - The top coordinate of the fill rectangle.\r\n     * @param {number} [width=this.frame.cutWidth] - The width of the fill rectangle.\r\n     * @param {number} [height=this.frame.cutHeight] - The height of the fill rectangle.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    fill: function (rgb, alpha, x, y, width, height)\r\n    {\r\n        var frame = this.frame;\r\n        var camera = this.camera;\r\n        var renderer = this.renderer;\r\n\r\n        if (alpha === undefined) { alpha = 1; }\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = frame.cutWidth; }\r\n        if (height === undefined) { height = frame.cutHeight; }\r\n\r\n        var r = (rgb >> 16 & 0xFF) / 255;\r\n        var g = (rgb >> 8 & 0xFF) / 255;\r\n        var b = (rgb & 0xFF) / 255;\r\n\r\n        var renderTarget = this.renderTarget;\r\n\r\n        camera.preRender();\r\n\r\n        if (renderTarget)\r\n        {\r\n            renderTarget.bind(true);\r\n\r\n            var pipeline = this.pipeline;\r\n\r\n            pipeline.manager.set(pipeline);\r\n\r\n            var tw = renderTarget.width;\r\n            var th = renderTarget.height;\r\n\r\n            var rw = renderer.width;\r\n            var rh = renderer.height;\r\n\r\n            var sx = rw / tw;\r\n            var sy = rh / th;\r\n\r\n            pipeline.drawFillRect(\r\n                x * sx, y * sy, width * sx, height * sy,\r\n                Utils.getTintFromFloats(b, g, r, 1),\r\n                alpha\r\n            );\r\n\r\n            renderTarget.unbind(true);\r\n        }\r\n        else\r\n        {\r\n            var ctx = this.context;\r\n\r\n            renderer.setContext(ctx);\r\n\r\n            ctx.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';\r\n            ctx.fillRect(x + frame.cutX, y + frame.cutY, width, height);\r\n\r\n            renderer.setContext();\r\n        }\r\n\r\n        this.dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clears the Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#clear\r\n     * @since 3.2.0\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    clear: function ()\r\n    {\r\n        if (this.dirty)\r\n        {\r\n            var renderTarget = this.renderTarget;\r\n\r\n            if (renderTarget)\r\n            {\r\n                renderTarget.clear();\r\n            }\r\n            else\r\n            {\r\n                var ctx = this.context;\r\n\r\n                ctx.save();\r\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n                ctx.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight);\r\n                ctx.restore();\r\n            }\r\n\r\n            this.dirty = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the given object, or an array of objects, to this Render Texture using a blend mode of ERASE.\r\n     * This has the effect of erasing any filled pixels in the objects from this Render Texture.\r\n     *\r\n     * It can accept any of the following:\r\n     *\r\n     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n     * * Tilemap Layers.\r\n     * * A Group. The contents of which will be iterated and drawn in turn.\r\n     * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n     * * Another Render Texture.\r\n     * * A Texture Frame instance.\r\n     * * A string. This is used to look-up a texture from the Texture Manager.\r\n     *\r\n     * Note: You cannot erase a Render Texture from itself.\r\n     *\r\n     * If passing in a Group or Container it will only draw children that return `true`\r\n     * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n     * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n     *\r\n     * If passing in an array of Game Objects it will draw them all, regardless if\r\n     * they pass a `willRender` check or not.\r\n     *\r\n     * You can pass in a string in which case it will look for a texture in the Texture\r\n     * Manager matching that string, and draw the base frame.\r\n     *\r\n     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n     * the coordinates differ based on what objects are being drawn. If the object is\r\n     * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n     * of the children. For all other types of object, the coordinates are exact.\r\n     *\r\n     * Calling this method causes the WebGL batch to flush, so it can write the texture\r\n     * data to the framebuffer being used internally. The batch is flushed at the end,\r\n     * after the entries have been iterated. So if you've a bunch of objects to draw,\r\n     * try and pass them in an array in one single call, rather than making lots of\r\n     * separate calls.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#erase\r\n     * @since 3.16.0\r\n     *\r\n     * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n     * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    erase: function (entries, x, y)\r\n    {\r\n        this._eraseMode = true;\r\n\r\n        this.draw(entries, x, y, 1, 16777215);\r\n\r\n        this._eraseMode = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the given object, or an array of objects, to this Render Texture.\r\n     *\r\n     * It can accept any of the following:\r\n     *\r\n     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n     * * Tilemap Layers.\r\n     * * A Group. The contents of which will be iterated and drawn in turn.\r\n     * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n     * * Another Render Texture.\r\n     * * A Texture Frame instance.\r\n     * * A string. This is used to look-up a texture from the Texture Manager.\r\n     *\r\n     * Note: You cannot draw a Render Texture to itself.\r\n     *\r\n     * If passing in a Group or Container it will only draw children that return `true`\r\n     * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n     * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n     *\r\n     * If passing in an array of Game Objects it will draw them all, regardless if\r\n     * they pass a `willRender` check or not.\r\n     *\r\n     * You can pass in a string in which case it will look for a texture in the Texture\r\n     * Manager matching that string, and draw the base frame. If you need to specify\r\n     * exactly which frame to draw then use the method `drawFrame` instead.\r\n     *\r\n     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n     * the coordinates differ based on what objects are being drawn. If the object is\r\n     * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n     * of the children. For all other types of object, the coordinates are exact.\r\n     *\r\n     * The `alpha` and `tint` values are only used by Texture Frames.\r\n     * Game Objects use their own alpha and tint values when being drawn.\r\n     *\r\n     * Calling this method causes the WebGL batch to flush, so it can write the texture\r\n     * data to the framebuffer being used internally. The batch is flushed at the end,\r\n     * after the entries have been iterated. So if you've a bunch of objects to draw,\r\n     * try and pass them in an array in one single call, rather than making lots of\r\n     * separate calls.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#draw\r\n     * @since 3.2.0\r\n     *\r\n     * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n     * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [alpha] -  The alpha value. Only used for Texture Frames and if not specified defaults to the `globalAlpha` property. Game Objects use their own current alpha value.\r\n     * @param {number} [tint] -  WebGL only. The tint color value. Only used for Texture Frames and if not specified defaults to the `globalTint` property. Game Objects use their own current tint value.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    draw: function (entries, x, y, alpha, tint)\r\n    {\r\n        this.beginDraw();\r\n        this.batchDraw(entries, x, y, alpha, tint);\r\n        this.endDraw();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the Texture Frame to the Render Texture at the given position.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * ```javascript\r\n     * var rt = this.add.renderTexture(0, 0, 800, 600);\r\n     * rt.drawFrame(key, frame);\r\n     * ```\r\n     *\r\n     * You can optionally provide a position, alpha and tint value to apply to the frame\r\n     * before it is drawn.\r\n     *\r\n     * Calling this method will cause a batch flush, so if you've got a stack of things to draw\r\n     * in a tight loop, try using the `draw` method instead.\r\n     *\r\n     * If you need to draw a Sprite to this Render Texture, use the `draw` method instead.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#drawFrame\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     * @param {number} [x=0] - The x position to draw the frame at.\r\n     * @param {number} [y=0] - The y position to draw the frame at.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - WebGL only. The tint color to use. If not specified it uses the `globalTint` property.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    drawFrame: function (key, frame, x, y, alpha, tint)\r\n    {\r\n        this.beginDraw();\r\n        this.batchDrawFrame(key, frame, x, y, alpha, tint);\r\n        this.endDraw();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Use this method if you need to batch draw a large number of Game Objects to\r\n     * this Render Texture in a single go, or on a frequent basis.\r\n     *\r\n     * This method starts the beginning of a batched draw.\r\n     *\r\n     * It is faster than calling `draw`, but you must be very careful to manage the\r\n     * flow of code and remember to call `endDraw()`. If you don't need to draw large\r\n     * numbers of objects it's much safer and easier to use the `draw` method instead.\r\n     *\r\n     * The flow should be:\r\n     *\r\n     * ```javascript\r\n     * // Call once:\r\n     * RenderTexture.beginDraw();\r\n     *\r\n     * // repeat n times:\r\n     * RenderTexture.batchDraw();\r\n     * // or\r\n     * RenderTexture.batchDrawFrame();\r\n     *\r\n     * // Call once:\r\n     * RenderTexture.endDraw();\r\n     * ```\r\n     *\r\n     * Do not call any methods other than `batchDraw`, `batchDrawFrame`, or `endDraw` once you\r\n     * have started a batch. Also, be very careful not to destroy this Render Texture while the\r\n     * batch is still open, or call `beginDraw` again.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#beginDraw\r\n     * @since 3.50.0\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    beginDraw: function ()\r\n    {\r\n        var camera = this.camera;\r\n        var renderer = this.renderer;\r\n        var renderTarget = this.renderTarget;\r\n\r\n        camera.preRender();\r\n\r\n        if (renderTarget)\r\n        {\r\n            renderer.beginCapture(renderTarget.width, renderTarget.height);\r\n        }\r\n        else\r\n        {\r\n            renderer.setContext(this.context);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Use this method if you have already called `beginDraw` and need to batch\r\n     * draw a large number of objects to this Render Texture.\r\n     *\r\n     * This method batches the drawing of the given objects to this Render Texture,\r\n     * without causing a bind or batch flush.\r\n     *\r\n     * It is faster than calling `draw`, but you must be very careful to manage the\r\n     * flow of code and remember to call `endDraw()`. If you don't need to draw large\r\n     * numbers of objects it's much safer and easier to use the `draw` method instead.\r\n     *\r\n     * The flow should be:\r\n     *\r\n     * ```javascript\r\n     * // Call once:\r\n     * RenderTexture.beginDraw();\r\n     *\r\n     * // repeat n times:\r\n     * RenderTexture.batchDraw();\r\n     * // or\r\n     * RenderTexture.batchDrawFrame();\r\n     *\r\n     * // Call once:\r\n     * RenderTexture.endDraw();\r\n     * ```\r\n     *\r\n     * Do not call any methods other than `batchDraw`, `batchDrawFrame`, or `endDraw` once you\r\n     * have started a batch. Also, be very careful not to destroy this Render Texture while the\r\n     * batch is still open, or call `beginDraw` again.\r\n     *\r\n     * Draws the given object, or an array of objects, to this Render Texture.\r\n     *\r\n     * It can accept any of the following:\r\n     *\r\n     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n     * * Tilemap Layers.\r\n     * * A Group. The contents of which will be iterated and drawn in turn.\r\n     * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n     * * Another Render Texture.\r\n     * * A Texture Frame instance.\r\n     * * A string. This is used to look-up a texture from the Texture Manager.\r\n     *\r\n     * Note: You cannot draw a Render Texture to itself.\r\n     *\r\n     * If passing in a Group or Container it will only draw children that return `true`\r\n     * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n     * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n     *\r\n     * If passing in an array of Game Objects it will draw them all, regardless if\r\n     * they pass a `willRender` check or not.\r\n     *\r\n     * You can pass in a string in which case it will look for a texture in the Texture\r\n     * Manager matching that string, and draw the base frame. If you need to specify\r\n     * exactly which frame to draw then use the method `drawFrame` instead.\r\n     *\r\n     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n     * the coordinates differ based on what objects are being drawn. If the object is\r\n     * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n     * of the children. For all other types of object, the coordinates are exact.\r\n     *\r\n     * The `alpha` and `tint` values are only used by Texture Frames.\r\n     * Game Objects use their own alpha and tint values when being drawn.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchDraw\r\n     * @since 3.50.0\r\n     *\r\n     * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n     * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [alpha] -  The alpha value. Only used for Texture Frames and if not specified defaults to the `globalAlpha` property. Game Objects use their own current alpha value.\r\n     * @param {number} [tint] -  WebGL only. The tint color value. Only used for Texture Frames and if not specified defaults to the `globalTint` property. Game Objects use their own current tint value.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    batchDraw: function (entries, x, y, alpha, tint)\r\n    {\r\n        if (alpha === undefined) { alpha = this.globalAlpha; }\r\n\r\n        if (tint === undefined)\r\n        {\r\n            tint = (this.globalTint >> 16) + (this.globalTint & 0xff00) + ((this.globalTint & 0xff) << 16);\r\n        }\r\n        else\r\n        {\r\n            tint = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16);\r\n        }\r\n\r\n        if (!Array.isArray(entries))\r\n        {\r\n            entries = [ entries ];\r\n        }\r\n\r\n        this.batchList(entries, x, y, alpha, tint);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Use this method if you have already called `beginDraw` and need to batch\r\n     * draw a large number of texture frames to this Render Texture.\r\n     *\r\n     * This method batches the drawing of the given frames to this Render Texture,\r\n     * without causing a bind or batch flush.\r\n     *\r\n     * It is faster than calling `drawFrame`, but you must be very careful to manage the\r\n     * flow of code and remember to call `endDraw()`. If you don't need to draw large\r\n     * numbers of frames it's much safer and easier to use the `drawFrame` method instead.\r\n     *\r\n     * The flow should be:\r\n     *\r\n     * ```javascript\r\n     * // Call once:\r\n     * RenderTexture.beginDraw();\r\n     *\r\n     * // repeat n times:\r\n     * RenderTexture.batchDraw();\r\n     * // or\r\n     * RenderTexture.batchDrawFrame();\r\n     *\r\n     * // Call once:\r\n     * RenderTexture.endDraw();\r\n     * ```\r\n     *\r\n     * Do not call any methods other than `batchDraw`, `batchDrawFrame`, or `endDraw` once you\r\n     * have started a batch. Also, be very careful not to destroy this Render Texture while the\r\n     * batch is still open, or call `beginDraw` again.\r\n     *\r\n     * Draws the Texture Frame to the Render Texture at the given position.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * ```javascript\r\n     * var rt = this.add.renderTexture(0, 0, 800, 600);\r\n     * rt.drawFrame(key, frame);\r\n     * ```\r\n     *\r\n     * You can optionally provide a position, alpha and tint value to apply to the frame\r\n     * before it is drawn.\r\n     *\r\n     * Calling this method will cause a batch flush, so if you've got a stack of things to draw\r\n     * in a tight loop, try using the `draw` method instead.\r\n     *\r\n     * If you need to draw a Sprite to this Render Texture, use the `draw` method instead.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchDrawFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     * @param {number} [x=0] - The x position to draw the frame at.\r\n     * @param {number} [y=0] - The y position to draw the frame at.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - WebGL only. The tint color to use. If not specified it uses the `globalTint` property.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    batchDrawFrame: function (key, frame, x, y, alpha, tint)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (alpha === undefined) { alpha = this.globalAlpha; }\r\n\r\n        if (tint === undefined)\r\n        {\r\n            tint = (this.globalTint >> 16) + (this.globalTint & 0xff00) + ((this.globalTint & 0xff) << 16);\r\n        }\r\n        else\r\n        {\r\n            tint = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16);\r\n        }\r\n\r\n        var textureFrame = this.textureManager.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            if (this.renderTarget)\r\n            {\r\n                this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);\r\n            }\r\n            else\r\n            {\r\n                this.batchTextureFrame(textureFrame, x + this.frame.cutX, y + this.frame.cutY, alpha, tint);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Use this method to finish batch drawing to this Render Texture.\r\n     *\r\n     * Never call this method without first calling `beginDraw`.\r\n     *\r\n     * It is faster than calling `draw`, but you must be very careful to manage the\r\n     * flow of code and remember to call `endDraw()`. If you don't need to draw large\r\n     * numbers of objects it's much safer and easier to use the `draw` method instead.\r\n     *\r\n     * The flow should be:\r\n     *\r\n     * ```javascript\r\n     * // Call once:\r\n     * RenderTexture.beginDraw();\r\n     *\r\n     * // repeat n times:\r\n     * RenderTexture.batchDraw();\r\n     * // or\r\n     * RenderTexture.batchDrawFrame();\r\n     *\r\n     * // Call once:\r\n     * RenderTexture.endDraw();\r\n     * ```\r\n     *\r\n     * Do not call any methods other than `batchDraw`, `batchDrawFrame`, or `endDraw` once you\r\n     * have started a batch. Also, be very careful not to destroy this Render Texture while the\r\n     * batch is still open, or call `beginDraw` again.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#endDraw\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [erase=false] - Draws all objects in this batch using a blend mode of ERASE. This has the effect of erasing any filled pixels in the objects being drawn.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    endDraw: function (erase)\r\n    {\r\n        if (erase === undefined) { erase = this._eraseMode; }\r\n\r\n        var renderer = this.renderer;\r\n\r\n        var renderTarget = this.renderTarget;\r\n\r\n        if (renderTarget)\r\n        {\r\n            var canvasTarget = renderer.endCapture();\r\n\r\n            var util = renderer.pipelines.setUtility();\r\n\r\n            util.blitFrame(canvasTarget, renderTarget, 1, false, false, erase);\r\n\r\n            renderer.resetScissor();\r\n            renderer.resetViewport();\r\n        }\r\n        else\r\n        {\r\n            renderer.setContext();\r\n        }\r\n\r\n        this.dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing of an array of children.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchList\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {array} children - The array of Game Objects to draw.\r\n     * @param {number} [x] - The x position to offset the Game Object by.\r\n     * @param {number} [y] - The y position to offset the Game Object by.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.\r\n     */\r\n    batchList: function (children, x, y, alpha, tint)\r\n    {\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            var entry = children[i];\r\n\r\n            if (!entry || entry === this)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (entry.renderWebGL || entry.renderCanvas)\r\n            {\r\n                //  Game Objects\r\n                this.drawGameObject(entry, x, y);\r\n            }\r\n            else if (entry.isParent || entry.list)\r\n            {\r\n                //  Groups / Display Lists\r\n                this.batchGroup(entry.getChildren(), x, y);\r\n            }\r\n            else if (typeof entry === 'string')\r\n            {\r\n                //  Texture key\r\n                this.batchTextureFrameKey(entry, null, x, y, alpha, tint);\r\n            }\r\n            else if (entry instanceof Frame)\r\n            {\r\n                //  Texture Frame instance\r\n                this.batchTextureFrame(entry, x, y, alpha, tint);\r\n            }\r\n            else if (Array.isArray(entry))\r\n            {\r\n                //  Another Array\r\n                this.batchList(entry, x, y, alpha, tint);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles drawing a Phaser Group contents.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchGroup\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {array} children - The array of Game Objects to draw.\r\n     * @param {number} [x=0] - The x position to offset the Game Object by.\r\n     * @param {number} [y=0] - The y position to offset the Game Object by.\r\n     */\r\n    batchGroup: function (children, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        x += this.frame.cutX;\r\n        y += this.frame.cutY;\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            var entry = children[i];\r\n\r\n            if (entry.willRender(this.camera))\r\n            {\r\n                var tx = entry.x + x;\r\n                var ty = entry.y + y;\r\n\r\n                this.drawGameObject(entry, tx, ty);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles drawing a single Phaser Game Object to this Render Texture using WebGL.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchGameObjectWebGL\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.\r\n     * @param {number} [x] - The x position to draw the Game Object at.\r\n     * @param {number} [y] - The y position to draw the Game Object at.\r\n     */\r\n    batchGameObjectWebGL: function (gameObject, x, y)\r\n    {\r\n        if (x === undefined) { x = gameObject.x; }\r\n        if (y === undefined) { y = gameObject.y; }\r\n\r\n        var prevX = gameObject.x;\r\n        var prevY = gameObject.y;\r\n\r\n        gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);\r\n\r\n        if (gameObject.renderDirect)\r\n        {\r\n            gameObject.renderDirect(this.renderer, gameObject, this.camera);\r\n        }\r\n        else\r\n        {\r\n            gameObject.renderWebGL(this.renderer, gameObject, this.camera);\r\n        }\r\n\r\n        gameObject.setPosition(prevX, prevY);\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles drawing a single Phaser Game Object to this Render Texture using Canvas.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchGameObjectCanvas\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.\r\n     * @param {number} [x] - The x position to draw the Game Object at.\r\n     * @param {number} [y] - The y position to draw the Game Object at.\r\n     */\r\n    batchGameObjectCanvas: function (gameObject, x, y)\r\n    {\r\n        if (x === undefined) { x = gameObject.x; }\r\n        if (y === undefined) { y = gameObject.y; }\r\n\r\n        var prevX = gameObject.x;\r\n        var prevY = gameObject.y;\r\n\r\n        if (this._eraseMode)\r\n        {\r\n            var blendMode = gameObject.blendMode;\r\n\r\n            gameObject.blendMode = BlendModes.ERASE;\r\n        }\r\n\r\n        gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);\r\n\r\n        gameObject.renderCanvas(this.renderer, gameObject, this.camera, null);\r\n\r\n        gameObject.setPosition(prevX, prevY);\r\n\r\n        if (this._eraseMode)\r\n        {\r\n            gameObject.blendMode = blendMode;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing of an array of children.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchTextureFrameKey\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     * @param {number} [x=0] - The x position to offset the Game Object by.\r\n     * @param {number} [y=0] - The y position to offset the Game Object by.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.\r\n     */\r\n    batchTextureFrameKey: function (key, frame, x, y, alpha, tint)\r\n    {\r\n        var textureFrame = this.textureManager.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            this.batchTextureFrame(textureFrame, x, y, alpha, tint);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing of a Texture Frame to this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchTextureFrame\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.Textures.Frame} textureFrame - The Texture Frame to draw.\r\n     * @param {number} [x=0] - The x position to draw the Frame at.\r\n     * @param {number} [y=0] - The y position to draw the Frame at.\r\n     * @param {number} [tint] - A tint color to be applied to the frame drawn to the Render Texture.\r\n     */\r\n    batchTextureFrame: function (textureFrame, x, y, alpha, tint)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        x += this.frame.cutX;\r\n        y += this.frame.cutY;\r\n\r\n        var renderTarget = this.renderTarget;\r\n\r\n        if (renderTarget)\r\n        {\r\n            this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);\r\n        }\r\n        else\r\n        {\r\n            var ctx = this.context;\r\n            var cd = textureFrame.canvasData;\r\n            var source = textureFrame.source.image;\r\n\r\n            var matrix = this.camera.matrix;\r\n\r\n            ctx.save();\r\n\r\n            ctx.globalCompositeOperation = (this._eraseMode) ? 'destination-out' : 'source-over';\r\n\r\n            ctx.globalAlpha = alpha;\r\n\r\n            matrix.setToContext(ctx);\r\n\r\n            ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);\r\n\r\n            ctx.restore();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the given area of this Render Texture.\r\n     *\r\n     * The snapshot is taken immediately.\r\n     *\r\n     * To capture the whole Render Texture see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n     *\r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#snapshotArea\r\n     * @since 3.19.0\r\n     *\r\n     * @param {number} x - The x coordinate to grab from.\r\n     * @param {number} y - The y coordinate to grab from.\r\n     * @param {number} width - The width of the area to grab.\r\n     * @param {number} height - The height of the area to grab.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)\r\n    {\r\n        if (this.renderTarget)\r\n        {\r\n            this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, x, y, width, height, type, encoderOptions);\r\n        }\r\n        else\r\n        {\r\n            this.renderer.snapshotCanvas(this.canvas, callback, false, x, y, width, height, type, encoderOptions);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the whole of this Render Texture.\r\n     *\r\n     * The snapshot is taken immediately.\r\n     *\r\n     * To capture just a portion of the Render Texture see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n     *\r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#snapshot\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    snapshot: function (callback, type, encoderOptions)\r\n    {\r\n        if (this.renderTarget)\r\n        {\r\n            this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, 0, 0, this.width, this.height, type, encoderOptions);\r\n        }\r\n        else\r\n        {\r\n            this.renderer.snapshotCanvas(this.canvas, callback, false, 0, 0, this.width, this.height, type, encoderOptions);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the given pixel from this Render Texture.\r\n     *\r\n     * The snapshot is taken immediately.\r\n     *\r\n     * To capture the whole Render Texture see the `snapshot` method. To capture a specific portion, see `snapshotArea`.\r\n     *\r\n     * Unlike the other two snapshot methods, this one will send your callback a `Color` object containing the color data for\r\n     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n     * using less memory, than the other snapshot methods.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#snapshotPixel\r\n     * @since 3.19.0\r\n     *\r\n     * @param {number} x - The x coordinate of the pixel to get.\r\n     * @param {number} y - The y coordinate of the pixel to get.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    snapshotPixel: function (x, y, callback)\r\n    {\r\n        if (this.renderTarget)\r\n        {\r\n            this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, true, x, y);\r\n        }\r\n        else\r\n        {\r\n            this.renderer.snapshotCanvas(this.canvas, callback, true, x, y);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (!this._saved)\r\n        {\r\n            CanvasPool.remove(this.canvas);\r\n\r\n            if (this.renderTarget)\r\n            {\r\n                this.renderTarget.destroy();\r\n            }\r\n\r\n            this.texture.destroy();\r\n            this.camera.destroy();\r\n\r\n            this.canvas = null;\r\n            this.context = null;\r\n            this.texture = null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = RenderTexture;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AnimationState = require('../../animations/AnimationState');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar PIPELINE_CONST = require('../../renderer/webgl/pipelines/const');\r\nvar RopeRender = require('./RopeRender');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Rope Game Object.\r\n *\r\n * The Rope object is WebGL only and does not have a Canvas counterpart.\r\n *\r\n * A Rope is a special kind of Game Object that has a texture that repeats along its entire length.\r\n * Unlike a Sprite, it isn't restricted to using just a quad and can have as many vertices as you define\r\n * when creating it. The vertices can be arranged in a horizontal or vertical strip and have their own\r\n * color and alpha values as well.\r\n *\r\n * A Ropes origin is always 0.5 x 0.5 and cannot be changed.\r\n *\r\n * @class Rope\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @webglOnly\r\n * @since 3.23.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {string} [texture] - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager. If not given, `__DEFAULT` is used.\r\n * @param {(string|number|null)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * @param {(number|Phaser.Types.Math.Vector2Like[])} [points=2] - An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided a simple quad is created. See `setPoints` to set this post-creation.\r\n * @param {boolean} [horizontal=true] - Should the vertices of this Rope be aligned horizontally (`true`), or vertically (`false`)?\r\n * @param {number[]} [colors] - An optional array containing the color data for this Rope. You should provide one color value per pair of vertices.\r\n * @param {number[]} [alphas] - An optional array containing the alpha data for this Rope. You should provide one alpha value per pair of vertices.\r\n */\r\nvar Rope = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.Size,\r\n        Components.Texture,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Components.ScrollFactor,\r\n        RopeRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Rope (scene, x, y, texture, frame, points, horizontal, colors, alphas)\r\n    {\r\n        if (texture === undefined) { texture = '__DEFAULT'; }\r\n        if (points === undefined) { points = 2; }\r\n        if (horizontal === undefined) { horizontal = true; }\r\n\r\n        GameObject.call(this, scene, 'Rope');\r\n\r\n        /**\r\n         * The Animation State of this Rope.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#anims\r\n         * @type {Phaser.Animations.AnimationState}\r\n         * @since 3.23.0\r\n         */\r\n        this.anims = new AnimationState(this);\r\n\r\n        /**\r\n         * An array containing the points data for this Rope.\r\n         *\r\n         * Each point should be given as a Vector2Like object (i.e. a Vector2, Geom.Point or object with public x/y properties).\r\n         *\r\n         * The point coordinates are given in local space, where 0 x 0 is the start of the Rope strip.\r\n         *\r\n         * You can modify the contents of this array directly in real-time to create interesting effects.\r\n         * If you do so, be sure to call `setDirty` _after_ modifying this array, so that the vertices data is\r\n         * updated before the next render. Alternatively, you can use the `setPoints` method instead.\r\n         *\r\n         * Should you need to change the _size_ of this array, then you should always use the `setPoints` method.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#points\r\n         * @type {Phaser.Types.Math.Vector2Like[]}\r\n         * @since 3.23.0\r\n         */\r\n        this.points = points;\r\n\r\n        /**\r\n         * An array containing the vertices data for this Rope.\r\n         *\r\n         * This data is calculated automatically in the `updateVertices` method, based on the points provided.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#vertices\r\n         * @type {Float32Array}\r\n         * @since 3.23.0\r\n         */\r\n        this.vertices;\r\n\r\n        /**\r\n         * An array containing the uv data for this Rope.\r\n         *\r\n         * This data is calculated automatically in the `setPoints` method, based on the points provided.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#uv\r\n         * @type {Float32Array}\r\n         * @since 3.23.0\r\n         */\r\n        this.uv;\r\n\r\n        /**\r\n         * An array containing the color data for this Rope.\r\n         *\r\n         * Colors should be given as numeric RGB values, such as 0xff0000.\r\n         * You should provide _two_ color values for every point in the Rope, one for the top and one for the bottom of each quad.\r\n         *\r\n         * You can modify the contents of this array directly in real-time, however, should you need to change the _size_\r\n         * of the array, then you should use the `setColors` method instead.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#colors\r\n         * @type {Uint32Array}\r\n         * @since 3.23.0\r\n         */\r\n        this.colors;\r\n\r\n        /**\r\n         * An array containing the alpha data for this Rope.\r\n         *\r\n         * Alphas should be given as float values, such as 0.5.\r\n         * You should provide _two_ alpha values for every point in the Rope, one for the top and one for the bottom of each quad.\r\n         *\r\n         * You can modify the contents of this array directly in real-time, however, should you need to change the _size_\r\n         * of the array, then you should use the `setAlphas` method instead.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#alphas\r\n         * @type {Float32Array}\r\n         * @since 3.23.0\r\n         */\r\n        this.alphas;\r\n\r\n        /**\r\n         * The tint fill mode.\r\n         *\r\n        * `false` = An additive tint (the default), where vertices colors are blended with the texture.\r\n        * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#tintFill\r\n         * @type {boolean}\r\n         * @since 3.23.0\r\n         */\r\n        this.tintFill = (texture === '__DEFAULT') ? true : false;\r\n\r\n        /**\r\n         * If the Rope is marked as `dirty` it will automatically recalculate its vertices\r\n         * the next time it renders. You can also force this by calling `updateVertices`.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#dirty\r\n         * @type {boolean}\r\n         * @since 3.23.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * Are the Rope vertices aligned horizontally, in a strip, or vertically, in a column?\r\n         *\r\n         * This property is set during instantiation and cannot be changed directly.\r\n         * See the `setVertical` and `setHorizontal` methods.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#horizontal\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.23.0\r\n         */\r\n        this.horizontal = horizontal;\r\n\r\n        /**\r\n         * The horizontally flipped state of the Game Object.\r\n         *\r\n         * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n         * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n         * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#_flipX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @private\r\n         * @since 3.23.0\r\n         */\r\n        this._flipX = false;\r\n\r\n        /**\r\n         * The vertically flipped state of the Game Object.\r\n         *\r\n         * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\r\n         * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n         * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#_flipY\r\n         * @type {boolean}\r\n         * @default false\r\n         * @private\r\n         * @since 3.23.0\r\n         */\r\n        this._flipY = false;\r\n\r\n        /**\r\n         * Internal Vector2 used for vertices updates.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#_perp\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.23.0\r\n         */\r\n        this._perp = new Vector2();\r\n\r\n        /**\r\n         * You can optionally choose to render the vertices of this Rope to a Graphics instance.\r\n         *\r\n         * Achieve this by setting the `debugCallback` and the `debugGraphic` properties.\r\n         *\r\n         * You can do this in a single call via the `Rope.setDebug` method, which will use the\r\n         * built-in debug function. You can also set it to your own callback. The callback\r\n         * will be invoked _once per render_ and sent the following parameters:\r\n         *\r\n         * `debugCallback(src, meshLength, verts)`\r\n         *\r\n         * `src` is the Rope instance being debugged.\r\n         * `meshLength` is the number of mesh vertices in total.\r\n         * `verts` is an array of the translated vertex coordinates.\r\n         *\r\n         * To disable rendering, set this property back to `null`.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#debugCallback\r\n         * @type {function}\r\n         * @since 3.23.0\r\n         */\r\n        this.debugCallback = null;\r\n\r\n        /**\r\n         * The Graphics instance that the debug vertices will be drawn to, if `setDebug` has\r\n         * been called.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.23.0\r\n         */\r\n        this.debugGraphic = null;\r\n\r\n        this.setTexture(texture, frame);\r\n        this.setPosition(x, y);\r\n        this.setSizeToFrame();\r\n        this.initPipeline(PIPELINE_CONST.ROPE_PIPELINE);\r\n\r\n        if (Array.isArray(points))\r\n        {\r\n            this.resizeArrays(points.length);\r\n        }\r\n\r\n        this.setPoints(points, colors, alphas);\r\n\r\n        this.updateVertices();\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * The Rope update loop.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#preUpdate\r\n     * @protected\r\n     * @since 3.23.0\r\n     *\r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    preUpdate: function (time, delta)\r\n    {\r\n        var prevFrame = this.anims.currentFrame;\r\n\r\n        this.anims.update(time, delta);\r\n\r\n        if (this.anims.currentFrame !== prevFrame)\r\n        {\r\n            this.updateUVs();\r\n            this.updateVertices();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Start playing the given animation.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#play\r\n     * @since 3.23.0\r\n     *\r\n     * @param {string} key - The string-based key of the animation to play.\r\n     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.\r\n     * @param {number} [startFrame=0] - Optionally start the animation playing from this frame index.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    play: function (key, ignoreIfPlaying, startFrame)\r\n    {\r\n        this.anims.play(key, ignoreIfPlaying, startFrame);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Flags this Rope as being dirty. A dirty rope will recalculate all of its vertices data\r\n     * the _next_ time it renders. You should set this rope as dirty if you update the points\r\n     * array directly.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setDirty\r\n     * @since 3.23.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDirty: function ()\r\n    {\r\n        this.dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the alignment of the points in this Rope to be horizontal, in a strip format.\r\n     *\r\n     * Calling this method will reset this Rope. The current points, vertices, colors and alpha\r\n     * values will be reset to thoes values given as parameters.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setHorizontal\r\n     * @since 3.23.0\r\n     *\r\n     * @param {(number|Phaser.Types.Math.Vector2Like[])} [points] - An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided the current points length is used.\r\n     * @param {(number|number[])} [colors] - Either a single color value, or an array of values.\r\n     * @param {(number|number[])} [alphas] - Either a single alpha value, or an array of values.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setHorizontal: function (points, colors, alphas)\r\n    {\r\n        if (points === undefined) { points = this.points.length; }\r\n\r\n        if (this.horizontal)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.horizontal = true;\r\n\r\n        return this.setPoints(points, colors, alphas);\r\n    },\r\n\r\n    /**\r\n     * Sets the alignment of the points in this Rope to be vertical, in a column format.\r\n     *\r\n     * Calling this method will reset this Rope. The current points, vertices, colors and alpha\r\n     * values will be reset to thoes values given as parameters.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setVertical\r\n     * @since 3.23.0\r\n     *\r\n     * @param {(number|Phaser.Types.Math.Vector2Like[])} [points] - An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided the current points length is used.\r\n     * @param {(number|number[])} [colors] - Either a single color value, or an array of values.\r\n     * @param {(number|number[])} [alphas] - Either a single alpha value, or an array of values.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setVertical: function (points, colors, alphas)\r\n    {\r\n        if (points === undefined) { points = this.points.length; }\r\n\r\n        if (!this.horizontal)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.horizontal = false;\r\n\r\n        return this.setPoints(points, colors, alphas);\r\n    },\r\n\r\n    /**\r\n     * Sets the tint fill mode.\r\n     *\r\n     * Mode 0 (`false`) is an additive tint, the default, which blends the vertices colors with the texture.\r\n     * This mode respects the texture alpha.\r\n     *\r\n     * Mode 1 (`true`) is a fill tint. Unlike an additive tint, a fill-tint literally replaces the pixel colors\r\n     * from the texture with those in the tint. You can use this for effects such as making a player flash 'white'\r\n     * if hit by something. This mode respects the texture alpha.\r\n     *\r\n     * See the `setColors` method for details of how to color each of the vertices.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setTintFill\r\n     * @webglOnly\r\n     * @since 3.23.0\r\n     *\r\n     * @param {boolean} [value=false] - Set to `false` for an Additive tint or `true` fill tint with alpha.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setTintFill: function (value)\r\n    {\r\n        if (value === undefined) { value = false; }\r\n\r\n        this.tintFill = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the alpha values used by the Rope during rendering.\r\n     *\r\n     * You can provide the values in a number of ways:\r\n     *\r\n     * 1) One single numeric value: `setAlphas(0.5)` - This will set a single alpha for the whole Rope.\r\n     * 2) Two numeric value: `setAlphas(1, 0.5)` - This will set a 'top' and 'bottom' alpha value across the whole Rope.\r\n     * 3) An array of values: `setAlphas([ 1, 0.5, 0.2 ])`\r\n     *\r\n     * If you provide an array of values and the array has exactly the same number of values as `points` in the Rope, it\r\n     * will use each alpha value per rope segment.\r\n     *\r\n     * If the provided array has a different number of values than `points` then it will use the values in order, from\r\n     * the first Rope segment and on, until it runs out of values. This allows you to control the alpha values at all\r\n     * vertices in the Rope.\r\n     *\r\n     * Note this method is called `setAlphas` (plural) and not `setAlpha`.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setAlphas\r\n     * @since 3.23.0\r\n     *\r\n     * @param {(number|number[])} [alphas] - Either a single alpha value, or an array of values. If nothing is provided alpha is reset to 1.\r\n     * @param {number} [bottomAlpha] - An optional bottom alpha value. See the method description for details.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setAlphas: function (alphas, bottomAlpha)\r\n    {\r\n        var total = this.points.length;\r\n\r\n        if (total < 1)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var currentAlphas = this.alphas;\r\n\r\n        if (alphas === undefined)\r\n        {\r\n            alphas = [ 1 ];\r\n        }\r\n        else if (!Array.isArray(alphas) && bottomAlpha === undefined)\r\n        {\r\n            alphas = [ alphas ];\r\n        }\r\n\r\n        var i;\r\n        var index = 0;\r\n\r\n        if (bottomAlpha !== undefined)\r\n        {\r\n            //  Top / Bottom alpha pair\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                index = i * 2;\r\n\r\n                currentAlphas[index] = alphas;\r\n                currentAlphas[index + 1] = bottomAlpha;\r\n            }\r\n        }\r\n        else if (alphas.length === total)\r\n        {\r\n            //  If there are exactly the same number of alphas as points, we'll combine the alphas\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                index = i * 2;\r\n\r\n                currentAlphas[index] = alphas[i];\r\n                currentAlphas[index + 1] = alphas[i];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var prevAlpha = alphas[0];\r\n\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                index = i * 2;\r\n\r\n                if (alphas.length > index)\r\n                {\r\n                    prevAlpha = alphas[index];\r\n                }\r\n\r\n                currentAlphas[index] = prevAlpha;\r\n\r\n                if (alphas.length > index + 1)\r\n                {\r\n                    prevAlpha = alphas[index + 1];\r\n                }\r\n\r\n                currentAlphas[index + 1] = prevAlpha;\r\n            }\r\n        }\r\n\r\n        return this;\r\n\r\n    },\r\n\r\n    /**\r\n     * Set the color values used by the Rope during rendering.\r\n     *\r\n     * Colors are used to control the level of tint applied across the Rope texture.\r\n     *\r\n     * You can provide the values in a number of ways:\r\n     *\r\n     * * One single numeric value: `setColors(0xff0000)` - This will set a single color tint for the whole Rope.\r\n     * * An array of values: `setColors([ 0xff0000, 0x00ff00, 0x0000ff ])`\r\n     *\r\n     * If you provide an array of values and the array has exactly the same number of values as `points` in the Rope, it\r\n     * will use each color per rope segment.\r\n     *\r\n     * If the provided array has a different number of values than `points` then it will use the values in order, from\r\n     * the first Rope segment and on, until it runs out of values. This allows you to control the color values at all\r\n     * vertices in the Rope.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setColors\r\n     * @since 3.23.0\r\n     *\r\n     * @param {(number|number[])} [colors] - Either a single color value, or an array of values. If nothing is provided color is reset to 0xffffff.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setColors: function (colors)\r\n    {\r\n        var total = this.points.length;\r\n\r\n        if (total < 1)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var currentColors = this.colors;\r\n\r\n        if (colors === undefined)\r\n        {\r\n            colors = [ 0xffffff ];\r\n        }\r\n        else if (!Array.isArray(colors))\r\n        {\r\n            colors = [ colors ];\r\n        }\r\n\r\n        var i;\r\n        var index = 0;\r\n\r\n        if (colors.length === total)\r\n        {\r\n            //  If there are exactly the same number of colors as points, we'll combine the colors\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                index = i * 2;\r\n\r\n                currentColors[index] = colors[i];\r\n                currentColors[index + 1] = colors[i];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var prevColor = colors[0];\r\n\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                index = i * 2;\r\n\r\n                if (colors.length > index)\r\n                {\r\n                    prevColor = colors[index];\r\n                }\r\n\r\n                currentColors[index] = prevColor;\r\n\r\n                if (colors.length > index + 1)\r\n                {\r\n                    prevColor = colors[index + 1];\r\n                }\r\n\r\n                currentColors[index + 1] = prevColor;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the points used by this Rope.\r\n     *\r\n     * The points should be provided as an array of Vector2, or vector2-like objects (i.e. those with public x/y properties).\r\n     *\r\n     * Each point corresponds to one segment of the Rope. The more points in the array, the more segments the rope has.\r\n     *\r\n     * Point coordinates are given in local-space, not world-space, and are directly related to the size of the texture\r\n     * this Rope object is using.\r\n     *\r\n     * For example, a Rope using a 512 px wide texture, split into 4 segments (128px each) would use the following points:\r\n     *\r\n     * ```javascript\r\n     * rope.setPoints([\r\n     *   { x: 0, y: 0 },\r\n     *   { x: 128, y: 0 },\r\n     *   { x: 256, y: 0 },\r\n     *   { x: 384, y: 0 }\r\n     * ]);\r\n     * ```\r\n     *\r\n     * Or, you can provide an integer to do the same thing:\r\n     *\r\n     * ```javascript\r\n     * rope.setPoints(4);\r\n     * ```\r\n     *\r\n     * Which will divide the Rope into 4 equally sized segments based on the frame width.\r\n     *\r\n     * Note that calling this method with a different number of points than the Rope has currently will\r\n     * _reset_ the color and alpha values, unless you provide them as arguments to this method.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setPoints\r\n     * @since 3.23.0\r\n     *\r\n     * @param {(number|Phaser.Types.Math.Vector2Like[])} [points=2] - An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided a simple quad is created.\r\n     * @param {(number|number[])} [colors] - Either a single color value, or an array of values.\r\n     * @param {(number|number[])} [alphas] - Either a single alpha value, or an array of values.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setPoints: function (points, colors, alphas)\r\n    {\r\n        if (points === undefined) { points = 2; }\r\n\r\n        if (typeof points === 'number')\r\n        {\r\n            //  Generate an array based on the points\r\n            var segments = points;\r\n\r\n            if (segments < 2)\r\n            {\r\n                segments = 2;\r\n            }\r\n\r\n            points = [];\r\n\r\n            var s;\r\n            var frameSegment;\r\n            var offset;\r\n\r\n            if (this.horizontal)\r\n            {\r\n                offset = -(this.frame.halfWidth);\r\n                frameSegment = this.frame.width / (segments - 1);\r\n\r\n                for (s = 0; s < segments; s++)\r\n                {\r\n                    points.push({ x: offset + s * frameSegment, y: 0 });\r\n                }\r\n            }\r\n            else\r\n            {\r\n                offset = -(this.frame.halfHeight);\r\n                frameSegment = this.frame.height / (segments - 1);\r\n\r\n                for (s = 0; s < segments; s++)\r\n                {\r\n                    points.push({ x: 0, y: offset + s * frameSegment });\r\n                }\r\n            }\r\n        }\r\n\r\n        var total = points.length;\r\n        var currentTotal = this.points.length;\r\n\r\n        if (total < 1)\r\n        {\r\n            console.warn('Rope: Not enough points given');\r\n\r\n            return this;\r\n        }\r\n        else if (total === 1)\r\n        {\r\n            points.unshift({ x: 0, y: 0 });\r\n            total++;\r\n        }\r\n\r\n        if (currentTotal !== total)\r\n        {\r\n            this.resizeArrays(total);\r\n        }\r\n\r\n        this.points = points;\r\n\r\n        this.updateUVs();\r\n\r\n        if (colors !== undefined && colors !== null)\r\n        {\r\n            this.setColors(colors);\r\n        }\r\n\r\n        if (alphas !== undefined && alphas !== null)\r\n        {\r\n            this.setAlphas(alphas);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates all of the UVs based on the Rope.points and `flipX` and `flipY` settings.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#updateUVs\r\n     * @since 3.23.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateUVs: function ()\r\n    {\r\n        var currentUVs = this.uv;\r\n        var total = this.points.length;\r\n\r\n        var u0 = this.frame.u0;\r\n        var v0 = this.frame.v0;\r\n        var u1 = this.frame.u1;\r\n        var v1 = this.frame.v1;\r\n\r\n        var partH = (u1 - u0) / (total - 1);\r\n        var partV = (v1 - v0) / (total - 1);\r\n\r\n        for (var i = 0; i < total; i++)\r\n        {\r\n            var index = i * 4;\r\n\r\n            var uv0;\r\n            var uv1;\r\n            var uv2;\r\n            var uv3;\r\n\r\n            if (this.horizontal)\r\n            {\r\n                if (this._flipX)\r\n                {\r\n                    uv0 = u1 - (i * partH);\r\n                    uv2 = u1 - (i * partH);\r\n                }\r\n                else\r\n                {\r\n                    uv0 = u0 + (i * partH);\r\n                    uv2 = u0 + (i * partH);\r\n                }\r\n\r\n                if (this._flipY)\r\n                {\r\n                    uv1 = v1;\r\n                    uv3 = v0;\r\n                }\r\n                else\r\n                {\r\n                    uv1 = v0;\r\n                    uv3 = v1;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (this._flipX)\r\n                {\r\n                    uv0 = u0;\r\n                    uv2 = u1;\r\n                }\r\n                else\r\n                {\r\n                    uv0 = u1;\r\n                    uv2 = u0;\r\n                }\r\n\r\n                if (this._flipY)\r\n                {\r\n                    uv1 = v1 - (i * partV);\r\n                    uv3 = v1 - (i * partV);\r\n                }\r\n                else\r\n                {\r\n                    uv1 = v0 + (i * partV);\r\n                    uv3 = v0 + (i * partV);\r\n                }\r\n            }\r\n\r\n            currentUVs[index + 0] = uv0;\r\n            currentUVs[index + 1] = uv1;\r\n            currentUVs[index + 2] = uv2;\r\n            currentUVs[index + 3] = uv3;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resizes all of the internal arrays: `vertices`, `uv`, `colors` and `alphas` to the new\r\n     * given Rope segment total.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#resizeArrays\r\n     * @since 3.23.0\r\n     *\r\n     * @param {number} newSize - The amount of segments to split the Rope in to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    resizeArrays: function (newSize)\r\n    {\r\n        var colors = this.colors;\r\n        var alphas = this.alphas;\r\n\r\n        this.vertices = new Float32Array(newSize * 4);\r\n        this.uv = new Float32Array(newSize * 4);\r\n\r\n        colors = new Uint32Array(newSize * 2);\r\n        alphas = new Float32Array(newSize * 2);\r\n\r\n        for (var i = 0; i < newSize * 2; i++)\r\n        {\r\n            colors[i] = 0xffffff;\r\n            alphas[i] = 1;\r\n        }\r\n\r\n        this.colors = colors;\r\n        this.alphas = alphas;\r\n\r\n        //  updateVertices during next render\r\n        this.dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates the vertices based on the Rope points.\r\n     *\r\n     * This method is called automatically during rendering if `Rope.dirty` is `true`, which is set\r\n     * by the `setPoints` and `setDirty` methods. You should flag the Rope as being dirty if you modify\r\n     * the Rope points directly.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#updateVertices\r\n     * @since 3.23.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateVertices: function ()\r\n    {\r\n        var perp = this._perp;\r\n        var points = this.points;\r\n        var vertices = this.vertices;\r\n\r\n        var total = points.length;\r\n\r\n        this.dirty = false;\r\n\r\n        if (total < 1)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var nextPoint;\r\n        var lastPoint = points[0];\r\n\r\n        var frameSize = (this.horizontal) ? this.frame.halfHeight : this.frame.halfWidth;\r\n\r\n        for (var i = 0; i < total; i++)\r\n        {\r\n            var point = points[i];\r\n            var index = i * 4;\r\n\r\n            if (i < total - 1)\r\n            {\r\n                nextPoint = points[i + 1];\r\n            }\r\n            else\r\n            {\r\n                nextPoint = point;\r\n            }\r\n\r\n            perp.x = nextPoint.y - lastPoint.y;\r\n            perp.y = -(nextPoint.x - lastPoint.x);\r\n\r\n            var perpLength = perp.length();\r\n\r\n            perp.x /= perpLength;\r\n            perp.y /= perpLength;\r\n\r\n            perp.x *= frameSize;\r\n            perp.y *= frameSize;\r\n\r\n            vertices[index] = point.x + perp.x;\r\n            vertices[index + 1] = point.y + perp.y;\r\n            vertices[index + 2] = point.x - perp.x;\r\n            vertices[index + 3] = point.y - perp.y;\r\n\r\n            lastPoint = point;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method enables rendering of the Rope vertices to the given Graphics instance.\r\n     *\r\n     * If you enable this feature, you **must** call `Graphics.clear()` in your Scene `update`,\r\n     * otherwise the Graphics instance you provide to debug will fill-up with draw calls,\r\n     * eventually crashing the browser. This is not done automatically to allow you to debug\r\n     * draw multiple Rope objects to a single Graphics instance.\r\n     *\r\n     * The Rope class has a built-in debug rendering callback `Rope.renderDebugVerts`, however\r\n     * you can also provide your own callback to be used instead. Do this by setting the `callback` parameter.\r\n     *\r\n     * The callback is invoked _once per render_ and sent the following parameters:\r\n     *\r\n     * `callback(src, meshLength, verts)`\r\n     *\r\n     * `src` is the Rope instance being debugged.\r\n     * `meshLength` is the number of mesh vertices in total.\r\n     * `verts` is an array of the translated vertex coordinates.\r\n     *\r\n     * If using your own callback you do not have to provide a Graphics instance to this method.\r\n     *\r\n     * To disable debug rendering, to either your own callback or the built-in one, call this method\r\n     * with no arguments.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setDebug\r\n     * @since 3.23.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} [graphic] - The Graphic instance to render to if using the built-in callback.\r\n     * @param {function} [callback] - The callback to invoke during debug render. Leave as undefined to use the built-in callback.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDebug: function (graphic, callback)\r\n    {\r\n        this.debugGraphic = graphic;\r\n\r\n        if (!graphic && !callback)\r\n        {\r\n            this.debugCallback = null;\r\n        }\r\n        else if (!callback)\r\n        {\r\n            this.debugCallback = this.renderDebugVerts;\r\n        }\r\n        else\r\n        {\r\n            this.debugCallback = callback;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The built-in Rope vertices debug rendering method.\r\n     *\r\n     * See `Rope.setDebug` for more details.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#renderDebugVerts\r\n     * @since 3.23.0\r\n     *\r\n     * @param {Phaser.GameObjects.Rope} src - The Rope object being rendered.\r\n     * @param {number} meshLength - The number of vertices in the mesh.\r\n     * @param {number[]} verts - An array of translated vertex coordinates.\r\n     */\r\n    renderDebugVerts: function (src, meshLength, verts)\r\n    {\r\n        var graphic = src.debugGraphic;\r\n\r\n        var px0 = verts[0];\r\n        var py0 = verts[1];\r\n        var px1 = verts[2];\r\n        var py1 = verts[3];\r\n\r\n        graphic.lineBetween(px0, py0, px1, py1);\r\n\r\n        for (var i = 4; i < meshLength; i += 4)\r\n        {\r\n            var x0 = verts[i + 0];\r\n            var y0 = verts[i + 1];\r\n            var x1 = verts[i + 2];\r\n            var y1 = verts[i + 3];\r\n\r\n            graphic.lineBetween(px0, py0, x0, y0);\r\n            graphic.lineBetween(px1, py1, x1, y1);\r\n            graphic.lineBetween(px1, py1, x0, y0);\r\n            graphic.lineBetween(x0, y0, x1, y1);\r\n\r\n            px0 = x0;\r\n            py0 = y0;\r\n            px1 = x1;\r\n            py1 = y1;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Handles the pre-destroy step for the Rope, which removes the Animation component and typed arrays.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#preDestroy\r\n     * @private\r\n     * @since 3.23.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.anims.destroy();\r\n\r\n        this.anims = undefined;\r\n\r\n        this.points = null;\r\n        this.vertices = null;\r\n        this.uv = null;\r\n        this.colors = null;\r\n        this.alphas = null;\r\n\r\n        this.debugCallback = null;\r\n        this.debugGraphic = null;\r\n    },\r\n\r\n    /**\r\n     * The horizontally flipped state of the Game Object.\r\n     *\r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     *\r\n     * @name Phaser.GameObjects.Rope#flipX\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.23.0\r\n     */\r\n    flipX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._flipX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._flipX = value;\r\n\r\n            return this.updateUVs();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertically flipped state of the Game Object.\r\n     *\r\n     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     *\r\n     * @name Phaser.GameObjects.Rope#flipY\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.23.0\r\n     */\r\n    flipY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._flipY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._flipY = value;\r\n\r\n            return this.updateUVs();\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Rope;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AddToDOM = require('../../dom/AddToDOM');\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameEvents = require('../../core/events');\r\nvar GameObject = require('../GameObject');\r\nvar GetTextSize = require('./GetTextSize');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar RemoveFromDOM = require('../../dom/RemoveFromDOM');\r\nvar TextRender = require('./TextRender');\r\nvar TextStyle = require('./TextStyle');\r\n\r\n/**\r\n * @classdesc\r\n * A Text Game Object.\r\n *\r\n * Text objects work by creating their own internal hidden Canvas and then renders text to it using\r\n * the standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered\r\n * to your game during the render pass.\r\n *\r\n * Because it uses the Canvas API you can take advantage of all the features this offers, such as\r\n * applying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts\r\n * loaded externally, such as Google or TypeKit Web fonts.\r\n *\r\n * **Important:** The font name must be quoted if it contains certain combinations of digits or\r\n * special characters, either when creating the Text object, or when setting the font via `setFont`\r\n * or `setFontFamily`, e.g.:\r\n *\r\n * ```javascript\r\n * this.add.text(0, 0, 'Hello World', { fontFamily: 'Georgia, \"Goudy Bookletter 1911\", Times, serif' });\r\n * ```\r\n *\r\n * ```javascript\r\n * this.add.text(0, 0, 'Hello World', { font: '\"Press Start 2P\"' });\r\n * ```\r\n *\r\n * You can only display fonts that are currently loaded and available to the browser: therefore fonts must\r\n * be pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,\r\n * or have the fonts ready available in the CSS on the page in which your Phaser game resides.\r\n *\r\n * See {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts\r\n * across mobile browsers.\r\n *\r\n * A note on performance: Every time the contents of a Text object changes, i.e. changing the text being\r\n * displayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the\r\n * new texture to the GPU. This can be an expensive operation if used often, or with large quantities of\r\n * Text objects in your game. If you run into performance issues you would be better off using Bitmap Text\r\n * instead, as it benefits from batching and avoids expensive Canvas API calls.\r\n *\r\n * @class Text\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|string[])} text - The text this Text object will display.\r\n * @param {Phaser.Types.GameObjects.Text.TextStyle} style - The text style configuration object.\r\n *\r\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Valid_family_names\r\n */\r\nvar Text = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Crop,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        TextRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Text (scene, x, y, text, style)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        GameObject.call(this, scene, 'Text');\r\n\r\n        /**\r\n         * The renderer in use by this Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.12.0\r\n         */\r\n        this.renderer = scene.sys.renderer;\r\n\r\n        this.setPosition(x, y);\r\n        this.setOrigin(0, 0);\r\n        this.initPipeline();\r\n\r\n        /**\r\n         * The canvas element that the text is rendered to.\r\n         *\r\n         * @name Phaser.GameObjects.Text#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.canvas = CanvasPool.create(this);\r\n\r\n        /**\r\n         * The context of the canvas element that the text is rendered to.\r\n         *\r\n         * @name Phaser.GameObjects.Text#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * The Text Style object.\r\n         *\r\n         * Manages the style of this Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#style\r\n         * @type {Phaser.GameObjects.TextStyle}\r\n         * @since 3.0.0\r\n         */\r\n        this.style = new TextStyle(this, style);\r\n\r\n        /**\r\n         * Whether to automatically round line positions.\r\n         *\r\n         * @name Phaser.GameObjects.Text#autoRound\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.autoRound = true;\r\n\r\n        /**\r\n         * The Regular Expression that is used to split the text up into lines, in\r\n         * multi-line text. By default this is `/(?:\\r\\n|\\r|\\n)/`.\r\n         * You can change this RegExp to be anything else that you may need.\r\n         *\r\n         * @name Phaser.GameObjects.Text#splitRegExp\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.splitRegExp = /(?:\\r\\n|\\r|\\n)/;\r\n\r\n        /**\r\n         * The text to display.\r\n         *\r\n         * @name Phaser.GameObjects.Text#_text\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._text = undefined;\r\n\r\n        /**\r\n         * Specify a padding value which is added to the line width and height when calculating the Text size.\r\n         * Allows you to add extra spacing if the browser is unable to accurately determine the true font dimensions.\r\n         *\r\n         * @name Phaser.GameObjects.Text#padding\r\n         * @type {Phaser.Types.GameObjects.Text.TextPadding}\r\n         * @since 3.0.0\r\n         */\r\n        this.padding = { left: 0, right: 0, top: 0, bottom: 0 };\r\n\r\n        /**\r\n         * The width of this Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#width\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.width = 1;\r\n\r\n        /**\r\n         * The height of this Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#height\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.height = 1;\r\n\r\n        /**\r\n         * The line spacing value.\r\n         * This value is added to the font height to calculate the overall line height.\r\n         * Only has an effect if this Text object contains multiple lines of text.\r\n         *\r\n         * If you update this property directly, instead of using the `setLineSpacing` method, then\r\n         * be sure to call `updateText` after, or you won't see the change reflected in the Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#lineSpacing\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.lineSpacing = 0;\r\n\r\n        /**\r\n         * Whether the text or its settings have changed and need updating.\r\n         *\r\n         * @name Phaser.GameObjects.Text#dirty\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        //  If resolution wasn't set, force it to 1\r\n        if (this.style.resolution === 0)\r\n        {\r\n            this.style.resolution = 1;\r\n        }\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.Text#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        //  Create a Texture for this Text object\r\n        this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);\r\n\r\n        //  Get the frame\r\n        this.frame = this.texture.get();\r\n\r\n        //  Set the resolution\r\n        this.frame.source.resolution = this.style.resolution;\r\n\r\n        if (this.renderer && this.renderer.gl)\r\n        {\r\n            //  Clear the default 1x1 glTexture, as we override it later\r\n            this.renderer.deleteTexture(this.frame.source.glTexture);\r\n\r\n            this.frame.source.glTexture = null;\r\n        }\r\n\r\n        this.initRTL();\r\n\r\n        this.setText(text);\r\n\r\n        if (style && style.padding)\r\n        {\r\n            this.setPadding(style.padding);\r\n        }\r\n\r\n        if (style && style.lineSpacing)\r\n        {\r\n            this.setLineSpacing(style.lineSpacing);\r\n        }\r\n\r\n        scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function ()\r\n        {\r\n            this.dirty = true;\r\n        }, this);\r\n    },\r\n\r\n    /**\r\n     * Initialize right to left text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#initRTL\r\n     * @since 3.0.0\r\n     */\r\n    initRTL: function ()\r\n    {\r\n        if (!this.style.rtl)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Here is where the crazy starts.\r\n        //\r\n        //  Due to browser implementation issues, you cannot fillText BiDi text to a canvas\r\n        //  that is not part of the DOM. It just completely ignores the direction property.\r\n\r\n        this.canvas.dir = 'rtl';\r\n\r\n        //  Experimental atm, but one day ...\r\n        this.context.direction = 'rtl';\r\n\r\n        //  Add it to the DOM, but hidden within the parent canvas.\r\n        this.canvas.style.display = 'none';\r\n\r\n        AddToDOM(this.canvas, this.scene.sys.canvas);\r\n\r\n        //  And finally we set the x origin\r\n        this.originX = 1;\r\n    },\r\n\r\n    /**\r\n     * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n     * bounds.\r\n     *\r\n     * @method Phaser.GameObjects.Text#runWordWrap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text to perform word wrap detection against.\r\n     *\r\n     * @return {string} The text after wrapping has been applied.\r\n     */\r\n    runWordWrap: function (text)\r\n    {\r\n        var style = this.style;\r\n\r\n        if (style.wordWrapCallback)\r\n        {\r\n            var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);\r\n\r\n            if (Array.isArray(wrappedLines))\r\n            {\r\n                wrappedLines = wrappedLines.join('\\n');\r\n            }\r\n\r\n            return wrappedLines;\r\n        }\r\n        else if (style.wordWrapWidth)\r\n        {\r\n            if (style.wordWrapUseAdvanced)\r\n            {\r\n                return this.advancedWordWrap(text, this.context, this.style.wordWrapWidth);\r\n            }\r\n            else\r\n            {\r\n                return this.basicWordWrap(text, this.context, this.style.wordWrapWidth);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            return text;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Advanced wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n     * bounds. Consecutive spaces will be collapsed and replaced with a single space. Lines will be\r\n     * trimmed of white space before processing. Throws an error if wordWrapWidth is less than a\r\n     * single character.\r\n     *\r\n     * @method Phaser.GameObjects.Text#advancedWordWrap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text to perform word wrap detection against.\r\n     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\r\n     * @param {number} wordWrapWidth - The word wrap width.\r\n     *\r\n     * @return {string} The wrapped text.\r\n     */\r\n    advancedWordWrap: function (text, context, wordWrapWidth)\r\n    {\r\n        var output = '';\r\n\r\n        // Condense consecutive spaces and split into lines\r\n        var lines = text\r\n            .replace(/ +/gi, ' ')\r\n            .split(this.splitRegExp);\r\n\r\n        var linesCount = lines.length;\r\n\r\n        for (var i = 0; i < linesCount; i++)\r\n        {\r\n            var line = lines[i];\r\n            var out = '';\r\n\r\n            // Trim whitespace\r\n            line = line.replace(/^ *|\\s*$/gi, '');\r\n\r\n            // If entire line is less than wordWrapWidth append the entire line and exit early\r\n            var lineWidth = context.measureText(line).width;\r\n\r\n            if (lineWidth < wordWrapWidth)\r\n            {\r\n                output += line + '\\n';\r\n                continue;\r\n            }\r\n\r\n            // Otherwise, calculate new lines\r\n            var currentLineWidth = wordWrapWidth;\r\n\r\n            // Split into words\r\n            var words = line.split(' ');\r\n\r\n            for (var j = 0; j < words.length; j++)\r\n            {\r\n                var word = words[j];\r\n                var wordWithSpace = word + ' ';\r\n                var wordWidth = context.measureText(wordWithSpace).width;\r\n\r\n                if (wordWidth > currentLineWidth)\r\n                {\r\n                    // Break word\r\n                    if (j === 0)\r\n                    {\r\n                        // Shave off letters from word until it's small enough\r\n                        var newWord = wordWithSpace;\r\n\r\n                        while (newWord.length)\r\n                        {\r\n                            newWord = newWord.slice(0, -1);\r\n                            wordWidth = context.measureText(newWord).width;\r\n\r\n                            if (wordWidth <= currentLineWidth)\r\n                            {\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        // If wordWrapWidth is too small for even a single letter, shame user\r\n                        // failure with a fatal error\r\n                        if (!newWord.length)\r\n                        {\r\n                            throw new Error('This text\\'s wordWrapWidth setting is less than a single character!');\r\n                        }\r\n\r\n                        // Replace current word in array with remainder\r\n                        var secondPart = word.substr(newWord.length);\r\n\r\n                        words[j] = secondPart;\r\n\r\n                        // Append first piece to output\r\n                        out += newWord;\r\n                    }\r\n\r\n                    // If existing word length is 0, don't include it\r\n                    var offset = (words[j].length) ? j : j + 1;\r\n\r\n                    // Collapse rest of sentence and remove any trailing white space\r\n                    var remainder = words.slice(offset).join(' ')\r\n                        .replace(/[ \\n]*$/gi, '');\r\n\r\n                    // Prepend remainder to next line\r\n                    lines[i + 1] = remainder + ' ' + (lines[i + 1] || '');\r\n                    linesCount = lines.length;\r\n\r\n                    break; // Processing on this line\r\n\r\n                    // Append word with space to output\r\n                }\r\n                else\r\n                {\r\n                    out += wordWithSpace;\r\n                    currentLineWidth -= wordWidth;\r\n                }\r\n            }\r\n\r\n            // Append processed line to output\r\n            output += out.replace(/[ \\n]*$/gi, '') + '\\n';\r\n        }\r\n\r\n        // Trim the end of the string\r\n        output = output.replace(/[\\s|\\n]*$/gi, '');\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n     * bounds. Spaces are not collapsed and whitespace is not trimmed.\r\n     *\r\n     * @method Phaser.GameObjects.Text#basicWordWrap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text to perform word wrap detection against.\r\n     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\r\n     * @param {number} wordWrapWidth - The word wrap width.\r\n     *\r\n     * @return {string} The wrapped text.\r\n     */\r\n    basicWordWrap: function (text, context, wordWrapWidth)\r\n    {\r\n        var result = '';\r\n        var lines = text.split(this.splitRegExp);\r\n        var lastLineIndex = lines.length - 1;\r\n        var whiteSpaceWidth = context.measureText(' ').width;\r\n\r\n        for (var i = 0; i <= lastLineIndex; i++)\r\n        {\r\n            var spaceLeft = wordWrapWidth;\r\n            var words = lines[i].split(' ');\r\n            var lastWordIndex = words.length - 1;\r\n\r\n            for (var j = 0; j <= lastWordIndex; j++)\r\n            {\r\n                var word = words[j];\r\n                var wordWidth = context.measureText(word).width;\r\n                var wordWidthWithSpace = wordWidth;\r\n\r\n                if (j < lastWordIndex)\r\n                {\r\n                    wordWidthWithSpace += whiteSpaceWidth;\r\n                }\r\n\r\n                if (wordWidthWithSpace > spaceLeft)\r\n                {\r\n                    // Skip printing the newline if it's the first word of the line that is greater\r\n                    // than the word wrap width.\r\n                    if (j > 0)\r\n                    {\r\n                        result += '\\n';\r\n                        spaceLeft = wordWrapWidth;\r\n                    }\r\n                }\r\n\r\n                result += word;\r\n\r\n                if (j < lastWordIndex)\r\n                {\r\n                    result += ' ';\r\n                    spaceLeft -= wordWidthWithSpace;\r\n                }\r\n                else\r\n                {\r\n                    spaceLeft -= wordWidth;\r\n                }\r\n            }\r\n\r\n            if (i < lastLineIndex)\r\n            {\r\n                result += '\\n';\r\n            }\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Runs the given text through this Text objects word wrapping and returns the results as an\r\n     * array, where each element of the array corresponds to a wrapped line of text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#getWrappedText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text for which the wrapping will be calculated. If unspecified, the Text objects current text will be used.\r\n     *\r\n     * @return {string[]} An array of strings with the pieces of wrapped text.\r\n     */\r\n    getWrappedText: function (text)\r\n    {\r\n        if (text === undefined) { text = this._text; }\r\n\r\n        this.style.syncFont(this.canvas, this.context);\r\n\r\n        var wrappedLines = this.runWordWrap(text);\r\n\r\n        return wrappedLines.split(this.splitRegExp);\r\n    },\r\n\r\n    /**\r\n     * Set the text to display.\r\n     *\r\n     * An array of strings will be joined with `\\n` line breaks.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this Text object.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setText: function (value)\r\n    {\r\n        if (!value && value !== 0)\r\n        {\r\n            value = '';\r\n        }\r\n\r\n        if (Array.isArray(value))\r\n        {\r\n            value = value.join('\\n');\r\n        }\r\n\r\n        if (value !== this._text)\r\n        {\r\n            this._text = value.toString();\r\n\r\n            this.updateText();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the text style.\r\n     *\r\n     * @example\r\n     * text.setStyle({\r\n     *     fontSize: '64px',\r\n     *     fontFamily: 'Arial',\r\n     *     color: '#ffffff',\r\n     *     align: 'center',\r\n     *     backgroundColor: '#ff00ff'\r\n     * });\r\n     *\r\n     * @method Phaser.GameObjects.Text#setStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} style - The style settings to set.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setStyle: function (style)\r\n    {\r\n        return this.style.setStyle(style);\r\n    },\r\n\r\n    /**\r\n     * Set the font.\r\n     *\r\n     * If a string is given, the font family is set.\r\n     *\r\n     * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`\r\n     * properties of that object are set.\r\n     *\r\n     * **Important:** The font name must be quoted if it contains certain combinations of digits or\r\n     * special characters:\r\n     *\r\n     * ```javascript\r\n     * Text.setFont('\"Press Start 2P\"');\r\n     * ```\r\n     *\r\n     * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n     * quoted properly, too:\r\n     *\r\n     * ```javascript\r\n     * Text.setFont('Georgia, \"Goudy Bookletter 1911\", Times, serif');\r\n     * ```\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFont\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} font - The font family or font settings to set.\r\n     *\r\n     * @return {this} This Text object.\r\n     *\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Valid_family_names\r\n     */\r\n    setFont: function (font)\r\n    {\r\n        return this.style.setFont(font);\r\n    },\r\n\r\n    /**\r\n     * Set the font family.\r\n     *\r\n     * **Important:** The font name must be quoted if it contains certain combinations of digits or\r\n     * special characters:\r\n     *\r\n     * ```javascript\r\n     * Text.setFont('\"Press Start 2P\"');\r\n     * ```\r\n     *\r\n     * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n     * quoted properly, too:\r\n     *\r\n     * ```javascript\r\n     * Text.setFont('Georgia, \"Goudy Bookletter 1911\", Times, serif');\r\n     * ```\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFontFamily\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} family - The font family.\r\n     *\r\n     * @return {this} This Text object.\r\n     *\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Valid_family_names\r\n     */\r\n    setFontFamily: function (family)\r\n    {\r\n        return this.style.setFontFamily(family);\r\n    },\r\n\r\n    /**\r\n     * Set the font size.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFontSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} size - The font size.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setFontSize: function (size)\r\n    {\r\n        return this.style.setFontSize(size);\r\n    },\r\n\r\n    /**\r\n     * Set the font style.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFontStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} style - The font style.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setFontStyle: function (style)\r\n    {\r\n        return this.style.setFontStyle(style);\r\n    },\r\n\r\n    /**\r\n     * Set a fixed width and height for the text.\r\n     *\r\n     * Pass in `0` for either of these parameters to disable fixed width or height respectively.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFixedSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The fixed width to set. `0` disables fixed width.\r\n     * @param {number} height - The fixed height to set. `0` disables fixed height.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setFixedSize: function (width, height)\r\n    {\r\n        return this.style.setFixedSize(width, height);\r\n    },\r\n\r\n    /**\r\n     * Set the background color.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setBackgroundColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - The background color.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setBackgroundColor: function (color)\r\n    {\r\n        return this.style.setBackgroundColor(color);\r\n    },\r\n\r\n    /**\r\n     * Set the fill style to be used by the Text object.\r\n     *\r\n     * This can be any valid CanvasRenderingContext2D fillStyle value, such as\r\n     * a color (in hex, rgb, rgba, hsl or named values), a gradient or a pattern.\r\n     *\r\n     * See the [MDN fillStyle docs](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle) for more details.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|any)} color - The text fill style. Can be any valid CanvasRenderingContext `fillStyle` value.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setFill: function (fillStyle)\r\n    {\r\n        return this.style.setFill(fillStyle);\r\n    },\r\n\r\n    /**\r\n     * Set the text fill color.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - The text fill color.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setColor: function (color)\r\n    {\r\n        return this.style.setColor(color);\r\n    },\r\n\r\n    /**\r\n     * Set the stroke settings.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setStroke\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - The stroke color.\r\n     * @param {number} thickness - The stroke thickness.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setStroke: function (color, thickness)\r\n    {\r\n        return this.style.setStroke(color, thickness);\r\n    },\r\n\r\n    /**\r\n     * Set the shadow settings.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal shadow offset.\r\n     * @param {number} [y=0] - The vertical shadow offset.\r\n     * @param {string} [color='#000'] - The shadow color.\r\n     * @param {number} [blur=0] - The shadow blur radius.\r\n     * @param {boolean} [shadowStroke=false] - Whether to stroke the shadow.\r\n     * @param {boolean} [shadowFill=true] - Whether to fill the shadow.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)\r\n    {\r\n        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);\r\n    },\r\n\r\n    /**\r\n     * Set the shadow offset.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal shadow offset.\r\n     * @param {number} y - The vertical shadow offset.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setShadowOffset: function (x, y)\r\n    {\r\n        return this.style.setShadowOffset(x, y);\r\n    },\r\n\r\n    /**\r\n     * Set the shadow color.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - The shadow color.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setShadowColor: function (color)\r\n    {\r\n        return this.style.setShadowColor(color);\r\n    },\r\n\r\n    /**\r\n     * Set the shadow blur radius.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowBlur\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} blur - The shadow blur radius.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setShadowBlur: function (blur)\r\n    {\r\n        return this.style.setShadowBlur(blur);\r\n    },\r\n\r\n    /**\r\n     * Enable or disable shadow stroke.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowStroke\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} enabled - Whether shadow stroke is enabled or not.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setShadowStroke: function (enabled)\r\n    {\r\n        return this.style.setShadowStroke(enabled);\r\n    },\r\n\r\n    /**\r\n     * Enable or disable shadow fill.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowFill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} enabled - Whether shadow fill is enabled or not.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setShadowFill: function (enabled)\r\n    {\r\n        return this.style.setShadowFill(enabled);\r\n    },\r\n\r\n    /**\r\n     * Set the width (in pixels) to use for wrapping lines. Pass in null to remove wrapping by width.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setWordWrapWidth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {?number} width - The maximum width of a line in pixels. Set to null to remove wrapping.\r\n     * @param {boolean} [useAdvancedWrap=false] - Whether or not to use the advanced wrapping\r\n     * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,\r\n     * spaces and whitespace are left as is.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setWordWrapWidth: function (width, useAdvancedWrap)\r\n    {\r\n        return this.style.setWordWrapWidth(width, useAdvancedWrap);\r\n    },\r\n\r\n    /**\r\n     * Set a custom callback for wrapping lines. Pass in null to remove wrapping by callback.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setWordWrapCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {TextStyleWordWrapCallback} callback - A custom function that will be responsible for wrapping the\r\n     * text. It will receive two arguments: text (the string to wrap), textObject (this Text\r\n     * instance). It should return the wrapped lines either as an array of lines or as a string with\r\n     * newline characters in place to indicate where breaks should happen.\r\n     * @param {object} [scope=null] - The scope that will be applied when the callback is invoked.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setWordWrapCallback: function (callback, scope)\r\n    {\r\n        return this.style.setWordWrapCallback(callback, scope);\r\n    },\r\n\r\n    /**\r\n     * Set the alignment of the text in this Text object.\r\n     *\r\n     * The argument can be one of: `left`, `right`, `center` or `justify`.\r\n     *\r\n     * Alignment only works if the Text object has more than one line of text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setAlign\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [align='left'] - The text alignment for multi-line text.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setAlign: function (align)\r\n    {\r\n        return this.style.setAlign(align);\r\n    },\r\n\r\n    /**\r\n     * Set the resolution used by this Text object.\r\n     *\r\n     * By default it will be set to match the resolution set in the Game Config,\r\n     * but you can override it via this method, or by specifying it in the Text style configuration object.\r\n     *\r\n     * It allows for much clearer text on High DPI devices, at the cost of memory because it uses larger\r\n     * internal Canvas textures for the Text.\r\n     *\r\n     * Therefore, please use with caution, as the more high res Text you have, the more memory it uses.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setResolution\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} value - The resolution for this Text object to use.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setResolution: function (value)\r\n    {\r\n        return this.style.setResolution(value);\r\n    },\r\n\r\n    /**\r\n     * Sets the line spacing value.\r\n     *\r\n     * This value is _added_ to the height of the font when calculating the overall line height.\r\n     * This only has an effect if this Text object consists of multiple lines of text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setLineSpacing\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} value - The amount to add to the font height to achieve the overall line height.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setLineSpacing: function (value)\r\n    {\r\n        this.lineSpacing = value;\r\n\r\n        return this.updateText();\r\n    },\r\n\r\n    /**\r\n     * Set the text padding.\r\n     *\r\n     * 'left' can be an object.\r\n     *\r\n     * If only 'left' and 'top' are given they are treated as 'x' and 'y'.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setPadding\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Types.GameObjects.Text.TextPadding)} left - The left padding value, or a padding config object.\r\n     * @param {number} [top] - The top padding value.\r\n     * @param {number} [right] - The right padding value.\r\n     * @param {number} [bottom] - The bottom padding value.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setPadding: function (left, top, right, bottom)\r\n    {\r\n        if (typeof left === 'object')\r\n        {\r\n            var config = left;\r\n\r\n            //  If they specify x and/or y this applies to all\r\n            var x = GetValue(config, 'x', null);\r\n\r\n            if (x !== null)\r\n            {\r\n                left = x;\r\n                right = x;\r\n            }\r\n            else\r\n            {\r\n                left = GetValue(config, 'left', 0);\r\n                right = GetValue(config, 'right', left);\r\n            }\r\n\r\n            var y = GetValue(config, 'y', null);\r\n\r\n            if (y !== null)\r\n            {\r\n                top = y;\r\n                bottom = y;\r\n            }\r\n            else\r\n            {\r\n                top = GetValue(config, 'top', 0);\r\n                bottom = GetValue(config, 'bottom', top);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (left === undefined) { left = 0; }\r\n            if (top === undefined) { top = left; }\r\n            if (right === undefined) { right = left; }\r\n            if (bottom === undefined) { bottom = top; }\r\n        }\r\n\r\n        this.padding.left = left;\r\n        this.padding.top = top;\r\n        this.padding.right = right;\r\n        this.padding.bottom = bottom;\r\n\r\n        return this.updateText();\r\n    },\r\n\r\n    /**\r\n     * Set the maximum number of lines to draw.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setMaxLines\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [max=0] - The maximum number of lines to draw.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setMaxLines: function (max)\r\n    {\r\n        return this.style.setMaxLines(max);\r\n    },\r\n\r\n    /**\r\n     * Update the displayed text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#updateText\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    updateText: function ()\r\n    {\r\n        var canvas = this.canvas;\r\n        var context = this.context;\r\n        var style = this.style;\r\n        var resolution = style.resolution;\r\n        var size = style.metrics;\r\n\r\n        style.syncFont(canvas, context);\r\n\r\n        var outputText = this._text;\r\n\r\n        if (style.wordWrapWidth || style.wordWrapCallback)\r\n        {\r\n            outputText = this.runWordWrap(this._text);\r\n        }\r\n\r\n        //  Split text into lines\r\n        var lines = outputText.split(this.splitRegExp);\r\n\r\n        var textSize = GetTextSize(this, size, lines);\r\n\r\n        var padding = this.padding;\r\n\r\n        var textWidth;\r\n\r\n        if (style.fixedWidth === 0)\r\n        {\r\n            this.width = textSize.width + padding.left + padding.right;\r\n\r\n            textWidth = textSize.width;\r\n        }\r\n        else\r\n        {\r\n            this.width = style.fixedWidth;\r\n\r\n            textWidth = this.width - padding.left - padding.right;\r\n\r\n            if (textWidth < textSize.width)\r\n            {\r\n                textWidth = textSize.width;\r\n            }\r\n        }\r\n\r\n        if (style.fixedHeight === 0)\r\n        {\r\n            this.height = textSize.height + padding.top + padding.bottom;\r\n        }\r\n        else\r\n        {\r\n            this.height = style.fixedHeight;\r\n        }\r\n\r\n        var w = this.width;\r\n        var h = this.height;\r\n\r\n        this.updateDisplayOrigin();\r\n\r\n        w *= resolution;\r\n        h *= resolution;\r\n\r\n        w = Math.max(w, 1);\r\n        h = Math.max(h, 1);\r\n\r\n        if (canvas.width !== w || canvas.height !== h)\r\n        {\r\n            canvas.width = w;\r\n            canvas.height = h;\r\n\r\n            this.frame.setSize(w, h);\r\n\r\n            //  Because resizing the canvas resets the context\r\n            style.syncFont(canvas, context);\r\n        }\r\n        else\r\n        {\r\n            context.clearRect(0, 0, w, h);\r\n        }\r\n\r\n        context.save();\r\n\r\n        context.scale(resolution, resolution);\r\n\r\n        if (style.backgroundColor)\r\n        {\r\n            context.fillStyle = style.backgroundColor;\r\n            context.fillRect(0, 0, w, h);\r\n        }\r\n\r\n        style.syncStyle(canvas, context);\r\n\r\n        context.textBaseline = 'alphabetic';\r\n\r\n        //  Apply padding\r\n        context.translate(padding.left, padding.top);\r\n\r\n        var linePositionX;\r\n        var linePositionY;\r\n\r\n        //  Draw text line by line\r\n        for (var i = 0; i < textSize.lines; i++)\r\n        {\r\n            linePositionX = style.strokeThickness / 2;\r\n            linePositionY = (style.strokeThickness / 2 + i * textSize.lineHeight) + size.ascent;\r\n\r\n            if (i > 0)\r\n            {\r\n                linePositionY += (textSize.lineSpacing * i);\r\n            }\r\n\r\n            if (style.rtl)\r\n            {\r\n                linePositionX = w - linePositionX;\r\n            }\r\n            else if (style.align === 'right')\r\n            {\r\n                linePositionX += textWidth - textSize.lineWidths[i];\r\n            }\r\n            else if (style.align === 'center')\r\n            {\r\n                linePositionX += (textWidth - textSize.lineWidths[i]) / 2;\r\n            }\r\n            else if (style.align === 'justify')\r\n            {\r\n                //  To justify text line its width must be no less than 85% of defined width\r\n                var minimumLengthToApplyJustification = 0.85;\r\n\r\n                if (textSize.lineWidths[i] / textSize.width >= minimumLengthToApplyJustification)\r\n                {\r\n                    var extraSpace = textSize.width - textSize.lineWidths[i];\r\n                    var spaceSize = context.measureText(' ').width;\r\n                    var trimmedLine = lines[i].trim();\r\n                    var array = trimmedLine.split(' ');\r\n\r\n                    extraSpace += (lines[i].length - trimmedLine.length) * spaceSize;\r\n\r\n                    var extraSpaceCharacters = Math.floor(extraSpace / spaceSize);\r\n                    var idx = 0;\r\n\r\n                    while (extraSpaceCharacters > 0)\r\n                    {\r\n                        array[idx] += ' ';\r\n                        idx = (idx + 1) % (array.length - 1 || 1);\r\n                        --extraSpaceCharacters;\r\n                    }\r\n\r\n                    lines[i] = array.join(' ');\r\n                }\r\n            }\r\n\r\n            if (this.autoRound)\r\n            {\r\n                linePositionX = Math.round(linePositionX);\r\n                linePositionY = Math.round(linePositionY);\r\n            }\r\n\r\n            if (style.strokeThickness)\r\n            {\r\n                this.style.syncShadow(context, style.shadowStroke);\r\n\r\n                context.strokeText(lines[i], linePositionX, linePositionY);\r\n            }\r\n\r\n            if (style.color)\r\n            {\r\n                this.style.syncShadow(context, style.shadowFill);\r\n\r\n                context.fillText(lines[i], linePositionX, linePositionY);\r\n            }\r\n        }\r\n\r\n        context.restore();\r\n\r\n        if (this.renderer && this.renderer.gl)\r\n        {\r\n            this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);\r\n\r\n            this.frame.glTexture = this.frame.source.glTexture;\r\n        }\r\n\r\n        this.dirty = true;\r\n\r\n        var input = this.input;\r\n\r\n        if (input && !input.customHitArea)\r\n        {\r\n            input.hitArea.width = this.width;\r\n            input.hitArea.height = this.height;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Get the current text metrics.\r\n     *\r\n     * @method Phaser.GameObjects.Text#getTextMetrics\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.Text.TextMetrics} The text metrics.\r\n     */\r\n    getTextMetrics: function ()\r\n    {\r\n        return this.style.getTextMetrics();\r\n    },\r\n\r\n    /**\r\n     * The text string being rendered by this Text Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#text\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\r\n    text: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._text;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.setText(value);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Build a JSON representation of the Text object.\r\n     *\r\n     * @method Phaser.GameObjects.Text#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Text object.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        var out = Components.ToJSON(this);\r\n\r\n        //  Extra Text data is added here\r\n\r\n        var data = {\r\n            autoRound: this.autoRound,\r\n            text: this._text,\r\n            style: this.style.toJSON(),\r\n            padding: {\r\n                left: this.padding.left,\r\n                right: this.padding.right,\r\n                top: this.padding.top,\r\n                bottom: this.padding.bottom\r\n            }\r\n        };\r\n\r\n        out.data = data;\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Text#preDestroy\r\n     * @protected\r\n     * @since 3.0.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (this.style.rtl)\r\n        {\r\n            RemoveFromDOM(this.canvas);\r\n        }\r\n\r\n        CanvasPool.remove(this.canvas);\r\n\r\n        this.texture.destroy();\r\n    }\r\n\r\n    /**\r\n     * The horizontal origin of this Game Object.\r\n     * The origin maps the relationship between the size and position of the Game Object.\r\n     * The default value is 0.5, meaning all Game Objects are positioned based on their center.\r\n     * Setting the value to 0 means the position now relates to the left of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#originX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n\r\n    /**\r\n     * The vertical origin of this Game Object.\r\n     * The origin maps the relationship between the size and position of the Game Object.\r\n     * The default value is 0.5, meaning all Game Objects are positioned based on their center.\r\n     * Setting the value to 0 means the position now relates to the top of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#originY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n\r\n});\r\n\r\nmodule.exports = Text;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameEvents = require('../../core/events');\r\nvar GameObject = require('../GameObject');\r\nvar GetPowerOfTwo = require('../../math/pow2/GetPowerOfTwo');\r\nvar Smoothing = require('../../display/canvas/Smoothing');\r\nvar TileSpriteRender = require('./TileSpriteRender');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n//  bitmask flag for GameObject.renderMask\r\nvar _FLAG = 8; // 1000\r\n\r\n/**\r\n * @classdesc\r\n * A TileSprite is a Sprite that has a repeating texture.\r\n *\r\n * The texture can be scrolled and scaled independently of the TileSprite itself. Textures will automatically wrap and\r\n * are designed so that you can create game backdrops using seamless textures as a source.\r\n *\r\n * You shouldn't ever create a TileSprite any larger than your actual canvas size. If you want to create a large repeating background\r\n * that scrolls across the whole map of your game, then you create a TileSprite that fits the canvas size and then use the `tilePosition`\r\n * property to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will\r\n * consume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to\r\n * adjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.\r\n *\r\n * An important note about Tile Sprites and NPOT textures: Internally, TileSprite textures use GL_REPEAT to provide\r\n * seamless repeating of the textures. This, combined with the way in which the textures are handled in WebGL, means\r\n * they need to be POT (power-of-two) sizes in order to wrap. If you provide a NPOT (non power-of-two) texture to a\r\n * TileSprite it will generate a POT sized canvas and draw your texture to it, scaled up to the POT size. It's then\r\n * scaled back down again during rendering to the original dimensions. While this works, in that it allows you to use\r\n * any size texture for a Tile Sprite, it does mean that NPOT textures are going to appear anti-aliased when rendered,\r\n * due to the interpolation that took place when it was resized into a POT texture. This is especially visible in\r\n * pixel art graphics. If you notice it and it becomes an issue, the only way to avoid it is to ensure that you\r\n * provide POT textures for Tile Sprites.\r\n *\r\n * @class TileSprite\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {number} width - The width of the Game Object. If zero it will use the size of the texture frame.\r\n * @param {number} height - The height of the Game Object. If zero it will use the size of the texture frame.\r\n * @param {string} textureKey - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|number)} [frameKey] - An optional frame from the Texture this Game Object is rendering with.\r\n */\r\nvar TileSprite = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Crop,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        TileSpriteRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function TileSprite (scene, x, y, width, height, textureKey, frameKey)\r\n    {\r\n        var renderer = scene.sys.renderer;\r\n\r\n        GameObject.call(this, scene, 'TileSprite');\r\n\r\n        var displayTexture = scene.sys.textures.get(textureKey);\r\n        var displayFrame = displayTexture.get(frameKey);\r\n\r\n        if (!width || !height)\r\n        {\r\n            width = displayFrame.width;\r\n            height = displayFrame.height;\r\n        }\r\n        else\r\n        {\r\n            width = Math.floor(width);\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        /**\r\n         * Internal tile position vector.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#_tilePosition\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tilePosition = new Vector2();\r\n\r\n        /**\r\n         * Internal tile scale vector.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#_tileScale\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tileScale = new Vector2(1, 1);\r\n\r\n        /**\r\n         * Whether the Tile Sprite has changed in some way, requiring an re-render of its tile texture.\r\n         *\r\n         * Such changes include the texture frame and scroll position of the Tile Sprite.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#dirty\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * The renderer in use by this Tile Sprite.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.0.0\r\n         */\r\n        this.renderer = renderer;\r\n\r\n        /**\r\n         * The Canvas element that the TileSprite renders its fill pattern in to.\r\n         * Only used in Canvas mode.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#canvas\r\n         * @type {?HTMLCanvasElement}\r\n         * @since 3.12.0\r\n         */\r\n        this.canvas = CanvasPool.create(this, width, height);\r\n\r\n        /**\r\n         * The Context of the Canvas element that the TileSprite renders its fill pattern in to.\r\n         * Only used in Canvas mode.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.12.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * The Texture the TileSprite is using as its fill pattern.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#displayTexture\r\n         * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this.displayTexture = displayTexture;\r\n\r\n        /**\r\n         * The Frame the TileSprite is using as its fill pattern.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#displayFrame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this.displayFrame = displayFrame;\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        /**\r\n         * The Texture this Game Object is using to render with.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#texture\r\n         * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n         * @since 3.0.0\r\n         */\r\n        this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);\r\n\r\n        /**\r\n         * The Texture Frame this Game Object is using to render with.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @since 3.0.0\r\n         */\r\n        this.frame = this.texture.get();\r\n\r\n        /**\r\n         * The next power of two value from the width of the Fill Pattern frame.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#potWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.potWidth = GetPowerOfTwo(displayFrame.width);\r\n\r\n        /**\r\n         * The next power of two value from the height of the Fill Pattern frame.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#potHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.potHeight = GetPowerOfTwo(displayFrame.height);\r\n\r\n        /**\r\n         * The Canvas that the TileSprites texture is rendered to.\r\n         * This is used to create a WebGL texture from.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#fillCanvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.12.0\r\n         */\r\n        this.fillCanvas = CanvasPool.create2D(this, this.potWidth, this.potHeight);\r\n\r\n        /**\r\n         * The Canvas Context used to render the TileSprites texture.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#fillContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.12.0\r\n         */\r\n        this.fillContext = this.fillCanvas.getContext('2d');\r\n\r\n        /**\r\n         * The texture that the Tile Sprite is rendered to, which is then rendered to a Scene.\r\n         * In WebGL this is a WebGLTexture. In Canvas it's a Canvas Fill Pattern.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#fillPattern\r\n         * @type {?(WebGLTexture|CanvasPattern)}\r\n         * @since 3.12.0\r\n         */\r\n        this.fillPattern = null;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(width, height);\r\n        this.setFrame(frameKey);\r\n        this.setOriginFromFrame();\r\n        this.initPipeline();\r\n\r\n        scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function (renderer)\r\n        {\r\n            if (!renderer)\r\n            {\r\n                return;\r\n            }\r\n            \r\n            var gl = renderer.gl;\r\n\r\n            this.dirty = true;\r\n            this.fillPattern = null;\r\n            this.fillPattern = renderer.createTexture2D(0, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT, gl.RGBA, this.fillCanvas, this.potWidth, this.potHeight);\r\n\r\n        }, this);\r\n    },\r\n\r\n    /**\r\n     * Sets the texture and frame this Game Object will use to render with.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setTexture: function (key, frame)\r\n    {\r\n        this.displayTexture = this.scene.sys.textures.get(key);\r\n\r\n        return this.setFrame(frame);\r\n    },\r\n\r\n    /**\r\n     * Sets the frame this Game Object will use to render with.\r\n     *\r\n     * The Frame has to belong to the current Texture being used.\r\n     *\r\n     * It can be either a string or an index.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number)} frame - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFrame: function (frame)\r\n    {\r\n        var newFrame = this.displayTexture.get(frame);\r\n\r\n        this.potWidth = GetPowerOfTwo(newFrame.width);\r\n        this.potHeight = GetPowerOfTwo(newFrame.height);\r\n\r\n        //  So updateCanvas is triggered\r\n        this.canvas.width = 0;\r\n\r\n        if (!newFrame.cutWidth || !newFrame.cutHeight)\r\n        {\r\n            this.renderFlags &= ~_FLAG;\r\n        }\r\n        else\r\n        {\r\n            this.renderFlags |= _FLAG;\r\n        }\r\n\r\n        this.displayFrame = newFrame;\r\n\r\n        this.dirty = true;\r\n\r\n        this.updateTileTexture();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setTilePosition\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} [x] - The x position of this sprite's tiling texture.\r\n     * @param {number} [y] - The y position of this sprite's tiling texture.\r\n     *\r\n     * @return {this} This Tile Sprite instance.\r\n     */\r\n    setTilePosition: function (x, y)\r\n    {\r\n        if (x !== undefined)\r\n        {\r\n            this.tilePositionX = x;\r\n        }\r\n\r\n        if (y !== undefined)\r\n        {\r\n            this.tilePositionY = y;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets {@link Phaser.GameObjects.TileSprite#tileScaleX} and {@link Phaser.GameObjects.TileSprite#tileScaleY}.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setTileScale\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} [x] - The horizontal scale of the tiling texture. If not given it will use the current `tileScaleX` value.\r\n     * @param {number} [y=x] - The vertical scale of the tiling texture. If not given it will use the `x` value.\r\n     *\r\n     * @return {this} This Tile Sprite instance.\r\n     */\r\n    setTileScale: function (x, y)\r\n    {\r\n        if (x === undefined) { x = this.tileScaleX; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.tileScaleX = x;\r\n        this.tileScaleY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Render the tile texture if it is dirty, or if the frame has changed.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#updateTileTexture\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    updateTileTexture: function ()\r\n    {\r\n        if (!this.dirty || !this.renderer)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Draw the displayTexture to our fillCanvas\r\n\r\n        var frame = this.displayFrame;\r\n\r\n        if (frame.source.isRenderTexture || frame.source.isGLTexture)\r\n        {\r\n            console.warn('TileSprites can only use Image or Canvas based textures');\r\n\r\n            this.dirty = false;\r\n\r\n            return;\r\n        }\r\n\r\n        var ctx = this.fillContext;\r\n        var canvas = this.fillCanvas;\r\n\r\n        var fw = this.potWidth;\r\n        var fh = this.potHeight;\r\n\r\n        if (!this.renderer || !this.renderer.gl)\r\n        {\r\n            fw = frame.cutWidth;\r\n            fh = frame.cutHeight;\r\n        }\r\n\r\n        ctx.clearRect(0, 0, fw, fh);\r\n\r\n        canvas.width = fw;\r\n        canvas.height = fh;\r\n\r\n        ctx.drawImage(\r\n            frame.source.image,\r\n            frame.cutX, frame.cutY,\r\n            frame.cutWidth, frame.cutHeight,\r\n            0, 0,\r\n            fw, fh\r\n        );\r\n\r\n        if (this.renderer && this.renderer.gl)\r\n        {\r\n            this.fillPattern = this.renderer.canvasToTexture(canvas, this.fillPattern);\r\n        }\r\n        else\r\n        {\r\n            this.fillPattern = ctx.createPattern(canvas, 'repeat');\r\n        }\r\n\r\n        this.updateCanvas();\r\n\r\n        this.dirty = false;\r\n    },\r\n\r\n    /**\r\n     * Draw the fill pattern to the internal canvas.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#updateCanvas\r\n     * @private\r\n     * @since 3.12.0\r\n     */\r\n    updateCanvas: function ()\r\n    {\r\n        var canvas = this.canvas;\r\n\r\n        if (canvas.width !== this.width || canvas.height !== this.height)\r\n        {\r\n            canvas.width = this.width;\r\n            canvas.height = this.height;\r\n\r\n            this.frame.setSize(this.width, this.height);\r\n            this.updateDisplayOrigin();\r\n\r\n            this.dirty = true;\r\n        }\r\n\r\n        if (!this.dirty || this.renderer && this.renderer.gl)\r\n        {\r\n            this.dirty = false;\r\n            return;\r\n        }\r\n\r\n        var ctx = this.context;\r\n\r\n        if (!this.scene.sys.game.config.antialias)\r\n        {\r\n            Smoothing.disable(ctx);\r\n        }\r\n\r\n        var scaleX = this._tileScale.x;\r\n        var scaleY = this._tileScale.y;\r\n\r\n        var positionX = this._tilePosition.x;\r\n        var positionY = this._tilePosition.y;\r\n\r\n        ctx.clearRect(0, 0, this.width, this.height);\r\n\r\n        ctx.save();\r\n\r\n        ctx.scale(scaleX, scaleY);\r\n\r\n        ctx.translate(-positionX, -positionY);\r\n\r\n        ctx.fillStyle = this.fillPattern;\r\n\r\n        ctx.fillRect(positionX, positionY, this.width / scaleX, this.height / scaleY);\r\n\r\n        ctx.restore();\r\n\r\n        this.dirty = false;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (this.renderer && this.renderer.gl)\r\n        {\r\n            this.renderer.deleteTexture(this.fillPattern);\r\n        }\r\n\r\n        CanvasPool.remove(this.canvas);\r\n        CanvasPool.remove(this.fillCanvas);\r\n\r\n        this.fillPattern = null;\r\n        this.fillContext = null;\r\n        this.fillCanvas = null;\r\n\r\n        this.displayTexture = null;\r\n        this.displayFrame = null;\r\n\r\n        this.texture.destroy();\r\n\r\n        this.renderer = null;\r\n    },\r\n\r\n    /**\r\n     * The horizontal scroll position of the Tile Sprite.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#tilePositionX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    tilePositionX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._tilePosition.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tilePosition.x = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scroll position of the Tile Sprite.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#tilePositionY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    tilePositionY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._tilePosition.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tilePosition.y = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of the Tile Sprite texture.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#tileScaleX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.11.0\r\n     */\r\n    tileScaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._tileScale.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tileScale.x = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of the Tile Sprite texture.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#tileScaleY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.11.0\r\n     */\r\n    tileScaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._tileScale.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tileScale.y = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = TileSprite;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Clamp = require('../../math/Clamp');\r\nvar Components = require('../components');\r\nvar Events = require('../events');\r\nvar GameEvents = require('../../core/events/');\r\nvar InputEvents = require('../../input/events/');\r\nvar GameObject = require('../GameObject');\r\nvar SoundEvents = require('../../sound/events/');\r\nvar UUID = require('../../utils/string/UUID');\r\nvar VideoRender = require('./VideoRender');\r\nvar MATH_CONST = require('../../math/const');\r\n\r\n/**\r\n * @classdesc\r\n * A Video Game Object.\r\n *\r\n * This Game Object is capable of handling playback of a previously loaded video from the Phaser Video Cache,\r\n * or playing a video based on a given URL. Videos can be either local, or streamed.\r\n *\r\n * ```javascript\r\n * preload () {\r\n *   this.load.video('pixar', 'nemo.mp4');\r\n * }\r\n *\r\n * create () {\r\n *   this.add.video(400, 300, 'pixar');\r\n * }\r\n * ```\r\n *\r\n * To all intents and purposes, a video is a standard Game Object, just like a Sprite. And as such, you can do\r\n * all the usual things to it, such as scaling, rotating, cropping, tinting, making interactive, giving a\r\n * physics body, etc.\r\n *\r\n * Transparent videos are also possible via the WebM file format. Providing the video file has was encoded with\r\n * an alpha channel, and providing the browser supports WebM playback (not all of them do), then it will render\r\n * in-game with full transparency.\r\n *\r\n * ### Autoplaying Videos\r\n *\r\n * Videos can only autoplay if the browser has been unlocked with an interaction, or satisfies the MEI settings.\r\n * The policies that control autoplaying are vast and vary between browser.\r\n * You can, and should, read more about it here: https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\r\n *\r\n * If your video doesn't contain any audio, then set the `noAudio` parameter to `true` when the video is _loaded_,\r\n * and it will often allow the video to play immediately:\r\n *\r\n * ```javascript\r\n * preload () {\r\n *   this.load.video('pixar', 'nemo.mp4', 'loadeddata', false, true);\r\n * }\r\n * ```\r\n *\r\n * The 5th parameter in the load call tells Phaser that the video doesn't contain any audio tracks. Video without\r\n * audio can autoplay without requiring a user interaction. Video with audio cannot do this unless it satisfies\r\n * the browsers MEI settings. See the MDN Autoplay Guide for further details.\r\n *\r\n * Note that due to a bug in IE11 you cannot play a video texture to a Sprite in WebGL. For IE11 force Canvas mode.\r\n *\r\n * More details about video playback and the supported media formats can be found on MDN:\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement\r\n * https://developer.mozilla.org/en-US/docs/Web/Media/Formats\r\n *\r\n * @class Video\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.20.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.TextureCrop\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} [key] - Optional key of the Video this Game Object will play, as stored in the Video Cache.\r\n */\r\nvar Video = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Size,\r\n        Components.TextureCrop,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        VideoRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Video (scene, x, y, key)\r\n    {\r\n        GameObject.call(this, scene, 'Video');\r\n\r\n        /**\r\n         * A reference to the HTML Video Element this Video Game Object is playing.\r\n         * Will be `null` until a video is loaded for playback.\r\n         *\r\n         * @name Phaser.GameObjects.Video#video\r\n         * @type {?HTMLVideoElement}\r\n         * @since 3.20.0\r\n         */\r\n        this.video = null;\r\n\r\n        /**\r\n         * The Phaser Texture this Game Object is using to render the video to.\r\n         * Will be `null` until a video is loaded for playback.\r\n         *\r\n         * @name Phaser.GameObjects.Video#videoTexture\r\n         * @type {?Phaser.Textures.Texture}\r\n         * @since 3.20.0\r\n         */\r\n        this.videoTexture = null;\r\n\r\n        /**\r\n         * A reference to the TextureSource belong to the `videoTexture` Texture object.\r\n         * Will be `null` until a video is loaded for playback.\r\n         *\r\n         * @name Phaser.GameObjects.Video#videoTextureSource\r\n         * @type {?Phaser.Textures.TextureSource}\r\n         * @since 3.20.0\r\n         */\r\n        this.videoTextureSource = null;\r\n\r\n        /**\r\n         * A Phaser CanvasTexture instance that holds the most recent snapshot taken from the video.\r\n         * This will only be set if `snapshot` or `snapshotArea` have been called, and will be `null` until that point.\r\n         *\r\n         * @name Phaser.GameObjects.Video#snapshotTexture\r\n         * @type {?Phaser.Textures.CanvasTexture}\r\n         * @since 3.20.0\r\n         */\r\n        this.snapshotTexture = null;\r\n\r\n        /**\r\n         * If you have saved this video to a texture via the `saveTexture` method, this controls if the video\r\n         * is rendered with `flipY` in WebGL or not. You often need to set this if you wish to use the video texture\r\n         * as the input source for a shader. If you find your video is appearing upside down within a shader or\r\n         * custom pipeline, flip this property.\r\n         *\r\n         * @name Phaser.GameObjects.Video#flipY\r\n         * @type {boolean}\r\n         * @since 3.20.0\r\n         */\r\n        this.flipY = false;\r\n\r\n        /**\r\n         * The key used by the texture as stored in the Texture Manager.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_key\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._key = UUID();\r\n\r\n        /**\r\n         * An internal flag holding the current state of the video lock, should document interaction be required\r\n         * before playback can begin.\r\n         *\r\n         * @name Phaser.GameObjects.Video#touchLocked\r\n         * @type {boolean}\r\n         * @since 3.20.0\r\n         */\r\n        this.touchLocked = true;\r\n\r\n        /**\r\n         * Should the video auto play when document interaction is required and happens?\r\n         *\r\n         * @name Phaser.GameObjects.Video#playWhenUnlocked\r\n         * @type {boolean}\r\n         * @since 3.20.0\r\n         */\r\n        this.playWhenUnlocked = false;\r\n\r\n        /**\r\n         * When starting playback of a video Phaser will monitor its `readyState` using a `setTimeout` call.\r\n         * The `setTimeout` happens once every `Video.retryInterval` ms. It will carry on monitoring the video\r\n         * state in this manner until the `retryLimit` is reached and then abort.\r\n         *\r\n         * @name Phaser.GameObjects.Video#retryLimit\r\n         * @type {number}\r\n         * @since 3.20.0\r\n         */\r\n        this.retryLimit = 20;\r\n\r\n        /**\r\n         * The current retry attempt.\r\n         *\r\n         * @name Phaser.GameObjects.Video#retry\r\n         * @type {number}\r\n         * @since 3.20.0\r\n         */\r\n        this.retry = 0;\r\n\r\n        /**\r\n         * The number of ms between each retry while monitoring the ready state of a downloading video.\r\n         *\r\n         * @name Phaser.GameObjects.Video#retryInterval\r\n         * @type {number}\r\n         * @since 3.20.0\r\n         */\r\n        this.retryInterval = 500;\r\n\r\n        /**\r\n         * The setTimeout callback ID.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_retryID\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._retryID = null;\r\n\r\n        /**\r\n         * The video was muted due to a system event, such as the game losing focus.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_systemMuted\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._systemMuted = false;\r\n\r\n        /**\r\n         * The video was muted due to game code, not a system event.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_codeMuted\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._codeMuted = false;\r\n\r\n        /**\r\n         * The video was paused due to a system event, such as the game losing focus.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_systemPaused\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._systemPaused = false;\r\n\r\n        /**\r\n         * The video was paused due to game code, not a system event.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_codePaused\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._codePaused = false;\r\n\r\n        /**\r\n         * The locally bound event callback handlers.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_callbacks\r\n         * @type {any}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._callbacks = {\r\n            play: this.playHandler.bind(this),\r\n            error: this.loadErrorHandler.bind(this),\r\n            end: this.completeHandler.bind(this),\r\n            time: this.timeUpdateHandler.bind(this),\r\n            seeking: this.seekingHandler.bind(this),\r\n            seeked: this.seekedHandler.bind(this)\r\n        };\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        /**\r\n         * An object containing in and out markers for sequence playback.\r\n         *\r\n         * @name Phaser.GameObjects.Video#markers\r\n         * @type {any}\r\n         * @since 3.20.0\r\n         */\r\n        this.markers = {};\r\n\r\n        /**\r\n         * The in marker.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_markerIn\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._markerIn = -1;\r\n\r\n        /**\r\n         * The out marker.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_markerOut\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._markerOut = MATH_CONST.MAX_SAFE_INTEGER;\r\n\r\n        /**\r\n         * The last time the TextureSource was updated.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_lastUpdate\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._lastUpdate = 0;\r\n\r\n        /**\r\n         * The key of the video being played from the Video cache, if any.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_cacheKey\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._cacheKey = '';\r\n\r\n        /**\r\n         * Is the video currently seeking?\r\n         *\r\n         * @name Phaser.GameObjects.Video#_isSeeking\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._isSeeking = false;\r\n\r\n        /**\r\n         * Should the Video element that this Video is using, be removed from the DOM\r\n         * when this Video is destroyed?\r\n         *\r\n         * @name Phaser.GameObjects.Video#removeVideoElementOnDestroy\r\n         * @type {boolean}\r\n         * @since 3.21.0\r\n         */\r\n        this.removeVideoElementOnDestroy = false;\r\n\r\n        this.setPosition(x, y);\r\n        this.initPipeline();\r\n\r\n        if (key)\r\n        {\r\n            this.changeSource(key, false);\r\n        }\r\n\r\n        var game = scene.sys.game.events;\r\n\r\n        game.on(GameEvents.PAUSE, this.globalPause, this);\r\n        game.on(GameEvents.RESUME, this.globalResume, this);\r\n\r\n        var sound = scene.sys.sound;\r\n\r\n        if (sound)\r\n        {\r\n            sound.on(SoundEvents.GLOBAL_MUTE, this.globalMute, this);\r\n        }\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * Starts this video playing.\r\n     *\r\n     * If the video is already playing, or has been queued to play with `changeSource` then this method just returns.\r\n     *\r\n     * Videos can only autoplay if the browser has been unlocked. This happens if you have interacted with the browser, i.e.\r\n     * by clicking on it or pressing a key, or due to server settings. The policies that control autoplaying are vast and\r\n     * vary between browser. You can read more here: https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\r\n     *\r\n     * If your video doesn't contain any audio, then set the `noAudio` parameter to `true` when the video is loaded,\r\n     * and it will often allow the video to play immediately:\r\n     *\r\n     * ```javascript\r\n     * preload () {\r\n     *   this.load.video('pixar', 'nemo.mp4', 'loadeddata', false, true);\r\n     * }\r\n     * ```\r\n     *\r\n     * The 5th parameter in the load call tells Phaser that the video doesn't contain any audio tracks. Video without\r\n     * audio can autoplay without requiring a user interaction. Video with audio cannot do this unless it satisfies\r\n     * the browsers MEI settings. See the MDN Autoplay Guide for details.\r\n     *\r\n     * If you need audio in your videos, then you'll have to consider the fact that the video cannot start playing until the\r\n     * user has interacted with the browser, into your game flow.\r\n     *\r\n     * @method Phaser.GameObjects.Video#play\r\n     * @since 3.20.0\r\n     *\r\n     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n     * @param {number} [markerIn] - Optional in marker time, in seconds, for playback of a sequence of the video.\r\n     * @param {number} [markerOut] - Optional out marker time, in seconds, for playback of a sequence of the video.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    play: function (loop, markerIn, markerOut)\r\n    {\r\n        if ((this.touchLocked && this.playWhenUnlocked) || this.isPlaying())\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var video = this.video;\r\n\r\n        if (!video)\r\n        {\r\n            console.warn('Video not loaded');\r\n\r\n            return this;\r\n        }\r\n\r\n        if (loop === undefined) { loop = video.loop; }\r\n\r\n        var sound = this.scene.sys.sound;\r\n\r\n        if (sound && sound.mute)\r\n        {\r\n            //  Mute will be set based on the global mute state of the Sound Manager (if there is one)\r\n            this.setMute(true);\r\n        }\r\n\r\n        if (!isNaN(markerIn))\r\n        {\r\n            this._markerIn = markerIn;\r\n        }\r\n\r\n        if (!isNaN(markerOut) && markerOut > markerIn)\r\n        {\r\n            this._markerOut = markerOut;\r\n        }\r\n\r\n        video.loop = loop;\r\n\r\n        var callbacks = this._callbacks;\r\n\r\n        var playPromise = video.play();\r\n\r\n        if (playPromise !== undefined)\r\n        {\r\n            playPromise.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this));\r\n        }\r\n        else\r\n        {\r\n            //  Old-school browsers with no Promises\r\n            video.addEventListener('playing', callbacks.play, true);\r\n\r\n            //  If video hasn't downloaded properly yet ...\r\n            if (video.readyState < 2)\r\n            {\r\n                this.retry = this.retryLimit;\r\n\r\n                this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\r\n            }\r\n        }\r\n\r\n        //  Set these _after_ calling `play` or they don't fire (useful, thanks browsers)\r\n        video.addEventListener('ended', callbacks.end, true);\r\n        video.addEventListener('timeupdate', callbacks.time, true);\r\n        video.addEventListener('seeking', callbacks.seeking, true);\r\n        video.addEventListener('seeked', callbacks.seeked, true);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method allows you to change the source of the current video element. It works by first stopping the\r\n     * current video, if playing. Then deleting the video texture, if one has been created. Finally, it makes a\r\n     * new video texture and starts playback of the new source through the existing video element.\r\n     *\r\n     * The reason you may wish to do this is because videos that require interaction to unlock, remain in an unlocked\r\n     * state, even if you change the source of the video. By changing the source to a new video you avoid having to\r\n     * go through the unlock process again.\r\n     *\r\n     * @method Phaser.GameObjects.Video#changeSource\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - The key of the Video this Game Object will swap to playing, as stored in the Video Cache.\r\n     * @param {boolean} [autoplay=true] - Should the video start playing immediately, once the swap is complete?\r\n     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n     * @param {number} [markerIn] - Optional in marker time, in seconds, for playback of a sequence of the video.\r\n     * @param {number} [markerOut] - Optional out marker time, in seconds, for playback of a sequence of the video.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    changeSource: function (key, autoplay, loop, markerIn, markerOut)\r\n    {\r\n        if (autoplay === undefined) { autoplay = true; }\r\n\r\n        var currentVideo = this.video;\r\n\r\n        if (currentVideo)\r\n        {\r\n            this.stop();\r\n        }\r\n\r\n        var newVideo = this.scene.sys.cache.video.get(key);\r\n\r\n        if (newVideo)\r\n        {\r\n            this.video = newVideo;\r\n\r\n            this._cacheKey = key;\r\n\r\n            this._codePaused = newVideo.paused;\r\n            this._codeMuted = newVideo.muted;\r\n\r\n            if (this.videoTexture)\r\n            {\r\n                this.scene.sys.textures.remove(this._key);\r\n\r\n                this.videoTexture = this.scene.sys.textures.create(this._key, newVideo, newVideo.videoWidth, newVideo.videoHeight);\r\n                this.videoTextureSource = this.videoTexture.source[0];\r\n                this.videoTexture.add('__BASE', 0, 0, 0, newVideo.videoWidth, newVideo.videoHeight);\r\n\r\n                this.setTexture(this.videoTexture);\r\n                this.setSizeToFrame();\r\n                this.updateDisplayOrigin();\r\n\r\n                this.emit(Events.VIDEO_CREATED, this, newVideo.videoWidth, newVideo.videoHeight);\r\n            }\r\n            else\r\n            {\r\n                this.updateTexture();\r\n            }\r\n\r\n            newVideo.currentTime = 0;\r\n\r\n            this._lastUpdate = 0;\r\n\r\n            if (autoplay)\r\n            {\r\n                this.play(loop, markerIn, markerOut);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.video = null;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a sequence marker to this video.\r\n     *\r\n     * Markers allow you to split a video up into sequences, delineated by a start and end time, given in seconds.\r\n     *\r\n     * You can then play back specific markers via the `playMarker` method.\r\n     *\r\n     * Note that marker timing is _not_ frame-perfect. You should construct your videos in such a way that you allow for\r\n     * plenty of extra padding before and after each sequence to allow for discrepancies in browser seek and currentTime accuracy.\r\n     *\r\n     * See https://github.com/w3c/media-and-entertainment/issues/4 for more details about this issue.\r\n     *\r\n     * @method Phaser.GameObjects.Video#addMarker\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - A unique name to give this marker.\r\n     * @param {number} markerIn - The time, in seconds, representing the start of this marker.\r\n     * @param {number} markerOut - The time, in seconds, representing the end of this marker.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    addMarker: function (key, markerIn, markerOut)\r\n    {\r\n        if (!isNaN(markerIn) && markerIn >= 0 && !isNaN(markerOut))\r\n        {\r\n            this.markers[key] = [ markerIn, markerOut ];\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Plays a pre-defined sequence in this video.\r\n     *\r\n     * Markers allow you to split a video up into sequences, delineated by a start and end time, given in seconds and\r\n     * specified via the `addMarker` method.\r\n     *\r\n     * Note that marker timing is _not_ frame-perfect. You should construct your videos in such a way that you allow for\r\n     * plenty of extra padding before and after each sequence to allow for discrepancies in browser seek and currentTime accuracy.\r\n     *\r\n     * See https://github.com/w3c/media-and-entertainment/issues/4 for more details about this issue.\r\n     *\r\n     * @method Phaser.GameObjects.Video#playMarker\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - The name of the marker sequence to play.\r\n     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    playMarker: function (key, loop)\r\n    {\r\n        var marker = this.markers[key];\r\n\r\n        if (marker)\r\n        {\r\n            this.play(loop, marker[0], marker[1]);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a previously set marker from this video.\r\n     *\r\n     * If the marker is currently playing it will _not_ stop playback.\r\n     *\r\n     * @method Phaser.GameObjects.Video#removeMarker\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - The name of the marker to remove.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    removeMarker: function (key)\r\n    {\r\n        delete this.markers[key];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the current frame of the video and renders it to a CanvasTexture object,\r\n     * which is then returned. You can optionally resize the grab by passing a width and height.\r\n     *\r\n     * This method returns a reference to the `Video.snapshotTexture` object. Calling this method\r\n     * multiple times will overwrite the previous snapshot with the most recent one.\r\n     *\r\n     * @method Phaser.GameObjects.Video#snapshot\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} [width] - The width of the resulting CanvasTexture.\r\n     * @param {number} [height] - The height of the resulting CanvasTexture.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture}\r\n     */\r\n    snapshot: function (width, height)\r\n    {\r\n        if (width === undefined) { width = this.width; }\r\n        if (height === undefined) { height = this.height; }\r\n\r\n        return this.snapshotArea(0, 0, this.width, this.height, width, height);\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the specified area of the current frame of the video and renders it to a CanvasTexture object,\r\n     * which is then returned. You can optionally resize the grab by passing a different `destWidth` and `destHeight`.\r\n     *\r\n     * This method returns a reference to the `Video.snapshotTexture` object. Calling this method\r\n     * multiple times will overwrite the previous snapshot with the most recent one.\r\n     *\r\n     * @method Phaser.GameObjects.Video#snapshotArea\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal location of the top-left of the area to grab from.\r\n     * @param {number} [y=0] - The vertical location of the top-left of the area to grab from.\r\n     * @param {number} [srcWidth] - The width of area to grab from the video. If not given it will grab the full video dimensions.\r\n     * @param {number} [srcHeight] - The height of area to grab from the video. If not given it will grab the full video dimensions.\r\n     * @param {number} [destWidth] - The destination width of the grab, allowing you to resize it.\r\n     * @param {number} [destHeight] - The destination height of the grab, allowing you to resize it.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture}\r\n     */\r\n    snapshotArea: function (x, y, srcWidth, srcHeight, destWidth, destHeight)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (srcWidth === undefined) { srcWidth = this.width; }\r\n        if (srcHeight === undefined) { srcHeight = this.height; }\r\n        if (destWidth === undefined) { destWidth = srcWidth; }\r\n        if (destHeight === undefined) { destHeight = srcHeight; }\r\n\r\n        var video = this.video;\r\n        var snap = this.snapshotTexture;\r\n\r\n        if (!snap)\r\n        {\r\n            snap = this.scene.sys.textures.createCanvas(UUID(), destWidth, destHeight);\r\n\r\n            this.snapshotTexture = snap;\r\n\r\n            if (video)\r\n            {\r\n                snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            snap.setSize(destWidth, destHeight);\r\n\r\n            if (video)\r\n            {\r\n                snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);\r\n            }\r\n        }\r\n\r\n        return snap.update();\r\n    },\r\n\r\n    /**\r\n     * Stores a copy of this Videos `snapshotTexture` in the Texture Manager using the given key.\r\n     *\r\n     * This texture is created when the `snapshot` or `snapshotArea` methods are called.\r\n     *\r\n     * After doing this, any texture based Game Object, such as a Sprite, can use the contents of the\r\n     * snapshot by using the texture key:\r\n     *\r\n     * ```javascript\r\n     * var vid = this.add.video(0, 0, 'intro');\r\n     *\r\n     * vid.snapshot();\r\n     *\r\n     * vid.saveSnapshotTexture('doodle');\r\n     *\r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     *\r\n     * Updating the contents of the `snapshotTexture`, for example by calling `snapshot` again,\r\n     * will automatically update _any_ Game Object that is using it as a texture.\r\n     * Calling `saveSnapshotTexture` again will not save another copy of the same texture,\r\n     * it will just rename the existing one.\r\n     *\r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame.\r\n     *\r\n     * @method Phaser.GameObjects.Video#saveSnapshotTexture\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} The Texture that was saved.\r\n     */\r\n    saveSnapshotTexture: function (key)\r\n    {\r\n        if (this.snapshotTexture)\r\n        {\r\n            this.scene.sys.textures.renameTexture(this.snapshotTexture.key, key);\r\n        }\r\n        else\r\n        {\r\n            this.snapshotTexture = this.scene.sys.textures.createCanvas(key, this.width, this.height);\r\n        }\r\n\r\n        return this.snapshotTexture;\r\n    },\r\n\r\n    /**\r\n     * Loads a Video from the given URL, ready for playback with the `Video.play` method.\r\n     *\r\n     * You can control at what point the browser determines the video as being ready for playback via\r\n     * the `loadEvent` parameter. See https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement\r\n     * for more details.\r\n     *\r\n     * @method Phaser.GameObjects.Video#loadURL\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} url - The URL of the video to load or be streamed.\r\n     * @param {string} [loadEvent='loadeddata'] - The load event to listen for. Either `loadeddata`, `canplay` or `canplaythrough`.\r\n     * @param {boolean} [noAudio=false] - Does the video have an audio track? If not you can enable auto-playing on it.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    loadURL: function (url, loadEvent, noAudio)\r\n    {\r\n        if (loadEvent === undefined) { loadEvent = 'loadeddata'; }\r\n        if (noAudio === undefined) { noAudio = false; }\r\n\r\n        if (this.video)\r\n        {\r\n            this.stop();\r\n        }\r\n\r\n        if (this.videoTexture)\r\n        {\r\n            this.scene.sys.textures.remove(this._key);\r\n        }\r\n\r\n        var video = document.createElement('video');\r\n\r\n        video.controls = false;\r\n\r\n        if (noAudio)\r\n        {\r\n            video.muted = true;\r\n            video.defaultMuted = true;\r\n\r\n            video.setAttribute('autoplay', 'autoplay');\r\n        }\r\n\r\n        video.setAttribute('playsinline', 'playsinline');\r\n        video.setAttribute('preload', 'auto');\r\n\r\n        video.addEventListener('error', this._callbacks.error, true);\r\n\r\n        video.src = url;\r\n\r\n        video.load();\r\n\r\n        this.video = video;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Loads a Video from the given MediaStream object, ready for playback with the `Video.play` method.\r\n     *\r\n     * You can control at what point the browser determines the video as being ready for playback via\r\n     * the `loadEvent` parameter. See https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement\r\n     * for more details.\r\n     *\r\n     * @method Phaser.GameObjects.Video#loadMediaStream\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} stream - The MediaStream object.\r\n     * @param {string} [loadEvent='loadeddata'] - The load event to listen for. Either `loadeddata`, `canplay` or `canplaythrough`.\r\n     * @param {boolean} [noAudio=false] - Does the video have an audio track? If not you can enable auto-playing on it.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    loadMediaStream: function (stream, loadEvent, noAudio)\r\n    {\r\n        if (loadEvent === undefined) { loadEvent = 'loadeddata'; }\r\n        if (noAudio === undefined) { noAudio = false; }\r\n\r\n        if (this.video)\r\n        {\r\n            this.stop();\r\n        }\r\n\r\n        if (this.videoTexture)\r\n        {\r\n            this.scene.sys.textures.remove(this._key);\r\n        }\r\n\r\n        var video = document.createElement('video');\r\n\r\n        video.controls = false;\r\n\r\n        if (noAudio)\r\n        {\r\n            video.muted = true;\r\n            video.defaultMuted = true;\r\n\r\n            video.setAttribute('autoplay', 'autoplay');\r\n        }\r\n\r\n        video.setAttribute('playsinline', 'playsinline');\r\n        video.setAttribute('preload', 'auto');\r\n\r\n        video.addEventListener('error', this._callbacks.error, true);\r\n\r\n        try\r\n        {\r\n            video.srcObject = stream;\r\n        }\r\n        catch (error)\r\n        {\r\n            video.src = window.URL.createObjectURL(stream);\r\n        }\r\n\r\n        video.load();\r\n\r\n        this.video = video;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This internal method is called automatically if the playback Promise resolves successfully.\r\n     *\r\n     * @method Phaser.GameObjects.Video#playPromiseSuccessHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_PLAY\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    playPromiseSuccessHandler: function ()\r\n    {\r\n        this._codePaused = false;\r\n        this.touchLocked = false;\r\n\r\n        this.emit(Events.VIDEO_PLAY, this);\r\n\r\n        if (this._markerIn > -1)\r\n        {\r\n            this.video.currentTime = this._markerIn;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This internal method is called automatically if the playback Promise fails to resolve.\r\n     *\r\n     * @method Phaser.GameObjects.Video#playPromiseErrorHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_ERROR\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {any} error - The Promise resolution error.\r\n     */\r\n    playPromiseErrorHandler: function (error)\r\n    {\r\n        this.scene.sys.input.once(InputEvents.POINTER_DOWN, this.unlockHandler, this);\r\n\r\n        this.touchLocked = true;\r\n        this.playWhenUnlocked = true;\r\n\r\n        this.emit(Events.VIDEO_ERROR, this, error);\r\n    },\r\n\r\n    /**\r\n     * Called when the video emits a `playing` event during load.\r\n     *\r\n     * This is only listened for if the browser doesn't support Promises.\r\n     *\r\n     * @method Phaser.GameObjects.Video#playHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_PLAY\r\n     * @since 3.20.0\r\n     */\r\n    playHandler: function ()\r\n    {\r\n        this._codePaused = false;\r\n        this.touchLocked = false;\r\n\r\n        this.emit(Events.VIDEO_PLAY, this);\r\n\r\n        this.video.removeEventListener('playing', this._callbacks.play, true);\r\n    },\r\n\r\n    /**\r\n     * This internal method is called automatically if the video fails to load.\r\n     *\r\n     * @method Phaser.GameObjects.Video#loadErrorHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_ERROR\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {Event} event - The error Event.\r\n     */\r\n    loadErrorHandler: function (event)\r\n    {\r\n        this.stop();\r\n\r\n        this.emit(Events.VIDEO_ERROR, this, event);\r\n    },\r\n\r\n    /**\r\n     * This internal method is called if the video couldn't be played because it was interaction locked\r\n     * by the browser, but an input event has since been received.\r\n     *\r\n     * @method Phaser.GameObjects.Video#unlockHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_UNLOCKED\r\n     * @fires Phaser.GameObjects.Events#VIDEO_PLAY\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {any} error - The Promise resolution error.\r\n     */\r\n    unlockHandler: function ()\r\n    {\r\n        this.touchLocked = false;\r\n        this.playWhenUnlocked = false;\r\n\r\n        this.emit(Events.VIDEO_UNLOCKED, this);\r\n\r\n        if (this._markerIn > -1)\r\n        {\r\n            this.video.currentTime = this._markerIn;\r\n        }\r\n\r\n        this.video.play();\r\n\r\n        this.emit(Events.VIDEO_PLAY, this);\r\n    },\r\n\r\n    /**\r\n     * Called when the video completes playback, i.e. reaches an `ended` state.\r\n     *\r\n     * This will never happen if the video is coming from a live stream, where the duration is `Infinity`.\r\n     *\r\n     * @method Phaser.GameObjects.Video#completeHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_COMPLETE\r\n     * @since 3.20.0\r\n     */\r\n    completeHandler: function ()\r\n    {\r\n        this.emit(Events.VIDEO_COMPLETE, this);\r\n    },\r\n\r\n    /**\r\n     * Called when the video emits a `timeUpdate` event during playback.\r\n     *\r\n     * This event is too slow and irregular to be used for actual video timing or texture updating,\r\n     * but we can use it to determine if a video has looped.\r\n     *\r\n     * @method Phaser.GameObjects.Video#timeUpdateHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_LOOP\r\n     * @since 3.20.0\r\n     */\r\n    timeUpdateHandler: function ()\r\n    {\r\n        if (this.video && this.video.currentTime < this._lastUpdate)\r\n        {\r\n            this.emit(Events.VIDEO_LOOP, this);\r\n\r\n            this._lastUpdate = 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The internal update step.\r\n     *\r\n     * @method Phaser.GameObjects.Video#preUpdate\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            var currentTime = video.currentTime;\r\n\r\n            //  Don't render a new frame unless the video has actually changed time\r\n            if (currentTime !== this._lastUpdate)\r\n            {\r\n                this._lastUpdate = currentTime;\r\n\r\n                this.updateTexture();\r\n\r\n                if (currentTime >= this._markerOut)\r\n                {\r\n                    if (video.loop)\r\n                    {\r\n                        video.currentTime = this._markerIn;\r\n\r\n                        this.updateTexture();\r\n\r\n                        this._lastUpdate = currentTime;\r\n\r\n                        this.emit(Events.VIDEO_LOOP, this);\r\n                    }\r\n                    else\r\n                    {\r\n                        this.emit(Events.VIDEO_COMPLETE, this);\r\n\r\n                        this.stop();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal callback that monitors the download progress of a video after changing its source.\r\n     *\r\n     * @method Phaser.GameObjects.Video#checkVideoProgress\r\n     * @fires Phaser.GameObjects.Events#VIDEO_TIMEOUT\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    checkVideoProgress: function ()\r\n    {\r\n        if (this.video.readyState >= 2)\r\n        {\r\n            //  We've got enough data to update the texture for playback\r\n            this.updateTexture();\r\n        }\r\n        else\r\n        {\r\n            this.retry--;\r\n\r\n            if (this.retry > 0)\r\n            {\r\n                this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\r\n            }\r\n            else\r\n            {\r\n                this.emit(Events.VIDEO_TIMEOUT, this);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that is called when enough video data has been received in order to create a texture\r\n     * from it. The texture is assigned to the `Video.videoTexture` property and given a base frame that\r\n     * encompases the whole video size.\r\n     *\r\n     * @method Phaser.GameObjects.Video#updateTexture\r\n     * @since 3.20.0\r\n     */\r\n    updateTexture: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        var width = video.videoWidth;\r\n        var height = video.videoHeight;\r\n\r\n        if (!this.videoTexture)\r\n        {\r\n            this.videoTexture = this.scene.sys.textures.create(this._key, video, width, height);\r\n            this.videoTextureSource = this.videoTexture.source[0];\r\n            this.videoTexture.add('__BASE', 0, 0, 0, width, height);\r\n\r\n            this.setTexture(this.videoTexture);\r\n            this.setSizeToFrame();\r\n            this.updateDisplayOrigin();\r\n\r\n            this.emit(Events.VIDEO_CREATED, this, width, height);\r\n        }\r\n        else\r\n        {\r\n            var textureSource = this.videoTextureSource;\r\n\r\n            if (textureSource.source !== video)\r\n            {\r\n                textureSource.source = video;\r\n                textureSource.width = width;\r\n                textureSource.height = height;\r\n            }\r\n\r\n            textureSource.update();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns the key of the currently played video, as stored in the Video Cache.\r\n     * If the video did not come from the cache this will return an empty string.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getVideoKey\r\n     * @since 3.20.0\r\n     *\r\n     * @return {string} The key of the video being played from the Video Cache, if any.\r\n     */\r\n    getVideoKey: function ()\r\n    {\r\n        return this._cacheKey;\r\n    },\r\n\r\n    /**\r\n     * Seeks to a given point in the video. The value is given as a float between 0 and 1,\r\n     * where 0 represents the start of the video and 1 represents the end.\r\n     *\r\n     * Seeking only works if the video has a duration, so will not work for live streams.\r\n     *\r\n     * When seeking begins, this video will emit a `seeking` event. When the video completes\r\n     * seeking (i.e. reaches its designated timestamp) it will emit a `seeked` event.\r\n     *\r\n     * If you wish to seek based on time instead, use the `Video.setCurrentTime` method.\r\n     *\r\n     * @method Phaser.GameObjects.Video#seekTo\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} value - The point in the video to seek to. A value between 0 and 1.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    seekTo: function (value)\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            var duration = video.duration;\r\n\r\n            if (duration !== Infinity && !isNaN(duration))\r\n            {\r\n                var seekTime = duration * value;\r\n\r\n                this.setCurrentTime(seekTime);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * A double-precision floating-point value indicating the current playback time in seconds.\r\n     * If the media has not started to play and has not been seeked, this value is the media's initial playback time.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getCurrentTime\r\n     * @since 3.20.0\r\n     *\r\n     * @return {number} A double-precision floating-point value indicating the current playback time in seconds.\r\n     */\r\n    getCurrentTime: function ()\r\n    {\r\n        return (this.video) ? this.video.currentTime : 0;\r\n    },\r\n\r\n    /**\r\n     * Seeks to a given playback time in the video. The value is given in _seconds_ or as a string.\r\n     *\r\n     * Seeking only works if the video has a duration, so will not work for live streams.\r\n     *\r\n     * When seeking begins, this video will emit a `seeking` event. When the video completes\r\n     * seeking (i.e. reaches its designated timestamp) it will emit a `seeked` event.\r\n     *\r\n     * You can provide a string prefixed with either a `+` or a `-`, such as `+2.5` or `-2.5`.\r\n     * In this case it will seek to +/- the value given, relative to the _current time_.\r\n     *\r\n     * If you wish to seek based on a duration percentage instead, use the `Video.seekTo` method.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setCurrentTime\r\n     * @since 3.20.0\r\n     *\r\n     * @param {(string|number)} value - The playback time to seek to in seconds. Can be expressed as a string, such as `+2` to seek 2 seconds ahead from the current time.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setCurrentTime: function (value)\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            if (typeof value === 'string')\r\n            {\r\n                var op = value[0];\r\n                var num = parseFloat(value.substr(1));\r\n\r\n                if (op === '+')\r\n                {\r\n                    value = video.currentTime + num;\r\n                }\r\n                else if (op === '-')\r\n                {\r\n                    value = video.currentTime - num;\r\n                }\r\n            }\r\n\r\n            video.currentTime = value;\r\n\r\n            this._lastUpdate = value;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean indicating if this Video is currently seeking, or not.\r\n     *\r\n     * @method Phaser.GameObjects.Video#isSeeking\r\n     * @since 3.20.0\r\n     *\r\n     * @return {boolean} A boolean indicating if this Video is currently seeking, or not.\r\n     */\r\n    isSeeking: function ()\r\n    {\r\n        return this._isSeeking;\r\n    },\r\n\r\n    /**\r\n     * Internal seeking handler.\r\n     *\r\n     * @method Phaser.GameObjects.Video#seekingHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_SEEKING\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    seekingHandler: function ()\r\n    {\r\n        this._isSeeking = true;\r\n\r\n        this.emit(Events.VIDEO_SEEKING, this);\r\n    },\r\n\r\n    /**\r\n     * Internal seeked handler.\r\n     *\r\n     * @method Phaser.GameObjects.Video#seekedHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_SEEKED\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    seekedHandler: function ()\r\n    {\r\n        this._isSeeking = false;\r\n\r\n        this.emit(Events.VIDEO_SEEKED, this);\r\n\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            this.updateTexture();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns the current progress of the video. Progress is defined as a value between 0 (the start)\r\n     * and 1 (the end).\r\n     *\r\n     * Progress can only be returned if the video has a duration, otherwise it will always return zero.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getProgress\r\n     * @since 3.20.0\r\n     *\r\n     * @return {number} The current progress of playback. If the video has no duration, will always return zero.\r\n     */\r\n    getProgress: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            var now = video.currentTime;\r\n            var duration = video.duration;\r\n\r\n            if (duration !== Infinity && !isNaN(duration))\r\n            {\r\n                return now / duration;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * A double-precision floating-point value which indicates the duration (total length) of the media in seconds,\r\n     * on the media's timeline. If no media is present on the element, or the media is not valid, the returned value is NaN.\r\n     *\r\n     * If the media has no known end (such as for live streams of unknown duration, web radio, media incoming from WebRTC,\r\n     * and so forth), this value is +Infinity.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getDuration\r\n     * @since 3.20.0\r\n     *\r\n     * @return {number} A double-precision floating-point value indicating the duration of the media in seconds.\r\n     */\r\n    getDuration: function ()\r\n    {\r\n        return (this.video) ? this.video.duration : 0;\r\n    },\r\n\r\n    /**\r\n     * Sets the muted state of the currently playing video, if one is loaded.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setMute\r\n     * @since 3.20.0\r\n     *\r\n     * @param {boolean} [value=true] - The mute value. `true` if the video should be muted, otherwise `false`.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setMute: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this._codeMuted = value;\r\n\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            video.muted = (this._systemMuted) ? true : value;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean indicating if this Video is currently muted.\r\n     *\r\n     * @method Phaser.GameObjects.Video#isMuted\r\n     * @since 3.20.0\r\n     *\r\n     * @return {boolean} A boolean indicating if this Video is currently muted, or not.\r\n     */\r\n    isMuted: function ()\r\n    {\r\n        return this._codeMuted;\r\n    },\r\n\r\n    /**\r\n     * Internal global mute handler. Will mute the video, if playing, if the global sound system mutes.\r\n     *\r\n     * @method Phaser.GameObjects.Video#globalMute\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {(Phaser.Sound.WebAudioSoundManager|Phaser.Sound.HTML5AudioSoundManager)} soundManager - A reference to the Sound Manager that emitted the event.\r\n     * @param {boolean} mute - The mute value. `true` if the Sound Manager is now muted, otherwise `false`.\r\n     */\r\n    globalMute: function (soundManager, value)\r\n    {\r\n        this._systemMuted = value;\r\n\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            video.muted = (this._codeMuted) ? true : value;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal global pause handler. Will pause the video if the Game itself pauses.\r\n     *\r\n     * @method Phaser.GameObjects.Video#globalPause\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    globalPause: function ()\r\n    {\r\n        this._systemPaused = true;\r\n\r\n        if (this.video)\r\n        {\r\n            this.video.pause();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal global resume handler. Will resume a paused video if the Game itself resumes.\r\n     *\r\n     * @method Phaser.GameObjects.Video#globalResume\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    globalResume: function ()\r\n    {\r\n        this._systemPaused = false;\r\n\r\n        if (this.video && !this._codePaused)\r\n        {\r\n            this.video.play();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the paused state of the currently loaded video.\r\n     *\r\n     * If the video is playing, calling this method with `true` will pause playback.\r\n     * If the video is paused, calling this method with `false` will resume playback.\r\n     *\r\n     * If no video is loaded, this method does nothing.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setPaused\r\n     * @since 3.20.0\r\n     *\r\n     * @param {boolean} [value=true] - The paused value. `true` if the video should be paused, `false` to resume it.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setPaused: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        var video = this.video;\r\n\r\n        this._codePaused = value;\r\n\r\n        if (video)\r\n        {\r\n            if (value)\r\n            {\r\n                if (!video.paused)\r\n                {\r\n                    video.pause();\r\n                }\r\n            }\r\n            else if (!value)\r\n            {\r\n                if (video.paused && !this._systemPaused)\r\n                {\r\n                    video.play();\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n     *\r\n     * @method Phaser.GameObjects.Video#getVolume\r\n     * @since 3.20.0\r\n     *\r\n     * @return {number} A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n     */\r\n    getVolume: function ()\r\n    {\r\n        return (this.video) ? this.video.volume : 1;\r\n    },\r\n\r\n    /**\r\n     * Sets the volume of the currently playing video.\r\n     *\r\n     * The value given is a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n     *\r\n     * @method Phaser.GameObjects.Video#setVolume\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} [value=1] - A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setVolume: function (value)\r\n    {\r\n        if (value === undefined) { value = 1; }\r\n\r\n        if (this.video)\r\n        {\r\n            this.video.volume = Clamp(value, 0, 1);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a double that indicates the rate at which the media is being played back.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getPlaybackRate\r\n     * @since 3.20.0\r\n     *\r\n     * @return {number} A double that indicates the rate at which the media is being played back.\r\n     */\r\n    getPlaybackRate: function ()\r\n    {\r\n        return (this.video) ? this.video.playbackRate : 1;\r\n    },\r\n\r\n    /**\r\n     * Sets the playback rate of the current video.\r\n     *\r\n     * The value given is a double that indicates the rate at which the media is being played back.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setPlaybackRate\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} [rate] - A double that indicates the rate at which the media is being played back.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setPlaybackRate: function (rate)\r\n    {\r\n        if (this.video)\r\n        {\r\n            this.video.playbackRate = rate;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean which indicates whether the media element should start over when it reaches the end.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getLoop\r\n     * @since 3.20.0\r\n     *\r\n     * @return {boolean} A boolean which indicates whether the media element will start over when it reaches the end.\r\n     */\r\n    getLoop: function ()\r\n    {\r\n        return (this.video) ? this.video.loop : false;\r\n    },\r\n\r\n    /**\r\n     * Sets the loop state of the current video.\r\n     *\r\n     * The value given is a boolean which indicates whether the media element will start over when it reaches the end.\r\n     *\r\n     * Not all videos can loop, for example live streams.\r\n     *\r\n     * Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setLoop\r\n     * @since 3.20.0\r\n     *\r\n     * @param {boolean} [value=true] - A boolean which indicates whether the media element will start over when it reaches the end.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setLoop: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        if (this.video)\r\n        {\r\n            this.video.loop = value;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean which indicates whether the video is currently playing.\r\n     *\r\n     * @method Phaser.GameObjects.Video#isPlaying\r\n     * @since 3.20.0\r\n     *\r\n     * @return {boolean} A boolean which indicates whether the video is playing, or not.\r\n     */\r\n    isPlaying: function ()\r\n    {\r\n        return (this.video) ? !(this.video.paused || this.video.ended) : false;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean which indicates whether the video is currently paused.\r\n     *\r\n     * @method Phaser.GameObjects.Video#isPaused\r\n     * @since 3.20.0\r\n     *\r\n     * @return {boolean} A boolean which indicates whether the video is paused, or not.\r\n     */\r\n    isPaused: function ()\r\n    {\r\n        return ((this.video && this.video.paused) || this._codePaused || this._systemPaused);\r\n    },\r\n\r\n    /**\r\n     * Stores this Video in the Texture Manager using the given key as a dynamic texture,\r\n     * which any texture-based Game Object, such as a Sprite, can use as its texture:\r\n     *\r\n     * ```javascript\r\n     * var vid = this.add.video(0, 0, 'intro');\r\n     *\r\n     * vid.play();\r\n     *\r\n     * vid.saveTexture('doodle');\r\n     *\r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     *\r\n     * The saved texture is automatically updated as the video plays. If you pause this video,\r\n     * or change its source, then the saved texture updates instantly.\r\n     *\r\n     * Calling `saveTexture` again will not save another copy of the same texture, it will just rename the existing one.\r\n     *\r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame.\r\n     *\r\n     * If you intend to save the texture so you can use it as the input for a Shader, you may need to set the\r\n     * `flipY` parameter to `true` if you find the video renders upside down in your shader.\r\n     *\r\n     * @method Phaser.GameObjects.Video#saveTexture\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y` during upload?\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was saved.\r\n     */\r\n    saveTexture: function (key, flipY)\r\n    {\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        if (this.videoTexture)\r\n        {\r\n            this.scene.sys.textures.renameTexture(this._key, key);\r\n        }\r\n\r\n        this._key = key;\r\n\r\n        this.flipY = flipY;\r\n\r\n        if (this.videoTextureSource)\r\n        {\r\n            this.videoTextureSource.setFlipY(flipY);\r\n        }\r\n\r\n        return this.videoTexture;\r\n    },\r\n\r\n    /**\r\n     * Stops the video playing and clears all internal event listeners.\r\n     *\r\n     * If you only wish to pause playback of the video, and resume it a later time, use the `Video.pause` method instead.\r\n     *\r\n     * If the video hasn't finished downloading, calling this method will not abort the download. To do that you need to\r\n     * call `destroy` instead.\r\n     *\r\n     * @method Phaser.GameObjects.Video#stop\r\n     * @fires Phaser.GameObjects.Events#VIDEO_STOP\r\n     * @since 3.20.0\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    stop: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            var callbacks = this._callbacks;\r\n\r\n            for (var callback in callbacks)\r\n            {\r\n                video.removeEventListener(callback, callbacks[callback], true);\r\n            }\r\n\r\n            video.pause();\r\n        }\r\n\r\n        if (this._retryID)\r\n        {\r\n            window.clearTimeout(this._retryID);\r\n        }\r\n\r\n        this.emit(Events.VIDEO_STOP, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the Video element from the DOM by calling parentNode.removeChild on itself.\r\n     *\r\n     * Also removes the autoplay and src attributes and nulls the Video reference.\r\n     *\r\n     * You should not call this method if you were playing a video from the Video Cache that\r\n     * you wish to play again in your game, or if another Video object is also using the same\r\n     * video.\r\n     *\r\n     * If you loaded an external video via `Video.loadURL` then you should call this function\r\n     * to clear up once you are done with the instance.\r\n     *\r\n     * @method Phaser.GameObjects.Video#removeVideoElement\r\n     * @since 3.20.0\r\n     */\r\n    removeVideoElement: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        if (!video)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (video.parentNode)\r\n        {\r\n            video.parentNode.removeChild(video);\r\n        }\r\n\r\n        while (video.hasChildNodes())\r\n        {\r\n            video.removeChild(video.firstChild);\r\n        }\r\n\r\n        video.removeAttribute('autoplay');\r\n        video.removeAttribute('src');\r\n\r\n        this.video = null;\r\n    },\r\n\r\n    /**\r\n     * Handles the pre-destroy step for the Video object.\r\n     *\r\n     * This calls `Video.stop` and optionally `Video.removeVideoElement`.\r\n     *\r\n     * If any Sprites are using this Video as their texture it is up to you to manage those.\r\n     *\r\n     * @method Phaser.GameObjects.Video#preDestroy\r\n     * @private\r\n     * @since 3.21.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.stop();\r\n\r\n        if (this.removeVideoElementOnDestroy)\r\n        {\r\n            this.removeVideoElement();\r\n        }\r\n\r\n        var game = this.scene.sys.game.events;\r\n\r\n        game.off(GameEvents.PAUSE, this.globalPause, this);\r\n        game.off(GameEvents.RESUME, this.globalResume, this);\r\n\r\n        var sound = this.scene.sys.sound;\r\n\r\n        if (sound)\r\n        {\r\n            sound.off(SoundEvents.GLOBAL_MUTE, this.globalMute, this);\r\n        }\r\n\r\n        if (this._retryID)\r\n        {\r\n            window.clearTimeout(this._retryID);\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Video;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Extend = require('../../utils/object/Extend');\r\nvar SetValue = require('../../utils/object/SetValue');\r\nvar ShaderRender = require('./ShaderRender');\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\n\r\n/**\r\n * @classdesc\r\n * A Shader Game Object.\r\n *\r\n * This Game Object allows you to easily add a quad with its own shader into the display list, and manipulate it\r\n * as you would any other Game Object, including scaling, rotating, positioning and adding to Containers. Shaders\r\n * can be masked with either Bitmap or Geometry masks and can also be used as a Bitmap Mask for a Camera or other\r\n * Game Object. They can also be made interactive and used for input events.\r\n *\r\n * It works by taking a reference to a `Phaser.Display.BaseShader` instance, as found in the Shader Cache. These can\r\n * be created dynamically at runtime, or loaded in via the GLSL File Loader:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.glsl('fire', 'shaders/fire.glsl.js');\r\n * }\r\n *\r\n * function create ()\r\n * {\r\n *     this.add.shader('fire', 400, 300, 512, 512);\r\n * }\r\n * ```\r\n *\r\n * Please see the Phaser 3 Examples GitHub repo for examples of loading and creating shaders dynamically.\r\n *\r\n * Due to the way in which they work, you cannot directly change the alpha or blend mode of a Shader. This should\r\n * be handled via exposed uniforms in the shader code itself.\r\n *\r\n * By default a Shader will be created with a standard set of uniforms. These were added to match those\r\n * found on sites such as ShaderToy or GLSLSandbox, and provide common functionality a shader may need,\r\n * such as the timestamp, resolution or pointer position. You can replace them by specifying your own uniforms\r\n * in the Base Shader.\r\n *\r\n * These Shaders work by halting the current pipeline during rendering, creating a viewport matched to the\r\n * size of this Game Object and then renders a quad using the bound shader. At the end, the pipeline is restored.\r\n *\r\n * Because it blocks the pipeline it means it will interrupt any batching that is currently going on, so you should\r\n * use these Game Objects sparingly. If you need to have a fully batched custom shader, then please look at using\r\n * a custom pipeline instead. However, for background or special masking effects, they are extremely effective.\r\n *\r\n * @class Shader\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @webglOnly\r\n * @since 3.17.0\r\n *\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the Game Object.\r\n * @param {number} [height=128] - The height of the Game Object.\r\n * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n * @param {any} [textureData] - Additional texture data if you want to create shader with none NPOT textures.\r\n */\r\nvar Shader = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.ComputedSize,\r\n        Components.Depth,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.ScrollFactor,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        ShaderRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Shader (scene, key, x, y, width, height, textures, textureData)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = 128; }\r\n        if (height === undefined) { height = 128; }\r\n\r\n        GameObject.call(this, scene, 'Shader');\r\n\r\n        /**\r\n         * This Game Object cannot have a blend mode, so skip all checks.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#blendMode\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this.blendMode = -1;\r\n\r\n        /**\r\n         * The underlying shader object being used.\r\n         * Empty by default and set during a call to the `setShader` method.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#shader\r\n         * @type {Phaser.Display.BaseShader}\r\n         * @since 3.17.0\r\n         */\r\n        this.shader;\r\n\r\n        var renderer = scene.sys.renderer;\r\n\r\n        /**\r\n         * A reference to the current renderer.\r\n         * Shaders only work with the WebGL Renderer.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.17.0\r\n         */\r\n        this.renderer = renderer;\r\n\r\n        /**\r\n         * The WebGL context belonging to the renderer.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @since 3.17.0\r\n         */\r\n        this.gl = renderer.gl;\r\n\r\n        /**\r\n         * Raw byte buffer of vertices this Shader uses.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#vertexData\r\n         * @type {ArrayBuffer}\r\n         * @since 3.17.0\r\n         */\r\n        this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2));\r\n\r\n        /**\r\n         * The WebGL vertex buffer object this shader uses.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#vertexBuffer\r\n         * @type {WebGLBuffer}\r\n         * @since 3.17.0\r\n         */\r\n        this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW);\r\n\r\n        /**\r\n         * The WebGL shader program this shader uses.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#program\r\n         * @type {WebGLProgram}\r\n         * @since 3.17.0\r\n         */\r\n        this.program = null;\r\n\r\n        /**\r\n         * Uint8 view to the vertex raw buffer. Used for uploading vertex buffer resources to the GPU.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#bytes\r\n         * @type {Uint8Array}\r\n         * @since 3.17.0\r\n         */\r\n        this.bytes = new Uint8Array(this.vertexData);\r\n\r\n        /**\r\n         * Float32 view of the array buffer containing the shaders vertices.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#vertexViewF32\r\n         * @type {Float32Array}\r\n         * @since 3.17.0\r\n         */\r\n        this.vertexViewF32 = new Float32Array(this.vertexData);\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_tempMatrix1\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.17.0\r\n         */\r\n        this._tempMatrix1 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_tempMatrix2\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.17.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_tempMatrix3\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.17.0\r\n         */\r\n        this._tempMatrix3 = new TransformMatrix();\r\n\r\n        /**\r\n         * The view matrix the shader uses during rendering.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#viewMatrix\r\n         * @type {Float32Array}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.viewMatrix = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);\r\n\r\n        /**\r\n         * The projection matrix the shader uses during rendering.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#projectionMatrix\r\n         * @type {Float32Array}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.projectionMatrix = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);\r\n\r\n        /**\r\n         * The default uniform mappings. These can be added to (or replaced) by specifying your own uniforms when\r\n         * creating this shader game object. The uniforms are updated automatically during the render step.\r\n         *\r\n         * The defaults are:\r\n         *\r\n         * `resolution` (2f) - Set to the size of this shader.\r\n         * `time` (1f) - The elapsed game time, in seconds.\r\n         * `mouse` (2f) - If a pointer has been bound (with `setPointer`), this uniform contains its position each frame.\r\n         * `date` (4fv) - A vec4 containing the year, month, day and time in seconds.\r\n         * `sampleRate` (1f) - Sound sample rate. 44100 by default.\r\n         * `iChannel0...3` (sampler2D) - Input channels 0 to 3. `null` by default.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#uniforms\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.uniforms = {};\r\n\r\n        /**\r\n         * The pointer bound to this shader, if any.\r\n         * Set via the chainable `setPointer` method, or by modifying this property directly.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#pointer\r\n         * @type {Phaser.Input.Pointer}\r\n         * @since 3.17.0\r\n         */\r\n        this.pointer = null;\r\n\r\n        /**\r\n         * The cached width of the renderer.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_rendererWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._rendererWidth = renderer.width;\r\n\r\n        /**\r\n         * The cached height of the renderer.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_rendererHeight\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._rendererHeight = renderer.height;\r\n\r\n        /**\r\n         * Internal texture count tracker.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_textureCount\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._textureCount = 0;\r\n\r\n        /**\r\n         * A reference to the GL Frame Buffer this Shader is drawing to.\r\n         * This property is only set if you have called `Shader.setRenderToTexture`.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#framebuffer\r\n         * @type {?WebGLFramebuffer}\r\n         * @since 3.19.0\r\n         */\r\n        this.framebuffer = null;\r\n\r\n        /**\r\n         * A reference to the WebGLTexture this Shader is rendering to.\r\n         * This property is only set if you have called `Shader.setRenderToTexture`.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#glTexture\r\n         * @type {?WebGLTexture}\r\n         * @since 3.19.0\r\n         */\r\n        this.glTexture = null;\r\n\r\n        /**\r\n         * A flag that indicates if this Shader has been set to render to a texture instead of the display list.\r\n         *\r\n         * This property is `true` if you have called `Shader.setRenderToTexture`, otherwise it's `false`.\r\n         *\r\n         * A Shader that is rendering to a texture _does not_ appear on the display list.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#renderToTexture\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this.renderToTexture = false;\r\n\r\n        /**\r\n         * A reference to the Phaser.Textures.Texture that has been stored in the Texture Manager for this Shader.\r\n         *\r\n         * This property is only set if you have called `Shader.setRenderToTexture`, otherwise it is `null`.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.19.0\r\n         */\r\n        this.texture = null;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(width, height);\r\n        this.setOrigin(0.5, 0.5);\r\n        this.setShader(key, textures, textureData);\r\n    },\r\n\r\n    /**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     * Also checks the Game Object against the given Cameras exclusion list.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#willRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n     */\r\n    willRender: function (camera)\r\n    {\r\n        if (this.renderToTexture)\r\n        {\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return !(GameObject.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Changes this Shader so instead of rendering to the display list it renders to a\r\n     * WebGL Framebuffer and WebGL Texture instead. This allows you to use the output\r\n     * of this shader as an input for another shader, by mapping a sampler2D uniform\r\n     * to it.\r\n     *\r\n     * After calling this method the `Shader.framebuffer` and `Shader.glTexture` properties\r\n     * are populated.\r\n     *\r\n     * Additionally, you can provide a key to this method. Doing so will create a Phaser Texture\r\n     * from this Shader and save it into the Texture Manager, allowing you to then use it for\r\n     * any texture-based Game Object, such as a Sprite or Image:\r\n     *\r\n     * ```javascript\r\n     * var shader = this.add.shader('myShader', x, y, width, height);\r\n     *\r\n     * shader.setRenderToTexture('doodle');\r\n     *\r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     *\r\n     * Note that it stores an active reference to this Shader. That means as this shader updates,\r\n     * so does the texture and any object using it to render with. Also, if you destroy this\r\n     * shader, be sure to clear any objects that may have been using it as a texture too.\r\n     *\r\n     * You can access the Phaser Texture that is created via the `Shader.texture` property.\r\n     *\r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame from a Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setRenderToTexture\r\n     * @since 3.19.0\r\n     *\r\n     * @param {string} [key] - The unique key to store the texture as within the global Texture Manager.\r\n     * @param {boolean} [flipY=false] - Does this texture need vertically flipping before rendering? This should usually be set to `true` if being fed from a buffer.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setRenderToTexture: function (key, flipY)\r\n    {\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        if (!this.renderToTexture)\r\n        {\r\n            var width = this.width;\r\n            var height = this.height;\r\n            var renderer = this.renderer;\r\n\r\n            this.glTexture = renderer.createTextureFromSource(null, width, height, 0);\r\n\r\n            this.glTexture.flipY = flipY;\r\n\r\n            this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, false);\r\n\r\n            this._rendererWidth = width;\r\n            this._rendererHeight = height;\r\n\r\n            this.renderToTexture = true;\r\n\r\n            this.projOrtho(0, this.width, this.height, 0);\r\n\r\n            if (key)\r\n            {\r\n                this.texture = this.scene.sys.textures.addGLTexture(key, this.glTexture, width, height);\r\n            }\r\n        }\r\n\r\n        //  And now render at least once, so our texture isn't blank on the first update\r\n\r\n        if (this.shader)\r\n        {\r\n            renderer.pipelines.clear();\r\n\r\n            this.load();\r\n            this.flush();\r\n\r\n            renderer.pipelines.rebind();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the fragment and, optionally, the vertex shader source code that this Shader will use.\r\n     * This will immediately delete the active shader program, if set, and then create a new one\r\n     * with the given source. Finally, the shader uniforms are initialized.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setShader\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n     * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setShader: function (key, textures, textureData)\r\n    {\r\n        if (textures === undefined) { textures = []; }\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            var cache = this.scene.sys.cache.shader;\r\n\r\n            if (!cache.has(key))\r\n            {\r\n                console.warn('Shader missing: ' + key);\r\n                return this;\r\n            }\r\n\r\n            this.shader = cache.get(key);\r\n        }\r\n        else\r\n        {\r\n            this.shader = key;\r\n        }\r\n\r\n        var gl = this.gl;\r\n        var renderer = this.renderer;\r\n\r\n        if (this.program)\r\n        {\r\n            gl.deleteProgram(this.program);\r\n        }\r\n\r\n        var program = renderer.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);\r\n\r\n        //  The default uniforms available within the vertex shader\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uViewMatrix'), false, this.viewMatrix);\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjectionMatrix'), false, this.projectionMatrix);\r\n        gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), this.width, this.height);\r\n\r\n        this.program = program;\r\n\r\n        var d = new Date();\r\n\r\n        //  The default uniforms available within the fragment shader\r\n        var defaultUniforms = {\r\n            resolution: { type: '2f', value: { x: this.width, y: this.height } },\r\n            time: { type: '1f', value: 0 },\r\n            mouse: { type: '2f', value: { x: this.width / 2, y: this.height / 2 } },\r\n            date: { type: '4fv', value: [ d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds() ] },\r\n            sampleRate: { type: '1f', value: 44100.0 },\r\n            iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: true } },\r\n            iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: true } },\r\n            iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: true } },\r\n            iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: true } }\r\n        };\r\n\r\n        if (this.shader.uniforms)\r\n        {\r\n            this.uniforms = Extend(true, {}, this.shader.uniforms, defaultUniforms);\r\n        }\r\n        else\r\n        {\r\n            this.uniforms = defaultUniforms;\r\n        }\r\n\r\n        for (var i = 0; i < 4; i++)\r\n        {\r\n            if (textures[i])\r\n            {\r\n                this.setSampler2D('iChannel' + i, textures[i], i, textureData);\r\n            }\r\n        }\r\n\r\n        this.initUniforms();\r\n\r\n        this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds a Phaser Pointer object to this Shader.\r\n     *\r\n     * The screen position of the pointer will be set in to the shaders `mouse` uniform\r\n     * automatically every frame. Call this method with no arguments to unbind the pointer.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setPointer\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} [pointer] - The Pointer to bind to this shader.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setPointer: function (pointer)\r\n    {\r\n        this.pointer = pointer;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets this shader to use an orthographic projection matrix.\r\n     * This matrix is stored locally in the `projectionMatrix` property,\r\n     * as well as being bound to the `uProjectionMatrix` uniform.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#projOrtho\r\n     * @since 3.17.0\r\n     *\r\n     * @param {number} left - The left value.\r\n     * @param {number} right - The right value.\r\n     * @param {number} bottom - The bottom value.\r\n     * @param {number} top - The top value.\r\n     */\r\n    projOrtho: function (left, right, bottom, top)\r\n    {\r\n        var near = -1000;\r\n        var far = 1000;\r\n\r\n        var leftRight = 1 / (left - right);\r\n        var bottomTop = 1 / (bottom - top);\r\n        var nearFar = 1 / (near - far);\r\n\r\n        var pm = this.projectionMatrix;\r\n\r\n        pm[0] = -2 * leftRight;\r\n        pm[5] = -2 * bottomTop;\r\n        pm[10] = 2 * nearFar;\r\n        pm[12] = (left + right) * leftRight;\r\n        pm[13] = (top + bottom) * bottomTop;\r\n        pm[14] = (far + near) * nearFar;\r\n\r\n        var program = this.program;\r\n\r\n        var gl = this.gl;\r\n        var renderer = this.renderer;\r\n\r\n        renderer.setProgram(program);\r\n\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjectionMatrix'), false, this.projectionMatrix);\r\n\r\n        this._rendererWidth = right;\r\n        this._rendererHeight = bottom;\r\n    },\r\n\r\n    // Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/\r\n    // http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\r\n\r\n    /**\r\n     * Initializes all of the uniforms this shader uses.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#initUniforms\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    initUniforms: function ()\r\n    {\r\n        var gl = this.gl;\r\n        var map = this.renderer.glFuncMap;\r\n        var program = this.program;\r\n\r\n        this._textureCount = 0;\r\n\r\n        for (var key in this.uniforms)\r\n        {\r\n            var uniform = this.uniforms[key];\r\n\r\n            var type = uniform.type;\r\n            var data = map[type];\r\n\r\n            uniform.uniformLocation = gl.getUniformLocation(program, key);\r\n\r\n            if (type !== 'sampler2D')\r\n            {\r\n                uniform.glMatrix = data.matrix;\r\n                uniform.glValueLength = data.length;\r\n                uniform.glFunc = data.func;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets a sampler2D uniform on this shader where the source texture is a WebGLTexture.\r\n     *\r\n     * This allows you to feed the output from one Shader into another:\r\n     *\r\n     * ```javascript\r\n     * let shader1 = this.add.shader(baseShader1, 0, 0, 512, 512).setRenderToTexture();\r\n     * let shader2 = this.add.shader(baseShader2, 0, 0, 512, 512).setRenderToTexture('output');\r\n     *\r\n     * shader1.setSampler2DBuffer('iChannel0', shader2.glTexture, 512, 512);\r\n     * shader2.setSampler2DBuffer('iChannel0', shader1.glTexture, 512, 512);\r\n     * ```\r\n     *\r\n     * In the above code, the result of baseShader1 is fed into Shader2 as the `iChannel0` sampler2D uniform.\r\n     * The result of baseShader2 is then fed back into shader1 again, creating a feedback loop.\r\n     *\r\n     * If you wish to use an image from the Texture Manager as a sampler2D input for this shader,\r\n     * see the `Shader.setSampler2D` method.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setSampler2DBuffer\r\n     * @since 3.19.0\r\n     *\r\n     * @param {string} uniformKey - The key of the sampler2D uniform to be updated, i.e. `iChannel0`.\r\n     * @param {WebGLTexture} texture - A WebGLTexture reference.\r\n     * @param {number} width - The width of the texture.\r\n     * @param {number} height - The height of the texture.\r\n     * @param {number} [textureIndex=0] - The texture index.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setSampler2DBuffer: function (uniformKey, texture, width, height, textureIndex, textureData)\r\n    {\r\n        if (textureIndex === undefined) { textureIndex = 0; }\r\n        if (textureData === undefined) { textureData = {}; }\r\n\r\n        var uniform = this.uniforms[uniformKey];\r\n\r\n        uniform.value = texture;\r\n\r\n        textureData.width = width;\r\n        textureData.height = height;\r\n\r\n        uniform.textureData = textureData;\r\n\r\n        this._textureCount = textureIndex;\r\n\r\n        this.initSampler2D(uniform);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a sampler2D uniform on this shader.\r\n     *\r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     *\r\n     * If you wish to use another Shader as a sampler2D input for this shader, see the `Shader.setSampler2DBuffer` method.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setSampler2D\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} uniformKey - The key of the sampler2D uniform to be updated, i.e. `iChannel0`.\r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {number} [textureIndex=0] - The texture index.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setSampler2D: function (uniformKey, textureKey, textureIndex, textureData)\r\n    {\r\n        if (textureIndex === undefined) { textureIndex = 0; }\r\n\r\n        var textureManager = this.scene.sys.textures;\r\n\r\n        if (textureManager.exists(textureKey))\r\n        {\r\n            var frame = textureManager.getFrame(textureKey);\r\n\r\n            if (frame.glTexture && frame.glTexture.isRenderTexture)\r\n            {\r\n                return this.setSampler2DBuffer(uniformKey, frame.glTexture, frame.width, frame.height, textureIndex, textureData);\r\n            }\r\n\r\n            var uniform = this.uniforms[uniformKey];\r\n            var source = frame.source;\r\n\r\n            uniform.textureKey = textureKey;\r\n            uniform.source = source.image;\r\n            uniform.value = frame.glTexture;\r\n\r\n            if (source.isGLTexture)\r\n            {\r\n                if (!textureData)\r\n                {\r\n                    textureData = {};\r\n                }\r\n\r\n                textureData.width = source.width;\r\n                textureData.height = source.height;\r\n            }\r\n\r\n            if (textureData)\r\n            {\r\n                uniform.textureData = textureData;\r\n            }\r\n\r\n            this._textureCount = textureIndex;\r\n\r\n            this.initSampler2D(uniform);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a property of a uniform already present on this shader.\r\n     *\r\n     * To modify the value of a uniform such as a 1f or 1i use the `value` property directly:\r\n     *\r\n     * ```javascript\r\n     * shader.setUniform('size.value', 16);\r\n     * ```\r\n     *\r\n     * You can use dot notation to access deeper values, for example:\r\n     *\r\n     * ```javascript\r\n     * shader.setUniform('resolution.value.x', 512);\r\n     * ```\r\n     *\r\n     * The change to the uniform will take effect the next time the shader is rendered.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setUniform\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} key - The key of the uniform to modify. Use dots for deep properties, i.e. `resolution.value.x`.\r\n     * @param {any} value - The value to set into the uniform.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setUniform: function (key, value)\r\n    {\r\n        SetValue(this.uniforms, key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the uniform object for the given key, or `null` if the uniform couldn't be found.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#getUniform\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} key - The key of the uniform to return the value for.\r\n     *\r\n     * @return {any} A reference to the uniform object. This is not a copy, so modifying it will update the original object also.\r\n     */\r\n    getUniform: function (key)\r\n    {\r\n        return GetFastValue(this.uniforms, key, null);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel0` sampler2D uniform.\r\n     *\r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setChannel0\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel0: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel0', textureKey, 0, textureData);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel1` sampler2D uniform.\r\n     *\r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setChannel1\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel1: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel1', textureKey, 1, textureData);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel2` sampler2D uniform.\r\n     *\r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setChannel2\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel2: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel2', textureKey, 2, textureData);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel3` sampler2D uniform.\r\n     *\r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setChannel3\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel3: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel3', textureKey, 3, textureData);\r\n    },\r\n\r\n    /**\r\n     * Internal method that takes a sampler2D uniform and prepares it for use by setting the\r\n     * gl texture parameters.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#initSampler2D\r\n     * @private\r\n     * @since 3.17.0\r\n     *\r\n     * @param {any} uniform - The sampler2D uniform to process.\r\n     */\r\n    initSampler2D: function (uniform)\r\n    {\r\n        if (!uniform.value)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var gl = this.gl;\r\n\r\n        gl.activeTexture(gl.TEXTURE0 + this._textureCount);\r\n        gl.bindTexture(gl.TEXTURE_2D, uniform.value);\r\n\r\n        //  Extended texture data\r\n\r\n        var data = uniform.textureData;\r\n\r\n        if (data && !uniform.value.isRenderTexture)\r\n        {\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\r\n\r\n            //  mag / minFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST\r\n            //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT\r\n            //  format can be: gl.LUMINANCE or gl.RGBA\r\n\r\n            var magFilter = gl[GetFastValue(data, 'magFilter', 'linear').toUpperCase()];\r\n            var minFilter = gl[GetFastValue(data, 'minFilter', 'linear').toUpperCase()];\r\n            var wrapS = gl[GetFastValue(data, 'wrapS', 'repeat').toUpperCase()];\r\n            var wrapT = gl[GetFastValue(data, 'wrapT', 'repeat').toUpperCase()];\r\n            var format = gl[GetFastValue(data, 'format', 'rgba').toUpperCase()];\r\n\r\n            if (data.repeat)\r\n            {\r\n                wrapS = gl.REPEAT;\r\n                wrapT = gl.REPEAT;\r\n            }\r\n\r\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);\r\n\r\n            if (data.width)\r\n            {\r\n                var width = GetFastValue(data, 'width', 512);\r\n                var height = GetFastValue(data, 'height', 2);\r\n                var border = GetFastValue(data, 'border', 0);\r\n\r\n                //  texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels)\r\n                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);\r\n            }\r\n            else\r\n            {\r\n                //  texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels)\r\n                gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.source);\r\n            }\r\n\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\r\n        }\r\n\r\n        this.renderer.setProgram(this.program);\r\n\r\n        gl.uniform1i(uniform.uniformLocation, this._textureCount);\r\n\r\n        this._textureCount++;\r\n    },\r\n\r\n    /**\r\n     * Synchronizes all of the uniforms this shader uses.\r\n     * Each uniforms gl function is called in turn.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#syncUniforms\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    syncUniforms: function ()\r\n    {\r\n        var gl = this.gl;\r\n\r\n        var uniforms = this.uniforms;\r\n        var uniform;\r\n        var length;\r\n        var glFunc;\r\n        var location;\r\n        var value;\r\n        var textureCount = 0;\r\n\r\n        for (var key in uniforms)\r\n        {\r\n            uniform = uniforms[key];\r\n\r\n            glFunc = uniform.glFunc;\r\n            length = uniform.glValueLength;\r\n            location = uniform.uniformLocation;\r\n            value = uniform.value;\r\n\r\n            if (value === null)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (length === 1)\r\n            {\r\n                if (uniform.glMatrix)\r\n                {\r\n                    glFunc.call(gl, location, uniform.transpose, value);\r\n                }\r\n                else\r\n                {\r\n                    glFunc.call(gl, location, value);\r\n                }\r\n            }\r\n            else if (length === 2)\r\n            {\r\n                glFunc.call(gl, location, value.x, value.y);\r\n            }\r\n            else if (length === 3)\r\n            {\r\n                glFunc.call(gl, location, value.x, value.y, value.z);\r\n            }\r\n            else if (length === 4)\r\n            {\r\n                glFunc.call(gl, location, value.x, value.y, value.z, value.w);\r\n            }\r\n            else if (uniform.type === 'sampler2D')\r\n            {\r\n                gl.activeTexture(gl.TEXTURE0 + textureCount);\r\n\r\n                gl.bindTexture(gl.TEXTURE_2D, value);\r\n\r\n                gl.uniform1i(location, textureCount);\r\n\r\n                textureCount++;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically during render.\r\n     *\r\n     * This method performs matrix ITRS and then stores the resulting value in the `uViewMatrix` uniform.\r\n     * It then sets up the vertex buffer and shader, updates and syncs the uniforms ready\r\n     * for flush to be called.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#load\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [matrix2D] - The transform matrix to use during rendering.\r\n     */\r\n    load: function (matrix2D)\r\n    {\r\n        //  ITRS\r\n\r\n        var gl = this.gl;\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var renderer = this.renderer;\r\n        var program = this.program;\r\n        var vm = this.viewMatrix;\r\n\r\n        if (!this.renderToTexture)\r\n        {\r\n            var x = -this._displayOriginX;\r\n            var y = -this._displayOriginY;\r\n\r\n            vm[0] = matrix2D[0];\r\n            vm[1] = matrix2D[1];\r\n            vm[4] = matrix2D[2];\r\n            vm[5] = matrix2D[3];\r\n            vm[8] = matrix2D[4];\r\n            vm[9] = matrix2D[5];\r\n            vm[12] = vm[0] * x + vm[4] * y;\r\n            vm[13] = vm[1] * x + vm[5] * y;\r\n        }\r\n\r\n        //  Update vertex shader uniforms\r\n\r\n        gl.useProgram(program);\r\n\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uViewMatrix'), false, vm);\r\n        gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), this.width, this.height);\r\n\r\n        //  Update fragment shader uniforms\r\n\r\n        var uniforms = this.uniforms;\r\n        var res = uniforms.resolution;\r\n\r\n        res.value.x = width;\r\n        res.value.y = height;\r\n\r\n        uniforms.time.value = renderer.game.loop.getDuration();\r\n\r\n        var pointer = this.pointer;\r\n\r\n        if (pointer)\r\n        {\r\n            var mouse = uniforms.mouse;\r\n\r\n            var px = pointer.x / width;\r\n            var py = 1 - pointer.y / height;\r\n\r\n            mouse.value.x = px.toFixed(2);\r\n            mouse.value.y = py.toFixed(2);\r\n        }\r\n\r\n        this.syncUniforms();\r\n    },\r\n\r\n    /**\r\n     * Called automatically during render.\r\n     *\r\n     * Sets the active shader, loads the vertex buffer and then draws.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#flush\r\n     * @since 3.17.0\r\n     */\r\n    flush: function ()\r\n    {\r\n        //  Bind\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var program = this.program;\r\n\r\n        var gl = this.gl;\r\n        var vertexBuffer = this.vertexBuffer;\r\n        var renderer = this.renderer;\r\n        var vertexSize = Float32Array.BYTES_PER_ELEMENT * 2;\r\n\r\n        if (this.renderToTexture)\r\n        {\r\n            renderer.setFramebuffer(this.framebuffer);\r\n\r\n            gl.clearColor(0, 0, 0, 0);\r\n\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n\r\n        var location = gl.getAttribLocation(program, 'inPosition');\r\n\r\n        if (location !== -1)\r\n        {\r\n            gl.enableVertexAttribArray(location);\r\n\r\n            gl.vertexAttribPointer(location, 2, gl.FLOAT, false, vertexSize, 0);\r\n        }\r\n\r\n        //  Draw\r\n\r\n        var vf = this.vertexViewF32;\r\n\r\n        vf[3] = height;\r\n        vf[4] = width;\r\n        vf[5] = height;\r\n        vf[8] = width;\r\n        vf[9] = height;\r\n        vf[10] = width;\r\n\r\n        //  Flush\r\n\r\n        var vertexCount = 6;\r\n\r\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));\r\n\r\n        gl.drawArrays(gl.TRIANGLES, 0, vertexCount);\r\n\r\n        if (this.renderToTexture)\r\n        {\r\n            renderer.setFramebuffer(null, false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass a Shader to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setAlpha\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    setAlpha: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass a Shader to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setBlendMode\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    setBlendMode: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#preDestroy\r\n     * @protected\r\n     * @since 3.17.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        var gl = this.gl;\r\n\r\n        gl.deleteProgram(this.program);\r\n        gl.deleteBuffer(this.vertexBuffer);\r\n\r\n        if (this.renderToTexture)\r\n        {\r\n            this.renderer.deleteFramebuffer(this.framebuffer);\r\n\r\n            this.texture.destroy();\r\n\r\n            this.framebuffer = null;\r\n            this.glTexture = null;\r\n            this.texture = null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Shader;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar DegToRad = require('../../math/DegToRad');\r\nvar Face = require('../../geom/mesh/Face');\r\nvar GameObject = require('../GameObject');\r\nvar GenerateVerts = require('../../geom/mesh/GenerateVerts');\r\nvar GenerateObjVerts = require('../../geom/mesh/GenerateObjVerts');\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\nvar Matrix4 = require('../../math/Matrix4');\r\nvar MeshRender = require('./MeshRender');\r\nvar StableSort = require('../../utils/array/StableSort');\r\nvar Vector3 = require('../../math/Vector3');\r\nvar Vertex = require('../../geom/mesh/Vertex');\r\n\r\n/**\r\n * @classdesc\r\n * A Mesh Game Object.\r\n *\r\n * The Mesh Game Object allows you to render a group of textured vertices and manipulate\r\n * the view of those vertices, such as rotation, translation or scaling.\r\n *\r\n * Support for generating mesh data from grids, model data or Wavefront OBJ Files is included.\r\n *\r\n * Although you can use this to render 3D objects, its primary use is for displaying more complex\r\n * Sprites, or Sprites where you need fine-grained control over the vertex positions in order to\r\n * achieve special effects in your games. Note that rendering still takes place using Phaser's\r\n * orthographic camera (after being transformed via `projectionMesh`, see `setPerspective`,\r\n * `setOrtho`, and `panZ` methods). As a result, all depth and face tests are done in an eventually\r\n * orthographic space.\r\n *\r\n * The rendering process will iterate through the faces of this Mesh and render out each face\r\n * that is considered as being in view of the camera. No depth buffer is used, and because of this,\r\n * you should be careful not to use model data with too many vertices, or overlapping geometry,\r\n * or you'll probably encounter z-depth fighting. The Mesh was designed to allow for more advanced\r\n * 2D layouts, rather than displaying 3D objects, even though it can do this to a degree.\r\n *\r\n * In short, if you want to remake Crysis, use a 3D engine, not a Mesh. However, if you want\r\n * to easily add some small fun 3D elements into your game, or create some special effects involving\r\n * vertex warping, this is the right object for you. Mesh data becomes part of the WebGL batch,\r\n * just like standard Sprites, so doesn't introduce any additional shader overhead. Because\r\n * the Mesh just generates vertices into the WebGL batch, like any other Sprite, you can use all of\r\n * the common Game Object components on a Mesh too, such as a custom pipeline, mask, blend mode\r\n * or texture.\r\n *\r\n * Note that the Mesh object is WebGL only and does not have a Canvas counterpart.\r\n *\r\n * The Mesh origin is always 0.5 x 0.5 and cannot be changed.\r\n *\r\n * @class Mesh\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @webglOnly\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y] - The vertical position of this Game Object in the world.\r\n * @param {string|Phaser.Textures.Texture} [texture] - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {string|number} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * @param {number[]} [vertices] - The vertices array. Either `xy` pairs, or `xyz` if the `containsZ` parameter is `true` (but see note).\r\n * @param {number[]} [uvs] - The UVs pairs array.\r\n * @param {number[]} [indicies] - Optional vertex indicies array. If you don't have one, pass `null` or an empty array.\r\n * @param {boolean} [containsZ=false] - Does the vertices data include a `z` component? Note: If not, it will be assumed `z=0`, see method `panZ` or `setOrtho`.\r\n * @param {number[]} [normals] - Optional vertex normals array. If you don't have one, pass `null` or an empty array.\r\n * @param {number|number[]} [colors=0xffffff] - An array of colors, one per vertex, or a single color value applied to all vertices.\r\n * @param {number|number[]} [alphas=1] - An array of alpha values, one per vertex, or a single alpha value applied to all vertices.\r\n */\r\nvar Mesh = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.Size,\r\n        Components.Texture,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Components.ScrollFactor,\r\n        MeshRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Mesh (scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (texture === undefined) { texture = '__WHITE'; }\r\n\r\n        GameObject.call(this, scene, 'Mesh');\r\n\r\n        /**\r\n         * An array containing the Face instances belonging to this Mesh.\r\n         *\r\n         * A Face consists of 3 Vertex objects.\r\n         *\r\n         * This array is populated during calls such as `addVertices` or `addOBJ`.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#faces\r\n         * @type {Phaser.Geom.Mesh.Face[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.faces = [];\r\n\r\n        /**\r\n         * An array containing Vertex instances. One instance per vertex in this Mesh.\r\n         *\r\n         * This array is populated during calls such as `addVertex` or `addOBJ`.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#vertices\r\n         * @type {Phaser.Geom.Mesh.Vertex[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.vertices = [];\r\n\r\n        /**\r\n         * The tint fill mode.\r\n         *\r\n         * `false` = An additive tint (the default), where vertices colors are blended with the texture.\r\n         * `true` = A fill tint, where the vertex colors replace the texture, but respects texture alpha.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#tintFill\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.50.0\r\n         */\r\n        this.tintFill = false;\r\n\r\n        /**\r\n         * You can optionally choose to render the vertices of this Mesh to a Graphics instance.\r\n         *\r\n         * Achieve this by setting the `debugCallback` and the `debugGraphic` properties.\r\n         *\r\n         * You can do this in a single call via the `Mesh.setDebug` method, which will use the\r\n         * built-in debug function. You can also set it to your own callback. The callback\r\n         * will be invoked _once per render_ and sent the following parameters:\r\n         *\r\n         * `debugCallback(src, meshLength, verts)`\r\n         *\r\n         * `src` is the Mesh instance being debugged.\r\n         * `meshLength` is the number of mesh vertices in total.\r\n         * `verts` is an array of the translated vertex coordinates.\r\n         *\r\n         * To disable rendering, set this property back to `null`.\r\n         *\r\n         * Please note that high vertex count Meshes will struggle to debug properly.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#debugCallback\r\n         * @type {function}\r\n         * @since 3.50.0\r\n         */\r\n        this.debugCallback = null;\r\n\r\n        /**\r\n         * The Graphics instance that the debug vertices will be drawn to, if `setDebug` has\r\n         * been called.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.50.0\r\n         */\r\n        this.debugGraphic = null;\r\n\r\n        /**\r\n         * When rendering, skip any Face that isn't counter clockwise?\r\n         *\r\n         * Enable this to hide backward-facing Faces during rendering.\r\n         *\r\n         * Disable it to render all Faces.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#hideCCW\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.hideCCW = true;\r\n\r\n        /**\r\n         * A Vector3 containing the 3D position of the vertices in this Mesh.\r\n         *\r\n         * Modifying the components of this property will allow you to reposition where\r\n         * the vertices are rendered within the Mesh. This happens in the `preUpdate` phase,\r\n         * where each vertex is transformed using the view and projection matrices.\r\n         *\r\n         * Changing this property will impact all vertices being rendered by this Mesh.\r\n         *\r\n         * You can also adjust the 'view' by using the `pan` methods.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#modelPosition\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.50.0\r\n         */\r\n        this.modelPosition = new Vector3();\r\n\r\n        /**\r\n         * A Vector3 containing the 3D scale of the vertices in this Mesh.\r\n         *\r\n         * Modifying the components of this property will allow you to scale\r\n         * the vertices within the Mesh. This happens in the `preUpdate` phase,\r\n         * where each vertex is transformed using the view and projection matrices.\r\n         *\r\n         * Changing this property will impact all vertices being rendered by this Mesh.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#modelScale\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.50.0\r\n         */\r\n        this.modelScale = new Vector3(1, 1, 1);\r\n\r\n        /**\r\n         * A Vector3 containing the 3D rotation of the vertices in this Mesh.\r\n         *\r\n         * The values should be given in radians, i.e. to rotate the vertices by 90\r\n         * degrees you can use `modelRotation.x = Phaser.Math.DegToRad(90)`.\r\n         *\r\n         * Modifying the components of this property will allow you to rotate\r\n         * the vertices within the Mesh. This happens in the `preUpdate` phase,\r\n         * where each vertex is transformed using the view and projection matrices.\r\n         *\r\n         * Changing this property will impact all vertices being rendered by this Mesh.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#modelRotation\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.50.0\r\n         */\r\n        this.modelRotation = new Vector3();\r\n\r\n        /**\r\n         * An internal cache, used to compare position, rotation, scale and face data\r\n         * each frame, to avoid math calculations in `preUpdate`.\r\n         *\r\n         * Cache structure = position xyz | rotation xyz | scale xyz | face count | view | ortho\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#dirtyCache\r\n         * @type {number[]}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.dirtyCache = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\r\n\r\n        /**\r\n         * The transformation matrix for this Mesh.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#transformMatrix\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.50.0\r\n         */\r\n        this.transformMatrix = new Matrix4();\r\n\r\n        /**\r\n         * The view position for this Mesh.\r\n         *\r\n         * Use the methods`panX`, `panY` and `panZ` to adjust the view.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#viewPosition\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.50.0\r\n         */\r\n        this.viewPosition = new Vector3();\r\n\r\n        /**\r\n         * The view matrix for this Mesh.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#viewMatrix\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.50.0\r\n         */\r\n        this.viewMatrix = new Matrix4();\r\n\r\n        /**\r\n         * The projection matrix for this Mesh.\r\n         *\r\n         * Update it with the `setPerspective` or `setOrtho` methods.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#projectionMatrix\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.50.0\r\n         */\r\n        this.projectionMatrix = new Matrix4();\r\n\r\n        /**\r\n         * How many faces were rendered by this Mesh Game Object in the last\r\n         * draw? This is reset in the `preUpdate` method and then incremented\r\n         * each time a face is drawn. Note that in multi-camera Scenes this\r\n         * value may exceed that found in `Mesh.getFaceCount` due to\r\n         * cameras drawing the same faces more than once.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#totalRendered\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.totalRendered = 0;\r\n\r\n        /**\r\n         * Internal cache var for the total number of faces rendered this frame.\r\n         *\r\n         * See `totalRendered` instead for the actual value.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#totalFrame\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.totalFrame = 0;\r\n\r\n        /**\r\n         * By default, the Mesh will check to see if its model or view transform has\r\n         * changed each frame and only recalculate the vertex positions if they have.\r\n         *\r\n         * This avoids lots of additional math in the `preUpdate` step when not required.\r\n         *\r\n         * However, if you are performing per-Face or per-Vertex manipulation on this Mesh,\r\n         * such as tweening a Face, or moving it without moving the rest of the Mesh,\r\n         * then you may need to disable the dirty cache in order for the Mesh to re-render\r\n         * correctly. You can toggle this property to do that. Please note that leaving\r\n         * this set to `true` will cause the Mesh to recalculate the position of every single\r\n         * vertex in it, every single frame. So only really do this if you know you\r\n         * need it.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#ignoreDirtyCache\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.ignoreDirtyCache = false;\r\n\r\n        var renderer = scene.sys.renderer;\r\n\r\n        this.setPosition(x, y);\r\n        this.setTexture(texture, frame);\r\n        this.setSize(renderer.width, renderer.height);\r\n        this.initPipeline();\r\n\r\n        this.setPerspective(renderer.width, renderer.height);\r\n\r\n        if (vertices)\r\n        {\r\n            this.addVertices(vertices, uvs, indicies, containsZ, normals, colors, alphas);\r\n        }\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * Translates the view position of this Mesh on the x axis by the given amount.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#panX\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} v - The amount to pan by.\r\n     */\r\n    panX: function (v)\r\n    {\r\n        this.viewPosition.addScale(Vector3.LEFT, v);\r\n\r\n        this.dirtyCache[10] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Translates the view position of this Mesh on the y axis by the given amount.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#panY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} v - The amount to pan by.\r\n     */\r\n    panY: function (v)\r\n    {\r\n        this.viewPosition.y += Vector3.DOWN.y * v;\r\n\r\n        this.dirtyCache[10] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Translates the view position of this Mesh on the z axis by the given amount.\r\n     *\r\n     * As the default `panZ` value is 0, vertices with `z=0` (the default) need special care or else they will not display as they are behind the camera.\r\n     * Consider using `mesh.panZ(mesh.height / (2 * Math.tan(Math.PI / 16)))`, which will interpret vertex geometry 1:1 with pixel geometry (or see `setOrtho`).\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#panZ\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} v - The amount to pan by.\r\n     */\r\n    panZ: function (amount)\r\n    {\r\n        this.viewPosition.z += amount;\r\n\r\n        this.dirtyCache[10] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Builds a new perspective projection matrix from the given values.\r\n     *\r\n     * These are also the initial projection matrix & parameters for `Mesh` (and see `panZ` for more discussion).\r\n     *\r\n     * See also `setOrtho`.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#setPerspective\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} width - The width of the projection matrix. Typically the same as the Mesh and/or Renderer.\r\n     * @param {number} height - The height of the projection matrix. Typically the same as the Mesh and/or Renderer.\r\n     * @param {number} [fov=45] - The field of view, in degrees.\r\n     * @param {number} [near=0.01] - The near value of the view.\r\n     * @param {number} [far=1000] - The far value of the view.\r\n     */\r\n    setPerspective: function (width, height, fov, near, far)\r\n    {\r\n        if (fov === undefined) { fov = 45; }\r\n        if (near === undefined) { near = 0.01; }\r\n        if (far === undefined) { far = 1000; }\r\n\r\n        this.projectionMatrix.perspective(DegToRad(fov), width / height, near, far);\r\n\r\n        this.dirtyCache[10] = 1;\r\n        this.dirtyCache[11] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Builds a new orthographic projection matrix from the given values.\r\n     *\r\n     * If using this mode you will often need to set `Mesh.hideCCW` to `false` as well.\r\n     *\r\n     * By default, calling this method with no parameters will set the scaleX value to\r\n     * match the renderer's aspect ratio. If you would like to render vertex positions 1:1\r\n     * to pixel positions, consider calling as `mesh.setOrtho(mesh.width, mesh.height)`.\r\n     *\r\n     * See also `setPerspective`.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#setOrtho\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [scaleX=1] - The default horizontal scale in relation to the Mesh / Renderer dimensions.\r\n     * @param {number} [scaleY=1] - The default vertical scale in relation to the Mesh / Renderer dimensions.\r\n     * @param {number} [near=-1000] - The near value of the view.\r\n     * @param {number} [far=1000] - The far value of the view.\r\n     */\r\n    setOrtho: function (scaleX, scaleY, near, far)\r\n    {\r\n        if (scaleX === undefined) { scaleX = this.scene.sys.renderer.getAspectRatio(); }\r\n        if (scaleY === undefined) { scaleY = 1; }\r\n        if (near === undefined) { near = -1000; }\r\n        if (far === undefined) { far = 1000; }\r\n\r\n        this.projectionMatrix.ortho(-scaleX, scaleX, -scaleY, scaleY, near, far);\r\n\r\n        this.dirtyCache[10] = 1;\r\n        this.dirtyCache[11] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Iterates and destroys all current Faces in this Mesh, then resets the\r\n     * `faces` and `vertices` arrays.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#clear\r\n     * @since 3.50.0\r\n     *\r\n     * @return {this} This Mesh Game Object.\r\n     */\r\n    clear: function ()\r\n    {\r\n        this.faces.forEach(function (face)\r\n        {\r\n            face.destroy();\r\n        });\r\n\r\n        this.faces = [];\r\n        this.vertices = [];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method will add the data from a triangulated Wavefront OBJ model file to this Mesh.\r\n     *\r\n     * The data should have been loaded via the OBJFile:\r\n     *\r\n     * ```javascript\r\n     * this.load.obj(key, url);\r\n     * ```\r\n     *\r\n     * Then use the same `key` as the first parameter to this method.\r\n     *\r\n     * Multiple Mesh Game Objects can use the same model data without impacting on each other.\r\n     *\r\n     * Make sure your 3D package has triangulated the model data prior to exporting it.\r\n     *\r\n     * You can add multiple models to a single Mesh, although they will act as one when\r\n     * moved or rotated. You can scale the model data, should it be too small, or too large, to see.\r\n     * You can also offset the vertices of the model via the `x`, `y` and `z` parameters.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#addVerticesFromObj\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} key - The key of the model data in the OBJ Cache to add to this Mesh.\r\n     * @param {number} [scale=1] - An amount to scale the model data by. Use this if the model has exported too small, or large, to see.\r\n     * @param {number} [x=0] - Translate the model x position by this amount.\r\n     * @param {number} [y=0] - Translate the model y position by this amount.\r\n     * @param {number} [z=0] - Translate the model z position by this amount.\r\n     * @param {number} [rotateX=0] - Rotate the model on the x axis by this amount, in radians.\r\n     * @param {number} [rotateY=0] - Rotate the model on the y axis by this amount, in radians.\r\n     * @param {number} [rotateZ=0] - Rotate the model on the z axis by this amount, in radians.\r\n     * @param {boolean} [zIsUp=true] - Is the z axis up (true), or is y axis up (false)?\r\n     *\r\n     * @return {this} This Mesh Game Object.\r\n     */\r\n    addVerticesFromObj: function (key, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp)\r\n    {\r\n        var data = this.scene.sys.cache.obj.get(key);\r\n\r\n        if (data)\r\n        {\r\n            GenerateObjVerts(data, this, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Compare the depth of two Faces.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#sortByDepth\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Geom.Mesh.Face} faceA - The first Face.\r\n     * @param {Phaser.Geom.Mesh.Face} faceB - The second Face.\r\n     *\r\n     * @return {number} The difference between the depths of each Face.\r\n     */\r\n    sortByDepth: function (faceA, faceB)\r\n    {\r\n        return faceA.depth - faceB.depth;\r\n    },\r\n\r\n    /**\r\n     * Runs a depth sort across all Faces in this Mesh, comparing their averaged depth.\r\n     *\r\n     * This is called automatically if you use any of the `rotate` methods, but you can\r\n     * also invoke it to sort the Faces should you manually position them.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#depthSort\r\n     * @since 3.50.0\r\n     *\r\n     * @return {this} This Mesh Game Object.\r\n     */\r\n    depthSort: function ()\r\n    {\r\n        StableSort(this.faces, this.sortByDepth);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Vertex into the vertices array of this Mesh.\r\n     *\r\n     * Just adding a vertex isn't enough to render it. You need to also\r\n     * make it part of a Face, with 3 Vertex instances per Face.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#addVertex\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The x position of the vertex.\r\n     * @param {number} y - The y position of the vertex.\r\n     * @param {number} z - The z position of the vertex.\r\n     * @param {number} u - The UV u coordinate of the vertex.\r\n     * @param {number} v - The UV v coordinate of the vertex.\r\n     * @param {number} [color=0xffffff] - The color value of the vertex.\r\n     * @param {number} [alpha=1] - The alpha value of the vertex.\r\n     *\r\n     * @return {this} This Mesh Game Object.\r\n     */\r\n    addVertex: function (x, y, z, u, v, color, alpha)\r\n    {\r\n        var vert = new Vertex(x, y, z, u, v, color, alpha);\r\n\r\n        this.vertices.push(vert);\r\n\r\n        return vert;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Face into the faces array of this Mesh.\r\n     *\r\n     * A Face consists of references to 3 Vertex instances, which must be provided.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#addFace\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Geom.Mesh.Vertex} vertex1 - The first vertex of the Face.\r\n     * @param {Phaser.Geom.Mesh.Vertex} vertex2 - The second vertex of the Face.\r\n     * @param {Phaser.Geom.Mesh.Vertex} vertex3 - The third vertex of the Face.\r\n     *\r\n     * @return {this} This Mesh Game Object.\r\n     */\r\n    addFace: function (vertex1, vertex2, vertex3)\r\n    {\r\n        var face = new Face(vertex1, vertex2, vertex3);\r\n\r\n        this.faces.push(face);\r\n\r\n        this.dirtyCache[9] = -1;\r\n\r\n        return face;\r\n    },\r\n\r\n    /**\r\n     * Adds new vertices to this Mesh by parsing the given data.\r\n     *\r\n     * This method will take vertex data in one of two formats, based on the `containsZ` parameter.\r\n     *\r\n     * If your vertex data are `x`, `y` pairs, then `containsZ` should be `false` (this is the default, and will result in `z=0` for each vertex).\r\n     *\r\n     * If your vertex data is groups of `x`, `y` and `z` values, then the `containsZ` parameter must be true.\r\n     *\r\n     * The `uvs` parameter is a numeric array consisting of `u` and `v` pairs.\r\n     *\r\n     * The `normals` parameter is a numeric array consisting of `x`, `y` vertex normal values and, if `containsZ` is true, `z` values as well.\r\n     *\r\n     * The `indicies` parameter is an optional array that, if given, is an indexed list of vertices to be added.\r\n     *\r\n     * The `colors` parameter is an optional array, or single value, that if given sets the color of each vertex created.\r\n     *\r\n     * The `alphas` parameter is an optional array, or single value, that if given sets the alpha of each vertex created.\r\n     *\r\n     * When providing indexed data it is assumed that _all_ of the arrays are indexed, not just the vertices.\r\n     *\r\n     * The following example will create a 256 x 256 sized quad using an index array:\r\n     *\r\n     * ```javascript\r\n     * let mesh = new Mesh(this);  // Assuming `this` is a scene!\r\n     * const vertices = [\r\n     *   -128, 128,\r\n     *   128, 128,\r\n     *   -128, -128,\r\n     *   128, -128\r\n     * ];\r\n     *\r\n     * const uvs = [\r\n     *   0, 1,\r\n     *   1, 1,\r\n     *   0, 0,\r\n     *   1, 0\r\n     * ];\r\n     *\r\n     * const indices = [ 0, 2, 1, 2, 3, 1 ];\r\n     *\r\n     * mesh.addVertices(vertices, uvs, indicies);\r\n     * // Note: Otherwise the added points will be \"behind\" the camera! This value will project vertex `x` & `y` values 1:1 to pixel values.\r\n     * mesh.hideCCW = false;\r\n     * mesh.setOrtho(mesh.width, mesh.height);\r\n     * ```\r\n     *\r\n     * If the data is not indexed, it's assumed that the arrays all contain sequential data.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#addVertices\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number[]} vertices - The vertices array. Either `xy` pairs, or `xyz` if the `containsZ` parameter is `true`.\r\n     * @param {number[]} uvs - The UVs pairs array.\r\n     * @param {number[]} [indicies] - Optional vertex indicies array. If you don't have one, pass `null` or an empty array.\r\n     * @param {boolean} [containsZ=false] - Does the vertices data include a `z` component? If not, it will be assumed `z=0`, see methods `panZ` or `setOrtho`.\r\n     * @param {number[]} [normals] - Optional vertex normals array. If you don't have one, pass `null` or an empty array.\r\n     * @param {number|number[]} [colors=0xffffff] - An array of colors, one per vertex, or a single color value applied to all vertices.\r\n     * @param {number|number[]} [alphas=1] - An array of alpha values, one per vertex, or a single alpha value applied to all vertices.\r\n     *\r\n     * @return {this} This Mesh Game Object.\r\n     */\r\n    addVertices: function (vertices, uvs, indicies, containsZ, normals, colors, alphas)\r\n    {\r\n        var result = GenerateVerts(vertices, uvs, indicies, containsZ, normals, colors, alphas);\r\n\r\n        if (result)\r\n        {\r\n            this.faces = this.faces.concat(result.faces);\r\n            this.vertices = this.vertices.concat(result.vertices);\r\n        }\r\n\r\n        this.dirtyCache[9] = -1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the total number of Faces in this Mesh Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#getFaceCount\r\n     * @since 3.50.0\r\n     *\r\n     * @return {number} The number of Faces in this Mesh Game Object.\r\n     */\r\n    getFaceCount: function ()\r\n    {\r\n        return this.faces.length;\r\n    },\r\n\r\n    /**\r\n     * Returns the total number of Vertices in this Mesh Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#getVertexCount\r\n     * @since 3.50.0\r\n     *\r\n     * @return {number} The number of Vertices in this Mesh Game Object.\r\n     */\r\n    getVertexCount: function ()\r\n    {\r\n        return this.vertices.length;\r\n    },\r\n\r\n    /**\r\n     * Returns the Face at the given index in this Mesh Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#getFace\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} index - The index of the Face to get.\r\n     *\r\n     * @return {Phaser.Geom.Mesh.Face} The Face at the given index, or `undefined` if index out of range.\r\n     */\r\n    getFace: function (index)\r\n    {\r\n        return this.faces[index];\r\n    },\r\n\r\n    /**\r\n     * Return an array of Face objects from this Mesh that intersect with the given coordinates.\r\n     *\r\n     * The given position is translated through the matrix of this Mesh and the given Camera,\r\n     * before being compared against the vertices.\r\n     *\r\n     * If more than one Face intersects, they will all be returned in the array, but the array will\r\n     * be depth sorted first, so the first element will always be that closest to the camera.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#getFaceAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The x position to check against.\r\n     * @param {number} y - The y position to check against.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The camera to pass the coordinates through. If not give, the default Scene Camera is used.\r\n     *\r\n     * @return {Phaser.Geom.Mesh.Face[]} An array of Face objects that intersect with the given point, ordered by depth.\r\n     */\r\n    getFaceAt: function (x, y, camera)\r\n    {\r\n        if (camera === undefined) { camera = this.scene.sys.cameras.main; }\r\n\r\n        var calcMatrix = GetCalcMatrix(this, camera).calc;\r\n\r\n        var faces = this.faces;\r\n        var results = [];\r\n\r\n        for (var i = 0; i < faces.length; i++)\r\n        {\r\n            var face = faces[i];\r\n\r\n            if (face.contains(x, y, calcMatrix))\r\n            {\r\n                results.push(face);\r\n            }\r\n        }\r\n\r\n        return StableSort(results, this.sortByDepth);\r\n    },\r\n\r\n    /**\r\n     * This method enables rendering of the Mesh vertices to the given Graphics instance.\r\n     *\r\n     * If you enable this feature, you **must** call `Graphics.clear()` in your Scene `update`,\r\n     * otherwise the Graphics instance you provide to debug will fill-up with draw calls,\r\n     * eventually crashing the browser. This is not done automatically to allow you to debug\r\n     * draw multiple Mesh objects to a single Graphics instance.\r\n     *\r\n     * The Mesh class has a built-in debug rendering callback `Mesh.renderDebug`, however\r\n     * you can also provide your own callback to be used instead. Do this by setting the `callback` parameter.\r\n     *\r\n     * The callback is invoked _once per render_ and sent the following parameters:\r\n     *\r\n     * `callback(src, faces)`\r\n     *\r\n     * `src` is the Mesh instance being debugged.\r\n     * `faces` is an array of the Faces that were rendered.\r\n     *\r\n     * You can get the final drawn vertex position from a Face object like this:\r\n     *\r\n     * ```javascript\r\n     * let face = faces[i];\r\n     *\r\n     * let x0 = face.vertex1.tx;\r\n     * let y0 = face.vertex1.ty;\r\n     * let x1 = face.vertex2.tx;\r\n     * let y1 = face.vertex2.ty;\r\n     * let x2 = face.vertex3.tx;\r\n     * let y2 = face.vertex3.ty;\r\n     *\r\n     * graphic.strokeTriangle(x0, y0, x1, y1, x2, y2);\r\n     * ```\r\n     *\r\n     * If using your own callback you do not have to provide a Graphics instance to this method.\r\n     *\r\n     * To disable debug rendering, to either your own callback or the built-in one, call this method\r\n     * with no arguments.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#setDebug\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} [graphic] - The Graphic instance to render to if using the built-in callback.\r\n     * @param {function} [callback] - The callback to invoke during debug render. Leave as undefined to use the built-in callback.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDebug: function (graphic, callback)\r\n    {\r\n        this.debugGraphic = graphic;\r\n\r\n        if (!graphic && !callback)\r\n        {\r\n            this.debugCallback = null;\r\n        }\r\n        else if (!callback)\r\n        {\r\n            this.debugCallback = this.renderDebug;\r\n        }\r\n        else\r\n        {\r\n            this.debugCallback = callback;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks if the transformation data in this mesh is dirty.\r\n     *\r\n     * This is used internally by the `preUpdate` step to determine if the vertices should\r\n     * be recalculated or not.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#isDirty\r\n     * @since 3.50.0\r\n     *\r\n     * @return {boolean} Returns `true` if the data of this mesh is dirty, otherwise `false`.\r\n     */\r\n    isDirty: function ()\r\n    {\r\n        var position = this.modelPosition;\r\n        var rotation = this.modelRotation;\r\n        var scale = this.modelScale;\r\n        var dirtyCache = this.dirtyCache;\r\n\r\n        var px = position.x;\r\n        var py = position.y;\r\n        var pz = position.z;\r\n\r\n        var rx = rotation.x;\r\n        var ry = rotation.y;\r\n        var rz = rotation.z;\r\n\r\n        var sx = scale.x;\r\n        var sy = scale.y;\r\n        var sz = scale.z;\r\n\r\n        var faces = this.getFaceCount();\r\n\r\n        var pxCached = dirtyCache[0];\r\n        var pyCached = dirtyCache[1];\r\n        var pzCached = dirtyCache[2];\r\n\r\n        var rxCached = dirtyCache[3];\r\n        var ryCached = dirtyCache[4];\r\n        var rzCached = dirtyCache[5];\r\n\r\n        var sxCached = dirtyCache[6];\r\n        var syCached = dirtyCache[7];\r\n        var szCached = dirtyCache[8];\r\n\r\n        var fCached = dirtyCache[9];\r\n\r\n        dirtyCache[0] = px;\r\n        dirtyCache[1] = py;\r\n        dirtyCache[2] = pz;\r\n\r\n        dirtyCache[3] = rx;\r\n        dirtyCache[4] = ry;\r\n        dirtyCache[5] = rz;\r\n\r\n        dirtyCache[6] = sx;\r\n        dirtyCache[7] = sy;\r\n        dirtyCache[8] = sz;\r\n\r\n        dirtyCache[9] = faces;\r\n\r\n        return (\r\n            pxCached !== px || pyCached !== py || pzCached !== pz ||\r\n            rxCached !== rx || ryCached !== ry || rzCached !== rz ||\r\n            sxCached !== sx || syCached !== sy || szCached !== sz ||\r\n            fCached !== faces\r\n        );\r\n    },\r\n\r\n    /**\r\n     * The Mesh update loop. The following takes place in this method:\r\n     *\r\n     * First, the `totalRendered` and `totalFrame` properties are set.\r\n     *\r\n     * If the view matrix of this Mesh isn't dirty, and the model position, rotate or scale properties are\r\n     * all clean, then the method returns at this point.\r\n     *\r\n     * Otherwise, if the viewPosition is dirty (i.e. from calling a method like `panZ`), then it will\r\n     * refresh the viewMatrix.\r\n     *\r\n     * After this, a new transformMatrix is built and it then iterates through all Faces in this\r\n     * Mesh, calling `transformCoordinatesLocal` on all of them. Internally, this updates every\r\n     * vertex, calculating its new transformed position, based on the new transform matrix.\r\n     *\r\n     * Finally, the faces are depth sorted.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#preUpdate\r\n     * @protected\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        this.totalRendered = this.totalFrame;\r\n        this.totalFrame = 0;\r\n\r\n        var dirty = this.dirtyCache;\r\n\r\n        if (!this.ignoreDirtyCache && !dirty[10] && !this.isDirty())\r\n        {\r\n            //  If neither the view or the mesh is dirty we can bail out and save lots of math\r\n            return;\r\n        }\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n\r\n        var viewMatrix = this.viewMatrix;\r\n        var viewPosition = this.viewPosition;\r\n\r\n        if (dirty[10])\r\n        {\r\n            viewMatrix.identity();\r\n            viewMatrix.translate(viewPosition);\r\n            viewMatrix.invert();\r\n\r\n            dirty[10] = 0;\r\n        }\r\n\r\n        var transformMatrix = this.transformMatrix;\r\n\r\n        transformMatrix.setWorldMatrix(\r\n            this.modelRotation,\r\n            this.modelPosition,\r\n            this.modelScale,\r\n            this.viewMatrix,\r\n            this.projectionMatrix\r\n        );\r\n\r\n        var z = viewPosition.z;\r\n\r\n        var faces = this.faces;\r\n\r\n        for (var i = 0; i < faces.length; i++)\r\n        {\r\n            faces[i].transformCoordinatesLocal(transformMatrix, width, height, z);\r\n        }\r\n\r\n        this.depthSort();\r\n    },\r\n\r\n    /**\r\n     * The built-in Mesh debug rendering method.\r\n     *\r\n     * See `Mesh.setDebug` for more details.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#renderDebug\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.Mesh} src - The Mesh object being rendered.\r\n     * @param {Phaser.Geom.Mesh.Face[]} faces - An array of Faces.\r\n     */\r\n    renderDebug: function (src, faces)\r\n    {\r\n        var graphic = src.debugGraphic;\r\n\r\n        for (var i = 0; i < faces.length; i++)\r\n        {\r\n            var face = faces[i];\r\n\r\n            var x0 = face.vertex1.tx;\r\n            var y0 = face.vertex1.ty;\r\n            var x1 = face.vertex2.tx;\r\n            var y1 = face.vertex2.ty;\r\n            var x2 = face.vertex3.tx;\r\n            var y2 = face.vertex3.ty;\r\n\r\n            graphic.strokeTriangle(x0, y0, x1, y1, x2, y2);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Handles the pre-destroy step for the Mesh, which removes the Animation component and typed arrays.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#preDestroy\r\n     * @private\r\n     * @since 3.50.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.clear();\r\n\r\n        this.debugCallback = null;\r\n        this.debugGraphic = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Mesh;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../renderer/BlendModes');\r\nvar GetAdvancedValue = require('../utils/object/GetAdvancedValue');\r\n\r\n/**\r\n * Builds a Game Object using the provided configuration object.\r\n *\r\n * @function Phaser.GameObjects.BuildGameObject\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene.\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The initial GameObject.\r\n * @param {Phaser.Types.GameObjects.GameObjectConfig} config - The config to build the GameObject with.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The built Game Object.\r\n */\r\nvar BuildGameObject = function (scene, gameObject, config)\r\n{\r\n    //  Position\r\n\r\n    gameObject.x = GetAdvancedValue(config, 'x', 0);\r\n    gameObject.y = GetAdvancedValue(config, 'y', 0);\r\n    gameObject.depth = GetAdvancedValue(config, 'depth', 0);\r\n\r\n    //  Flip\r\n\r\n    gameObject.flipX = GetAdvancedValue(config, 'flipX', false);\r\n    gameObject.flipY = GetAdvancedValue(config, 'flipY', false);\r\n\r\n    //  Scale\r\n    //  Either: { scale: 2 } or { scale: { x: 2, y: 2 }}\r\n\r\n    var scale = GetAdvancedValue(config, 'scale', null);\r\n\r\n    if (typeof scale === 'number')\r\n    {\r\n        gameObject.setScale(scale);\r\n    }\r\n    else if (scale !== null)\r\n    {\r\n        gameObject.scaleX = GetAdvancedValue(scale, 'x', 1);\r\n        gameObject.scaleY = GetAdvancedValue(scale, 'y', 1);\r\n    }\r\n\r\n    //  ScrollFactor\r\n    //  Either: { scrollFactor: 2 } or { scrollFactor: { x: 2, y: 2 }}\r\n\r\n    var scrollFactor = GetAdvancedValue(config, 'scrollFactor', null);\r\n\r\n    if (typeof scrollFactor === 'number')\r\n    {\r\n        gameObject.setScrollFactor(scrollFactor);\r\n    }\r\n    else if (scrollFactor !== null)\r\n    {\r\n        gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, 'x', 1);\r\n        gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, 'y', 1);\r\n    }\r\n\r\n    //  Rotation\r\n\r\n    gameObject.rotation = GetAdvancedValue(config, 'rotation', 0);\r\n\r\n    var angle = GetAdvancedValue(config, 'angle', null);\r\n\r\n    if (angle !== null)\r\n    {\r\n        gameObject.angle = angle;\r\n    }\r\n\r\n    //  Alpha\r\n\r\n    gameObject.alpha = GetAdvancedValue(config, 'alpha', 1);\r\n\r\n    //  Origin\r\n    //  Either: { origin: 0.5 } or { origin: { x: 0.5, y: 0.5 }}\r\n\r\n    var origin = GetAdvancedValue(config, 'origin', null);\r\n\r\n    if (typeof origin === 'number')\r\n    {\r\n        gameObject.setOrigin(origin);\r\n    }\r\n    else if (origin !== null)\r\n    {\r\n        var ox = GetAdvancedValue(origin, 'x', 0.5);\r\n        var oy = GetAdvancedValue(origin, 'y', 0.5);\r\n\r\n        gameObject.setOrigin(ox, oy);\r\n    }\r\n\r\n    //  BlendMode\r\n\r\n    gameObject.blendMode = GetAdvancedValue(config, 'blendMode', BlendModes.NORMAL);\r\n\r\n    //  Visible\r\n\r\n    gameObject.visible = GetAdvancedValue(config, 'visible', true);\r\n\r\n    //  Add to Scene\r\n\r\n    var add = GetAdvancedValue(config, 'add', true);\r\n\r\n    if (add)\r\n    {\r\n        scene.sys.displayList.add(gameObject);\r\n    }\r\n\r\n    if (gameObject.preUpdate)\r\n    {\r\n        scene.sys.updateList.add(gameObject);\r\n    }\r\n\r\n    return gameObject;\r\n};\r\n\r\nmodule.exports = BuildGameObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar Line = require('../../geom/line/Line');\r\n\r\n/**\r\n * @classdesc\r\n * The Shape Game Object is a base class for the various different shapes, such as the Arc, Star or Polygon.\r\n * You cannot add a Shape directly to your Scene, it is meant as a base for your own custom Shape classes.\r\n *\r\n * @class Shape\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {string} [type] - The internal type of the Shape.\r\n * @param {any} [data] - The data of the source shape geometry, if any.\r\n */\r\nvar Shape = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Transform,\r\n        Components.Visible\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Shape (scene, type, data)\r\n    {\r\n        if (type === undefined) { type = 'Shape'; }\r\n\r\n        GameObject.call(this, scene, type);\r\n\r\n        /**\r\n         * The source Shape data. Typically a geometry object.\r\n         * You should not manipulate this directly.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#geom\r\n         * @type {any}\r\n         * @readonly\r\n         * @since 3.13.0\r\n         */\r\n        this.geom = data;\r\n\r\n        /**\r\n         * Holds the polygon path data for filled rendering.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#pathData\r\n         * @type {number[]}\r\n         * @readonly\r\n         * @since 3.13.0\r\n         */\r\n        this.pathData = [];\r\n\r\n        /**\r\n         * Holds the earcut polygon path index data for filled rendering.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#pathIndexes\r\n         * @type {number[]}\r\n         * @readonly\r\n         * @since 3.13.0\r\n         */\r\n        this.pathIndexes = [];\r\n\r\n        /**\r\n         * The fill color used by this Shape.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#fillColor\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillColor = 0xffffff;\r\n\r\n        /**\r\n         * The fill alpha value used by this Shape.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#fillAlpha\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillAlpha = 1;\r\n\r\n        /**\r\n         * The stroke color used by this Shape.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#strokeColor\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.strokeColor = 0xffffff;\r\n\r\n        /**\r\n         * The stroke alpha value used by this Shape.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#strokeAlpha\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.strokeAlpha = 1;\r\n\r\n        /**\r\n         * The stroke line width used by this Shape.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#lineWidth\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.lineWidth = 1;\r\n\r\n        /**\r\n         * Controls if this Shape is filled or not.\r\n         * Note that some Shapes do not support being filled (such as Line shapes)\r\n         *\r\n         * @name Phaser.GameObjects.Shape#isFilled\r\n         * @type {boolean}\r\n         * @since 3.13.0\r\n         */\r\n        this.isFilled = false;\r\n\r\n        /**\r\n         * Controls if this Shape is stroked or not.\r\n         * Note that some Shapes do not support being stroked (such as Iso Box shapes)\r\n         *\r\n         * @name Phaser.GameObjects.Shape#isStroked\r\n         * @type {boolean}\r\n         * @since 3.13.0\r\n         */\r\n        this.isStroked = false;\r\n\r\n        /**\r\n         * Controls if this Shape path is closed during rendering when stroked.\r\n         * Note that some Shapes are always closed when stroked (such as Ellipse shapes)\r\n         *\r\n         * @name Phaser.GameObjects.Shape#closePath\r\n         * @type {boolean}\r\n         * @since 3.13.0\r\n         */\r\n        this.closePath = true;\r\n\r\n        /**\r\n         * Private internal value.\r\n         * A Line used when parsing internal path data to avoid constant object re-creation.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#_tempLine\r\n         * @type {Phaser.Geom.Line}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._tempLine = new Line();\r\n\r\n        /**\r\n         * The native (un-scaled) width of this Game Object.\r\n         *\r\n         * Changing this value will not change the size that the Game Object is rendered in-game.\r\n         * For that you need to either set the scale of the Game Object (`setScale`) or use\r\n         * the `displayWidth` property.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#width\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.width = 0;\r\n\r\n        /**\r\n         * The native (un-scaled) height of this Game Object.\r\n         *\r\n         * Changing this value will not change the size that the Game Object is rendered in-game.\r\n         * For that you need to either set the scale of the Game Object (`setScale`) or use\r\n         * the `displayHeight` property.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = 0;\r\n\r\n        this.initPipeline();\r\n    },\r\n\r\n    /**\r\n     * Sets the fill color and alpha for this Shape.\r\n     *\r\n     * If you wish for the Shape to not be filled then call this method with no arguments, or just set `isFilled` to `false`.\r\n     *\r\n     * Note that some Shapes do not support fill colors, such as the Line shape.\r\n     *\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Shape#setFillStyle\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} [color] - The color used to fill this shape. If not provided the Shape will not be filled.\r\n     * @param {number} [alpha=1] - The alpha value used when filling this shape, if a fill color is given.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFillStyle: function (color, alpha)\r\n    {\r\n        if (alpha === undefined) { alpha = 1; }\r\n\r\n        if (color === undefined)\r\n        {\r\n            this.isFilled = false;\r\n        }\r\n        else\r\n        {\r\n            this.fillColor = color;\r\n            this.fillAlpha = alpha;\r\n            this.isFilled = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the stroke color and alpha for this Shape.\r\n     *\r\n     * If you wish for the Shape to not be stroked then call this method with no arguments, or just set `isStroked` to `false`.\r\n     *\r\n     * Note that some Shapes do not support being stroked, such as the Iso Box shape.\r\n     *\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Shape#setStrokeStyle\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} [lineWidth] - The width of line to stroke with. If not provided or undefined the Shape will not be stroked.\r\n     * @param {number} [color] - The color used to stroke this shape. If not provided the Shape will not be stroked.\r\n     * @param {number} [alpha=1] - The alpha value used when stroking this shape, if a stroke color is given.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setStrokeStyle: function (lineWidth, color, alpha)\r\n    {\r\n        if (alpha === undefined) { alpha = 1; }\r\n\r\n        if (lineWidth === undefined)\r\n        {\r\n            this.isStroked = false;\r\n        }\r\n        else\r\n        {\r\n            this.lineWidth = lineWidth;\r\n            this.strokeColor = color;\r\n            this.strokeAlpha = alpha;\r\n            this.isStroked = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets if this Shape path is closed during rendering when stroked.\r\n     * Note that some Shapes are always closed when stroked (such as Ellipse shapes)\r\n     *\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Shape#setClosePath\r\n     * @since 3.13.0\r\n     *\r\n     * @param {boolean} value - Set to `true` if the Shape should be closed when stroked, otherwise `false`.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setClosePath: function (value)\r\n    {\r\n        this.closePath = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the internal size of this Game Object, as used for frame or physics body creation.\r\n     *\r\n     * This will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or call the\r\n     * `setDisplaySize` method, which is the same thing as changing the scale but allows you\r\n     * to do so by giving pixel values.\r\n     *\r\n     * If you have enabled this Game Object for input, changing the size will _not_ change the\r\n     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.\r\n     *\r\n     * @method Phaser.GameObjects.Shape#setSize\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the display size of this Shape.\r\n     *\r\n     * Calling this will adjust the scale.\r\n     *\r\n     * @method Phaser.GameObjects.Shape#setDisplaySize\r\n     * @since 3.53.0\r\n     *\r\n     * @param {number} width - The display width of this Shape.\r\n     * @param {number} height - The display height of this Shape.\r\n     *\r\n     * @return {this} This Shape instance.\r\n     */\r\n    setDisplaySize: function (width, height)\r\n    {\r\n        this.displayWidth = width;\r\n        this.displayHeight = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Shape#preDestroy\r\n     * @protected\r\n     * @since 3.13.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.geom = null;\r\n        this._tempLine = null;\r\n        this.pathData = [];\r\n        this.pathIndexes = [];\r\n    },\r\n\r\n    /**\r\n     * The displayed width of this Game Object.\r\n     *\r\n     * This value takes into account the scale factor.\r\n     *\r\n     * Setting this value will adjust the Game Object's scale property.\r\n     *\r\n     * @name Phaser.GameObjects.Shape#displayWidth\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\r\n    displayWidth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.scaleX * this.width;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleX = value / this.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The displayed height of this Game Object.\r\n     *\r\n     * This value takes into account the scale factor.\r\n     *\r\n     * Setting this value will adjust the Game Object's scale property.\r\n     *\r\n     * @name Phaser.GameObjects.Shape#displayHeight\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\r\n    displayHeight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.scaleY * this.height;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleY = value / this.height;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Shape;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar GetAdvancedValue = require('../utils/object/GetAdvancedValue');\n\n/**\n * Adds an Animation component to a Sprite and populates it based on the given config.\n *\n * @function Phaser.GameObjects.BuildGameObjectAnimation\n * @since 3.0.0\n *\n * @param {Phaser.GameObjects.Sprite} sprite - The sprite to add an Animation component to.\n * @param {object} config - The animation config.\n *\n * @return {Phaser.GameObjects.Sprite} The updated Sprite.\n */\nvar BuildGameObjectAnimation = function (sprite, config)\n{\n    var animConfig = GetAdvancedValue(config, 'anims', null);\n\n    if (animConfig === null)\n    {\n        return sprite;\n    }\n\n    if (typeof animConfig === 'string')\n    {\n        //  { anims: 'key' }\n        sprite.anims.play(animConfig);\n    }\n    else if (typeof animConfig === 'object')\n    {\n        //  { anims: {\n        //              key: string\n        //              startFrame: [string|number]\n        //              delay: [float]\n        //              repeat: [integer]\n        //              repeatDelay: [float]\n        //              yoyo: [boolean]\n        //              play: [boolean]\n        //              delayedPlay: [boolean]\n        //           }\n        //  }\n\n        var anims = sprite.anims;\n\n        var key = GetAdvancedValue(animConfig, 'key', undefined);\n\n        if (key)\n        {\n            var startFrame = GetAdvancedValue(animConfig, 'startFrame', undefined);\n\n            var delay = GetAdvancedValue(animConfig, 'delay', 0);\n            var repeat = GetAdvancedValue(animConfig, 'repeat', 0);\n            var repeatDelay = GetAdvancedValue(animConfig, 'repeatDelay', 0);\n            var yoyo = GetAdvancedValue(animConfig, 'yoyo', false);\n\n            var play = GetAdvancedValue(animConfig, 'play', false);\n            var delayedPlay = GetAdvancedValue(animConfig, 'delayedPlay', 0);\n\n            var playConfig = {\n                key: key,\n                delay: delay,\n                repeat: repeat,\n                repeatDelay: repeatDelay,\n                yoyo: yoyo,\n                startFrame: startFrame\n            };\n\n            if (play)\n            {\n                anims.play(playConfig);\n            }\n            else if (delayedPlay > 0)\n            {\n                anims.playAfterDelay(playConfig, delayedPlay);\n            }\n            else\n            {\n                anims.load(playConfig);\n            }\n        }\n    }\n\n    return sprite;\n};\n\nmodule.exports = BuildGameObjectAnimation;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Frame = require('../../textures/Frame');\r\n\r\n/**\r\n * @classdesc\r\n * A Bob Game Object.\r\n *\r\n * A Bob belongs to a Blitter Game Object. The Blitter is responsible for managing and rendering this object.\r\n *\r\n * A Bob has a position, alpha value and a frame from a texture that it uses to render with. You can also toggle\r\n * the flipped and visible state of the Bob. The Frame the Bob uses to render can be changed dynamically, but it\r\n * must be a Frame within the Texture used by the parent Blitter.\r\n *\r\n * Bob positions are relative to the Blitter parent. So if you move the Blitter parent, all Bob children will\r\n * have their positions impacted by this change as well.\r\n *\r\n * You can manipulate Bob objects directly from your game code, but the creation and destruction of them should be\r\n * handled via the Blitter parent.\r\n *\r\n * @class Bob\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Blitter} blitter - The parent Blitter object is responsible for updating this Bob.\r\n * @param {number} x - The horizontal position of this Game Object in the world, relative to the parent Blitter position.\r\n * @param {number} y - The vertical position of this Game Object in the world, relative to the parent Blitter position.\r\n * @param {(string|number)} frame - The Frame this Bob will render with, as defined in the Texture the parent Blitter is using.\r\n * @param {boolean} visible - Should the Bob render visible or not to start with?\r\n */\r\nvar Bob = new Class({\r\n\r\n    initialize:\r\n\r\n    function Bob (blitter, x, y, frame, visible)\r\n    {\r\n        /**\r\n         * The Blitter object that this Bob belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#parent\r\n         * @type {Phaser.GameObjects.Blitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.parent = blitter;\r\n\r\n        /**\r\n         * The x position of this Bob, relative to the x position of the Blitter.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.x = x;\r\n\r\n        /**\r\n         * The y position of this Bob, relative to the y position of the Blitter.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.y = y;\r\n\r\n        /**\r\n         * The frame that the Bob uses to render with.\r\n         * To change the frame use the `Bob.setFrame` method.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.frame = frame;\r\n\r\n        /**\r\n         * A blank object which can be used to store data related to this Bob in.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#data\r\n         * @type {object}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = {};\r\n\r\n        /**\r\n         * The tint value of this Bob.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#tint\r\n         * @type {number}\r\n         * @default 0xffffff\r\n         * @since 3.20.0\r\n         */\r\n        this.tint = 0xffffff;\r\n\r\n        /**\r\n         * The visible state of this Bob.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#_visible\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._visible = visible;\r\n\r\n        /**\r\n         * The alpha value of this Bob.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#_alpha\r\n         * @type {number}\r\n         * @private\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this._alpha = 1;\r\n\r\n        /**\r\n         * The horizontally flipped state of the Bob.\r\n         * A Bob that is flipped horizontally will render inversed on the horizontal axis.\r\n         * Flipping always takes place from the middle of the texture.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#flipX\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.flipX = false;\r\n\r\n        /**\r\n         * The vertically flipped state of the Bob.\r\n         * A Bob that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\r\n         * Flipping always takes place from the middle of the texture.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#flipY\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.flipY = false;\r\n    },\r\n\r\n    /**\r\n     * Changes the Texture Frame being used by this Bob.\r\n     * The frame must be part of the Texture the parent Blitter is using.\r\n     * If no value is given it will use the default frame of the Blitter parent.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|Phaser.Textures.Frame)} [frame] - The frame to be used during rendering.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setFrame: function (frame)\r\n    {\r\n        if (frame === undefined)\r\n        {\r\n            this.frame = this.parent.frame;\r\n        }\r\n        else if (frame instanceof Frame && frame.texture === this.parent.texture)\r\n        {\r\n            this.frame = frame;\r\n        }\r\n        else\r\n        {\r\n            this.frame = this.parent.texture.get(frame);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets the horizontal and vertical flipped state of this Bob back to their default un-flipped state.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#resetFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    resetFlip: function ()\r\n    {\r\n        this.flipX = false;\r\n        this.flipY = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets this Bob.\r\n     *\r\n     * Changes the position to the values given, and optionally changes the frame.\r\n     *\r\n     * Also resets the flipX and flipY values, sets alpha back to 1 and visible to true.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     * @param {number} y - The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     * @param {(string|number|Phaser.Textures.Frame)} [frame] - The Frame the Bob will use. It _must_ be part of the Texture the parent Blitter object is using.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    reset: function (x, y, frame)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        this.flipX = false;\r\n        this.flipY = false;\r\n\r\n        this._alpha = 1;\r\n        this._visible = true;\r\n\r\n        this.parent.dirty = true;\r\n\r\n        if (frame)\r\n        {\r\n            this.setFrame(frame);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Changes the position of this Bob to the values given.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setPosition\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} x - The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     * @param {number} y - The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setPosition: function (x, y)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal flipped state of this Bob.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setFlipX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setFlipX: function (value)\r\n    {\r\n        this.flipX = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical flipped state of this Bob.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setFlipY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setFlipY: function (value)\r\n    {\r\n        this.flipY = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal and vertical flipped state of this Bob.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} x - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     * @param {boolean} y - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setFlip: function (x, y)\r\n    {\r\n        this.flipX = x;\r\n        this.flipY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the visibility of this Bob.\r\n     *\r\n     * An invisible Bob will skip rendering.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The visible state of the Game Object.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setVisible: function (value)\r\n    {\r\n        this.visible = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the Alpha level of this Bob. The alpha controls the opacity of the Game Object as it renders.\r\n     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.\r\n     *\r\n     * A Bob with alpha 0 will skip rendering.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The alpha value used for this Bob. Between 0 and 1.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setAlpha: function (value)\r\n    {\r\n        this.alpha = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tint of this Bob.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setTint\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} value - The tint value used for this Bob. Between 0 and 0xffffff.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setTint: function (value)\r\n    {\r\n        this.tint = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Bob instance.\r\n     * Removes itself from the Blitter and clears the parent, frame and data properties.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.parent.dirty = true;\r\n\r\n        this.parent.children.remove(this);\r\n\r\n        this.parent = undefined;\r\n        this.frame = undefined;\r\n        this.data = undefined;\r\n    },\r\n\r\n    /**\r\n     * The visible state of the Bob.\r\n     *\r\n     * An invisible Bob will skip rendering.\r\n     *\r\n     * @name Phaser.GameObjects.Bob#visible\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    visible: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._visible;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.parent.dirty |= (this._visible !== value);\r\n            this._visible = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The alpha value of the Bob, between 0 and 1.\r\n     *\r\n     * A Bob with alpha 0 will skip rendering.\r\n     *\r\n     * @name Phaser.GameObjects.Bob#alpha\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    alpha: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alpha;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.parent.dirty |= ((this._alpha > 0) !== (value > 0));\r\n            this._alpha = value;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Bob;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar DOMElementRender = require('./DOMElementRender');\r\nvar GameObject = require('../GameObject');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar RemoveFromDOM = require('../../dom/RemoveFromDOM');\r\nvar SCENE_EVENTS = require('../../scene/events');\r\nvar Vector4 = require('../../math/Vector4');\r\n\r\n/**\r\n * @classdesc\r\n * DOM Element Game Objects are a way to control and manipulate HTML Elements over the top of your game.\r\n *\r\n * In order for DOM Elements to display you have to enable them by adding the following to your game\r\n * configuration object:\r\n *\r\n * ```javascript\r\n * dom {\r\n *   createContainer: true\r\n * }\r\n * ```\r\n *\r\n * When this is added, Phaser will automatically create a DOM Container div that is positioned over the top\r\n * of the game canvas. This div is sized to match the canvas, and if the canvas size changes, as a result of\r\n * settings within the Scale Manager, the dom container is resized accordingly.\r\n *\r\n * If you have not already done so, you have to provide a `parent` in the Game Configuration, or the DOM\r\n * Container will fail to be created.\r\n *\r\n * You can create a DOM Element by either passing in DOMStrings, or by passing in a reference to an existing\r\n * Element that you wish to be placed under the control of Phaser. For example:\r\n *\r\n * ```javascript\r\n * this.add.dom(x, y, 'div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');\r\n * ```\r\n *\r\n * The above code will insert a div element into the DOM Container at the given x/y coordinate. The DOMString in\r\n * the 4th argument sets the initial CSS style of the div and the final argument is the inner text. In this case,\r\n * it will create a lime colored div that is 220px by 100px in size with the text Phaser in it, in an Arial font.\r\n *\r\n * You should nearly always, without exception, use explicitly sized HTML Elements, in order to fully control\r\n * alignment and positioning of the elements next to regular game content.\r\n *\r\n * Rather than specify the CSS and HTML directly you can use the `load.html` File Loader to load it into the\r\n * cache and then use the `createFromCache` method instead. You can also use `createFromHTML` and various other\r\n * methods available in this class to help construct your elements.\r\n *\r\n * Once the element has been created you can then control it like you would any other Game Object. You can set its\r\n * position, scale, rotation, alpha and other properties. It will move as the main Scene Camera moves and be clipped\r\n * at the edge of the canvas. It's important to remember some limitations of DOM Elements: The obvious one is that\r\n * they appear above or below your game canvas. You cannot blend them into the display list, meaning you cannot have\r\n * a DOM Element, then a Sprite, then another DOM Element behind it.\r\n *\r\n * They also cannot be enabled for input. To do that, you have to use the `addListener` method to add native event\r\n * listeners directly. The final limitation is to do with cameras. The DOM Container is sized to match the game canvas\r\n * entirely and clipped accordingly. DOM Elements respect camera scrolling and scrollFactor settings, but if you\r\n * change the size of the camera so it no longer matches the size of the canvas, they won't be clipped accordingly.\r\n *\r\n * Also, all DOM Elements are inserted into the same DOM Container, regardless of which Scene they are created in.\r\n *\r\n * Note that you should only have DOM Elements in a Scene with a _single_ Camera. If you require multiple cameras,\r\n * use parallel scenes to achieve this.\r\n *\r\n * DOM Elements are a powerful way to align native HTML with your Phaser Game Objects. For example, you can insert\r\n * a login form for a multiplayer game directly into your title screen. Or a text input box for a highscore table.\r\n * Or a banner ad from a 3rd party service. Or perhaps you'd like to use them for high resolution text display and\r\n * UI. The choice is up to you, just remember that you're dealing with standard HTML and CSS floating over the top\r\n * of your game, and should treat it accordingly.\r\n *\r\n * @class DOMElement\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.17.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this DOM Element in the world.\r\n * @param {number} [y=0] - The vertical position of this DOM Element in the world.\r\n * @param {(Element|string)} [element] - An existing DOM element, or a string. If a string starting with a # it will do a `getElementById` look-up on the string (minus the hash). Without a hash, it represents the type of element to create, i.e. 'div'.\r\n * @param {(string|any)} [style] - If a string, will be set directly as the elements `style` property value. If a plain object, will be iterated and the values transferred. In both cases the values replacing whatever CSS styles may have been previously set.\r\n * @param {string} [innerText] - If given, will be set directly as the elements `innerText` property value, replacing whatever was there before.\r\n */\r\nvar DOMElement = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Origin,\r\n        Components.ScrollFactor,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        DOMElementRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function DOMElement (scene, x, y, element, style, innerText)\r\n    {\r\n        GameObject.call(this, scene, 'DOMElement');\r\n\r\n        /**\r\n         * A reference to the parent DOM Container that the Game instance created when it started.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#parent\r\n         * @type {Element}\r\n         * @since 3.17.0\r\n         */\r\n        this.parent = scene.sys.game.domContainer;\r\n\r\n        /**\r\n         * A reference to the HTML Cache.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#cache\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.17.0\r\n         */\r\n        this.cache = scene.sys.cache.html;\r\n\r\n        /**\r\n         * The actual DOM Element that this Game Object is bound to. For example, if you've created a `<div>`\r\n         * then this property is a direct reference to that element within the dom.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#node\r\n         * @type {Element}\r\n         * @since 3.17.0\r\n         */\r\n        this.node;\r\n\r\n        /**\r\n         * By default a DOM Element will have its transform, display, opacity, zIndex and blend mode properties\r\n         * updated when its rendered. If, for some reason, you don't want any of these changed other than the\r\n         * CSS transform, then set this flag to `true`. When `true` only the CSS Transform is applied and it's\r\n         * up to you to keep track of and set the other properties as required.\r\n         *\r\n         * This can be handy if, for example, you've a nested DOM Element and you don't want the opacity to be\r\n         * picked-up by any of its children.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#transformOnly\r\n         * @type {boolean}\r\n         * @since 3.17.0\r\n         */\r\n        this.transformOnly = false;\r\n\r\n        /**\r\n         * The angle, in radians, by which to skew the DOM Element on the horizontal axis.\r\n         *\r\n         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#skewX\r\n         * @type {number}\r\n         * @since 3.17.0\r\n         */\r\n        this.skewX = 0;\r\n\r\n        /**\r\n         * The angle, in radians, by which to skew the DOM Element on the vertical axis.\r\n         *\r\n         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#skewY\r\n         * @type {number}\r\n         * @since 3.17.0\r\n         */\r\n        this.skewY = 0;\r\n\r\n        /**\r\n         * A Vector4 that contains the 3D rotation of this DOM Element around a fixed axis in 3D space.\r\n         *\r\n         * All values in the Vector4 are treated as degrees, unless the `rotate3dAngle` property is changed.\r\n         *\r\n         * For more details see the following MDN page:\r\n         *\r\n         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#rotate3d\r\n         * @type {Phaser.Math.Vector4}\r\n         * @since 3.17.0\r\n         */\r\n        this.rotate3d = new Vector4();\r\n\r\n        /**\r\n         * The unit that represents the 3D rotation values. By default this is `deg` for degrees, but can\r\n         * be changed to any supported unit. See this page for further details:\r\n         *\r\n         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#rotate3dAngle\r\n         * @type {string}\r\n         * @since 3.17.0\r\n         */\r\n        this.rotate3dAngle = 'deg';\r\n\r\n        /**\r\n         * Sets the CSS `pointerEvents` attribute on the DOM Element during rendering.\r\n         *\r\n         * This is 'auto' by default. Changing it may have unintended side-effects with\r\n         * internal Phaser input handling, such as dragging, so only change this if you\r\n         * understand the implications.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#pointerEvents\r\n         * @type {string}\r\n         * @since 3.55.0\r\n         */\r\n        this.pointerEvents = 'auto';\r\n\r\n        /**\r\n         * The native (un-scaled) width of this Game Object.\r\n         *\r\n         * For a DOM Element this property is read-only.\r\n         *\r\n         * The property `displayWidth` holds the computed bounds of this DOM Element, factoring in scaling.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#width\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.width = 0;\r\n\r\n        /**\r\n         * The native (un-scaled) height of this Game Object.\r\n         *\r\n         * For a DOM Element this property is read-only.\r\n         *\r\n         * The property `displayHeight` holds the computed bounds of this DOM Element, factoring in scaling.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#height\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.height = 0;\r\n\r\n        /**\r\n         * The computed display width of this Game Object, based on the `getBoundingClientRect` DOM call.\r\n         *\r\n         * The property `width` holds the un-scaled width of this DOM Element.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#displayWidth\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.displayWidth = 0;\r\n\r\n        /**\r\n         * The computed display height of this Game Object, based on the `getBoundingClientRect` DOM call.\r\n         *\r\n         * The property `height` holds the un-scaled height of this DOM Element.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#displayHeight\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.displayHeight = 0;\r\n\r\n        /**\r\n         * Internal native event handler.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#handler\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this.handler = this.dispatchNativeEvent.bind(this);\r\n\r\n        this.setPosition(x, y);\r\n\r\n        if (typeof element === 'string')\r\n        {\r\n            //  hash?\r\n            if (element[0] === '#')\r\n            {\r\n                this.setElement(element.substr(1), style, innerText);\r\n            }\r\n            else\r\n            {\r\n                this.createElement(element, style, innerText);\r\n            }\r\n        }\r\n        else if (element)\r\n        {\r\n            this.setElement(element, style, innerText);\r\n        }\r\n\r\n        scene.sys.events.on(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);\r\n        scene.sys.events.on(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * Handles a Scene Sleep and Wake event.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#handleSceneEvent\r\n     * @private\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Scenes.Systems} sys - The Scene Systems.\r\n     */\r\n    handleSceneEvent: function (sys)\r\n    {\r\n        var node = this.node;\r\n        var style = node.style;\r\n\r\n        if (node)\r\n        {\r\n            style.display = (sys.settings.visible) ? 'block' : 'none';\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal and vertical skew values of this DOM Element.\r\n     *\r\n     * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/transform\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#setSkew\r\n     * @since 3.17.0\r\n     *\r\n     * @param {number} [x=0] - The angle, in radians, by which to skew the DOM Element on the horizontal axis.\r\n     * @param {number} [y=x] - The angle, in radians, by which to skew the DOM Element on the vertical axis.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    setSkew: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.skewX = x;\r\n        this.skewY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the perspective CSS property of the _parent DOM Container_. This determines the distance between the z=0\r\n     * plane and the user in order to give a 3D-positioned element some perspective. Each 3D element with\r\n     * z > 0 becomes larger; each 3D-element with z < 0 becomes smaller. The strength of the effect is determined\r\n     * by the value of this property.\r\n     *\r\n     * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/perspective\r\n     *\r\n     * **Changing this value changes it globally for all DOM Elements, as they all share the same parent container.**\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#setPerspective\r\n     * @since 3.17.0\r\n     *\r\n     * @param {number} value - The perspective value, in pixels, that determines the distance between the z plane and the user.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    setPerspective: function (value)\r\n    {\r\n        this.parent.style.perspective = value + 'px';\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The perspective CSS property value of the _parent DOM Container_. This determines the distance between the z=0\r\n     * plane and the user in order to give a 3D-positioned element some perspective. Each 3D element with\r\n     * z > 0 becomes larger; each 3D-element with z < 0 becomes smaller. The strength of the effect is determined\r\n     * by the value of this property.\r\n     *\r\n     * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/perspective\r\n     *\r\n     * **Changing this value changes it globally for all DOM Elements, as they all share the same parent container.**\r\n     *\r\n     * @name Phaser.GameObjects.DOMElement#perspective\r\n     * @type {number}\r\n     * @since 3.17.0\r\n     */\r\n    perspective: {\r\n\r\n        get: function ()\r\n        {\r\n            return parseFloat(this.parent.style.perspective);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.parent.style.perspective = value + 'px';\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Adds one or more native DOM event listeners onto the underlying Element of this Game Object.\r\n     * The event is then dispatched via this Game Objects standard event emitter.\r\n     *\r\n     * For example:\r\n     *\r\n     * ```javascript\r\n     * var div = this.add.dom(x, y, element);\r\n     *\r\n     * div.addListener('click');\r\n     *\r\n     * div.on('click', handler);\r\n     * ```\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#addListener\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} events - The DOM event/s to listen for. You can specify multiple events by separating them with spaces.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    addListener: function (events)\r\n    {\r\n        if (this.node)\r\n        {\r\n            events = events.split(' ');\r\n\r\n            for (var i = 0; i < events.length; i++)\r\n            {\r\n                this.node.addEventListener(events[i], this.handler, false);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes one or more native DOM event listeners from the underlying Element of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#removeListener\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} events - The DOM event/s to stop listening for. You can specify multiple events by separating them with spaces.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    removeListener: function (events)\r\n    {\r\n        if (this.node)\r\n        {\r\n            events = events.split(' ');\r\n\r\n            for (var i = 0; i < events.length; i++)\r\n            {\r\n                this.node.removeEventListener(events[i], this.handler);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal event proxy to dispatch native DOM Events via this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#dispatchNativeEvent\r\n     * @private\r\n     * @since 3.17.0\r\n     *\r\n     * @param {any} event - The native DOM event.\r\n     */\r\n    dispatchNativeEvent: function (event)\r\n    {\r\n        this.emit(event.type, event);\r\n    },\r\n\r\n    /**\r\n     * Creates a native DOM Element, adds it to the parent DOM Container and then binds it to this Game Object,\r\n     * so you can control it. The `tagName` should be a string and is passed to `document.createElement`:\r\n     *\r\n     * ```javascript\r\n     * this.add.dom().createElement('div');\r\n     * ```\r\n     *\r\n     * For more details on acceptable tag names see: https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement\r\n     *\r\n     * You can also pass in a DOMString or style object to set the CSS on the created element, and an optional `innerText`\r\n     * value as well. Here is an example of a DOMString:\r\n     *\r\n     * ```javascript\r\n     * this.add.dom().createElement('div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');\r\n     * ```\r\n     *\r\n     * And using a style object:\r\n     *\r\n     * ```javascript\r\n     * var style = {\r\n     *   'background-color': 'lime';\r\n     *   'width': '200px';\r\n     *   'height': '100px';\r\n     *   'font': '48px Arial';\r\n     * };\r\n     *\r\n     * this.add.dom().createElement('div', style, 'Phaser');\r\n     * ```\r\n     *\r\n     * If this Game Object already has an Element, it is removed from the DOM entirely first.\r\n     * Any event listeners you may have previously created will need to be re-created after this call.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#createElement\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} tagName - A string that specifies the type of element to be created. The nodeName of the created element is initialized with the value of tagName. Don't use qualified names (like \"html:a\") with this method.\r\n     * @param {(string|any)} [style] - Either a DOMString that holds the CSS styles to be applied to the created element, or an object the styles will be ready from.\r\n     * @param {string} [innerText] - A DOMString that holds the text that will be set as the innerText of the created element.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    createElement: function (tagName, style, innerText)\r\n    {\r\n        return this.setElement(document.createElement(tagName), style, innerText);\r\n    },\r\n\r\n    /**\r\n     * Binds a new DOM Element to this Game Object. If this Game Object already has an Element it is removed from the DOM\r\n     * entirely first. Any event listeners you may have previously created will need to be re-created on the new element.\r\n     *\r\n     * The `element` argument you pass to this method can be either a string tagName:\r\n     *\r\n     * ```javascript\r\n     * <h1 id=\"heading\">Phaser</h1>\r\n     *\r\n     * this.add.dom().setElement('heading');\r\n     * ```\r\n     *\r\n     * Or a reference to an Element instance:\r\n     *\r\n     * ```javascript\r\n     * <h1 id=\"heading\">Phaser</h1>\r\n     *\r\n     * var h1 = document.getElementById('heading');\r\n     *\r\n     * this.add.dom().setElement(h1);\r\n     * ```\r\n     *\r\n     * You can also pass in a DOMString or style object to set the CSS on the created element, and an optional `innerText`\r\n     * value as well. Here is an example of a DOMString:\r\n     *\r\n     * ```javascript\r\n     * this.add.dom().setElement(h1, 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');\r\n     * ```\r\n     *\r\n     * And using a style object:\r\n     *\r\n     * ```javascript\r\n     * var style = {\r\n     *   'background-color': 'lime';\r\n     *   'width': '200px';\r\n     *   'height': '100px';\r\n     *   'font': '48px Arial';\r\n     * };\r\n     *\r\n     * this.add.dom().setElement(h1, style, 'Phaser');\r\n     * ```\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#setElement\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|Element)} element - If a string it is passed to `getElementById()`, or it should be a reference to an existing Element.\r\n     * @param {(string|any)} [style] - Either a DOMString that holds the CSS styles to be applied to the created element, or an object the styles will be ready from.\r\n     * @param {string} [innerText] - A DOMString that holds the text that will be set as the innerText of the created element.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    setElement: function (element, style, innerText)\r\n    {\r\n        //  Already got an element? Remove it first\r\n        this.removeElement();\r\n\r\n        var target;\r\n\r\n        if (typeof element === 'string')\r\n        {\r\n            //  hash?\r\n            if (element[0] === '#')\r\n            {\r\n                element = element.substr(1);\r\n            }\r\n\r\n            target = document.getElementById(element);\r\n        }\r\n        else if (typeof element === 'object' && element.nodeType === 1)\r\n        {\r\n            target = element;\r\n        }\r\n\r\n        if (!target)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.node = target;\r\n\r\n        //  style can be empty, a string or a plain object\r\n        if (style && IsPlainObject(style))\r\n        {\r\n            for (var key in style)\r\n            {\r\n                target.style[key] = style[key];\r\n            }\r\n        }\r\n        else if (typeof style === 'string')\r\n        {\r\n            target.style = style;\r\n        }\r\n\r\n        //  Add / Override the values we need\r\n\r\n        target.style.zIndex = '0';\r\n        target.style.display = 'inline';\r\n        target.style.position = 'absolute';\r\n\r\n        //  Node handler\r\n\r\n        target.phaser = this;\r\n\r\n        if (this.parent)\r\n        {\r\n            this.parent.appendChild(target);\r\n        }\r\n\r\n        //  InnerText\r\n\r\n        if (innerText)\r\n        {\r\n            target.innerText = innerText;\r\n        }\r\n\r\n        return this.updateSize();\r\n    },\r\n\r\n    /**\r\n     * Takes a block of html from the HTML Cache, that has previously been preloaded into the game, and then\r\n     * creates a DOM Element from it. The loaded HTML is set as the `innerHTML` property of the created\r\n     * element.\r\n     *\r\n     * Assume the following html is stored in a file called `loginform.html`:\r\n     *\r\n     * ```html\r\n     * <input type=\"text\" name=\"nameField\" placeholder=\"Enter your name\" style=\"font-size: 32px\">\r\n     * <input type=\"button\" name=\"playButton\" value=\"Let's Play\" style=\"font-size: 32px\">\r\n     * ```\r\n     *\r\n     * Which is loaded into your game using the cache key 'login':\r\n     *\r\n     * ```javascript\r\n     * this.load.html('login', 'assets/loginform.html');\r\n     * ```\r\n     *\r\n     * You can create a DOM Element from it using the cache key:\r\n     *\r\n     * ```javascript\r\n     * this.add.dom().createFromCache('login');\r\n     * ```\r\n     *\r\n     * The optional `elementType` argument controls the container that is created, into which the loaded html is inserted.\r\n     * The default is a plain `div` object, but any valid tagName can be given.\r\n     *\r\n     * If this Game Object already has an Element, it is removed from the DOM entirely first.\r\n     * Any event listeners you may have previously created will need to be re-created after this call.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#createFromCache\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} The key of the html cache entry to use for this DOM Element.\r\n     * @param {string} [tagName='div'] - The tag name of the element into which all of the loaded html will be inserted. Defaults to a plain div tag.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    createFromCache: function (key, tagName)\r\n    {\r\n        var html = this.cache.get(key);\r\n\r\n        if (html)\r\n        {\r\n            this.createFromHTML(html, tagName);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a string of html and then creates a DOM Element from it. The HTML is set as the `innerHTML`\r\n     * property of the created element.\r\n     *\r\n     * ```javascript\r\n     * let form = `\r\n     * <input type=\"text\" name=\"nameField\" placeholder=\"Enter your name\" style=\"font-size: 32px\">\r\n     * <input type=\"button\" name=\"playButton\" value=\"Let's Play\" style=\"font-size: 32px\">\r\n     * `;\r\n     * ```\r\n     *\r\n     * You can create a DOM Element from it using the string:\r\n     *\r\n     * ```javascript\r\n     * this.add.dom().createFromHTML(form);\r\n     * ```\r\n     *\r\n     * The optional `elementType` argument controls the type of container that is created, into which the html is inserted.\r\n     * The default is a plain `div` object, but any valid tagName can be given.\r\n     *\r\n     * If this Game Object already has an Element, it is removed from the DOM entirely first.\r\n     * Any event listeners you may have previously created will need to be re-created after this call.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#createFromHTML\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} html - A string of html to be set as the `innerHTML` property of the created element.\r\n     * @param {string} [tagName='div'] - The tag name of the element into which all of the html will be inserted. Defaults to a plain div tag.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    createFromHTML: function (html, tagName)\r\n    {\r\n        if (tagName === undefined) { tagName = 'div'; }\r\n\r\n        //  Already got an element? Remove it first\r\n        this.removeElement();\r\n\r\n        var element = document.createElement(tagName);\r\n\r\n        this.node = element;\r\n\r\n        element.style.zIndex = '0';\r\n        element.style.display = 'inline';\r\n        element.style.position = 'absolute';\r\n\r\n        //  Node handler\r\n\r\n        element.phaser = this;\r\n\r\n        if (this.parent)\r\n        {\r\n            this.parent.appendChild(element);\r\n        }\r\n\r\n        element.innerHTML = html;\r\n\r\n        return this.updateSize();\r\n    },\r\n\r\n    /**\r\n     * Removes the current DOM Element bound to this Game Object from the DOM entirely and resets the\r\n     * `node` property of this Game Object to be `null`.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#removeElement\r\n     * @since 3.17.0\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    removeElement: function ()\r\n    {\r\n        if (this.node)\r\n        {\r\n            RemoveFromDOM(this.node);\r\n\r\n            this.node = null;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that calls `getBoundingClientRect` on the `node` and then sets the bounds width\r\n     * and height into the `displayWidth` and `displayHeight` properties, and the `clientWidth` and `clientHeight`\r\n     * values into the `width` and `height` properties respectively.\r\n     *\r\n     * This is called automatically whenever a new element is created or set.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#updateSize\r\n     * @since 3.17.0\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    updateSize: function ()\r\n    {\r\n        var node = this.node;\r\n\r\n        var nodeBounds = node.getBoundingClientRect();\r\n\r\n        this.width = node.clientWidth;\r\n        this.height = node.clientHeight;\r\n\r\n        this.displayWidth = nodeBounds.width || 0;\r\n        this.displayHeight = nodeBounds.height || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through\r\n     * them, looking for the first one that has a property matching the given key and value. It then returns this child\r\n     * if found, or `null` if not.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#getChildByProperty\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} property - The property to search the children for.\r\n     * @param {string} value - The value the property must strictly equal.\r\n     *\r\n     * @return {?Element} The first matching child DOM Element, or `null` if not found.\r\n     */\r\n    getChildByProperty: function (property, value)\r\n    {\r\n        if (this.node)\r\n        {\r\n            var children = this.node.querySelectorAll('*');\r\n\r\n            for (var i = 0; i < children.length; i++)\r\n            {\r\n                if (children[i][property] === value)\r\n                {\r\n                    return children[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through\r\n     * them, looking for the first one that has a matching id. It then returns this child if found, or `null` if not.\r\n     *\r\n     * Be aware that class and id names are case-sensitive.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#getChildByID\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} id - The id to search the children for.\r\n     *\r\n     * @return {?Element} The first matching child DOM Element, or `null` if not found.\r\n     */\r\n    getChildByID: function (id)\r\n    {\r\n        return this.getChildByProperty('id', id);\r\n    },\r\n\r\n    /**\r\n     * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through\r\n     * them, looking for the first one that has a matching name. It then returns this child if found, or `null` if not.\r\n     *\r\n     * Be aware that class and id names are case-sensitive.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#getChildByName\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} name - The name to search the children for.\r\n     *\r\n     * @return {?Element} The first matching child DOM Element, or `null` if not found.\r\n     */\r\n    getChildByName: function (name)\r\n    {\r\n        return this.getChildByProperty('name', name);\r\n    },\r\n\r\n    /**\r\n     * Sets the `className` property of the DOM Element node and updates the internal sizes.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#setClassName\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} className - A string representing the class or space-separated classes of the element.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    setClassName: function (className)\r\n    {\r\n        if (this.node)\r\n        {\r\n            this.node.className = className;\r\n\r\n            this.updateSize();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `innerText` property of the DOM Element node and updates the internal sizes.\r\n     *\r\n     * Note that only certain types of Elements can have `innerText` set on them.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#setText\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} text - A DOMString representing the rendered text content of the element.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    setText: function (text)\r\n    {\r\n        if (this.node)\r\n        {\r\n            this.node.innerText = text;\r\n\r\n            this.updateSize();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `innerHTML` property of the DOM Element node and updates the internal sizes.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#setHTML\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} html - A DOMString of html to be set as the `innerHTML` property of the element.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    setHTML: function (html)\r\n    {\r\n        if (this.node)\r\n        {\r\n            this.node.innerHTML = html;\r\n\r\n            this.updateSize();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Runs internal update tasks.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#preUpdate\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        var parent = this.parentContainer;\r\n        var node = this.node;\r\n\r\n        if (node && parent && !parent.willRender())\r\n        {\r\n            node.style.display = 'none';\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     *\r\n     * DOMElements always return `true` as they need to still set values during the render pass, even if not visible.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#willRender\r\n     * @since 3.17.0\r\n     *\r\n     * @return {boolean} `true` if the Game Object should be rendered, otherwise `false`.\r\n     */\r\n    willRender: function ()\r\n    {\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Handles the pre-destroy step for the DOM Element, which removes the underlying node from the DOM.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#preDestroy\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.removeElement();\r\n\r\n        this.scene.sys.events.off(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);\r\n        this.scene.sys.events.off(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = DOMElement;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CSSBlendModes = require('./CSSBlendModes');\r\nvar GameObject = require('../GameObject');\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\n\r\nvar tempMatrix1 = new TransformMatrix();\r\nvar tempMatrix2 = new TransformMatrix();\r\nvar tempMatrix3 = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.DOMElement#renderWebGL\r\n * @since 3.17.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active renderer.\r\n * @param {Phaser.GameObjects.DOMElement} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar DOMElementCSSRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (!src.node)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var style = src.node.style;\r\n    var settings = src.scene.sys.settings;\r\n\r\n    if (!style || !settings.visible || GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter !== 0 && (src.cameraFilter & camera.id)) || (src.parentContainer && !src.parentContainer.willRender()))\r\n    {\r\n        style.display = 'none';\r\n\r\n        return;\r\n    }\r\n\r\n    var parent = src.parentContainer;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (parent)\r\n    {\r\n        alpha *= parent.alpha;\r\n    }\r\n\r\n    var camMatrix = tempMatrix1;\r\n    var srcMatrix = tempMatrix2;\r\n    var calcMatrix = tempMatrix3;\r\n\r\n    var dx = 0;\r\n    var dy = 0;\r\n\r\n    var tx = '0%';\r\n    var ty = '0%';\r\n\r\n    if (parentMatrix)\r\n    {\r\n        dx = (src.width * src.scaleX) * src.originX;\r\n        dy = (src.height * src.scaleY) * src.originY;\r\n\r\n        srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);\r\n\r\n        camMatrix.copyFrom(camera.matrix);\r\n\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        srcMatrix.e = src.x - dx;\r\n        srcMatrix.f = src.y - dy;\r\n\r\n        //  Multiply by the src matrix, store result in calcMatrix\r\n        camMatrix.multiply(srcMatrix, calcMatrix);\r\n    }\r\n    else\r\n    {\r\n        dx = (src.width) * src.originX;\r\n        dy = (src.height) * src.originY;\r\n\r\n        srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);\r\n\r\n        camMatrix.copyFrom(camera.matrix);\r\n\r\n        tx = (100 * src.originX) + '%';\r\n        ty = (100 * src.originY) + '%';\r\n\r\n        srcMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        srcMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        //  Multiply by the src matrix, store result in calcMatrix\r\n        camMatrix.multiply(srcMatrix, calcMatrix);\r\n    }\r\n\r\n    if (!src.transformOnly)\r\n    {\r\n        style.display = 'block';\r\n        style.opacity = alpha;\r\n        style.zIndex = src._depth;\r\n        style.pointerEvents = src.pointerEvents;\r\n        style.mixBlendMode = CSSBlendModes[src._blendMode];\r\n    }\r\n\r\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/transform\r\n\r\n    style.transform =\r\n        calcMatrix.getCSSMatrix() +\r\n        ' skew(' + src.skewX + 'rad, ' + src.skewY + 'rad)' +\r\n        ' rotate3d(' + src.rotate3d.x + ',' + src.rotate3d.y + ',' + src.rotate3d.z + ',' + src.rotate3d.w + src.rotate3dAngle + ')';\r\n\r\n    style.transformOrigin = tx + ' ' + ty;\r\n};\r\n\r\nmodule.exports = DOMElementCSSRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar ExternRender = require('./ExternRender');\r\n\r\n/**\r\n * @classdesc\r\n * An Extern Game Object is a special type of Game Object that allows you to pass\r\n * rendering off to a 3rd party.\r\n *\r\n * When you create an Extern and place it in the display list of a Scene, the renderer will\r\n * process the list as usual. When it finds an Extern it will flush the current batch,\r\n * clear down the pipeline and prepare a transform matrix which your render function can\r\n * take advantage of, if required.\r\n *\r\n * The WebGL context is then left in a 'clean' state, ready for you to bind your own shaders,\r\n * or draw to it, whatever you wish to do. This should all take place in the `render` method.\r\n * The correct way to deploy an Extern object is to create a class that extends it, then\r\n * override the `render` (and optionally `preUpdate`) methods and pass off control to your\r\n * 3rd party libraries or custom WebGL code there.\r\n *\r\n * Once you've finished, you should free-up any of your resources.\r\n * The Extern will then rebind the Phaser pipeline and carry on rendering the display list.\r\n *\r\n * Although this object has lots of properties such as Alpha, Blend Mode and Tint, none of\r\n * them are used during rendering unless you take advantage of them in your own render code.\r\n *\r\n * @class Extern\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n */\r\nvar Extern = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.Origin,\r\n        Components.ScrollFactor,\r\n        Components.Size,\r\n        Components.Texture,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        ExternRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Extern (scene)\r\n    {\r\n        GameObject.call(this, scene, 'Extern');\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    preUpdate: function ()\r\n    {\r\n        //  override this!\r\n        //  Arguments: time, delta\r\n    },\r\n\r\n    render: function ()\r\n    {\r\n        //  override this!\r\n        //  Arguments: renderer, camera, calcMatrix\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Extern;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Commands = require('./Commands');\r\nvar SetTransform = require('../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Graphics#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Graphics} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n * @param {CanvasRenderingContext2D} [renderTargetCtx] - The target rendering context.\r\n * @param {boolean} allowClip - If `true` then path operations will be used instead of fill operations.\r\n */\r\nvar GraphicsCanvasRenderer = function (renderer, src, camera, parentMatrix, renderTargetCtx, allowClip)\r\n{\r\n    var commandBuffer = src.commandBuffer;\r\n    var commandBufferLength = commandBuffer.length;\r\n\r\n    var ctx = renderTargetCtx || renderer.currentContext;\r\n\r\n    if (commandBufferLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var lineAlpha = 1;\r\n    var fillAlpha = 1;\r\n    var lineColor = 0;\r\n    var fillColor = 0;\r\n    var lineWidth = 1;\r\n    var red = 0;\r\n    var green = 0;\r\n    var blue = 0;\r\n\r\n    //  Reset any currently active paths\r\n    ctx.beginPath();\r\n\r\n    for (var index = 0; index < commandBufferLength; ++index)\r\n    {\r\n        var commandID = commandBuffer[index];\r\n\r\n        switch (commandID)\r\n        {\r\n            case Commands.ARC:\r\n                ctx.arc(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2],\r\n                    commandBuffer[index + 3],\r\n                    commandBuffer[index + 4],\r\n                    commandBuffer[index + 5],\r\n                    commandBuffer[index + 6]\r\n                );\r\n\r\n                //  +7 because overshoot is the 7th value, not used in Canvas\r\n                index += 7;\r\n                break;\r\n\r\n            case Commands.LINE_STYLE:\r\n                lineWidth = commandBuffer[index + 1];\r\n                lineColor = commandBuffer[index + 2];\r\n                lineAlpha = commandBuffer[index + 3];\r\n                red = ((lineColor & 0xFF0000) >>> 16);\r\n                green = ((lineColor & 0xFF00) >>> 8);\r\n                blue = (lineColor & 0xFF);\r\n                ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + lineAlpha + ')';\r\n                ctx.lineWidth = lineWidth;\r\n                index += 3;\r\n                break;\r\n\r\n            case Commands.FILL_STYLE:\r\n                fillColor = commandBuffer[index + 1];\r\n                fillAlpha = commandBuffer[index + 2];\r\n                red = ((fillColor & 0xFF0000) >>> 16);\r\n                green = ((fillColor & 0xFF00) >>> 8);\r\n                blue = (fillColor & 0xFF);\r\n                ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';\r\n                index += 2;\r\n                break;\r\n\r\n            case Commands.BEGIN_PATH:\r\n                ctx.beginPath();\r\n                break;\r\n\r\n            case Commands.CLOSE_PATH:\r\n                ctx.closePath();\r\n                break;\r\n\r\n            case Commands.FILL_PATH:\r\n                if (!allowClip)\r\n                {\r\n                    ctx.fill();\r\n                }\r\n                break;\r\n\r\n            case Commands.STROKE_PATH:\r\n                if (!allowClip)\r\n                {\r\n                    ctx.stroke();\r\n                }\r\n                break;\r\n\r\n            case Commands.FILL_RECT:\r\n                if (!allowClip)\r\n                {\r\n                    ctx.fillRect(\r\n                        commandBuffer[index + 1],\r\n                        commandBuffer[index + 2],\r\n                        commandBuffer[index + 3],\r\n                        commandBuffer[index + 4]\r\n                    );\r\n                }\r\n                else\r\n                {\r\n                    ctx.rect(\r\n                        commandBuffer[index + 1],\r\n                        commandBuffer[index + 2],\r\n                        commandBuffer[index + 3],\r\n                        commandBuffer[index + 4]\r\n                    );\r\n                }\r\n                index += 4;\r\n                break;\r\n\r\n            case Commands.FILL_TRIANGLE:\r\n                ctx.beginPath();\r\n                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);\r\n                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);\r\n                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);\r\n                ctx.closePath();\r\n                if (!allowClip)\r\n                {\r\n                    ctx.fill();\r\n                }\r\n                index += 6;\r\n                break;\r\n\r\n            case Commands.STROKE_TRIANGLE:\r\n                ctx.beginPath();\r\n                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);\r\n                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);\r\n                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);\r\n                ctx.closePath();\r\n                if (!allowClip)\r\n                {\r\n                    ctx.stroke();\r\n                }\r\n                index += 6;\r\n                break;\r\n\r\n            case Commands.LINE_TO:\r\n                ctx.lineTo(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2]\r\n                );\r\n                index += 2;\r\n                break;\r\n\r\n            case Commands.MOVE_TO:\r\n                ctx.moveTo(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2]\r\n                );\r\n                index += 2;\r\n                break;\r\n\r\n            case Commands.LINE_FX_TO:\r\n                ctx.lineTo(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2]\r\n                );\r\n                index += 5;\r\n                break;\r\n\r\n            case Commands.MOVE_FX_TO:\r\n                ctx.moveTo(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2]\r\n                );\r\n                index += 5;\r\n                break;\r\n\r\n            case Commands.SAVE:\r\n                ctx.save();\r\n                break;\r\n\r\n            case Commands.RESTORE:\r\n                ctx.restore();\r\n                break;\r\n\r\n            case Commands.TRANSLATE:\r\n                ctx.translate(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2]\r\n                );\r\n                index += 2;\r\n                break;\r\n\r\n            case Commands.SCALE:\r\n                ctx.scale(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2]\r\n                );\r\n                index += 2;\r\n                break;\r\n\r\n            case Commands.ROTATE:\r\n                ctx.rotate(\r\n                    commandBuffer[index + 1]\r\n                );\r\n                index += 1;\r\n                break;\r\n\r\n            case Commands.GRADIENT_FILL_STYLE:\r\n                index += 5;\r\n                break;\r\n\r\n            case Commands.GRADIENT_LINE_STYLE:\r\n                index += 6;\r\n                break;\r\n        }\r\n    }\r\n\r\n    //  Restore the context saved in SetTransform\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = GraphicsCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FloatBetween = require('../../math/FloatBetween');\r\nvar GetEaseFunction = require('../../tweens/builders/GetEaseFunction');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Wrap = require('../../math/Wrap');\r\n\r\n/**\r\n * @classdesc\r\n * A Particle Emitter property.\r\n *\r\n * Facilitates changing Particle properties as they are emitted and throughout their lifetime.\r\n *\r\n * @class EmitterOp\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} config - Settings for the Particle Emitter that owns this property.\r\n * @param {string} key - The name of the property.\r\n * @param {number} defaultValue - The default value of the property.\r\n * @param {boolean} [emitOnly=false] - Whether the property can only be modified when a Particle is emitted.\r\n */\r\nvar EmitterOp = new Class({\r\n\r\n    initialize:\r\n\r\n    function EmitterOp (config, key, defaultValue, emitOnly)\r\n    {\r\n        if (emitOnly === undefined)\r\n        {\r\n            emitOnly = false;\r\n        }\r\n\r\n        /**\r\n         * The name of this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#propertyKey\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.propertyKey = key;\r\n\r\n        /**\r\n         * The value of this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#propertyValue\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.propertyValue = defaultValue;\r\n\r\n        /**\r\n         * The default value of this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#defaultValue\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultValue = defaultValue;\r\n\r\n        /**\r\n         * The number of steps for stepped easing between {@link Phaser.GameObjects.Particles.EmitterOp#start} and\r\n         * {@link Phaser.GameObjects.Particles.EmitterOp#end} values, per emit.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#steps\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.steps = 0;\r\n\r\n        /**\r\n         * The step counter for stepped easing, per emit.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#counter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.counter = 0;\r\n\r\n        /**\r\n         * The start value for this property to ease between.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#start\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.start = 0;\r\n\r\n        /**\r\n         * The end value for this property to ease between.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#end\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.end = 0;\r\n\r\n        /**\r\n         * The easing function to use for updating this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#ease\r\n         * @type {?function}\r\n         * @since 3.0.0\r\n         */\r\n        this.ease;\r\n\r\n        /**\r\n         * Whether this property can only be modified when a Particle is emitted.\r\n         *\r\n         * Set to `true` to allow only {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} callbacks to be set and\r\n         * affect this property.\r\n         *\r\n         * Set to `false` to allow both {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and\r\n         * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks to be set and affect this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#emitOnly\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.emitOnly = emitOnly;\r\n\r\n        /**\r\n         * The callback to run for Particles when they are emitted from the Particle Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#onEmit\r\n         * @type {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.onEmit = this.defaultEmit;\r\n\r\n        /**\r\n         * The callback to run for Particles when they are updated.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#onUpdate\r\n         * @type {Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.onUpdate = this.defaultUpdate;\r\n\r\n        this.loadConfig(config);\r\n    },\r\n\r\n    /**\r\n     * Load the property from a Particle Emitter configuration object.\r\n     *\r\n     * Optionally accepts a new property key to use, replacing the current one.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#loadConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} [config] - Settings for the Particle Emitter that owns this property.\r\n     * @param {string} [newKey] - The new key to use for this property, if any.\r\n     */\r\n    loadConfig: function (config, newKey)\r\n    {\r\n        if (config === undefined)\r\n        {\r\n            config = {};\r\n        }\r\n\r\n        if (newKey)\r\n        {\r\n            this.propertyKey = newKey;\r\n        }\r\n\r\n        this.propertyValue = GetFastValue(\r\n            config,\r\n            this.propertyKey,\r\n            this.defaultValue\r\n        );\r\n\r\n        this.setMethods();\r\n\r\n        if (this.emitOnly)\r\n        {\r\n            //  Reset it back again\r\n            this.onUpdate = this.defaultUpdate;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Build a JSON representation of this Particle Emitter property.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} A JSON representation of this Particle Emitter property.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return this.propertyValue;\r\n    },\r\n\r\n    /**\r\n     * Change the current value of the property and update its callback methods.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#onChange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value of the property.\r\n     *\r\n     * @return {this} This Emitter Op object.\r\n     */\r\n    onChange: function (value)\r\n    {\r\n        this.propertyValue = value;\r\n\r\n        return this.setMethods();\r\n    },\r\n\r\n    /**\r\n     * Update the {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks based on the type of the current\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#propertyValue}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#setMethods\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Emitter Op object.\r\n     */\r\n    setMethods: function ()\r\n    {\r\n        var value = this.propertyValue;\r\n\r\n        var t = typeof value;\r\n\r\n        //  Reset them in case they're not changed below\r\n        this.onEmit = this.defaultEmit;\r\n        this.onUpdate = this.defaultUpdate;\r\n\r\n        if (t === 'number')\r\n        {\r\n            //  Explicit static value:\r\n            //  x: 400\r\n\r\n            this.onEmit = this.staticValueEmit;\r\n            this.onUpdate = this.staticValueUpdate; // How?\r\n        }\r\n        else if (Array.isArray(value))\r\n        {\r\n            //  Picks a random element from the array:\r\n            //  x: [ 100, 200, 300, 400 ]\r\n\r\n            this.onEmit = this.randomStaticValueEmit;\r\n        }\r\n        else if (t === 'function')\r\n        {\r\n            //  The same as setting just the onUpdate function and no onEmit (unless this op is an emitOnly one)\r\n            //  Custom callback, must return a value:\r\n\r\n            /*\r\n            x: function (particle, key, t, value)\r\n               {\r\n                   return value + 50;\r\n               }\r\n            */\r\n\r\n            if (this.emitOnly)\r\n            {\r\n                this.onEmit = value;\r\n            }\r\n            else\r\n            {\r\n                this.onUpdate = value;\r\n            }\r\n        }\r\n        else if (t === 'object' && this.hasBoth(value, 'start', 'end'))\r\n        {\r\n            this.start = value.start;\r\n            this.end = value.end;\r\n\r\n            //  x: { start: 100, end: 400, random: true } (random optional) = eases between start and end\r\n\r\n            var isRandom = this.has(value, 'random');\r\n\r\n            if (isRandom)\r\n            {\r\n                this.onEmit = this.randomRangedValueEmit;\r\n            }\r\n\r\n            if (this.has(value, 'steps'))\r\n            {\r\n                //  A stepped (per emit) range\r\n\r\n                //  x: { start: 100, end: 400, steps: 64 }\r\n\r\n                //  Increments a value stored in the emitter\r\n\r\n                this.steps = value.steps;\r\n                this.counter = this.start;\r\n\r\n                this.onEmit = this.steppedEmit;\r\n            }\r\n            else\r\n            {\r\n                //  An eased range (defaults to Linear if not specified)\r\n\r\n                //  x: { start: 100, end: 400, [ ease: 'Linear' ] }\r\n\r\n                var easeType = this.has(value, 'ease') ? value.ease : 'Linear';\r\n\r\n                this.ease = GetEaseFunction(easeType, value.easeParams);\r\n\r\n                if (!isRandom)\r\n                {\r\n                    this.onEmit = this.easedValueEmit;\r\n                }\r\n\r\n                this.onUpdate = this.easeValueUpdate;\r\n            }\r\n        }\r\n        else if (t === 'object' && this.hasBoth(value, 'min', 'max'))\r\n        {\r\n            //  { min: 100, max: 400 } = pick a random number between min and max\r\n\r\n            this.start = value.min;\r\n            this.end = value.max;\r\n            this.onEmit = this.randomRangedValueEmit;\r\n        }\r\n        else if (t === 'object' && this.has(value, 'random'))\r\n        {\r\n            //  { random: [ 100, 400 ] } = pick a random number between the two elements of the array\r\n\r\n            var rnd = value.random;\r\n\r\n            if (Array.isArray(rnd))\r\n            {\r\n                this.start = rnd[0];\r\n                this.end = rnd[1];\r\n            }\r\n\r\n            this.onEmit = this.randomRangedValueEmit;\r\n        }\r\n        else if (t === 'object' && this.hasEither(value, 'onEmit', 'onUpdate'))\r\n        {\r\n            //  Custom onEmit and onUpdate callbacks\r\n\r\n            /*\r\n            x: {\r\n                //  Called at the start of the particles life, when it is being created\r\n                onEmit: function (particle, key, t, value)\r\n                {\r\n                    return value;\r\n                },\r\n\r\n                //  Called during the particles life on each update\r\n                onUpdate: function (particle, key, t, value)\r\n                {\r\n                    return value;\r\n                }\r\n            }\r\n            */\r\n\r\n            if (this.has(value, 'onEmit'))\r\n            {\r\n                this.onEmit = value.onEmit;\r\n            }\r\n\r\n            if (this.has(value, 'onUpdate'))\r\n            {\r\n                this.onUpdate = value.onUpdate;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether an object has the given property.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#has\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - The object to check.\r\n     * @param {string} key - The key of the property to look for in the object.\r\n     *\r\n     * @return {boolean} `true` if the property exists in the object, `false` otherwise.\r\n     */\r\n    has: function (object, key)\r\n    {\r\n        return object.hasOwnProperty(key);\r\n    },\r\n\r\n    /**\r\n     * Check whether an object has both of the given properties.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#hasBoth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - The object to check.\r\n     * @param {string} key1 - The key of the first property to check the object for.\r\n     * @param {string} key2 - The key of the second property to check the object for.\r\n     *\r\n     * @return {boolean} `true` if both properties exist in the object, `false` otherwise.\r\n     */\r\n    hasBoth: function (object, key1, key2)\r\n    {\r\n        return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);\r\n    },\r\n\r\n    /**\r\n     * Check whether an object has at least one of the given properties.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#hasEither\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - The object to check.\r\n     * @param {string} key1 - The key of the first property to check the object for.\r\n     * @param {string} key2 - The key of the second property to check the object for.\r\n     *\r\n     * @return {boolean} `true` if at least one of the properties exists in the object, `false` if neither exist.\r\n     */\r\n    hasEither: function (object, key1, key2)\r\n    {\r\n        return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);\r\n    },\r\n\r\n    /**\r\n     * The returned value sets what the property will be at the START of the particles life, on emit.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#defaultEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The name of the property.\r\n     * @param {number} [value] - The current value of the property.\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    defaultEmit: function (particle, key, value)\r\n    {\r\n        return value;\r\n    },\r\n\r\n    /**\r\n     * The returned value updates the property for the duration of the particles life.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#defaultUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The name of the property.\r\n     * @param {number} t - The T value (between 0 and 1)\r\n     * @param {number} value - The current value of the property.\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    defaultUpdate: function (particle, key, t, value)\r\n    {\r\n        return value;\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback that returns the current value of the property.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#staticValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The current value of the property.\r\n     */\r\n    staticValueEmit: function ()\r\n    {\r\n        return this.propertyValue;\r\n    },\r\n\r\n    /**\r\n     * An `onUpdate` callback that returns the current value of the property.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#staticValueUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The current value of the property.\r\n     */\r\n    staticValueUpdate: function ()\r\n    {\r\n        return this.propertyValue;\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback that returns a random value from the current value array.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#randomStaticValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    randomStaticValueEmit: function ()\r\n    {\r\n        var randomIndex = Math.floor(Math.random() * this.propertyValue.length);\r\n\r\n        return this.propertyValue[randomIndex];\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback that returns a value between the {@link Phaser.GameObjects.Particles.EmitterOp#start} and\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#end} range.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#randomRangedValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The key of the property.\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    randomRangedValueEmit: function (particle, key)\r\n    {\r\n        var value = FloatBetween(this.start, this.end);\r\n\r\n        if (particle && particle.data[key])\r\n        {\r\n            particle.data[key].min = value;\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback that returns a stepped value between the\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}\r\n     * range.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#steppedEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    steppedEmit: function ()\r\n    {\r\n        var current = this.counter;\r\n\r\n        var next = this.counter + (this.end - this.start) / this.steps;\r\n\r\n        this.counter = Wrap(next, this.start, this.end);\r\n\r\n        return current;\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback for an eased property.\r\n     *\r\n     * It prepares the particle for easing by {@link Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#easedValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The name of the property.\r\n     *\r\n     * @return {number} {@link Phaser.GameObjects.Particles.EmitterOp#start}, as the new value of the property.\r\n     */\r\n    easedValueEmit: function (particle, key)\r\n    {\r\n        if (particle && particle.data[key])\r\n        {\r\n            var data = particle.data[key];\r\n\r\n            data.min = this.start;\r\n            data.max = this.end;\r\n        }\r\n\r\n        return this.start;\r\n    },\r\n\r\n    /**\r\n     * An `onUpdate` callback that returns an eased value between the\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}\r\n     * range.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The name of the property.\r\n     * @param {number} t - The T value (between 0 and 1)\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    easeValueUpdate: function (particle, key, t)\r\n    {\r\n        var data = particle.data[key];\r\n\r\n        return (data.max - data.min) * this.ease(t) + data.min;\r\n    }\r\n});\r\n\r\nmodule.exports = EmitterOp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * @classdesc\r\n * The GravityWell action applies a force on the particle to draw it towards, or repel it from, a single point.\r\n * \r\n * The force applied is inversely proportional to the square of the distance from the particle to the point, in accordance with Newton's law of gravity.\r\n * \r\n * This simulates the effect of gravity over large distances (as between planets, for example).\r\n *\r\n * @class GravityWell\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(number|Phaser.Types.GameObjects.Particles.GravityWellConfig)} [x=0] - The x coordinate of the Gravity Well, in world space.\r\n * @param {number} [y=0] - The y coordinate of the Gravity Well, in world space.\r\n * @param {number} [power=0] - The strength of the gravity force - larger numbers produce a stronger force.\r\n * @param {number} [epsilon=100] - The minimum distance for which the gravity force is calculated.\r\n * @param {number} [gravity=50] - The gravitational force of this Gravity Well.\r\n */\r\nvar GravityWell = new Class({\r\n\r\n    initialize:\r\n\r\n    function GravityWell (x, y, power, epsilon, gravity)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            var config = x;\r\n\r\n            x = GetFastValue(config, 'x', 0);\r\n            y = GetFastValue(config, 'y', 0);\r\n            power = GetFastValue(config, 'power', 0);\r\n            epsilon = GetFastValue(config, 'epsilon', 100);\r\n            gravity = GetFastValue(config, 'gravity', 50);\r\n        }\r\n        else\r\n        {\r\n            if (x === undefined) { x = 0; }\r\n            if (y === undefined) { y = 0; }\r\n            if (power === undefined) { power = 0; }\r\n            if (epsilon === undefined) { epsilon = 100; }\r\n            if (gravity === undefined) { gravity = 50; }\r\n        }\r\n\r\n        /**\r\n         * The x coordinate of the Gravity Well, in world space.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.x = x;\r\n\r\n        /**\r\n         * The y coordinate of the Gravity Well, in world space.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.y = y;\r\n\r\n        /**\r\n         * The active state of the Gravity Well. An inactive Gravity Well will not influence any particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * Internal gravity value.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#_gravity\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._gravity = gravity;\r\n\r\n        /**\r\n         * Internal power value.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#_power\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._power = 0;\r\n\r\n        /**\r\n         * Internal epsilon value.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#_epsilon\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._epsilon = 0;\r\n\r\n        /**\r\n         * The strength of the gravity force - larger numbers produce a stronger force.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#power\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.power = power;\r\n\r\n        /**\r\n         * The minimum distance for which the gravity force is calculated.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#epsilon\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.epsilon = epsilon;\r\n    },\r\n\r\n    /**\r\n     * Takes a Particle and updates it based on the properties of this Gravity Well.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.GravityWell#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle to update.\r\n     * @param {number} delta - The delta time in ms.\r\n     * @param {number} step - The delta value divided by 1000.\r\n     */\r\n    update: function (particle, delta)\r\n    {\r\n        var x = this.x - particle.x;\r\n        var y = this.y - particle.y;\r\n        var dSq = x * x + y * y;\r\n\r\n        if (dSq === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var d = Math.sqrt(dSq);\r\n\r\n        if (dSq < this._epsilon)\r\n        {\r\n            dSq = this._epsilon;\r\n        }\r\n\r\n        var factor = ((this._power * delta) / (dSq * d)) * 100;\r\n\r\n        particle.velocityX += x * factor;\r\n        particle.velocityY += y * factor;\r\n    },\r\n\r\n    epsilon: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.sqrt(this._epsilon);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._epsilon = value * value;\r\n        }\r\n\r\n    },\r\n\r\n    power: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._power / this._gravity;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._power = value * this._gravity;\r\n        }\r\n\r\n    },\r\n\r\n    gravity: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._gravity;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var pwr = this.power;\r\n            this._gravity = value;\r\n            this.power = pwr;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = GravityWell;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar DegToRad = require('../../math/DegToRad');\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\n\r\n/**\r\n * @classdesc\r\n * A Particle is a simple Game Object controlled by a Particle Emitter and Manager, and rendered by the Manager.\r\n * It uses its own lightweight physics system, and can interact only with its Emitter's bounds and zones.\r\n *\r\n * @class Particle\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Emitter to which this Particle belongs.\r\n */\r\nvar Particle = new Class({\r\n\r\n    initialize:\r\n\r\n    function Particle (emitter)\r\n    {\r\n        /**\r\n         * The Emitter to which this Particle belongs.\r\n         *\r\n         * A Particle can only belong to a single Emitter and is created, updated and destroyed via it.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#emitter\r\n         * @type {Phaser.GameObjects.Particles.ParticleEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.emitter = emitter;\r\n\r\n        /**\r\n         * The texture frame used to render this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.frame = null;\r\n\r\n        /**\r\n         * The x coordinate of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y coordinate of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        /**\r\n         * The x velocity of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#velocityX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.velocityX = 0;\r\n\r\n        /**\r\n         * The y velocity of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#velocityY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.velocityY = 0;\r\n\r\n        /**\r\n         * The x acceleration of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#accelerationX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.accelerationX = 0;\r\n\r\n        /**\r\n         * The y acceleration of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#accelerationY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.accelerationY = 0;\r\n\r\n        /**\r\n         * The maximum horizontal velocity this Particle can travel at.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#maxVelocityX\r\n         * @type {number}\r\n         * @default 10000\r\n         * @since 3.0.0\r\n         */\r\n        this.maxVelocityX = 10000;\r\n\r\n        /**\r\n         * The maximum vertical velocity this Particle can travel at.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#maxVelocityY\r\n         * @type {number}\r\n         * @default 10000\r\n         * @since 3.0.0\r\n         */\r\n        this.maxVelocityY = 10000;\r\n\r\n        /**\r\n         * The bounciness, or restitution, of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#bounce\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.bounce = 0;\r\n\r\n        /**\r\n         * The horizontal scale of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#scaleX\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.scaleX = 1;\r\n\r\n        /**\r\n         * The vertical scale of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#scaleY\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.scaleY = 1;\r\n\r\n        /**\r\n         * The alpha value of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#alpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.alpha = 1;\r\n\r\n        /**\r\n         * The angle of this Particle in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#angle\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angle = 0;\r\n\r\n        /**\r\n         * The angle of this Particle in radians.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#rotation\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.rotation = 0;\r\n\r\n        /**\r\n         * The tint applied to this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#tint\r\n         * @type {number}\r\n         * @webglOnly\r\n         * @since 3.0.0\r\n         */\r\n        this.tint = 0xffffff;\r\n\r\n        /**\r\n         * The lifespan of this Particle in ms.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#life\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         */\r\n        this.life = 1000;\r\n\r\n        /**\r\n         * The current life of this Particle in ms.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#lifeCurrent\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         */\r\n        this.lifeCurrent = 1000;\r\n\r\n        /**\r\n         * The delay applied to this Particle upon emission, in ms.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#delayCurrent\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.delayCurrent = 0;\r\n\r\n        /**\r\n         * The normalized lifespan T value, where 0 is the start and 1 is the end.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#lifeT\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.lifeT = 0;\r\n\r\n        /**\r\n         * The data used by the ease equation.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#data\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = {\r\n            tint: { min: 0xffffff, max: 0xffffff, current: 0xffffff },\r\n            alpha: { min: 1, max: 1 },\r\n            rotate: { min: 0, max: 0 },\r\n            scaleX: { min: 1, max: 1 },\r\n            scaleY: { min: 1, max: 1 }\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Checks to see if this Particle is alive and updating.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#isAlive\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if this Particle is alive and updating, otherwise `false`.\r\n     */\r\n    isAlive: function ()\r\n    {\r\n        return (this.lifeCurrent > 0);\r\n    },\r\n\r\n    /**\r\n     * Resets the position of this particle back to zero.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#resetPosition\r\n     * @since 3.16.0\r\n     */\r\n    resetPosition: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n    },\r\n\r\n    /**\r\n     * Starts this Particle from the given coordinates.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#fire\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to launch this Particle from.\r\n     * @param {number} y - The y coordinate to launch this Particle from.\r\n     */\r\n    fire: function (x, y)\r\n    {\r\n        var emitter = this.emitter;\r\n\r\n        this.frame = emitter.getFrame();\r\n\r\n        if (emitter.emitZone)\r\n        {\r\n            //  Updates particle.x and particle.y during this call\r\n            emitter.emitZone.getPoint(this);\r\n        }\r\n\r\n        if (x === undefined)\r\n        {\r\n            this.x += emitter.x.onEmit(this, 'x');\r\n        }\r\n        else\r\n        {\r\n            this.x += x;\r\n        }\r\n\r\n        if (y === undefined)\r\n        {\r\n            this.y += emitter.y.onEmit(this, 'y');\r\n        }\r\n        else\r\n        {\r\n            this.y += y;\r\n        }\r\n\r\n        this.life = emitter.lifespan.onEmit(this, 'lifespan');\r\n        this.lifeCurrent = this.life;\r\n        this.lifeT = 0;\r\n\r\n        var sx = emitter.speedX.onEmit(this, 'speedX');\r\n        var sy = (emitter.speedY) ? emitter.speedY.onEmit(this, 'speedY') : sx;\r\n\r\n        if (emitter.radial)\r\n        {\r\n            var rad = DegToRad(emitter.angle.onEmit(this, 'angle'));\r\n\r\n            this.velocityX = Math.cos(rad) * Math.abs(sx);\r\n            this.velocityY = Math.sin(rad) * Math.abs(sy);\r\n        }\r\n        else if (emitter.moveTo)\r\n        {\r\n            var mx = emitter.moveToX.onEmit(this, 'moveToX');\r\n            var my = (emitter.moveToY) ? emitter.moveToY.onEmit(this, 'moveToY') : mx;\r\n\r\n            var angle = Math.atan2(my - this.y, mx - this.x);\r\n\r\n            var speed = DistanceBetween(this.x, this.y, mx, my) / (this.life / 1000);\r\n\r\n            //  We know how many pixels we need to move, but how fast?\r\n            // var speed = this.distanceToXY(displayObject, x, y) / (maxTime / 1000);\r\n\r\n            this.velocityX = Math.cos(angle) * speed;\r\n            this.velocityY = Math.sin(angle) * speed;\r\n        }\r\n        else\r\n        {\r\n            this.velocityX = sx;\r\n            this.velocityY = sy;\r\n        }\r\n\r\n        if (emitter.acceleration)\r\n        {\r\n            this.accelerationX = emitter.accelerationX.onEmit(this, 'accelerationX');\r\n            this.accelerationY = emitter.accelerationY.onEmit(this, 'accelerationY');\r\n        }\r\n\r\n        this.maxVelocityX = emitter.maxVelocityX.onEmit(this, 'maxVelocityX');\r\n        this.maxVelocityY = emitter.maxVelocityY.onEmit(this, 'maxVelocityY');\r\n\r\n        this.delayCurrent = emitter.delay.onEmit(this, 'delay');\r\n\r\n        this.scaleX = emitter.scaleX.onEmit(this, 'scaleX');\r\n        this.scaleY = (emitter.scaleY) ? emitter.scaleY.onEmit(this, 'scaleY') : this.scaleX;\r\n\r\n        this.angle = emitter.rotate.onEmit(this, 'rotate');\r\n        this.rotation = DegToRad(this.angle);\r\n\r\n        this.bounce = emitter.bounce.onEmit(this, 'bounce');\r\n\r\n        this.alpha = emitter.alpha.onEmit(this, 'alpha');\r\n\r\n        this.tint = emitter.tint.onEmit(this, 'tint');\r\n    },\r\n\r\n    /**\r\n     * An internal method that calculates the velocity of the Particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#computeVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Emitter that is updating this Particle.\r\n     * @param {number} delta - The delta time in ms.\r\n     * @param {number} step - The delta value divided by 1000.\r\n     * @param {array} processors - Particle processors (gravity wells).\r\n     */\r\n    computeVelocity: function (emitter, delta, step, processors)\r\n    {\r\n        var vx = this.velocityX;\r\n        var vy = this.velocityY;\r\n\r\n        var ax = this.accelerationX;\r\n        var ay = this.accelerationY;\r\n\r\n        var mx = this.maxVelocityX;\r\n        var my = this.maxVelocityY;\r\n\r\n        vx += (emitter.gravityX * step);\r\n        vy += (emitter.gravityY * step);\r\n\r\n        if (ax)\r\n        {\r\n            vx += (ax * step);\r\n        }\r\n\r\n        if (ay)\r\n        {\r\n            vy += (ay * step);\r\n        }\r\n\r\n        if (vx > mx)\r\n        {\r\n            vx = mx;\r\n        }\r\n        else if (vx < -mx)\r\n        {\r\n            vx = -mx;\r\n        }\r\n\r\n        if (vy > my)\r\n        {\r\n            vy = my;\r\n        }\r\n        else if (vy < -my)\r\n        {\r\n            vy = -my;\r\n        }\r\n\r\n        this.velocityX = vx;\r\n        this.velocityY = vy;\r\n\r\n        //  Apply any additional processors\r\n        for (var i = 0; i < processors.length; i++)\r\n        {\r\n            processors[i].update(this, delta, step);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if this Particle is still within the bounds defined by the given Emitter.\r\n     *\r\n     * If not, and depending on the Emitter collision flags, the Particle may either stop or rebound.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#checkBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Emitter to check the bounds against.\r\n     */\r\n    checkBounds: function (emitter)\r\n    {\r\n        var bounds = emitter.bounds;\r\n        var bounce = -this.bounce;\r\n\r\n        if (this.x < bounds.x && emitter.collideLeft)\r\n        {\r\n            this.x = bounds.x;\r\n            this.velocityX *= bounce;\r\n        }\r\n        else if (this.x > bounds.right && emitter.collideRight)\r\n        {\r\n            this.x = bounds.right;\r\n            this.velocityX *= bounce;\r\n        }\r\n\r\n        if (this.y < bounds.y && emitter.collideTop)\r\n        {\r\n            this.y = bounds.y;\r\n            this.velocityY *= bounce;\r\n        }\r\n        else if (this.y > bounds.bottom && emitter.collideBottom)\r\n        {\r\n            this.y = bounds.bottom;\r\n            this.velocityY *= bounce;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The main update method for this Particle.\r\n     *\r\n     * Updates its life values, computes the velocity and repositions the Particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delta - The delta time in ms.\r\n     * @param {number} step - The delta value divided by 1000.\r\n     * @param {array} processors - An optional array of update processors.\r\n     *\r\n     * @return {boolean} Returns `true` if this Particle has now expired and should be removed, otherwise `false` if still active.\r\n     */\r\n    update: function (delta, step, processors)\r\n    {\r\n        if (this.delayCurrent > 0)\r\n        {\r\n            this.delayCurrent -= delta;\r\n\r\n            return false;\r\n        }\r\n\r\n        var emitter = this.emitter;\r\n\r\n        //  How far along in life is this particle? (t = 0 to 1)\r\n        var t = 1 - (this.lifeCurrent / this.life);\r\n\r\n        this.lifeT = t;\r\n\r\n        this.computeVelocity(emitter, delta, step, processors);\r\n\r\n        this.x += this.velocityX * step;\r\n        this.y += this.velocityY * step;\r\n\r\n        if (emitter.bounds)\r\n        {\r\n            this.checkBounds(emitter);\r\n        }\r\n\r\n        if (emitter.deathZone && emitter.deathZone.willKill(this))\r\n        {\r\n            this.lifeCurrent = 0;\r\n\r\n            //  No need to go any further, particle has been killed\r\n            return true;\r\n        }\r\n\r\n        this.scaleX = emitter.scaleX.onUpdate(this, 'scaleX', t, this.scaleX);\r\n\r\n        if (emitter.scaleY)\r\n        {\r\n            this.scaleY = emitter.scaleY.onUpdate(this, 'scaleY', t, this.scaleY);\r\n        }\r\n        else\r\n        {\r\n            this.scaleY = this.scaleX;\r\n        }\r\n\r\n        this.angle = emitter.rotate.onUpdate(this, 'rotate', t, this.angle);\r\n        this.rotation = DegToRad(this.angle);\r\n\r\n        this.alpha = emitter.alpha.onUpdate(this, 'alpha', t, this.alpha);\r\n\r\n        this.tint = emitter.tint.onUpdate(this, 'tint', t, this.tint);\r\n\r\n        this.lifeCurrent -= delta;\r\n\r\n        return (this.lifeCurrent <= 0);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Particle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../../renderer/BlendModes');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar DeathZone = require('./zones/DeathZone');\r\nvar EdgeZone = require('./zones/EdgeZone');\r\nvar EmitterOp = require('./EmitterOp');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetRandom = require('../../utils/array/GetRandom');\r\nvar HasAny = require('../../utils/object/HasAny');\r\nvar HasValue = require('../../utils/object/HasValue');\r\nvar Particle = require('./Particle');\r\nvar RandomZone = require('./zones/RandomZone');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar StableSort = require('../../utils/array/StableSort');\r\nvar Vector2 = require('../../math/Vector2');\r\nvar Wrap = require('../../math/Wrap');\r\n\r\n/**\r\n * @classdesc\r\n * A particle emitter represents a single particle stream.\r\n * It controls a pool of {@link Phaser.GameObjects.Particles.Particle Particles} and is controlled by a {@link Phaser.GameObjects.Particles.ParticleEmitterManager Particle Emitter Manager}.\r\n *\r\n * @class ParticleEmitter\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} manager - The Emitter Manager this Emitter belongs to.\r\n * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} config - Settings for this emitter.\r\n */\r\nvar ParticleEmitter = new Class({\r\n\r\n    Mixins: [\r\n        Components.BlendMode,\r\n        Components.Mask,\r\n        Components.ScrollFactor,\r\n        Components.Visible\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function ParticleEmitter (manager, config)\r\n    {\r\n        /**\r\n         * The Emitter Manager this Emitter belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#manager\r\n         * @type {Phaser.GameObjects.Particles.ParticleEmitterManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = manager;\r\n\r\n        /**\r\n         * The texture assigned to particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.0.0\r\n         */\r\n        this.texture = manager.texture;\r\n\r\n        /**\r\n         * The texture frames assigned to particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#frames\r\n         * @type {Phaser.Textures.Frame[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.frames = [ manager.defaultFrame ];\r\n\r\n        /**\r\n         * The default texture frame assigned to particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#defaultFrame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultFrame = manager.defaultFrame;\r\n\r\n        /**\r\n         * Names of simple configuration properties.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#configFastMap\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.configFastMap = [\r\n            'active',\r\n            'blendMode',\r\n            'collideBottom',\r\n            'collideLeft',\r\n            'collideRight',\r\n            'collideTop',\r\n            'deathCallback',\r\n            'deathCallbackScope',\r\n            'emitCallback',\r\n            'emitCallbackScope',\r\n            'follow',\r\n            'frequency',\r\n            'gravityX',\r\n            'gravityY',\r\n            'maxParticles',\r\n            'name',\r\n            'on',\r\n            'particleBringToTop',\r\n            'particleClass',\r\n            'radial',\r\n            'timeScale',\r\n            'trackVisible',\r\n            'visible'\r\n        ];\r\n\r\n        /**\r\n         * Names of complex configuration properties.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#configOpMap\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.configOpMap = [\r\n            'accelerationX',\r\n            'accelerationY',\r\n            'angle',\r\n            'alpha',\r\n            'bounce',\r\n            'delay',\r\n            'lifespan',\r\n            'maxVelocityX',\r\n            'maxVelocityY',\r\n            'moveToX',\r\n            'moveToY',\r\n            'quantity',\r\n            'rotate',\r\n            'scaleX',\r\n            'scaleY',\r\n            'speedX',\r\n            'speedY',\r\n            'tint',\r\n            'x',\r\n            'y'\r\n        ];\r\n\r\n        /**\r\n         * The name of this Particle Emitter.\r\n         *\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * The Particle Class which will be emitted by this Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#particleClass\r\n         * @type {Phaser.GameObjects.Particles.Particle}\r\n         * @default Phaser.GameObjects.Particles.Particle\r\n         * @since 3.0.0\r\n         */\r\n        this.particleClass = Particle;\r\n\r\n        /**\r\n         * The x-coordinate of the particle origin (where particles will be emitted).\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#x\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setPosition\r\n         */\r\n        this.x = new EmitterOp(config, 'x', 0, true);\r\n\r\n        /**\r\n         * The y-coordinate of the particle origin (where particles will be emitted).\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#y\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setPosition\r\n         */\r\n        this.y = new EmitterOp(config, 'y', 0, true);\r\n\r\n        /**\r\n         * A radial emitter will emit particles in all directions between angle min and max,\r\n         * using {@link Phaser.GameObjects.Particles.ParticleEmitter#speed} as the value. If set to false then this acts as a point Emitter.\r\n         * A point emitter will emit particles only in the direction derived from the speedX and speedY values.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#radial\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setRadial\r\n         */\r\n        this.radial = true;\r\n\r\n        /**\r\n         * Horizontal acceleration applied to emitted particles, in pixels per second squared.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#gravityX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setGravity\r\n         */\r\n        this.gravityX = 0;\r\n\r\n        /**\r\n         * Vertical acceleration applied to emitted particles, in pixels per second squared.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#gravityY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setGravity\r\n         */\r\n        this.gravityY = 0;\r\n\r\n        /**\r\n         * Whether accelerationX and accelerationY are non-zero. Set automatically during configuration.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#acceleration\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.acceleration = false;\r\n\r\n        /**\r\n         * Horizontal acceleration applied to emitted particles, in pixels per second squared.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#accelerationX\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.accelerationX = new EmitterOp(config, 'accelerationX', 0, true);\r\n\r\n        /**\r\n         * Vertical acceleration applied to emitted particles, in pixels per second squared.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#accelerationY\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.accelerationY = new EmitterOp(config, 'accelerationY', 0, true);\r\n\r\n        /**\r\n         * The maximum horizontal velocity of emitted particles, in pixels per second squared.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#maxVelocityX\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 10000\r\n         * @since 3.0.0\r\n         */\r\n        this.maxVelocityX = new EmitterOp(config, 'maxVelocityX', 10000, true);\r\n\r\n        /**\r\n         * The maximum vertical velocity of emitted particles, in pixels per second squared.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#maxVelocityY\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 10000\r\n         * @since 3.0.0\r\n         */\r\n        this.maxVelocityY = new EmitterOp(config, 'maxVelocityY', 10000, true);\r\n\r\n        /**\r\n         * The initial horizontal speed of emitted particles, in pixels per second.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#speedX\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setSpeedX\r\n         */\r\n        this.speedX = new EmitterOp(config, 'speedX', 0, true);\r\n\r\n        /**\r\n         * The initial vertical speed of emitted particles, in pixels per second.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#speedY\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setSpeedY\r\n         */\r\n        this.speedY = new EmitterOp(config, 'speedY', 0, true);\r\n\r\n        /**\r\n         * Whether moveToX and moveToY are nonzero. Set automatically during configuration.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#moveTo\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.moveTo = false;\r\n\r\n        /**\r\n         * The x-coordinate emitted particles move toward, when {@link Phaser.GameObjects.Particles.ParticleEmitter#moveTo} is true.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#moveToX\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.moveToX = new EmitterOp(config, 'moveToX', 0, true);\r\n\r\n        /**\r\n         * The y-coordinate emitted particles move toward, when {@link Phaser.GameObjects.Particles.ParticleEmitter#moveTo} is true.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#moveToY\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.moveToY = new EmitterOp(config, 'moveToY', 0, true);\r\n\r\n        /**\r\n         * Whether particles will rebound when they meet the emitter bounds.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#bounce\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.bounce = new EmitterOp(config, 'bounce', 0, true);\r\n\r\n        /**\r\n         * The horizontal scale of emitted particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#scaleX\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setScale\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setScaleX\r\n         */\r\n        this.scaleX = new EmitterOp(config, 'scaleX', 1);\r\n\r\n        /**\r\n         * The vertical scale of emitted particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#scaleY\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setScale\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setScaleY\r\n         */\r\n        this.scaleY = new EmitterOp(config, 'scaleY', 1);\r\n\r\n        /**\r\n         * Color tint applied to emitted particles. Value must not include the alpha channel.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#tint\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0xffffff\r\n         * @since 3.0.0\r\n         */\r\n        this.tint = new EmitterOp(config, 'tint', 0xffffff);\r\n\r\n        /**\r\n         * The alpha (transparency) of emitted particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#alpha\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setAlpha\r\n         */\r\n        this.alpha = new EmitterOp(config, 'alpha', 1);\r\n\r\n        /**\r\n         * The lifespan of emitted particles, in ms.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#lifespan\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setLifespan\r\n         */\r\n        this.lifespan = new EmitterOp(config, 'lifespan', 1000, true);\r\n\r\n        /**\r\n         * The angle of the initial velocity of emitted particles, in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#angle\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default { min: 0, max: 360 }\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setAngle\r\n         */\r\n        this.angle = new EmitterOp(config, 'angle', { min: 0, max: 360 }, true);\r\n\r\n        /**\r\n         * The rotation of emitted particles, in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#rotate\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.rotate = new EmitterOp(config, 'rotate', 0);\r\n\r\n        /**\r\n         * A function to call when a particle is emitted.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#emitCallback\r\n         * @type {?Phaser.Types.GameObjects.Particles.ParticleEmitterCallback}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.emitCallback = null;\r\n\r\n        /**\r\n         * The calling context for {@link Phaser.GameObjects.Particles.ParticleEmitter#emitCallback}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#emitCallbackScope\r\n         * @type {?*}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.emitCallbackScope = null;\r\n\r\n        /**\r\n         * A function to call when a particle dies.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#deathCallback\r\n         * @type {?Phaser.Types.GameObjects.Particles.ParticleDeathCallback}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.deathCallback = null;\r\n\r\n        /**\r\n         * The calling context for {@link Phaser.GameObjects.Particles.ParticleEmitter#deathCallback}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#deathCallbackScope\r\n         * @type {?*}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.deathCallbackScope = null;\r\n\r\n        /**\r\n         * Set to hard limit the amount of particle objects this emitter is allowed to create.\r\n         * 0 means unlimited.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#maxParticles\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.maxParticles = 0;\r\n\r\n        /**\r\n         * How many particles are emitted each time particles are emitted (one explosion or one flow cycle).\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#quantity\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrequency\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setQuantity\r\n         */\r\n        this.quantity = new EmitterOp(config, 'quantity', 1, true);\r\n\r\n        /**\r\n         * How many ms to wait after emission before the particles start updating.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#delay\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.delay = new EmitterOp(config, 'delay', 0, true);\r\n\r\n        /**\r\n         * For a flow emitter, the time interval (>= 0) between particle flow cycles in ms.\r\n         * A value of 0 means there is one particle flow cycle for each logic update (the maximum flow frequency). This is the default setting.\r\n         * For an exploding emitter, this value will be -1.\r\n         * Calling {@link Phaser.GameObjects.Particles.ParticleEmitter#flow} also puts the emitter in flow mode (frequency >= 0).\r\n         * Calling {@link Phaser.GameObjects.Particles.ParticleEmitter#explode} also puts the emitter in explode mode (frequency = -1).\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#frequency\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrequency\r\n         */\r\n        this.frequency = 0;\r\n\r\n        /**\r\n         * Controls if the emitter is currently emitting a particle flow (when frequency >= 0).\r\n         * Already alive particles will continue to update until they expire.\r\n         * Controlled by {@link Phaser.GameObjects.Particles.ParticleEmitter#start} and {@link Phaser.GameObjects.Particles.ParticleEmitter#stop}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#on\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.on = true;\r\n\r\n        /**\r\n         * Newly emitted particles are added to the top of the particle list, i.e. rendered above those already alive.\r\n         * Set to false to send them to the back.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#particleBringToTop\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.particleBringToTop = true;\r\n\r\n        /**\r\n         * The time rate applied to active particles, affecting lifespan, movement, and tweens. Values larger than 1 are faster than normal.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.timeScale = 1;\r\n\r\n        /**\r\n         * An object describing a shape to emit particles from.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#emitZone\r\n         * @type {?Phaser.GameObjects.Particles.Zones.EdgeZone|Phaser.GameObjects.Particles.Zones.RandomZone}\r\n         * @default null\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setEmitZone\r\n         */\r\n        this.emitZone = null;\r\n\r\n        /**\r\n         * An object describing a shape that deactivates particles when they interact with it.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#deathZone\r\n         * @type {?Phaser.GameObjects.Particles.Zones.DeathZone}\r\n         * @default null\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setDeathZone\r\n         */\r\n        this.deathZone = null;\r\n\r\n        /**\r\n         * A rectangular boundary constraining particle movement.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#bounds\r\n         * @type {?Phaser.Geom.Rectangle}\r\n         * @default null\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setBounds\r\n         */\r\n        this.bounds = null;\r\n\r\n        /**\r\n         * Whether particles interact with the left edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideLeft\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.collideLeft = true;\r\n\r\n        /**\r\n         * Whether particles interact with the right edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideRight\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.collideRight = true;\r\n\r\n        /**\r\n         * Whether particles interact with the top edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideTop\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.collideTop = true;\r\n\r\n        /**\r\n         * Whether particles interact with the bottom edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideBottom\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.collideBottom = true;\r\n\r\n        /**\r\n         * Whether this emitter updates itself and its particles.\r\n         *\r\n         * Controlled by {@link Phaser.GameObjects.Particles.ParticleEmitter#pause}\r\n         * and {@link Phaser.GameObjects.Particles.ParticleEmitter#resume}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * Set this to false to hide any active particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#visible\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setVisible\r\n         */\r\n        this.visible = true;\r\n\r\n        /**\r\n         * The blend mode of this emitter's particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#blendMode\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setBlendMode\r\n         */\r\n        this.blendMode = BlendModes.NORMAL;\r\n\r\n        /**\r\n         * A Game Object whose position is used as the particle origin.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#follow\r\n         * @type {?Phaser.GameObjects.GameObject}\r\n         * @default null\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#startFollow\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#stopFollow\r\n         */\r\n        this.follow = null;\r\n\r\n        /**\r\n         * The offset of the particle origin from the {@link Phaser.GameObjects.Particles.ParticleEmitter#follow} target.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#followOffset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#startFollow\r\n         */\r\n        this.followOffset = new Vector2();\r\n\r\n        /**\r\n         * Whether the emitter's {@link Phaser.GameObjects.Particles.ParticleEmitter#visible} state will track\r\n         * the {@link Phaser.GameObjects.Particles.ParticleEmitter#follow} target's visibility state.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#trackVisible\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#startFollow\r\n         */\r\n        this.trackVisible = false;\r\n\r\n        /**\r\n         * The current texture frame, as an index of {@link Phaser.GameObjects.Particles.ParticleEmitter#frames}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#currentFrame\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrame\r\n         */\r\n        this.currentFrame = 0;\r\n\r\n        /**\r\n         * Whether texture {@link Phaser.GameObjects.Particles.ParticleEmitter#frames} are selected at random.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#randomFrame\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrame\r\n         */\r\n        this.randomFrame = true;\r\n\r\n        /**\r\n         * The number of consecutive particles that receive a single texture frame (per frame cycle).\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#frameQuantity\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrame\r\n         */\r\n        this.frameQuantity = 1;\r\n\r\n        /**\r\n         * Inactive particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#dead\r\n         * @type {Phaser.GameObjects.Particles.Particle[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.dead = [];\r\n\r\n        /**\r\n         * Active particles\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#alive\r\n         * @type {Phaser.GameObjects.Particles.Particle[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.alive = [];\r\n\r\n        /**\r\n         * The time until the next flow cycle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#_counter\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._counter = 0;\r\n\r\n        /**\r\n         * Counts up to {@link Phaser.GameObjects.Particles.ParticleEmitter#frameQuantity}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#_frameCounter\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._frameCounter = 0;\r\n\r\n        if (config)\r\n        {\r\n            this.fromJSON(config);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Merges configuration settings into the emitter's current settings.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#fromJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} config - Settings for this emitter.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    fromJSON: function (config)\r\n    {\r\n        if (!config)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        //  Only update properties from their current state if they exist in the given config\r\n\r\n        var i = 0;\r\n        var key = '';\r\n\r\n        for (i = 0; i < this.configFastMap.length; i++)\r\n        {\r\n            key = this.configFastMap[i];\r\n\r\n            if (HasValue(config, key))\r\n            {\r\n                this[key] = GetFastValue(config, key);\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < this.configOpMap.length; i++)\r\n        {\r\n            key = this.configOpMap[i];\r\n\r\n            if (HasValue(config, key))\r\n            {\r\n                this[key].loadConfig(config);\r\n            }\r\n        }\r\n\r\n        this.acceleration = (this.accelerationX.propertyValue !== 0 || this.accelerationY.propertyValue !== 0);\r\n\r\n        this.moveTo = (this.moveToX.propertyValue !== 0 || this.moveToY.propertyValue !== 0);\r\n\r\n        //  Special 'speed' override\r\n\r\n        if (HasValue(config, 'speed'))\r\n        {\r\n            this.speedX.loadConfig(config, 'speed');\r\n            this.speedY = null;\r\n        }\r\n\r\n        //  If you specify speedX, speedY or moveTo then it changes the emitter from radial to a point emitter\r\n        if (HasAny(config, [ 'speedX', 'speedY' ]) || this.moveTo)\r\n        {\r\n            this.radial = false;\r\n        }\r\n\r\n        //  Special 'scale' override\r\n\r\n        if (HasValue(config, 'scale'))\r\n        {\r\n            this.scaleX.loadConfig(config, 'scale');\r\n            this.scaleY = null;\r\n        }\r\n\r\n        if (HasValue(config, 'callbackScope'))\r\n        {\r\n            var callbackScope = GetFastValue(config, 'callbackScope', null);\r\n\r\n            this.emitCallbackScope = callbackScope;\r\n            this.deathCallbackScope = callbackScope;\r\n        }\r\n\r\n        if (HasValue(config, 'emitZone'))\r\n        {\r\n            this.setEmitZone(config.emitZone);\r\n        }\r\n\r\n        if (HasValue(config, 'deathZone'))\r\n        {\r\n            this.setDeathZone(config.deathZone);\r\n        }\r\n\r\n        if (HasValue(config, 'bounds'))\r\n        {\r\n            this.setBounds(config.bounds);\r\n        }\r\n\r\n        if (HasValue(config, 'followOffset'))\r\n        {\r\n            this.followOffset.setFromObject(GetFastValue(config, 'followOffset', 0));\r\n        }\r\n\r\n        if (HasValue(config, 'frame'))\r\n        {\r\n            this.setFrame(config.frame);\r\n        }\r\n\r\n        if (HasValue(config, 'reserve'))\r\n        {\r\n            this.reserve(config.reserve);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a description of this emitter suitable for JSON serialization.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [output] - An object to copy output into.\r\n     *\r\n     * @return {object} - The output object.\r\n     */\r\n    toJSON: function (output)\r\n    {\r\n        if (output === undefined) { output = {}; }\r\n\r\n        var i = 0;\r\n        var key = '';\r\n\r\n        for (i = 0; i < this.configFastMap.length; i++)\r\n        {\r\n            key = this.configFastMap[i];\r\n\r\n            output[key] = this[key];\r\n        }\r\n\r\n        for (i = 0; i < this.configOpMap.length; i++)\r\n        {\r\n            key = this.configOpMap[i];\r\n\r\n            if (this[key])\r\n            {\r\n                output[key] = this[key].toJSON();\r\n            }\r\n        }\r\n\r\n        //  special handlers\r\n        if (!this.speedY)\r\n        {\r\n            delete output.speedX;\r\n            output.speed = this.speedX.toJSON();\r\n        }\r\n\r\n        if (!this.scaleY)\r\n        {\r\n            delete output.scaleX;\r\n            output.scale = this.scaleX.toJSON();\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Continuously moves the particle origin to follow a Game Object's position.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#startFollow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} target - The Game Object to follow.\r\n     * @param {number} [offsetX=0] - Horizontal offset of the particle origin from the Game Object.\r\n     * @param {number} [offsetY=0] - Vertical offset of the particle origin from the Game Object.\r\n     * @param {boolean} [trackVisible=false] - Whether the emitter's visible state will track the target's visible state.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    startFollow: function (target, offsetX, offsetY, trackVisible)\r\n    {\r\n        if (offsetX === undefined) { offsetX = 0; }\r\n        if (offsetY === undefined) { offsetY = 0; }\r\n        if (trackVisible === undefined) { trackVisible = false; }\r\n\r\n        this.follow = target;\r\n        this.followOffset.set(offsetX, offsetY);\r\n        this.trackVisible = trackVisible;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stops following a Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#stopFollow\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    stopFollow: function ()\r\n    {\r\n        this.follow = null;\r\n        this.followOffset.set(0, 0);\r\n        this.trackVisible = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Chooses a texture frame from {@link Phaser.GameObjects.Particles.ParticleEmitter#frames}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#getFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Textures.Frame} The texture frame.\r\n     */\r\n    getFrame: function ()\r\n    {\r\n        if (this.frames.length === 1)\r\n        {\r\n            return this.defaultFrame;\r\n        }\r\n        else if (this.randomFrame)\r\n        {\r\n            return GetRandom(this.frames);\r\n        }\r\n        else\r\n        {\r\n            var frame = this.frames[this.currentFrame];\r\n\r\n            this._frameCounter++;\r\n\r\n            if (this._frameCounter === this.frameQuantity)\r\n            {\r\n                this._frameCounter = 0;\r\n                this.currentFrame = Wrap(this.currentFrame + 1, 0, this._frameLength);\r\n            }\r\n\r\n            return frame;\r\n        }\r\n    },\r\n\r\n    // frame: 0\r\n    // frame: 'red'\r\n    // frame: [ 0, 1, 2, 3 ]\r\n    // frame: [ 'red', 'green', 'blue', 'pink', 'white' ]\r\n    // frame: { frames: [ 'red', 'green', 'blue', 'pink', 'white' ], [cycle: bool], [quantity: int] }\r\n\r\n    /**\r\n     * Sets a pattern for assigning texture frames to emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(array|string|number|Phaser.Types.GameObjects.Particles.ParticleEmitterFrameConfig)} frames - One or more texture frames, or a configuration object.\r\n     * @param {boolean} [pickRandom=true] - Whether frames should be assigned at random from `frames`.\r\n     * @param {number} [quantity=1] - The number of consecutive particles that will receive each frame.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setFrame: function (frames, pickRandom, quantity)\r\n    {\r\n        if (pickRandom === undefined) { pickRandom = true; }\r\n        if (quantity === undefined) { quantity = 1; }\r\n\r\n        this.randomFrame = pickRandom;\r\n        this.frameQuantity = quantity;\r\n        this.currentFrame = 0;\r\n        this._frameCounter = 0;\r\n\r\n        var t = typeof (frames);\r\n\r\n        if (Array.isArray(frames) || t === 'string' || t === 'number')\r\n        {\r\n            this.manager.setEmitterFrames(frames, this);\r\n        }\r\n        else if (t === 'object')\r\n        {\r\n            var frameConfig = frames;\r\n\r\n            frames = GetFastValue(frameConfig, 'frames', null);\r\n\r\n            if (frames)\r\n            {\r\n                this.manager.setEmitterFrames(frames, this);\r\n            }\r\n\r\n            var isCycle = GetFastValue(frameConfig, 'cycle', false);\r\n\r\n            this.randomFrame = (isCycle) ? false : true;\r\n\r\n            this.frameQuantity = GetFastValue(frameConfig, 'quantity', quantity);\r\n        }\r\n\r\n        this._frameLength = this.frames.length;\r\n\r\n        if (this._frameLength === 1)\r\n        {\r\n            this.frameQuantity = 1;\r\n            this.randomFrame = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle movement on or off.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setRadial\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - Radial mode (true) or point mode (true).\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setRadial: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.radial = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the position of the emitter's particle origin.\r\n     * New particles will be emitted here.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} x - The x-coordinate of the particle origin.\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} y - The y-coordinate of the particle origin.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setPosition: function (x, y)\r\n    {\r\n        this.x.onChange(x);\r\n        this.y.onChange(y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets or modifies a rectangular boundary constraining the particles.\r\n     *\r\n     * To remove the boundary, set {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds} to null.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Types.GameObjects.Particles.ParticleEmitterBounds|Phaser.Types.GameObjects.Particles.ParticleEmitterBoundsAlt)} x - The x-coordinate of the left edge of the boundary, or an object representing a rectangle.\r\n     * @param {number} y - The y-coordinate of the top edge of the boundary.\r\n     * @param {number} width - The width of the boundary.\r\n     * @param {number} height - The height of the boundary.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setBounds: function (x, y, width, height)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            var obj = x;\r\n\r\n            x = obj.x;\r\n            y = obj.y;\r\n            width = (HasValue(obj, 'w')) ? obj.w : obj.width;\r\n            height = (HasValue(obj, 'h')) ? obj.h : obj.height;\r\n        }\r\n\r\n        if (this.bounds)\r\n        {\r\n            this.bounds.setTo(x, y, width, height);\r\n        }\r\n        else\r\n        {\r\n            this.bounds = new Rectangle(x, y, width, height);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the initial horizontal speed of emitted particles.\r\n     * Changes the emitter to point mode.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setSpeedX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The speed, in pixels per second.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setSpeedX: function (value)\r\n    {\r\n        this.speedX.onChange(value);\r\n\r\n        //  If you specify speedX and Y then it changes the emitter from radial to a point emitter\r\n        this.radial = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the initial vertical speed of emitted particles.\r\n     * Changes the emitter to point mode.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setSpeedY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The speed, in pixels per second.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setSpeedY: function (value)\r\n    {\r\n        if (this.speedY)\r\n        {\r\n            this.speedY.onChange(value);\r\n\r\n            //  If you specify speedX and Y then it changes the emitter from radial to a point emitter\r\n            this.radial = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the initial radial speed of emitted particles.\r\n     * Changes the emitter to radial mode.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setSpeed\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The speed, in pixels per second.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setSpeed: function (value)\r\n    {\r\n        this.speedX.onChange(value);\r\n        this.speedY = null;\r\n\r\n        //  If you specify speedX and Y then it changes the emitter from radial to a point emitter\r\n        this.radial = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal scale of emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setScaleX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - The scale, relative to 1.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setScaleX: function (value)\r\n    {\r\n        this.scaleX.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical scale of emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setScaleY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - The scale, relative to 1.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setScaleY: function (value)\r\n    {\r\n        this.scaleY.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scale of emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - The scale, relative to 1.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setScale: function (value)\r\n    {\r\n        this.scaleX.onChange(value);\r\n        this.scaleY = null;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal gravity applied to emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setGravityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - Acceleration due to gravity, in pixels per second squared.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setGravityX: function (value)\r\n    {\r\n        this.gravityX = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical gravity applied to emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setGravityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - Acceleration due to gravity, in pixels per second squared.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setGravityY: function (value)\r\n    {\r\n        this.gravityY = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the gravity applied to emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - Horizontal acceleration due to gravity, in pixels per second squared.\r\n     * @param {number} y - Vertical acceleration due to gravity, in pixels per second squared.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setGravity: function (x, y)\r\n    {\r\n        this.gravityX = x;\r\n        this.gravityY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the opacity of emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - A value between 0 (transparent) and 1 (opaque).\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setAlpha: function (value)\r\n    {\r\n        this.alpha.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the color tint of emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setTint\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - A value between 0 and 0xffffff.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setTint: function (value)\r\n    {\r\n        this.tint.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angle of a {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle stream.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setEmitterAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The angle of the initial velocity of emitted particles.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setEmitterAngle: function (value)\r\n    {\r\n        this.angle.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angle of a {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle stream.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The angle of the initial velocity of emitted particles.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setAngle: function (value)\r\n    {\r\n        this.angle.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the lifespan of newly emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setLifespan\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The particle lifespan, in ms.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setLifespan: function (value)\r\n    {\r\n        this.lifespan.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the number of particles released at each flow cycle or explosion.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setQuantity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} quantity - The number of particles to release at each flow cycle or explosion.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setQuantity: function (quantity)\r\n    {\r\n        this.quantity.onChange(quantity);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the emitter's {@link Phaser.GameObjects.Particles.ParticleEmitter#frequency}\r\n     * and {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setFrequency\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} frequency - The time interval (>= 0) of each flow cycle, in ms; or -1 to put the emitter in explosion mode.\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} [quantity] - The number of particles to release at each flow cycle or explosion.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setFrequency: function (frequency, quantity)\r\n    {\r\n        this.frequency = frequency;\r\n\r\n        this._counter = 0;\r\n\r\n        if (quantity)\r\n        {\r\n            this.quantity.onChange(quantity);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets or removes the {@link Phaser.GameObjects.Particles.ParticleEmitter#emitZone}.\r\n     *\r\n     * An {@link Phaser.Types.GameObjects.Particles.ParticleEmitterEdgeZoneConfig EdgeZone} places particles on its edges. Its {@link Phaser.Types.GameObjects.Particles.EdgeZoneSource source} can be a Curve, Path, Circle, Ellipse, Line, Polygon, Rectangle, or Triangle; or any object with a suitable {@link Phaser.Types.GameObjects.Particles.EdgeZoneSourceCallback getPoints} method.\r\n     *\r\n     * A {@link Phaser.Types.GameObjects.Particles.ParticleEmitterRandomZoneConfig RandomZone} places randomly within its interior. Its {@link RandomZoneSource source} can be a Circle, Ellipse, Line, Polygon, Rectangle, or Triangle; or any object with a suitable {@link Phaser.Types.GameObjects.Particles.RandomZoneSourceCallback getRandomPoint} method.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setEmitZone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterEdgeZoneConfig|Phaser.Types.GameObjects.Particles.ParticleEmitterRandomZoneConfig} [zoneConfig] - An object describing the zone, or `undefined` to remove any current emit zone.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setEmitZone: function (zoneConfig)\r\n    {\r\n        if (zoneConfig === undefined)\r\n        {\r\n            this.emitZone = null;\r\n        }\r\n        else\r\n        {\r\n            //  Where source = Geom like Circle, or a Path or Curve\r\n            //  emitZone: { type: 'random', source: X }\r\n            //  emitZone: { type: 'edge', source: X, quantity: 32, [stepRate=0], [yoyo=false], [seamless=true] }\r\n\r\n            var type = GetFastValue(zoneConfig, 'type', 'random');\r\n            var source = GetFastValue(zoneConfig, 'source', null);\r\n\r\n            switch (type)\r\n            {\r\n                case 'random':\r\n\r\n                    this.emitZone = new RandomZone(source);\r\n\r\n                    break;\r\n\r\n                case 'edge':\r\n\r\n                    var quantity = GetFastValue(zoneConfig, 'quantity', 1);\r\n                    var stepRate = GetFastValue(zoneConfig, 'stepRate', 0);\r\n                    var yoyo = GetFastValue(zoneConfig, 'yoyo', false);\r\n                    var seamless = GetFastValue(zoneConfig, 'seamless', true);\r\n\r\n                    this.emitZone = new EdgeZone(source, quantity, stepRate, yoyo, seamless);\r\n\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets or removes the {@link Phaser.GameObjects.Particles.ParticleEmitter#deathZone}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setDeathZone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterDeathZoneConfig} [zoneConfig] - An object describing the zone, or `undefined` to remove any current death zone.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setDeathZone: function (zoneConfig)\r\n    {\r\n        if (zoneConfig === undefined)\r\n        {\r\n            this.deathZone = null;\r\n        }\r\n        else\r\n        {\r\n            //  Where source = Geom like Circle or Rect that supports a 'contains' function\r\n            //  deathZone: { type: 'onEnter', source: X }\r\n            //  deathZone: { type: 'onLeave', source: X }\r\n\r\n            var type = GetFastValue(zoneConfig, 'type', 'onEnter');\r\n            var source = GetFastValue(zoneConfig, 'source', null);\r\n\r\n            if (source && typeof source.contains === 'function')\r\n            {\r\n                var killOnEnter = (type === 'onEnter') ? true : false;\r\n\r\n                this.deathZone = new DeathZone(source, killOnEnter);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates inactive particles and adds them to this emitter's pool.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#reserve\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} particleCount - The number of particles to create.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    reserve: function (particleCount)\r\n    {\r\n        var dead = this.dead;\r\n\r\n        for (var i = 0; i < particleCount; i++)\r\n        {\r\n            dead.push(new this.particleClass(this));\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the number of active (in-use) particles in this emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#getAliveParticleCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The number of particles with `active=true`.\r\n     */\r\n    getAliveParticleCount: function ()\r\n    {\r\n        return this.alive.length;\r\n    },\r\n\r\n    /**\r\n     * Gets the number of inactive (available) particles in this emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#getDeadParticleCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The number of particles with `active=false`.\r\n     */\r\n    getDeadParticleCount: function ()\r\n    {\r\n        return this.dead.length;\r\n    },\r\n\r\n    /**\r\n     * Gets the total number of particles in this emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#getParticleCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The number of particles, including both alive and dead.\r\n     */\r\n    getParticleCount: function ()\r\n    {\r\n        return this.getAliveParticleCount() + this.getDeadParticleCount();\r\n    },\r\n\r\n    /**\r\n     * Whether this emitter is at its limit (if set).\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#atLimit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Returns `true` if this Emitter is at its limit, or `false` if no limit, or below the `maxParticles` level.\r\n     */\r\n    atLimit: function ()\r\n    {\r\n        return (this.maxParticles > 0 && this.getParticleCount() === this.maxParticles);\r\n    },\r\n\r\n    /**\r\n     * Sets a function to call for each newly emitted particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#onParticleEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterCallback} callback - The function.\r\n     * @param {*} [context] - The calling context.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    onParticleEmit: function (callback, context)\r\n    {\r\n        if (callback === undefined)\r\n        {\r\n            //  Clear any previously set callback\r\n            this.emitCallback = null;\r\n            this.emitCallbackScope = null;\r\n        }\r\n        else if (typeof callback === 'function')\r\n        {\r\n            this.emitCallback = callback;\r\n\r\n            if (context)\r\n            {\r\n                this.emitCallbackScope = context;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a function to call for each particle death.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#onParticleDeath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleDeathCallback} callback - The function.\r\n     * @param {*} [context] - The function's calling context.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    onParticleDeath: function (callback, context)\r\n    {\r\n        if (callback === undefined)\r\n        {\r\n            //  Clear any previously set callback\r\n            this.deathCallback = null;\r\n            this.deathCallbackScope = null;\r\n        }\r\n        else if (typeof callback === 'function')\r\n        {\r\n            this.deathCallback = callback;\r\n\r\n            if (context)\r\n            {\r\n                this.deathCallbackScope = context;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deactivates every particle in this emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#killAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    killAll: function ()\r\n    {\r\n        var dead = this.dead;\r\n        var alive = this.alive;\r\n\r\n        while (alive.length > 0)\r\n        {\r\n            dead.push(alive.pop());\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calls a function for each active particle in this emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#forEachAlive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterCallback} callback - The function.\r\n     * @param {*} context - The function's calling context.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    forEachAlive: function (callback, context)\r\n    {\r\n        var alive = this.alive;\r\n        var length = alive.length;\r\n\r\n        for (var index = 0; index < length; ++index)\r\n        {\r\n            //  Sends the Particle and the Emitter\r\n            callback.call(context, alive[index], this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calls a function for each inactive particle in this emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#forEachDead\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterCallback} callback - The function.\r\n     * @param {*} context - The function's calling context.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    forEachDead: function (callback, context)\r\n    {\r\n        var dead = this.dead;\r\n        var length = dead.length;\r\n\r\n        for (var index = 0; index < length; ++index)\r\n        {\r\n            //  Sends the Particle and the Emitter\r\n            callback.call(context, dead[index], this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#on} the emitter and resets the flow counter.\r\n     *\r\n     * If this emitter is in flow mode (frequency >= 0; the default), the particle flow will start (or restart).\r\n     *\r\n     * If this emitter is in explode mode (frequency = -1), nothing will happen.\r\n     * Use {@link Phaser.GameObjects.Particles.ParticleEmitter#explode} or {@link Phaser.GameObjects.Particles.ParticleEmitter#flow} instead.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#start\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    start: function ()\r\n    {\r\n        this.on = true;\r\n\r\n        this._counter = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#on off} the emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#stop\r\n     * @since 3.11.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    stop: function ()\r\n    {\r\n        this.on = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * {@link Phaser.GameObjects.Particles.ParticleEmitter#active Deactivates} the emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    pause: function ()\r\n    {\r\n        this.active = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * {@link Phaser.GameObjects.Particles.ParticleEmitter#active Activates} the emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    resume: function ()\r\n    {\r\n        this.active = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the emitter from its manager and the scene.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#remove\r\n     * @since 3.22.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    remove: function ()\r\n    {\r\n        this.manager.removeEmitter(this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sorts active particles with {@link Phaser.GameObjects.Particles.ParticleEmitter#depthSortCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#depthSort\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    depthSort: function ()\r\n    {\r\n        StableSort(this.alive, this.depthSortCallback);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Puts the emitter in flow mode (frequency >= 0) and starts (or restarts) a particle flow.\r\n     *\r\n     * To resume a flow at the current frequency and quantity, use {@link Phaser.GameObjects.Particles.ParticleEmitter#start} instead.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#flow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} frequency - The time interval (>= 0) of each flow cycle, in ms.\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} [count=1] - The number of particles to emit at each flow cycle.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    flow: function (frequency, count)\r\n    {\r\n        if (count === undefined) { count = 1; }\r\n\r\n        this.frequency = frequency;\r\n\r\n        this.quantity.onChange(count);\r\n\r\n        return this.start();\r\n    },\r\n\r\n    /**\r\n     * Puts the emitter in explode mode (frequency = -1), stopping any current particle flow, and emits several particles all at once.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#explode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} count - The amount of Particles to emit.\r\n     * @param {number} x - The x coordinate to emit the Particles from.\r\n     * @param {number} y - The y coordinate to emit the Particles from.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Particle} The most recently emitted Particle.\r\n     */\r\n    explode: function (count, x, y)\r\n    {\r\n        this.frequency = -1;\r\n\r\n        return this.emitParticle(count, x, y);\r\n    },\r\n\r\n    /**\r\n     * Emits particles at a given position (or the emitter's current position).\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#emitParticleAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=this.x] - The x coordinate to emit the Particles from.\r\n     * @param {number} [y=this.x] - The y coordinate to emit the Particles from.\r\n     * @param {number} [count=this.quantity] - The number of Particles to emit.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Particle} The most recently emitted Particle.\r\n     */\r\n    emitParticleAt: function (x, y, count)\r\n    {\r\n        return this.emitParticle(count, x, y);\r\n    },\r\n\r\n    /**\r\n     * Emits particles at a given position (or the emitter's current position).\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#emitParticle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [count=this.quantity] - The number of Particles to emit.\r\n     * @param {number} [x=this.x] - The x coordinate to emit the Particles from.\r\n     * @param {number} [y=this.x] - The y coordinate to emit the Particles from.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Particle} The most recently emitted Particle.\r\n     *\r\n     * @see Phaser.GameObjects.Particles.Particle#fire\r\n     */\r\n    emitParticle: function (count, x, y)\r\n    {\r\n        if (this.atLimit())\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (count === undefined)\r\n        {\r\n            count = this.quantity.onEmit();\r\n        }\r\n\r\n        var dead = this.dead;\r\n\r\n        var followX = (this.follow) ? this.follow.x + this.followOffset.x : x;\r\n        var followY = (this.follow) ? this.follow.y + this.followOffset.y : y;\r\n\r\n        for (var i = 0; i < count; i++)\r\n        {\r\n            var particle = dead.pop();\r\n\r\n            if (!particle)\r\n            {\r\n                particle = new this.particleClass(this);\r\n            }\r\n\r\n            particle.fire(followX, followY);\r\n\r\n            if (this.particleBringToTop)\r\n            {\r\n                this.alive.push(particle);\r\n            }\r\n            else\r\n            {\r\n                this.alive.unshift(particle);\r\n            }\r\n\r\n            if (this.emitCallback)\r\n            {\r\n                this.emitCallback.call(this.emitCallbackScope, particle, this);\r\n            }\r\n\r\n            if (this.atLimit())\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return particle;\r\n    },\r\n\r\n    /**\r\n     * Updates this emitter and its particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    preUpdate: function (time, delta)\r\n    {\r\n        //  Scale the delta\r\n        delta *= this.timeScale;\r\n\r\n        var step = (delta / 1000);\r\n\r\n        if (this.trackVisible)\r\n        {\r\n            this.visible = this.follow.visible;\r\n        }\r\n\r\n        //  Any particle processors?\r\n        var processors = this.manager.getProcessors();\r\n\r\n        var particles = this.alive;\r\n        var dead = this.dead;\r\n\r\n        var i = 0;\r\n        var rip = [];\r\n        var length = particles.length;\r\n\r\n        for (i = 0; i < length; i++)\r\n        {\r\n            var particle = particles[i];\r\n\r\n            //  update returns `true` if the particle is now dead (lifeCurrent <= 0)\r\n            if (particle.update(delta, step, processors))\r\n            {\r\n                rip.push({ index: i, particle: particle });\r\n            }\r\n        }\r\n\r\n        //  Move dead particles to the dead array\r\n        length = rip.length;\r\n\r\n        if (length > 0)\r\n        {\r\n            var deathCallback = this.deathCallback;\r\n            var deathCallbackScope = this.deathCallbackScope;\r\n\r\n            for (i = length - 1; i >= 0; i--)\r\n            {\r\n                var entry = rip[i];\r\n\r\n                //  Remove from particles array\r\n                particles.splice(entry.index, 1);\r\n\r\n                //  Add to dead array\r\n                dead.push(entry.particle);\r\n\r\n                //  Callback\r\n                if (deathCallback)\r\n                {\r\n                    deathCallback.call(deathCallbackScope, entry.particle);\r\n                }\r\n\r\n                entry.particle.resetPosition();\r\n            }\r\n        }\r\n\r\n        if (!this.on)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (this.frequency === 0)\r\n        {\r\n            this.emitParticle();\r\n        }\r\n        else if (this.frequency > 0)\r\n        {\r\n            this._counter -= delta;\r\n\r\n            if (this._counter <= 0)\r\n            {\r\n                this.emitParticle();\r\n\r\n                //  counter = frequency - remained from previous delta\r\n                this._counter = (this.frequency - Math.abs(this._counter));\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Calculates the difference of two particles, for sorting them by depth.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#depthSortCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} a - The first particle.\r\n     * @param {object} b - The second particle.\r\n     *\r\n     * @return {number} The difference of a and b's y coordinates.\r\n     */\r\n    depthSortCallback: function (a, b)\r\n    {\r\n        return a.y - b.y;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ParticleEmitter;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A Death Zone.\r\n *\r\n * A Death Zone is a special type of zone that will kill a Particle as soon as it either enters, or leaves, the zone.\r\n *\r\n * The zone consists of a `source` which could be a Geometric shape, such as a Rectangle or Ellipse, or your own\r\n * object as long as it includes a `contains` method for which the Particles can be tested against.\r\n *\r\n * @class DeathZone\r\n * @memberof Phaser.GameObjects.Particles.Zones\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Particles.DeathZoneSource} source - An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.\r\n * @param {boolean} killOnEnter - Should the Particle be killed when it enters the zone? `true` or leaves it? `false`\r\n */\r\nvar DeathZone = new Class({\r\n\r\n    initialize:\r\n\r\n    function DeathZone (source, killOnEnter)\r\n    {\r\n        /**\r\n         * An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.\r\n         * This could be a Geometry shape, such as `Phaser.Geom.Circle`, or your own custom object.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.DeathZone#source\r\n         * @type {Phaser.Types.GameObjects.Particles.DeathZoneSource}\r\n         * @since 3.0.0\r\n         */\r\n        this.source = source;\r\n\r\n        /**\r\n         * Set to `true` if the Particle should be killed if it enters this zone.\r\n         * Set to `false` to kill the Particle if it leaves this zone.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.DeathZone#killOnEnter\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.killOnEnter = killOnEnter;\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Particle will be killed or not by this zone.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.DeathZone#willKill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle to be checked against this zone.\r\n     *\r\n     * @return {boolean} Return `true` if the Particle is to be killed, otherwise return `false`.\r\n     */\r\n    willKill: function (particle)\r\n    {\r\n        var withinZone = this.source.contains(particle.x, particle.y);\r\n\r\n        return (withinZone && this.killOnEnter || !withinZone && !this.killOnEnter);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = DeathZone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A zone that places particles on a shape's edges.\r\n *\r\n * @class EdgeZone\r\n * @memberof Phaser.GameObjects.Particles.Zones\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Particles.EdgeZoneSource} source - An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n * @param {number} quantity - The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.\r\n * @param {number} stepRate - The distance between each particle. When set, `quantity` is implied and should be set to 0.\r\n * @param {boolean} [yoyo=false] - Whether particles are placed from start to end and then end to start.\r\n * @param {boolean} [seamless=true] - Whether one endpoint will be removed if it's identical to the other.\r\n */\r\nvar EdgeZone = new Class({\r\n\r\n    initialize:\r\n\r\n    function EdgeZone (source, quantity, stepRate, yoyo, seamless)\r\n    {\r\n        if (yoyo === undefined) { yoyo = false; }\r\n        if (seamless === undefined) { seamless = true; }\r\n\r\n        /**\r\n         * An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#source\r\n         * @type {Phaser.Types.GameObjects.Particles.EdgeZoneSource|Phaser.Types.GameObjects.Particles.RandomZoneSource}\r\n         * @since 3.0.0\r\n         */\r\n        this.source = source;\r\n\r\n        /**\r\n         * The points placed on the source edge.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#points\r\n         * @type {Phaser.Geom.Point[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.points = [];\r\n\r\n        /**\r\n         * The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#quantity\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.quantity = quantity;\r\n\r\n        /**\r\n         * The distance between each particle. When set, `quantity` is implied and should be set to 0.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#stepRate\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.stepRate = stepRate;\r\n\r\n        /**\r\n         * Whether particles are placed from start to end and then end to start.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#yoyo\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.yoyo = yoyo;\r\n\r\n        /**\r\n         * The counter used for iterating the EdgeZone's points.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#counter\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.counter = -1;\r\n\r\n        /**\r\n         * Whether one endpoint will be removed if it's identical to the other.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#seamless\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.seamless = seamless;\r\n\r\n        /**\r\n         * An internal count of the points belonging to this EdgeZone.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_length\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._length = 0;\r\n\r\n        /**\r\n         * An internal value used to keep track of the current iteration direction for the EdgeZone's points.\r\n         *\r\n         * 0 = forwards, 1 = backwards\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_direction\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._direction = 0;\r\n\r\n        this.updateSource();\r\n    },\r\n\r\n    /**\r\n     * Update the {@link Phaser.GameObjects.Particles.Zones.EdgeZone#points} from the EdgeZone's\r\n     * {@link Phaser.GameObjects.Particles.Zones.EdgeZone#source}.\r\n     *\r\n     * Also updates internal properties.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#updateSource\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Edge Zone.\r\n     */\r\n    updateSource: function ()\r\n    {\r\n        this.points = this.source.getPoints(this.quantity, this.stepRate);\r\n\r\n        //  Remove ends?\r\n        if (this.seamless)\r\n        {\r\n            var a = this.points[0];\r\n            var b = this.points[this.points.length - 1];\r\n\r\n            if (a.x === b.x && a.y === b.y)\r\n            {\r\n                this.points.pop();\r\n            }\r\n        }\r\n\r\n        var oldLength = this._length;\r\n\r\n        this._length = this.points.length;\r\n\r\n        //  Adjust counter if we now have less points than before\r\n        if (this._length < oldLength && this.counter > this._length)\r\n        {\r\n            this.counter = this._length - 1;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Change the source of the EdgeZone.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#changeSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EdgeZoneSource} source - An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n     *\r\n     * @return {this} This Edge Zone.\r\n     */\r\n    changeSource: function (source)\r\n    {\r\n        this.source = source;\r\n\r\n        return this.updateSource();\r\n    },\r\n\r\n    /**\r\n     * Get the next point in the Zone and set its coordinates on the given Particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle.\r\n     */\r\n    getPoint: function (particle)\r\n    {\r\n        if (this._direction === 0)\r\n        {\r\n            this.counter++;\r\n\r\n            if (this.counter >= this._length)\r\n            {\r\n                if (this.yoyo)\r\n                {\r\n                    this._direction = 1;\r\n                    this.counter = this._length - 1;\r\n                }\r\n                else\r\n                {\r\n                    this.counter = 0;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.counter--;\r\n\r\n            if (this.counter === -1)\r\n            {\r\n                if (this.yoyo)\r\n                {\r\n                    this._direction = 0;\r\n                    this.counter = 0;\r\n                }\r\n                else\r\n                {\r\n                    this.counter = this._length - 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        var point = this.points[this.counter];\r\n\r\n        if (point)\r\n        {\r\n            particle.x = point.x;\r\n            particle.y = point.y;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = EdgeZone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Vector2 = require('../../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A zone that places particles randomly within a shapes area.\r\n *\r\n * @class RandomZone\r\n * @memberof Phaser.GameObjects.Particles.Zones\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Particles.RandomZoneSource} source - An object instance with a `getRandomPoint(point)` method.\r\n */\r\nvar RandomZone = new Class({\r\n\r\n    initialize:\r\n\r\n    function RandomZone (source)\r\n    {\r\n        /**\r\n         * An object instance with a `getRandomPoint(point)` method.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.RandomZone#source\r\n         * @type {Phaser.Types.GameObjects.Particles.RandomZoneSource}\r\n         * @since 3.0.0\r\n         */\r\n        this.source = source;\r\n\r\n        /**\r\n         * Internal calculation vector.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.RandomZone#_tempVec\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tempVec = new Vector2();\r\n    },\r\n\r\n    /**\r\n     * Get the next point in the Zone and set its coordinates on the given Particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.RandomZone#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle.\r\n     */\r\n    getPoint: function (particle)\r\n    {\r\n        var vec = this._tempVec;\r\n\r\n        this.source.getRandomPoint(vec);\r\n\r\n        particle.x = vec.x;\r\n        particle.y = vec.y;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = RandomZone;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar Components = require('../components');\nvar Sprite = require('../sprite/Sprite');\n\n/**\n * @classdesc\n * A PathFollower Game Object.\n *\n * A PathFollower is a Sprite Game Object with some extra helpers to allow it to follow a Path automatically.\n *\n * Anything you can do with a standard Sprite can be done with this PathFollower, such as animate it, tint it,\n * scale it and so on.\n *\n * PathFollowers are bound to a single Path at any one time and can traverse the length of the Path, from start\n * to finish, forwards or backwards, or from any given point on the Path to its end. They can optionally rotate\n * to face the direction of the path, be offset from the path coordinates or rotate independently of the Path.\n *\n * @class PathFollower\n * @extends Phaser.GameObjects.Sprite\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @extends Phaser.GameObjects.Components.PathFollower\n *\n * @param {Phaser.Scene} scene - The Scene to which this PathFollower belongs.\n * @param {Phaser.Curves.Path} path - The Path this PathFollower is following. It can only follow one Path at a time.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n */\nvar PathFollower = new Class({\n\n    Extends: Sprite,\n\n    Mixins: [\n        Components.PathFollower\n    ],\n\n    initialize:\n\n    function PathFollower (scene, path, x, y, texture, frame)\n    {\n        Sprite.call(this, scene, x, y, texture, frame);\n\n        this.path = path;\n    },\n\n    /**\n     * Internal update handler that advances this PathFollower along the path.\n     *\n     * Called automatically by the Scene step, should not typically be called directly.\n     *\n     * @method Phaser.GameObjects.PathFollower#preUpdate\n     * @protected\n     * @since 3.0.0\n     *\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\n     */\n    preUpdate: function (time, delta)\n    {\n        this.anims.update(time, delta);\n        this.pathUpdate(time);\n    }\n\n});\n\nmodule.exports = PathFollower;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns an object containing dimensions of the Text object.\r\n *\r\n * @function Phaser.GameObjects.GetTextSize\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Text} text - The Text object to calculate the size from.\r\n * @param {Phaser.Types.GameObjects.Text.TextMetrics} size - The Text metrics to use when calculating the size.\r\n * @param {string[]} lines - The lines of text to calculate the size from.\r\n *\r\n * @return {Phaser.Types.GameObjects.Text.GetTextSizeObject} An object containing dimensions of the Text object.\r\n */\r\nvar GetTextSize = function (text, size, lines)\r\n{\r\n    var canvas = text.canvas;\r\n    var context = text.context;\r\n    var style = text.style;\r\n\r\n    var lineWidths = [];\r\n    var maxLineWidth = 0;\r\n    var drawnLines = lines.length;\r\n\r\n    if (style.maxLines > 0 && style.maxLines < lines.length)\r\n    {\r\n        drawnLines = style.maxLines;\r\n    }\r\n\r\n    style.syncFont(canvas, context);\r\n\r\n    //  Text Width\r\n\r\n    for (var i = 0; i < drawnLines; i++)\r\n    {\r\n        var lineWidth = style.strokeThickness;\r\n\r\n        lineWidth += context.measureText(lines[i]).width;\r\n\r\n        // Adjust for wrapped text\r\n        if (style.wordWrap)\r\n        {\r\n            lineWidth -= context.measureText(' ').width;\r\n        }\r\n\r\n        lineWidths[i] = Math.ceil(lineWidth);\r\n        maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);\r\n    }\r\n\r\n    //  Text Height\r\n\r\n    var lineHeight = size.fontSize + style.strokeThickness;\r\n    var height = lineHeight * drawnLines;\r\n    var lineSpacing = text.lineSpacing;\r\n\r\n    //  Adjust for line spacing\r\n    if (drawnLines > 1)\r\n    {\r\n        height += lineSpacing * (drawnLines - 1);\r\n    }\r\n\r\n    return {\r\n        width: maxLineWidth,\r\n        height: height,\r\n        lines: drawnLines,\r\n        lineWidths: lineWidths,\r\n        lineSpacing: lineSpacing,\r\n        lineHeight: lineHeight\r\n    };\r\n};\r\n\r\nmodule.exports = GetTextSize;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\nvar GetValue = require('../../utils/object/GetValue');\nvar MeasureText = require('./MeasureText');\n\n//  Key: [ Object Key, Default Value ]\n\nvar propertyMap = {\n    fontFamily: [ 'fontFamily', 'Courier' ],\n    fontSize: [ 'fontSize', '16px' ],\n    fontStyle: [ 'fontStyle', '' ],\n    backgroundColor: [ 'backgroundColor', null ],\n    color: [ 'color', '#fff' ],\n    stroke: [ 'stroke', '#fff' ],\n    strokeThickness: [ 'strokeThickness', 0 ],\n    shadowOffsetX: [ 'shadow.offsetX', 0 ],\n    shadowOffsetY: [ 'shadow.offsetY', 0 ],\n    shadowColor: [ 'shadow.color', '#000' ],\n    shadowBlur: [ 'shadow.blur', 0 ],\n    shadowStroke: [ 'shadow.stroke', false ],\n    shadowFill: [ 'shadow.fill', false ],\n    align: [ 'align', 'left' ],\n    maxLines: [ 'maxLines', 0 ],\n    fixedWidth: [ 'fixedWidth', 0 ],\n    fixedHeight: [ 'fixedHeight', 0 ],\n    resolution: [ 'resolution', 0 ],\n    rtl: [ 'rtl', false ],\n    testString: [ 'testString', '|Mqgy' ],\n    baselineX: [ 'baselineX', 1.2 ],\n    baselineY: [ 'baselineY', 1.4 ],\n    wordWrapWidth: [ 'wordWrap.width', null ],\n    wordWrapCallback: [ 'wordWrap.callback', null ],\n    wordWrapCallbackScope: [ 'wordWrap.callbackScope', null ],\n    wordWrapUseAdvanced: [ 'wordWrap.useAdvancedWrap', false ]\n};\n\n/**\n * @classdesc\n * A TextStyle class manages all of the style settings for a Text object.\n *\n * Text Game Objects create a TextStyle instance automatically, which is\n * accessed via the `Text.style` property. You do not normally need to\n * instantiate one yourself.\n *\n * @class TextStyle\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.GameObjects.Text} text - The Text object that this TextStyle is styling.\n * @param {Phaser.Types.GameObjects.Text.TextStyle} style - The style settings to set.\n */\nvar TextStyle = new Class({\n\n    initialize:\n\n    function TextStyle (text, style)\n    {\n        /**\n         * The Text object that this TextStyle is styling.\n         *\n         * @name Phaser.GameObjects.TextStyle#parent\n         * @type {Phaser.GameObjects.Text}\n         * @since 3.0.0\n         */\n        this.parent = text;\n\n        /**\n         * The font family.\n         *\n         * @name Phaser.GameObjects.TextStyle#fontFamily\n         * @type {string}\n         * @default 'Courier'\n         * @since 3.0.0\n         */\n        this.fontFamily;\n\n        /**\n         * The font size.\n         *\n         * @name Phaser.GameObjects.TextStyle#fontSize\n         * @type {string}\n         * @default '16px'\n         * @since 3.0.0\n         */\n        this.fontSize;\n\n        /**\n         * The font style.\n         *\n         * @name Phaser.GameObjects.TextStyle#fontStyle\n         * @type {string}\n         * @since 3.0.0\n         */\n        this.fontStyle;\n\n        /**\n         * The background color.\n         *\n         * @name Phaser.GameObjects.TextStyle#backgroundColor\n         * @type {string}\n         * @since 3.0.0\n         */\n        this.backgroundColor;\n\n        /**\n         * The text fill color.\n         *\n         * @name Phaser.GameObjects.TextStyle#color\n         * @type {string}\n         * @default '#fff'\n         * @since 3.0.0\n         */\n        this.color;\n\n        /**\n         * The text stroke color.\n         *\n         * @name Phaser.GameObjects.TextStyle#stroke\n         * @type {string}\n         * @default '#fff'\n         * @since 3.0.0\n         */\n        this.stroke;\n\n        /**\n         * The text stroke thickness.\n         *\n         * @name Phaser.GameObjects.TextStyle#strokeThickness\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.strokeThickness;\n\n        /**\n         * The horizontal shadow offset.\n         *\n         * @name Phaser.GameObjects.TextStyle#shadowOffsetX\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.shadowOffsetX;\n\n        /**\n         * The vertical shadow offset.\n         *\n         * @name Phaser.GameObjects.TextStyle#shadowOffsetY\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.shadowOffsetY;\n\n        /**\n         * The shadow color.\n         *\n         * @name Phaser.GameObjects.TextStyle#shadowColor\n         * @type {string}\n         * @default '#000'\n         * @since 3.0.0\n         */\n        this.shadowColor;\n\n        /**\n         * The shadow blur radius.\n         *\n         * @name Phaser.GameObjects.TextStyle#shadowBlur\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.shadowBlur;\n\n        /**\n         * Whether shadow stroke is enabled or not.\n         *\n         * @name Phaser.GameObjects.TextStyle#shadowStroke\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.shadowStroke;\n\n        /**\n         * Whether shadow fill is enabled or not.\n         *\n         * @name Phaser.GameObjects.TextStyle#shadowFill\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.shadowFill;\n\n        /**\n         * The text alignment.\n         *\n         * @name Phaser.GameObjects.TextStyle#align\n         * @type {string}\n         * @default 'left'\n         * @since 3.0.0\n         */\n        this.align;\n\n        /**\n         * The maximum number of lines to draw.\n         *\n         * @name Phaser.GameObjects.TextStyle#maxLines\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.maxLines;\n\n        /**\n         * The fixed width of the text.\n         *\n         * `0` means no fixed with.\n         *\n         * @name Phaser.GameObjects.TextStyle#fixedWidth\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.fixedWidth;\n\n        /**\n         * The fixed height of the text.\n         *\n         * `0` means no fixed height.\n         *\n         * @name Phaser.GameObjects.TextStyle#fixedHeight\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.fixedHeight;\n\n        /**\n         * The resolution the text is rendered to its internal canvas at.\n         * The default is 0, which means it will use the resolution set in the Game Config.\n         *\n         * @name Phaser.GameObjects.TextStyle#resolution\n         * @type {number}\n         * @default 0\n         * @since 3.12.0\n         */\n        this.resolution;\n\n        /**\n         * Whether the text should render right to left.\n         *\n         * @name Phaser.GameObjects.TextStyle#rtl\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.rtl;\n\n        /**\n         * The test string to use when measuring the font.\n         *\n         * @name Phaser.GameObjects.TextStyle#testString\n         * @type {string}\n         * @default '|Mqgy'\n         * @since 3.0.0\n         */\n        this.testString;\n\n        /**\n         * The amount of horizontal padding added to the width of the text when calculating the font metrics.\n         *\n         * @name Phaser.GameObjects.TextStyle#baselineX\n         * @type {number}\n         * @default 1.2\n         * @since 3.3.0\n         */\n        this.baselineX;\n\n        /**\n         * The amount of vertical padding added to the height of the text when calculating the font metrics.\n         *\n         * @name Phaser.GameObjects.TextStyle#baselineY\n         * @type {number}\n         * @default 1.4\n         * @since 3.3.0\n         */\n        this.baselineY;\n\n        /**\n         * The maximum width of a line of text in pixels. Null means no line wrapping. Setting this\n         * property directly will not re-run the word wrapping algorithm. To change the width and\n         * re-wrap, use {@link Phaser.GameObjects.TextStyle#setWordWrapWidth}.\n         *\n         * @name Phaser.GameObjects.TextStyle#wordWrapWidth\n         * @type {number | null}\n         * @default null\n         * @since 3.24.0\n         */\n        this.wordWrapWidth;\n\n        /**\n         * A custom function that will be responsible for wrapping the text. It will receive two\n         * arguments: text (the string to wrap), textObject (this Text instance). It should return\n         * the wrapped lines either as an array of lines or as a string with newline characters in\n         * place to indicate where breaks should happen. Setting this directly will not re-run the\n         * word wrapping algorithm. To change the callback and re-wrap, use\n         * {@link Phaser.GameObjects.TextStyle#setWordWrapCallback}.\n         *\n         * @name Phaser.GameObjects.TextStyle#wordWrapCallback\n         * @type {TextStyleWordWrapCallback | null}\n         * @default null\n         * @since 3.24.0\n         */\n        this.wordWrapCallback;\n\n        /**\n         * The scope that will be applied when the wordWrapCallback is invoked. Setting this directly will not re-run the\n         * word wrapping algorithm. To change the callback and re-wrap, use\n         * {@link Phaser.GameObjects.TextStyle#setWordWrapCallback}.\n         *\n         * @name Phaser.GameObjects.TextStyle#wordWrapCallbackScope\n         * @type {object | null}\n         * @default null\n         * @since 3.24.0\n         */\n        this.wordWrapCallbackScope;\n\n        /**\n         * Whether or not to use the advanced wrapping algorithm. If true, spaces are collapsed and\n         * whitespace is trimmed from lines. If false, spaces and whitespace are left as is. Setting\n         * this property directly will not re-run the word wrapping algorithm. To change the\n         * advanced setting and re-wrap, use {@link Phaser.GameObjects.TextStyle#setWordWrapWidth}.\n         *\n         * @name Phaser.GameObjects.TextStyle#wordWrapUseAdvanced\n         * @type {boolean}\n         * @default false\n         * @since 3.24.0\n         */\n        this.wordWrapUseAdvanced;\n\n        /**\n         * The font style, size and family.\n         *\n         * @name Phaser.GameObjects.TextStyle#_font\n         * @type {string}\n         * @private\n         * @since 3.0.0\n         */\n        this._font;\n\n        //  Set to defaults + user style\n        this.setStyle(style, false, true);\n\n        var metrics = GetValue(style, 'metrics', false);\n\n        //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning\n        //  Doing this is reset if you then change the font of this TextStyle after creation\n        if (metrics)\n        {\n            this.metrics = {\n                ascent: GetValue(metrics, 'ascent', 0),\n                descent: GetValue(metrics, 'descent', 0),\n                fontSize: GetValue(metrics, 'fontSize', 0)\n            };\n        }\n        else\n        {\n            this.metrics = MeasureText(this);\n        }\n    },\n\n    /**\n     * Set the text style.\n     *\n     * @example\n     * text.setStyle({\n     *     fontSize: '64px',\n     *     fontFamily: 'Arial',\n     *     color: '#ffffff',\n     *     align: 'center',\n     *     backgroundColor: '#ff00ff'\n     * });\n     *\n     * @method Phaser.GameObjects.TextStyle#setStyle\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.GameObjects.Text.TextStyle} style - The style settings to set.\n     * @param {boolean} [updateText=true] - Whether to update the text immediately.\n     * @param {boolean} [setDefaults=false] - Use the default values is not set, or the local values.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setStyle: function (style, updateText, setDefaults)\n    {\n        if (updateText === undefined) { updateText = true; }\n        if (setDefaults === undefined) { setDefaults = false; }\n\n        //  Avoid type mutation\n        // eslint-disable-next-line no-prototype-builtins\n        if (style && style.hasOwnProperty('fontSize') && typeof style.fontSize === 'number')\n        {\n            style.fontSize = style.fontSize.toString() + 'px';\n        }\n\n        for (var key in propertyMap)\n        {\n            var value = (setDefaults) ? propertyMap[key][1] : this[key];\n\n            if (key === 'wordWrapCallback' || key === 'wordWrapCallbackScope')\n            {\n                // Callback & scope should be set without processing the values\n                this[key] = GetValue(style, propertyMap[key][0], value);\n            }\n            else\n            {\n                this[key] = GetAdvancedValue(style, propertyMap[key][0], value);\n            }\n        }\n\n        //  Allow for 'font' override\n        var font = GetValue(style, 'font', null);\n\n        if (font !== null)\n        {\n            this.setFont(font, false);\n        }\n\n        this._font = [ this.fontStyle, this.fontSize, this.fontFamily ].join(' ').trim();\n\n        //  Allow for 'fill' to be used in place of 'color'\n        var fill = GetValue(style, 'fill', null);\n\n        if (fill !== null)\n        {\n            this.color = fill;\n        }\n\n        if (updateText)\n        {\n            return this.update(true);\n        }\n        else\n        {\n            return this.parent;\n        }\n    },\n\n    /**\n     * Synchronize the font settings to the given Canvas Rendering Context.\n     *\n     * @method Phaser.GameObjects.TextStyle#syncFont\n     * @since 3.0.0\n     *\n     * @param {HTMLCanvasElement} canvas - The Canvas Element.\n     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\n     */\n    syncFont: function (canvas, context)\n    {\n        context.font = this._font;\n    },\n\n    /**\n     * Synchronize the text style settings to the given Canvas Rendering Context.\n     *\n     * @method Phaser.GameObjects.TextStyle#syncStyle\n     * @since 3.0.0\n     *\n     * @param {HTMLCanvasElement} canvas - The Canvas Element.\n     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\n     */\n    syncStyle: function (canvas, context)\n    {\n        context.textBaseline = 'alphabetic';\n\n        context.fillStyle = this.color;\n        context.strokeStyle = this.stroke;\n\n        context.lineWidth = this.strokeThickness;\n        context.lineCap = 'round';\n        context.lineJoin = 'round';\n    },\n\n    /**\n     * Synchronize the shadow settings to the given Canvas Rendering Context.\n     *\n     * @method Phaser.GameObjects.TextStyle#syncShadow\n     * @since 3.0.0\n     *\n     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\n     * @param {boolean} enabled - Whether shadows are enabled or not.\n     */\n    syncShadow: function (context, enabled)\n    {\n        if (enabled)\n        {\n            context.shadowOffsetX = this.shadowOffsetX;\n            context.shadowOffsetY = this.shadowOffsetY;\n            context.shadowColor = this.shadowColor;\n            context.shadowBlur = this.shadowBlur;\n        }\n        else\n        {\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n            context.shadowColor = 0;\n            context.shadowBlur = 0;\n        }\n    },\n\n    /**\n     * Update the style settings for the parent Text object.\n     *\n     * @method Phaser.GameObjects.TextStyle#update\n     * @since 3.0.0\n     *\n     * @param {boolean} recalculateMetrics - Whether to recalculate font and text metrics.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    update: function (recalculateMetrics)\n    {\n        if (recalculateMetrics)\n        {\n            this._font = [ this.fontStyle, this.fontSize, this.fontFamily ].join(' ').trim();\n\n            this.metrics = MeasureText(this);\n        }\n\n        return this.parent.updateText();\n    },\n\n    /**\n     * Set the font.\n     *\n     * If a string is given, the font family is set.\n     *\n     * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`\n     * properties of that object are set.\n     *\n     * @method Phaser.GameObjects.TextStyle#setFont\n     * @since 3.0.0\n     *\n     * @param {(string|object)} font - The font family or font settings to set.\n     * @param {boolean} [updateText=true] - Whether to update the text immediately.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setFont: function (font, updateText)\n    {\n        if (updateText === undefined) { updateText = true; }\n\n        var fontFamily = font;\n        var fontSize = '';\n        var fontStyle = '';\n\n        if (typeof font !== 'string')\n        {\n            fontFamily = GetValue(font, 'fontFamily', 'Courier');\n            fontSize = GetValue(font, 'fontSize', '16px');\n            fontStyle = GetValue(font, 'fontStyle', '');\n        }\n        else\n        {\n            var fontSplit = font.split(' ');\n\n            var i = 0;\n\n            fontStyle = (fontSplit.length > 2) ? fontSplit[i++] : '';\n            fontSize = fontSplit[i++] || '16px';\n            fontFamily = fontSplit[i++] || 'Courier';\n        }\n\n        if (fontFamily !== this.fontFamily || fontSize !== this.fontSize || fontStyle !== this.fontStyle)\n        {\n            this.fontFamily = fontFamily;\n            this.fontSize = fontSize;\n            this.fontStyle = fontStyle;\n\n            if (updateText)\n            {\n                this.update(true);\n            }\n        }\n\n        return this.parent;\n    },\n\n    /**\n     * Set the font family.\n     *\n     * @method Phaser.GameObjects.TextStyle#setFontFamily\n     * @since 3.0.0\n     *\n     * @param {string} family - The font family.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setFontFamily: function (family)\n    {\n        if (this.fontFamily !== family)\n        {\n            this.fontFamily = family;\n\n            this.update(true);\n        }\n\n        return this.parent;\n    },\n\n    /**\n     * Set the font style.\n     *\n     * @method Phaser.GameObjects.TextStyle#setFontStyle\n     * @since 3.0.0\n     *\n     * @param {string} style - The font style.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setFontStyle: function (style)\n    {\n        if (this.fontStyle !== style)\n        {\n            this.fontStyle = style;\n\n            this.update(true);\n        }\n\n        return this.parent;\n    },\n\n    /**\n     * Set the font size.\n     *\n     * @method Phaser.GameObjects.TextStyle#setFontSize\n     * @since 3.0.0\n     *\n     * @param {(number|string)} size - The font size.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setFontSize: function (size)\n    {\n        if (typeof size === 'number')\n        {\n            size = size.toString() + 'px';\n        }\n\n        if (this.fontSize !== size)\n        {\n            this.fontSize = size;\n\n            this.update(true);\n        }\n\n        return this.parent;\n    },\n\n    /**\n     * Set the test string to use when measuring the font.\n     *\n     * @method Phaser.GameObjects.TextStyle#setTestString\n     * @since 3.0.0\n     *\n     * @param {string} string - The test string to use when measuring the font.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setTestString: function (string)\n    {\n        this.testString = string;\n\n        return this.update(true);\n    },\n\n    /**\n     * Set a fixed width and height for the text.\n     *\n     * Pass in `0` for either of these parameters to disable fixed width or height respectively.\n     *\n     * @method Phaser.GameObjects.TextStyle#setFixedSize\n     * @since 3.0.0\n     *\n     * @param {number} width - The fixed width to set.\n     * @param {number} height - The fixed height to set.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setFixedSize: function (width, height)\n    {\n        this.fixedWidth = width;\n        this.fixedHeight = height;\n\n        if (width)\n        {\n            this.parent.width = width;\n        }\n\n        if (height)\n        {\n            this.parent.height = height;\n        }\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the background color.\n     *\n     * @method Phaser.GameObjects.TextStyle#setBackgroundColor\n     * @since 3.0.0\n     *\n     * @param {string} color - The background color.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setBackgroundColor: function (color)\n    {\n        this.backgroundColor = color;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the text fill color.\n     *\n     * @method Phaser.GameObjects.TextStyle#setFill\n     * @since 3.0.0\n     *\n     * @param {string} color - The text fill color.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setFill: function (color)\n    {\n        this.color = color;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the text fill color.\n     *\n     * @method Phaser.GameObjects.TextStyle#setColor\n     * @since 3.0.0\n     *\n     * @param {string} color - The text fill color.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setColor: function (color)\n    {\n        this.color = color;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the resolution used by the Text object.\n     *\n     * By default it will be set to match the resolution set in the Game Config,\n     * but you can override it via this method. It allows for much clearer text on High DPI devices,\n     * at the cost of memory because it uses larger internal Canvas textures for the Text.\n     *\n     * Please use with caution, as the more high res Text you have, the more memory it uses up.\n     *\n     * @method Phaser.GameObjects.TextStyle#setResolution\n     * @since 3.12.0\n     *\n     * @param {number} value - The resolution for this Text object to use.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setResolution: function (value)\n    {\n        this.resolution = value;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the stroke settings.\n     *\n     * @method Phaser.GameObjects.TextStyle#setStroke\n     * @since 3.0.0\n     *\n     * @param {string} color - The stroke color.\n     * @param {number} thickness - The stroke thickness.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setStroke: function (color, thickness)\n    {\n        if (thickness === undefined) { thickness = this.strokeThickness; }\n\n        if (color === undefined && this.strokeThickness !== 0)\n        {\n            //  Reset the stroke to zero (disabling it)\n            this.strokeThickness = 0;\n\n            this.update(true);\n        }\n        else if (this.stroke !== color || this.strokeThickness !== thickness)\n        {\n            this.stroke = color;\n            this.strokeThickness = thickness;\n\n            this.update(true);\n        }\n\n        return this.parent;\n    },\n\n    /**\n     * Set the shadow settings.\n     *\n     * Calling this method always re-measures the parent Text object,\n     * so only call it when you actually change the shadow settings.\n     *\n     * @method Phaser.GameObjects.TextStyle#setShadow\n     * @since 3.0.0\n     *\n     * @param {number} [x=0] - The horizontal shadow offset.\n     * @param {number} [y=0] - The vertical shadow offset.\n     * @param {string} [color='#000'] - The shadow color.\n     * @param {number} [blur=0] - The shadow blur radius.\n     * @param {boolean} [shadowStroke=false] - Whether to stroke the shadow.\n     * @param {boolean} [shadowFill=true] - Whether to fill the shadow.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)\n    {\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = 0; }\n        if (color === undefined) { color = '#000'; }\n        if (blur === undefined) { blur = 0; }\n        if (shadowStroke === undefined) { shadowStroke = false; }\n        if (shadowFill === undefined) { shadowFill = true; }\n\n        this.shadowOffsetX = x;\n        this.shadowOffsetY = y;\n        this.shadowColor = color;\n        this.shadowBlur = blur;\n        this.shadowStroke = shadowStroke;\n        this.shadowFill = shadowFill;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the shadow offset.\n     *\n     * @method Phaser.GameObjects.TextStyle#setShadowOffset\n     * @since 3.0.0\n     *\n     * @param {number} [x=0] - The horizontal shadow offset.\n     * @param {number} [y=0] - The vertical shadow offset.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setShadowOffset: function (x, y)\n    {\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = x; }\n\n        this.shadowOffsetX = x;\n        this.shadowOffsetY = y;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the shadow color.\n     *\n     * @method Phaser.GameObjects.TextStyle#setShadowColor\n     * @since 3.0.0\n     *\n     * @param {string} [color='#000'] - The shadow color.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setShadowColor: function (color)\n    {\n        if (color === undefined) { color = '#000'; }\n\n        this.shadowColor = color;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the shadow blur radius.\n     *\n     * @method Phaser.GameObjects.TextStyle#setShadowBlur\n     * @since 3.0.0\n     *\n     * @param {number} [blur=0] - The shadow blur radius.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setShadowBlur: function (blur)\n    {\n        if (blur === undefined) { blur = 0; }\n\n        this.shadowBlur = blur;\n\n        return this.update(false);\n    },\n\n    /**\n     * Enable or disable shadow stroke.\n     *\n     * @method Phaser.GameObjects.TextStyle#setShadowStroke\n     * @since 3.0.0\n     *\n     * @param {boolean} enabled - Whether shadow stroke is enabled or not.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setShadowStroke: function (enabled)\n    {\n        this.shadowStroke = enabled;\n\n        return this.update(false);\n    },\n\n    /**\n     * Enable or disable shadow fill.\n     *\n     * @method Phaser.GameObjects.TextStyle#setShadowFill\n     * @since 3.0.0\n     *\n     * @param {boolean} enabled - Whether shadow fill is enabled or not.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setShadowFill: function (enabled)\n    {\n        this.shadowFill = enabled;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the width (in pixels) to use for wrapping lines.\n     *\n     * Pass in null to remove wrapping by width.\n     *\n     * @method Phaser.GameObjects.TextStyle#setWordWrapWidth\n     * @since 3.0.0\n     *\n     * @param {number} width - The maximum width of a line in pixels. Set to null to remove wrapping.\n     * @param {boolean} [useAdvancedWrap=false] - Whether or not to use the advanced wrapping\n     * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,\n     * spaces and whitespace are left as is.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setWordWrapWidth: function (width, useAdvancedWrap)\n    {\n        if (useAdvancedWrap === undefined) { useAdvancedWrap = false; }\n\n        this.wordWrapWidth = width;\n        this.wordWrapUseAdvanced = useAdvancedWrap;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set a custom callback for wrapping lines.\n     *\n     * Pass in null to remove wrapping by callback.\n     *\n     * @method Phaser.GameObjects.TextStyle#setWordWrapCallback\n     * @since 3.0.0\n     *\n     * @param {TextStyleWordWrapCallback} callback - A custom function that will be responsible for wrapping the\n     * text. It will receive two arguments: text (the string to wrap), textObject (this Text\n     * instance). It should return the wrapped lines either as an array of lines or as a string with\n     * newline characters in place to indicate where breaks should happen.\n     * @param {object} [scope=null] - The scope that will be applied when the callback is invoked.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setWordWrapCallback: function (callback, scope)\n    {\n        if (scope === undefined) { scope = null; }\n\n        this.wordWrapCallback = callback;\n        this.wordWrapCallbackScope = scope;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the alignment of the text in this Text object.\n     *\n     * The argument can be one of: `left`, `right`, `center` or `justify`.\n     *\n     * Alignment only works if the Text object has more than one line of text.\n     *\n     * @method Phaser.GameObjects.TextStyle#setAlign\n     * @since 3.0.0\n     *\n     * @param {string} [align='left'] - The text alignment for multi-line text.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setAlign: function (align)\n    {\n        if (align === undefined) { align = 'left'; }\n\n        this.align = align;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the maximum number of lines to draw.\n     *\n     * @method Phaser.GameObjects.TextStyle#setMaxLines\n     * @since 3.0.0\n     *\n     * @param {number} [max=0] - The maximum number of lines to draw.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setMaxLines: function (max)\n    {\n        if (max === undefined) { max = 0; }\n\n        this.maxLines = max;\n\n        return this.update(false);\n    },\n\n    /**\n     * Get the current text metrics.\n     *\n     * @method Phaser.GameObjects.TextStyle#getTextMetrics\n     * @since 3.0.0\n     *\n     * @return {Phaser.Types.GameObjects.Text.TextMetrics} The text metrics.\n     */\n    getTextMetrics: function ()\n    {\n        var metrics = this.metrics;\n\n        return {\n            ascent: metrics.ascent,\n            descent: metrics.descent,\n            fontSize: metrics.fontSize\n        };\n    },\n\n    /**\n     * Build a JSON representation of this Text Style.\n     *\n     * @method Phaser.GameObjects.TextStyle#toJSON\n     * @since 3.0.0\n     *\n     * @return {object} A JSON representation of this Text Style.\n     */\n    toJSON: function ()\n    {\n        var output = {};\n\n        for (var key in propertyMap)\n        {\n            output[key] = this[key];\n        }\n\n        output.metrics = this.getTextMetrics();\n\n        return output;\n    },\n\n    /**\n     * Destroy this Text Style.\n     *\n     * @method Phaser.GameObjects.TextStyle#destroy\n     * @since 3.0.0\n     */\n    destroy: function ()\n    {\n        this.parent = undefined;\n    }\n\n});\n\nmodule.exports = TextStyle;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\n\r\n/**\r\n * Calculates the ascent, descent and fontSize of a given font style.\r\n *\r\n * @function Phaser.GameObjects.MeasureText\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.TextStyle} textStyle - The TextStyle object to measure.\r\n *\r\n * @return {Phaser.Types.GameObjects.Text.TextMetrics} An object containing the ascent, descent and fontSize of the TextStyle.\r\n */\r\nvar MeasureText = function (textStyle)\r\n{\r\n    var canvas = CanvasPool.create(this);\r\n    var context = canvas.getContext('2d');\r\n\r\n    textStyle.syncFont(canvas, context);\r\n\r\n    var metrics = context.measureText(textStyle.testString);\r\n\r\n    if ('actualBoundingBoxAscent' in metrics)\r\n    {\r\n        var ascent = metrics.actualBoundingBoxAscent;\r\n        var descent = metrics.actualBoundingBoxDescent;\r\n\r\n        CanvasPool.remove(canvas);\r\n\r\n        return {\r\n            ascent: ascent,\r\n            descent: descent,\r\n            fontSize: ascent + descent\r\n        };\r\n    }\r\n\r\n    var width = Math.ceil(metrics.width * textStyle.baselineX);\r\n    var baseline = width;\r\n    var height = 2 * baseline;\r\n\r\n    baseline = baseline * textStyle.baselineY | 0;\r\n\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    context.fillStyle = '#f00';\r\n    context.fillRect(0, 0, width, height);\r\n\r\n    context.font = textStyle._font;\r\n\r\n    context.textBaseline = 'alphabetic';\r\n    context.fillStyle = '#000';\r\n    context.fillText(textStyle.testString, 0, baseline);\r\n\r\n    var output = {\r\n        ascent: 0,\r\n        descent: 0,\r\n        fontSize: 0\r\n    };\r\n\r\n    var imagedata = context.getImageData(0, 0, width, height);\r\n    if (!imagedata)\r\n    {\r\n        output.ascent = baseline;\r\n        output.descent = baseline + 6;\r\n        output.fontSize = output.ascent + output.descent;\r\n\r\n        CanvasPool.remove(canvas);\r\n\r\n        return output;\r\n    }\r\n\r\n    var pixels = imagedata.data;\r\n    var numPixels = pixels.length;\r\n    var line = width * 4;\r\n    var i;\r\n    var j;\r\n    var idx = 0;\r\n    var stop = false;\r\n\r\n    // ascent. scan from top to bottom until we find a non red pixel\r\n    for (i = 0; i < baseline; i++)\r\n    {\r\n        for (j = 0; j < line; j += 4)\r\n        {\r\n            if (pixels[idx + j] !== 255)\r\n            {\r\n                stop = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!stop)\r\n        {\r\n            idx += line;\r\n        }\r\n        else\r\n        {\r\n            break;\r\n        }\r\n    }\r\n\r\n    output.ascent = baseline - i;\r\n\r\n    idx = numPixels - line;\r\n    stop = false;\r\n\r\n    // descent. scan from bottom to top until we find a non red pixel\r\n    for (i = height; i > baseline; i--)\r\n    {\r\n        for (j = 0; j < line; j += 4)\r\n        {\r\n            if (pixels[idx + j] !== 255)\r\n            {\r\n                stop = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!stop)\r\n        {\r\n            idx -= line;\r\n        }\r\n        else\r\n        {\r\n            break;\r\n        }\r\n    }\r\n\r\n    output.descent = (i - baseline);\r\n    output.fontSize = output.ascent + output.descent;\r\n\r\n    CanvasPool.remove(canvas);\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = MeasureText;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ArcRender = require('./ArcRender');\r\nvar Class = require('../../../utils/Class');\r\nvar DegToRad = require('../../../math/DegToRad');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar GeomCircle = require('../../../geom/circle/Circle');\r\nvar MATH_CONST = require('../../../math/const');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The Arc Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * When it renders it displays an arc shape. You can control the start and end angles of the arc,\r\n * as well as if the angles are winding clockwise or anti-clockwise. With the default settings\r\n * it renders as a complete circle. By changing the angles you can create other arc shapes,\r\n * such as half-circles.\r\n * \r\n * Arcs also have an `iterations` property and corresponding `setIterations` method. This allows\r\n * you to control how smooth the shape renders in WebGL, by controlling the number of iterations\r\n * that take place during construction.\r\n *\r\n * @class Arc\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [radius=128] - The radius of the arc.\r\n * @param {number} [startAngle=0] - The start angle of the arc, in degrees.\r\n * @param {number} [endAngle=360] - The end angle of the arc, in degrees.\r\n * @param {boolean} [anticlockwise=false] - The winding order of the start and end angles.\r\n * @param {number} [fillColor] - The color the arc will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the arc will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Arc = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        ArcRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Arc (scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (radius === undefined) { radius = 128; }\r\n        if (startAngle === undefined) { startAngle = 0; }\r\n        if (endAngle === undefined) { endAngle = 360; }\r\n        if (anticlockwise === undefined) { anticlockwise = false; }\r\n\r\n        Shape.call(this, scene, 'Arc', new GeomCircle(0, 0, radius));\r\n\r\n        /**\r\n         * Private internal value. Holds the start angle in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Arc#_startAngle\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._startAngle = startAngle;\r\n\r\n        /**\r\n         * Private internal value. Holds the end angle in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Arc#_endAngle\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._endAngle = endAngle;\r\n\r\n        /**\r\n         * Private internal value. Holds the winding order of the start and end angles.\r\n         *\r\n         * @name Phaser.GameObjects.Arc#_anticlockwise\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._anticlockwise = anticlockwise;\r\n\r\n        /**\r\n         * Private internal value. Holds the number of iterations used when drawing the arc.\r\n         *\r\n         * @name Phaser.GameObjects.Arc#_iterations\r\n         * @type {number}\r\n         * @default 0.01\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._iterations = 0.01;\r\n\r\n        this.setPosition(x, y);\r\n\r\n        var diameter = this.geom.radius * 2;\r\n        this.setSize(diameter, diameter);\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * The number of iterations used when drawing the arc.\r\n     * Increase this value for smoother arcs, at the cost of more polygons being rendered.\r\n     * Modify this value by small amounts, such as 0.01.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#iterations\r\n     * @type {number}\r\n     * @default 0.01\r\n     * @since 3.13.0\r\n     */\r\n    iterations: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._iterations;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._iterations = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The radius of the arc.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#radius\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\r\n    radius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.geom.radius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.geom.radius = value;\r\n\r\n            var diameter = value * 2;\r\n            this.setSize(diameter, diameter);\r\n            this.updateDisplayOrigin();\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The start angle of the arc, in degrees.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#startAngle\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\r\n    startAngle: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._startAngle;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._startAngle = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The end angle of the arc, in degrees.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#endAngle\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\r\n    endAngle: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._endAngle;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._endAngle = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The winding order of the start and end angles.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#anticlockwise\r\n     * @type {boolean}\r\n     * @since 3.13.0\r\n     */\r\n    anticlockwise: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._anticlockwise;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._anticlockwise = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the radius of the arc.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#setRadius\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the radius to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRadius: function (value)\r\n    {\r\n        this.radius = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the number of iterations used when drawing the arc.\r\n     * Increase this value for smoother arcs, at the cost of more polygons being rendered.\r\n     * Modify this value by small amounts, such as 0.01.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#setIterations\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the iterations to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setIterations: function (value)\r\n    {\r\n        if (value === undefined) { value = 0.01; }\r\n\r\n        this.iterations = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the starting angle of the arc, in degrees.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#setStartAngle\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the starting angle to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setStartAngle: function (angle, anticlockwise)\r\n    {\r\n        this._startAngle = angle;\r\n\r\n        if (anticlockwise !== undefined)\r\n        {\r\n            this._anticlockwise = anticlockwise;\r\n        }\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the ending angle of the arc, in degrees.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#setEndAngle\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the ending angle to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setEndAngle: function (angle, anticlockwise)\r\n    {\r\n        this._endAngle = angle;\r\n\r\n        if (anticlockwise !== undefined)\r\n        {\r\n            this._anticlockwise = anticlockwise;\r\n        }\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var step = this._iterations;\r\n        var iteration = step;\r\n\r\n        var radius = this.geom.radius;\r\n        var startAngle = DegToRad(this._startAngle);\r\n        var endAngle = DegToRad(this._endAngle);\r\n        var anticlockwise = this._anticlockwise;\r\n\r\n        var x = radius;\r\n        var y = radius;\r\n\r\n        endAngle -= startAngle;\r\n\r\n        if (anticlockwise)\r\n        {\r\n            if (endAngle < -MATH_CONST.PI2)\r\n            {\r\n                endAngle = -MATH_CONST.PI2;\r\n            }\r\n            else if (endAngle > 0)\r\n            {\r\n                endAngle = -MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;\r\n            }\r\n        }\r\n        else if (endAngle > MATH_CONST.PI2)\r\n        {\r\n            endAngle = MATH_CONST.PI2;\r\n        }\r\n        else if (endAngle < 0)\r\n        {\r\n            endAngle = MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;\r\n        }\r\n\r\n        var path = [ x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius ];\r\n\r\n        var ta;\r\n\r\n        while (iteration < 1)\r\n        {\r\n            ta = endAngle * iteration + startAngle;\r\n\r\n            path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);\r\n\r\n            iteration += step;\r\n        }\r\n\r\n        ta = endAngle + startAngle;\r\n\r\n        path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);\r\n\r\n        path.push(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius);\r\n\r\n        this.pathIndexes = Earcut(path);\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Arc;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar CurveRender = require('./CurveRender');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar Rectangle = require('../../../geom/rectangle/Rectangle');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The Curve Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * To render a Curve Shape you must first create a `Phaser.Curves.Curve` object, then pass it to\r\n * the Curve Shape in the constructor.\r\n * \r\n * The Curve shape also has a `smoothness` property and corresponding `setSmoothness` method.\r\n * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations\r\n * that take place during construction. Increase and decrease the default value for smoother, or more\r\n * jagged, shapes.\r\n *\r\n * @class Curve\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {Phaser.Curves.Curve} [curve] - The Curve object to use to create the Shape.\r\n * @param {number} [fillColor] - The color the curve will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the curve will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Curve = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        CurveRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Curve (scene, x, y, curve, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        Shape.call(this, scene, 'Curve', curve);\r\n\r\n        /**\r\n         * Private internal value.\r\n         * The number of points used to draw the curve. Higher values create smoother renders at the cost of more triangles being drawn.\r\n         *\r\n         * @name Phaser.GameObjects.Curve#_smoothness\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._smoothness = 32;\r\n\r\n        /**\r\n         * Private internal value.\r\n         * The Curve bounds rectangle.\r\n         *\r\n         * @name Phaser.GameObjects.Curve#_curveBounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._curveBounds = new Rectangle();\r\n\r\n        this.closePath = false;\r\n\r\n        this.setPosition(x, y);\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * The smoothness of the curve. The number of points used when rendering it.\r\n     * Increase this value for smoother curves, at the cost of more polygons being rendered.\r\n     *\r\n     * @name Phaser.GameObjects.Curve#smoothness\r\n     * @type {number}\r\n     * @default 32\r\n     * @since 3.13.0\r\n     */\r\n    smoothness: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._smoothness;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._smoothness = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the smoothness of the curve. The number of points used when rendering it.\r\n     * Increase this value for smoother curves, at the cost of more polygons being rendered.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Curve#setSmoothness\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the smoothness to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSmoothness: function (value)\r\n    {\r\n        this._smoothness = value;\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Curve#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var bounds = this._curveBounds;\r\n        var smoothness = this._smoothness;\r\n\r\n        //  Update the bounds in case the underlying data has changed\r\n        this.geom.getBounds(bounds, smoothness);\r\n\r\n        this.setSize(bounds.width, bounds.height);\r\n        this.updateDisplayOrigin();\r\n\r\n        var path = [];\r\n        var points = this.geom.getPoints(smoothness);\r\n\r\n        for (var i = 0; i < points.length; i++)\r\n        {\r\n            path.push(points[i].x, points[i].y);\r\n        }\r\n\r\n        path.push(points[0].x, points[0].y);\r\n\r\n        this.pathIndexes = Earcut(path);\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Curve;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar EllipseRender = require('./EllipseRender');\r\nvar GeomEllipse = require('../../../geom/ellipse/Ellipse');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The Ellipse Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * When it renders it displays an ellipse shape. You can control the width and height of the ellipse.\r\n * If the width and height match it will render as a circle. If the width is less than the height,\r\n * it will look more like an egg shape.\r\n * \r\n * The Ellipse shape also has a `smoothness` property and corresponding `setSmoothness` method.\r\n * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations\r\n * that take place during construction. Increase and decrease the default value for smoother, or more\r\n * jagged, shapes.\r\n *\r\n * @class Ellipse\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the ellipse. An ellipse with equal width and height renders as a circle.\r\n * @param {number} [height=128] - The height of the ellipse. An ellipse with equal width and height renders as a circle.\r\n * @param {number} [fillColor] - The color the ellipse will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the ellipse will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Ellipse = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        EllipseRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Ellipse (scene, x, y, width, height, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = 128; }\r\n        if (height === undefined) { height = 128; }\r\n\r\n        Shape.call(this, scene, 'Ellipse', new GeomEllipse(width / 2, height / 2, width, height));\r\n\r\n        /**\r\n         * Private internal value.\r\n         * The number of points used to draw the curve. Higher values create smoother renders at the cost of more triangles being drawn.\r\n         *\r\n         * @name Phaser.GameObjects.Ellipse#_smoothness\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._smoothness = 64;\r\n\r\n        this.setPosition(x, y);\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * The smoothness of the ellipse. The number of points used when rendering it.\r\n     * Increase this value for a smoother ellipse, at the cost of more polygons being rendered.\r\n     *\r\n     * @name Phaser.GameObjects.Ellipse#smoothness\r\n     * @type {number}\r\n     * @default 64\r\n     * @since 3.13.0\r\n     */\r\n    smoothness: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._smoothness;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._smoothness = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the size of the ellipse by changing the underlying geometry data, rather than scaling the object.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Ellipse#setSize\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.geom.setPosition(width / 2, height / 2);\r\n        this.geom.setSize(width, height);\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the smoothness of the ellipse. The number of points used when rendering it.\r\n     * Increase this value for a smoother ellipse, at the cost of more polygons being rendered.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Ellipse#setSmoothness\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the smoothness to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSmoothness: function (value)\r\n    {\r\n        this._smoothness = value;\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Ellipse#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var path = [];\r\n        var points = this.geom.getPoints(this._smoothness);\r\n\r\n        for (var i = 0; i < points.length; i++)\r\n        {\r\n            path.push(points[i].x, points[i].y);\r\n        }\r\n\r\n        path.push(points[0].x, points[0].y);\r\n\r\n        this.pathIndexes = Earcut(path);\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Ellipse;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../../utils/Class');\nvar Shape = require('../Shape');\nvar GridRender = require('./GridRender');\n\n/**\n * @classdesc\n * The Grid Shape is a Game Object that can be added to a Scene, Group or Container. You can\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\n *\n * This shape supports only fill colors and cannot be stroked.\n *\n * A Grid Shape allows you to display a grid in your game, where you can control the size of the\n * grid as well as the width and height of the grid cells. You can set a fill color for each grid\n * cell as well as an alternate fill color. When the alternate fill color is set then the grid\n * cells will alternate the fill colors as they render, creating a chess-board effect. You can\n * also optionally have an outline fill color. If set, this draws lines between the grid cells\n * in the given color. If you specify an outline color with an alpha of zero, then it will draw\n * the cells spaced out, but without the lines between them.\n *\n * @class Grid\n * @extends Phaser.GameObjects.Shape\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.13.0\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\n * @param {number} [width=128] - The width of the grid.\n * @param {number} [height=128] - The height of the grid.\n * @param {number} [cellWidth=32] - The width of one cell in the grid.\n * @param {number} [cellHeight=32] - The height of one cell in the grid.\n * @param {number} [fillColor] - The color the grid cells will be filled with, i.e. 0xff0000 for red.\n * @param {number} [fillAlpha] - The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\n * @param {number} [outlineFillColor] - The color of the lines between the grid cells. See the `setOutline` method.\n * @param {number} [outlineFillAlpha] - The alpha of the lines between the grid cells.\n */\nvar Grid = new Class({\n\n    Extends: Shape,\n\n    Mixins: [\n        GridRender\n    ],\n\n    initialize:\n\n    function Grid (scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha)\n    {\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = 0; }\n        if (width === undefined) { width = 128; }\n        if (height === undefined) { height = 128; }\n        if (cellWidth === undefined) { cellWidth = 32; }\n        if (cellHeight === undefined) { cellHeight = 32; }\n\n        Shape.call(this, scene, 'Grid', null);\n\n        /**\n         * The width of each grid cell.\n         * Must be a positive value.\n         *\n         * @name Phaser.GameObjects.Grid#cellWidth\n         * @type {number}\n         * @since 3.13.0\n         */\n        this.cellWidth = cellWidth;\n\n        /**\n         * The height of each grid cell.\n         * Must be a positive value.\n         *\n         * @name Phaser.GameObjects.Grid#cellHeight\n         * @type {number}\n         * @since 3.13.0\n         */\n        this.cellHeight = cellHeight;\n\n        /**\n         * Will the grid render its cells in the `fillColor`?\n         *\n         * @name Phaser.GameObjects.Grid#showCells\n         * @type {boolean}\n         * @since 3.13.0\n         */\n        this.showCells = true;\n\n        /**\n         * The color of the lines between each grid cell.\n         *\n         * @name Phaser.GameObjects.Grid#outlineFillColor\n         * @type {number}\n         * @since 3.13.0\n         */\n        this.outlineFillColor = 0;\n\n        /**\n         * The alpha value for the color of the lines between each grid cell.\n         *\n         * @name Phaser.GameObjects.Grid#outlineFillAlpha\n         * @type {number}\n         * @since 3.13.0\n         */\n        this.outlineFillAlpha = 0;\n\n        /**\n         * Will the grid display the lines between each cell when it renders?\n         *\n         * @name Phaser.GameObjects.Grid#showOutline\n         * @type {boolean}\n         * @since 3.13.0\n         */\n        this.showOutline = true;\n\n        /**\n         * Will the grid render the alternating cells in the `altFillColor`?\n         *\n         * @name Phaser.GameObjects.Grid#showAltCells\n         * @type {boolean}\n         * @since 3.13.0\n         */\n        this.showAltCells = false;\n\n        /**\n         * The color the alternating grid cells will be filled with, i.e. 0xff0000 for red.\n         *\n         * @name Phaser.GameObjects.Grid#altFillColor\n         * @type {number}\n         * @since 3.13.0\n         */\n        this.altFillColor;\n\n        /**\n         * The alpha the alternating grid cells will be filled with.\n         * You can also set the alpha of the overall Shape using its `alpha` property.\n         *\n         * @name Phaser.GameObjects.Grid#altFillAlpha\n         * @type {number}\n         * @since 3.13.0\n         */\n        this.altFillAlpha;\n\n        this.setPosition(x, y);\n        this.setSize(width, height);\n\n        this.setFillStyle(fillColor, fillAlpha);\n\n        if (outlineFillColor !== undefined)\n        {\n            this.setOutlineStyle(outlineFillColor, outlineFillAlpha);\n        }\n\n        this.updateDisplayOrigin();\n    },\n\n    /**\n     * Sets the fill color and alpha level the grid cells will use when rendering.\n     *\n     * If this method is called with no values then the grid cells will not be rendered,\n     * however the grid lines and alternating cells may still be.\n     *\n     * Also see the `setOutlineStyle` and `setAltFillStyle` methods.\n     *\n     * This call can be chained.\n     *\n     * @method Phaser.GameObjects.Grid#setFillStyle\n     * @since 3.13.0\n     *\n     * @param {number} [fillColor] - The color the grid cells will be filled with, i.e. 0xff0000 for red.\n     * @param {number} [fillAlpha=1] - The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setFillStyle: function (fillColor, fillAlpha)\n    {\n        if (fillAlpha === undefined) { fillAlpha = 1; }\n\n        if (fillColor === undefined)\n        {\n            this.showCells = false;\n        }\n        else\n        {\n            this.fillColor = fillColor;\n            this.fillAlpha = fillAlpha;\n            this.showCells = true;\n        }\n\n        return this;\n    },\n\n    /**\n     * Sets the fill color and alpha level that the alternating grid cells will use.\n     *\n     * If this method is called with no values then alternating grid cells will not be rendered in a different color.\n     *\n     * Also see the `setOutlineStyle` and `setFillStyle` methods.\n     *\n     * This call can be chained.\n     *\n     * @method Phaser.GameObjects.Grid#setAltFillStyle\n     * @since 3.13.0\n     *\n     * @param {number} [fillColor] - The color the alternating grid cells will be filled with, i.e. 0xff0000 for red.\n     * @param {number} [fillAlpha=1] - The alpha the alternating grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setAltFillStyle: function (fillColor, fillAlpha)\n    {\n        if (fillAlpha === undefined) { fillAlpha = 1; }\n\n        if (fillColor === undefined)\n        {\n            this.showAltCells = false;\n        }\n        else\n        {\n            this.altFillColor = fillColor;\n            this.altFillAlpha = fillAlpha;\n            this.showAltCells = true;\n        }\n\n        return this;\n    },\n\n    /**\n     * Sets the fill color and alpha level that the lines between each grid cell will use.\n     *\n     * If this method is called with no values then the grid lines will not be rendered at all, however\n     * the cells themselves may still be if they have colors set.\n     *\n     * Also see the `setFillStyle` and `setAltFillStyle` methods.\n     *\n     * This call can be chained.\n     *\n     * @method Phaser.GameObjects.Grid#setOutlineStyle\n     * @since 3.13.0\n     *\n     * @param {number} [fillColor] - The color the lines between the grid cells will be filled with, i.e. 0xff0000 for red.\n     * @param {number} [fillAlpha=1] - The alpha the lines between the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setOutlineStyle: function (fillColor, fillAlpha)\n    {\n        if (fillAlpha === undefined) { fillAlpha = 1; }\n\n        if (fillColor === undefined)\n        {\n            this.showOutline = false;\n        }\n        else\n        {\n            this.outlineFillColor = fillColor;\n            this.outlineFillAlpha = fillAlpha;\n            this.showOutline = true;\n        }\n\n        return this;\n    }\n\n});\n\nmodule.exports = Grid;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar IsoBoxRender = require('./IsoBoxRender');\r\nvar Class = require('../../../utils/Class');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The IsoBox Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports only fill colors and cannot be stroked.\r\n * \r\n * An IsoBox is an 'isometric' rectangle. Each face of it has a different fill color. You can set\r\n * the color of the top, left and right faces of the rectangle respectively. You can also choose\r\n * which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.\r\n * \r\n * You cannot view an IsoBox from under-neath, however you can change the 'angle' by setting\r\n * the `projection` property.\r\n *\r\n * @class IsoBox\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [size=48] - The width of the iso box in pixels. The left and right faces will be exactly half this value.\r\n * @param {number} [height=32] - The height of the iso box. The left and right faces will be this tall. The overall height of the isobox will be this value plus half the `size` value.\r\n * @param {number} [fillTop=0xeeeeee] - The fill color of the top face of the iso box.\r\n * @param {number} [fillLeft=0x999999] - The fill color of the left face of the iso box.\r\n * @param {number} [fillRight=0xcccccc] - The fill color of the right face of the iso box.\r\n */\r\nvar IsoBox = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        IsoBoxRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function IsoBox (scene, x, y, size, height, fillTop, fillLeft, fillRight)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (size === undefined) { size = 48; }\r\n        if (height === undefined) { height = 32; }\r\n        if (fillTop === undefined) { fillTop = 0xeeeeee; }\r\n        if (fillLeft === undefined) { fillLeft = 0x999999; }\r\n        if (fillRight === undefined) { fillRight = 0xcccccc; }\r\n\r\n        Shape.call(this, scene, 'IsoBox', null);\r\n\r\n        /**\r\n         * The projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#projection\r\n         * @type {number}\r\n         * @default 4\r\n         * @since 3.13.0\r\n         */\r\n        this.projection = 4;\r\n\r\n        /**\r\n         * The color used to fill in the top of the iso box.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#fillTop\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillTop = fillTop;\r\n\r\n        /**\r\n         * The color used to fill in the left-facing side of the iso box.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#fillLeft\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillLeft = fillLeft;\r\n\r\n        /**\r\n         * The color used to fill in the right-facing side of the iso box.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#fillRight\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillRight = fillRight;\r\n\r\n        /**\r\n         * Controls if the top-face of the iso box be rendered.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#showTop\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.13.0\r\n         */\r\n        this.showTop = true;\r\n\r\n        /**\r\n         * Controls if the left-face of the iso box be rendered.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#showLeft\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.13.0\r\n         */\r\n        this.showLeft = true;\r\n\r\n        /**\r\n         * Controls if the right-face of the iso box be rendered.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#showRight\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.13.0\r\n         */\r\n        this.showRight = true;\r\n\r\n        this.isFilled = true;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(size, height);\r\n\r\n        this.updateDisplayOrigin();\r\n    },\r\n\r\n    /**\r\n     * Sets the projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoBox#setProjection\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the projection to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setProjection: function (value)\r\n    {\r\n        this.projection = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets which faces of the iso box will be rendered.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoBox#setFaces\r\n     * @since 3.13.0\r\n     * \r\n     * @param {boolean} [showTop=true] - Show the top-face of the iso box.\r\n     * @param {boolean} [showLeft=true] - Show the left-face of the iso box.\r\n     * @param {boolean} [showRight=true] - Show the right-face of the iso box.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFaces: function (showTop, showLeft, showRight)\r\n    {\r\n        if (showTop === undefined) { showTop = true; }\r\n        if (showLeft === undefined) { showLeft = true; }\r\n        if (showRight === undefined) { showRight = true; }\r\n\r\n        this.showTop = showTop;\r\n        this.showLeft = showLeft;\r\n        this.showRight = showRight;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the fill colors for each face of the iso box.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoBox#setFillStyle\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} [fillTop] - The color used to fill the top of the iso box.\r\n     * @param {number} [fillLeft] - The color used to fill in the left-facing side of the iso box.\r\n     * @param {number} [fillRight] - The color used to fill in the right-facing side of the iso box.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFillStyle: function (fillTop, fillLeft, fillRight)\r\n    {\r\n        this.fillTop = fillTop;\r\n        this.fillLeft = fillLeft;\r\n        this.fillRight = fillRight;\r\n\r\n        this.isFilled = true;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = IsoBox;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar IsoTriangleRender = require('./IsoTriangleRender');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The IsoTriangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports only fill colors and cannot be stroked.\r\n * \r\n * An IsoTriangle is an 'isometric' triangle. Think of it like a pyramid. Each face has a different\r\n * fill color. You can set the color of the top, left and right faces of the triangle respectively\r\n * You can also choose which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.\r\n * \r\n * You cannot view an IsoTriangle from under-neath, however you can change the 'angle' by setting\r\n * the `projection` property. The `reversed` property controls if the IsoTriangle is rendered upside\r\n * down or not.\r\n *\r\n * @class IsoTriangle\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [size=48] - The width of the iso triangle in pixels. The left and right faces will be exactly half this value.\r\n * @param {number} [height=32] - The height of the iso triangle. The left and right faces will be this tall. The overall height of the iso triangle will be this value plus half the `size` value.\r\n * @param {boolean} [reversed=false] - Is the iso triangle upside down?\r\n * @param {number} [fillTop=0xeeeeee] - The fill color of the top face of the iso triangle.\r\n * @param {number} [fillLeft=0x999999] - The fill color of the left face of the iso triangle.\r\n * @param {number} [fillRight=0xcccccc] - The fill color of the right face of the iso triangle.\r\n */\r\nvar IsoTriangle = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        IsoTriangleRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function IsoTriangle (scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (size === undefined) { size = 48; }\r\n        if (height === undefined) { height = 32; }\r\n        if (reversed === undefined) { reversed = false; }\r\n        if (fillTop === undefined) { fillTop = 0xeeeeee; }\r\n        if (fillLeft === undefined) { fillLeft = 0x999999; }\r\n        if (fillRight === undefined) { fillRight = 0xcccccc; }\r\n\r\n        Shape.call(this, scene, 'IsoTriangle', null);\r\n\r\n        /**\r\n         * The projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#projection\r\n         * @type {number}\r\n         * @default 4\r\n         * @since 3.13.0\r\n         */\r\n        this.projection = 4;\r\n\r\n        /**\r\n         * The color used to fill in the top of the iso triangle. This is only used if the triangle is reversed.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#fillTop\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillTop = fillTop;\r\n\r\n        /**\r\n         * The color used to fill in the left-facing side of the iso triangle.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#fillLeft\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillLeft = fillLeft;\r\n\r\n        /**\r\n         * The color used to fill in the right-facing side of the iso triangle.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#fillRight\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillRight = fillRight;\r\n\r\n        /**\r\n         * Controls if the top-face of the iso triangle be rendered.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#showTop\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.13.0\r\n         */\r\n        this.showTop = true;\r\n\r\n        /**\r\n         * Controls if the left-face of the iso triangle be rendered.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#showLeft\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.13.0\r\n         */\r\n        this.showLeft = true;\r\n\r\n        /**\r\n         * Controls if the right-face of the iso triangle be rendered.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#showRight\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.13.0\r\n         */\r\n        this.showRight = true;\r\n\r\n        /**\r\n         * Sets if the iso triangle will be rendered upside down or not.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#isReversed\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.13.0\r\n         */\r\n        this.isReversed = reversed;\r\n\r\n        this.isFilled = true;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(size, height);\r\n\r\n        this.updateDisplayOrigin();\r\n    },\r\n\r\n    /**\r\n     * Sets the projection level of the iso triangle. Change this to change the 'angle' at which you are looking at the pyramid.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoTriangle#setProjection\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the projection to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setProjection: function (value)\r\n    {\r\n        this.projection = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets if the iso triangle will be rendered upside down or not.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoTriangle#setReversed\r\n     * @since 3.13.0\r\n     * \r\n     * @param {boolean} reversed - Sets if the iso triangle will be rendered upside down or not.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setReversed: function (reversed)\r\n    {\r\n        this.isReversed = reversed;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets which faces of the iso triangle will be rendered.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoTriangle#setFaces\r\n     * @since 3.13.0\r\n     * \r\n     * @param {boolean} [showTop=true] - Show the top-face of the iso triangle (only if `reversed` is true)\r\n     * @param {boolean} [showLeft=true] - Show the left-face of the iso triangle.\r\n     * @param {boolean} [showRight=true] - Show the right-face of the iso triangle.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFaces: function (showTop, showLeft, showRight)\r\n    {\r\n        if (showTop === undefined) { showTop = true; }\r\n        if (showLeft === undefined) { showLeft = true; }\r\n        if (showRight === undefined) { showRight = true; }\r\n\r\n        this.showTop = showTop;\r\n        this.showLeft = showLeft;\r\n        this.showRight = showRight;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the fill colors for each face of the iso triangle.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoTriangle#setFillStyle\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} [fillTop] - The color used to fill the top of the iso triangle.\r\n     * @param {number} [fillLeft] - The color used to fill in the left-facing side of the iso triangle.\r\n     * @param {number} [fillRight] - The color used to fill in the right-facing side of the iso triangle.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFillStyle: function (fillTop, fillLeft, fillRight)\r\n    {\r\n        this.fillTop = fillTop;\r\n        this.fillLeft = fillLeft;\r\n        this.fillRight = fillRight;\r\n\r\n        this.isFilled = true;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = IsoTriangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Shape = require('../Shape');\r\nvar GeomLine = require('../../../geom/line/Line');\r\nvar LineRender = require('./LineRender');\r\n\r\n/**\r\n * @classdesc\r\n * The Line Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n *\r\n * This shape supports only stroke colors and cannot be filled.\r\n *\r\n * A Line Shape allows you to draw a line between two points in your game. You can control the\r\n * stroke color and thickness of the line. In WebGL only you can also specify a different\r\n * thickness for the start and end of the line, allowing you to render lines that taper-off.\r\n *\r\n * If you need to draw multiple lines in a sequence you may wish to use the Polygon Shape instead.\r\n *\r\n * Be aware that as with all Game Objects the default origin is 0.5. If you need to draw a Line\r\n * between two points and want the x1/y1 values to match the x/y values, then set the origin to 0.\r\n *\r\n * @class Line\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [x1=0] - The horizontal position of the start of the line.\r\n * @param {number} [y1=0] - The vertical position of the start of the line.\r\n * @param {number} [x2=128] - The horizontal position of the end of the line.\r\n * @param {number} [y2=0] - The vertical position of the end of the line.\r\n * @param {number} [strokeColor] - The color the line will be drawn in, i.e. 0xff0000 for red.\r\n * @param {number} [strokeAlpha] - The alpha the line will be drawn in. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Line = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        LineRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Line (scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (x1 === undefined) { x1 = 0; }\r\n        if (y1 === undefined) { y1 = 0; }\r\n        if (x2 === undefined) { x2 = 128; }\r\n        if (y2 === undefined) { y2 = 0; }\r\n\r\n        Shape.call(this, scene, 'Line', new GeomLine(x1, y1, x2, y2));\r\n\r\n        var width = Math.max(1, this.geom.right - this.geom.left);\r\n        var height = Math.max(1, this.geom.bottom - this.geom.top);\r\n\r\n        /**\r\n         * The width (or thickness) of the line.\r\n         * See the setLineWidth method for extra details on changing this on WebGL.\r\n         *\r\n         * @name Phaser.GameObjects.Line#lineWidth\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.lineWidth = 1;\r\n\r\n        /**\r\n         * Private internal value. Holds the start width of the line.\r\n         *\r\n         * @name Phaser.GameObjects.Line#_startWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._startWidth = 1;\r\n\r\n        /**\r\n         * Private internal value. Holds the end width of the line.\r\n         *\r\n         * @name Phaser.GameObjects.Line#_endWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._endWidth = 1;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(width, height);\r\n\r\n        if (strokeColor !== undefined)\r\n        {\r\n            this.setStrokeStyle(1, strokeColor, strokeAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n    },\r\n\r\n    /**\r\n     * Sets the width of the line.\r\n     *\r\n     * When using the WebGL renderer you can have different start and end widths.\r\n     * When using the Canvas renderer only the `startWidth` value is used. The `endWidth` is ignored.\r\n     *\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Line#setLineWidth\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} startWidth - The start width of the line.\r\n     * @param {number} [endWidth] - The end width of the line. Only used in WebGL.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setLineWidth: function (startWidth, endWidth)\r\n    {\r\n        if (endWidth === undefined) { endWidth = startWidth; }\r\n\r\n        this._startWidth = startWidth;\r\n        this._endWidth = endWidth;\r\n\r\n        this.lineWidth = startWidth;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the start and end coordinates of this Line.\r\n     *\r\n     * @method Phaser.GameObjects.Line#setTo\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} [x1=0] - The horizontal position of the start of the line.\r\n     * @param {number} [y1=0] - The vertical position of the start of the line.\r\n     * @param {number} [x2=0] - The horizontal position of the end of the line.\r\n     * @param {number} [y2=0] - The vertical position of the end of the line.\r\n     *\r\n     * @return {this} This Line object.\r\n     */\r\n    setTo: function (x1, y1, x2, y2)\r\n    {\r\n        this.geom.setTo(x1, y1, x2, y2);\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Line;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PolygonRender = require('./PolygonRender');\r\nvar Class = require('../../../utils/Class');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar GetAABB = require('../../../geom/polygon/GetAABB');\r\nvar GeomPolygon = require('../../../geom/polygon/Polygon');\r\nvar Shape = require('../Shape');\r\nvar Smooth = require('../../../geom/polygon/Smooth');\r\n\r\n/**\r\n * @classdesc\r\n * The Polygon Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * The Polygon Shape is created by providing a list of points, which are then used to create an\r\n * internal Polygon geometry object. The points can be set from a variety of formats:\r\n *\r\n * - A string containing paired values separated by a single space: `'40 0 40 20 100 20 100 80 40 80 40 100 0 50'`\r\n * - An array of Point or Vector2 objects: `[new Phaser.Math.Vector2(x1, y1), ...]`\r\n * - An array of objects with public x/y properties: `[obj1, obj2, ...]`\r\n * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\r\n * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`\r\n * \r\n * By default the `x` and `y` coordinates of this Shape refer to the center of it. However, depending\r\n * on the coordinates of the points provided, the final shape may be rendered offset from its origin.\r\n *\r\n * @class Polygon\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {any} [points] - The points that make up the polygon.\r\n * @param {number} [fillColor] - The color the polygon will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the polygon will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Polygon = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        PolygonRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Polygon (scene, x, y, points, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        Shape.call(this, scene, 'Polygon', new GeomPolygon(points));\r\n\r\n        var bounds = GetAABB(this.geom);\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(bounds.width, bounds.height);\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Smooths the polygon over the number of iterations specified.\r\n     * The base polygon data will be updated and replaced with the smoothed values.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Polygon#smooth\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} [iterations=1] - The number of times to apply the polygon smoothing.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    smooth: function (iterations)\r\n    {\r\n        if (iterations === undefined) { iterations = 1; }\r\n\r\n        for (var i = 0; i < iterations; i++)\r\n        {\r\n            Smooth(this.geom);\r\n        }\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Polygon#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var path = [];\r\n        var points = this.geom.points;\r\n\r\n        for (var i = 0; i < points.length; i++)\r\n        {\r\n            path.push(points[i].x, points[i].y);\r\n        }\r\n\r\n        path.push(points[0].x, points[0].y);\r\n\r\n        this.pathIndexes = Earcut(path);\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Polygon;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../../utils/Class');\nvar GeomRectangle = require('../../../geom/rectangle/Rectangle');\nvar Shape = require('../Shape');\nvar RectangleRender = require('./RectangleRender');\n\n/**\n * @classdesc\n * The Rectangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\n *\n * This shape supports both fill and stroke colors.\n *\n * You can change the size of the rectangle by changing the `width` and `height` properties.\n *\n * @class Rectangle\n * @extends Phaser.GameObjects.Shape\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.13.0\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {number} [width=128] - The width of the rectangle.\n * @param {number} [height=128] - The height of the rectangle.\n * @param {number} [fillColor] - The color the rectangle will be filled with, i.e. 0xff0000 for red.\n * @param {number} [fillAlpha] - The alpha the rectangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\n */\nvar Rectangle = new Class({\n\n    Extends: Shape,\n\n    Mixins: [\n        RectangleRender\n    ],\n\n    initialize:\n\n    function Rectangle (scene, x, y, width, height, fillColor, fillAlpha)\n    {\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = 0; }\n        if (width === undefined) { width = 128; }\n        if (height === undefined) { height = 128; }\n\n        Shape.call(this, scene, 'Rectangle', new GeomRectangle(0, 0, width, height));\n\n        this.setPosition(x, y);\n        this.setSize(width, height);\n\n        if (fillColor !== undefined)\n        {\n            this.setFillStyle(fillColor, fillAlpha);\n        }\n\n        this.updateDisplayOrigin();\n        this.updateData();\n    },\n\n    /**\n     * Sets the internal size of this Game Object, as used for frame or physics body creation.\n     *\n     * This will not change the size that the Game Object is rendered in-game.\n     * For that you need to either set the scale of the Game Object (`setScale`) or call the\n     * `setDisplaySize` method, which is the same thing as changing the scale but allows you\n     * to do so by giving pixel values.\n     *\n     * If you have enabled this Game Object for input, changing the size will _not_ change the\n     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.\n     *\n     * @method Phaser.GameObjects.Rectangle#setSize\n     * @since 3.13.0\n     *\n     * @param {number} width - The width of this Game Object.\n     * @param {number} height - The height of this Game Object.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setSize: function (width, height)\n    {\n        this.width = width;\n        this.height = height;\n\n        this.geom.setSize(width, height);\n\n        this.updateData();\n\n        return this;\n    },\n\n    /**\n     * Internal method that updates the data and path values.\n     *\n     * @method Phaser.GameObjects.Rectangle#updateData\n     * @private\n     * @since 3.13.0\n     *\n     * @return {this} This Game Object instance.\n     */\n    updateData: function ()\n    {\n        var path = [];\n        var rect = this.geom;\n        var line = this._tempLine;\n\n        rect.getLineA(line);\n\n        path.push(line.x1, line.y1, line.x2, line.y2);\n\n        rect.getLineB(line);\n\n        path.push(line.x2, line.y2);\n\n        rect.getLineC(line);\n\n        path.push(line.x2, line.y2);\n\n        rect.getLineD(line);\n\n        path.push(line.x2, line.y2);\n\n        this.pathData = path;\n\n        return this;\n    }\n\n});\n\nmodule.exports = Rectangle;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar StarRender = require('./StarRender');\r\nvar Class = require('../../../utils/Class');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The Star Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * As the name implies, the Star shape will display a star in your game. You can control several\r\n * aspects of it including the number of points that constitute the star. The default is 5. If\r\n * you change it to 4 it will render as a diamond. If you increase them, you'll get a more spiky\r\n * star shape.\r\n * \r\n * You can also control the inner and outer radius, which is how 'long' each point of the star is.\r\n * Modify these values to create more interesting shapes.\r\n *\r\n * @class Star\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [points=5] - The number of points on the star.\r\n * @param {number} [innerRadius=32] - The inner radius of the star.\r\n * @param {number} [outerRadius=64] - The outer radius of the star.\r\n * @param {number} [fillColor] - The color the star will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the star will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Star = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        StarRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Star (scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (points === undefined) { points = 5; }\r\n        if (innerRadius === undefined) { innerRadius = 32; }\r\n        if (outerRadius === undefined) { outerRadius = 64; }\r\n\r\n        Shape.call(this, scene, 'Star', null);\r\n\r\n        /**\r\n         * Private internal value.\r\n         * The number of points in the star.\r\n         *\r\n         * @name Phaser.GameObjects.Star#_points\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._points = points;\r\n\r\n        /**\r\n         * Private internal value.\r\n         * The inner radius of the star.\r\n         *\r\n         * @name Phaser.GameObjects.Star#_innerRadius\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._innerRadius = innerRadius;\r\n\r\n        /**\r\n         * Private internal value.\r\n         * The outer radius of the star.\r\n         *\r\n         * @name Phaser.GameObjects.Star#_outerRadius\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._outerRadius = outerRadius;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(outerRadius * 2, outerRadius * 2);\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the number of points that make up the Star shape.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Star#setPoints\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The amount of points the Star will have.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setPoints: function (value)\r\n    {\r\n        this._points = value;\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the inner radius of the Star shape.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Star#setInnerRadius\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The amount to set the inner radius to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setInnerRadius: function (value)\r\n    {\r\n        this._innerRadius = value;\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the outer radius of the Star shape.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Star#setOuterRadius\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The amount to set the outer radius to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setOuterRadius: function (value)\r\n    {\r\n        this._outerRadius = value;\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * The number of points that make up the Star shape.\r\n     *\r\n     * @name Phaser.GameObjects.Star#points\r\n     * @type {number}\r\n     * @default 5\r\n     * @since 3.13.0\r\n     */\r\n    points: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._points;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._points = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The inner radius of the Star shape.\r\n     *\r\n     * @name Phaser.GameObjects.Star#innerRadius\r\n     * @type {number}\r\n     * @default 32\r\n     * @since 3.13.0\r\n     */\r\n    innerRadius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._innerRadius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._innerRadius = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The outer radius of the Star shape.\r\n     *\r\n     * @name Phaser.GameObjects.Star#outerRadius\r\n     * @type {number}\r\n     * @default 64\r\n     * @since 3.13.0\r\n     */\r\n    outerRadius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._outerRadius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._outerRadius = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Star#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var path = [];\r\n\r\n        var points = this._points;\r\n        var innerRadius = this._innerRadius;\r\n        var outerRadius = this._outerRadius;\r\n\r\n        var rot = Math.PI / 2 * 3;\r\n        var step = Math.PI / points;\r\n\r\n        //  So origin 0.5 = the center of the star\r\n        var x = outerRadius;\r\n        var y = outerRadius;\r\n    \r\n        path.push(x, y + -outerRadius);\r\n\r\n        for (var i = 0; i < points; i++)\r\n        {\r\n            path.push(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);\r\n\r\n            rot += step;\r\n\r\n            path.push(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);\r\n    \r\n            rot += step;\r\n        }\r\n\r\n        path.push(x, y + -outerRadius);\r\n\r\n        this.pathIndexes = Earcut(path);\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Star;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Shape = require('../Shape');\r\nvar GeomTriangle = require('../../../geom/triangle/Triangle');\r\nvar TriangleRender = require('./TriangleRender');\r\n\r\n/**\r\n * @classdesc\r\n * The Triangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * The Triangle consists of 3 lines, joining up to form a triangular shape. You can control the\r\n * position of each point of these lines. The triangle is always closed and cannot have an open\r\n * face. If you require that, consider using a Polygon instead.\r\n *\r\n * @class Triangle\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [x1=0] - The horizontal position of the first point in the triangle.\r\n * @param {number} [y1=128] - The vertical position of the first point in the triangle.\r\n * @param {number} [x2=64] - The horizontal position of the second point in the triangle.\r\n * @param {number} [y2=0] - The vertical position of the second point in the triangle.\r\n * @param {number} [x3=128] - The horizontal position of the third point in the triangle.\r\n * @param {number} [y3=128] - The vertical position of the third point in the triangle.\r\n * @param {number} [fillColor] - The color the triangle will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the triangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Triangle = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        TriangleRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Triangle (scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (x1 === undefined) { x1 = 0; }\r\n        if (y1 === undefined) { y1 = 128; }\r\n        if (x2 === undefined) { x2 = 64; }\r\n        if (y2 === undefined) { y2 = 0; }\r\n        if (x3 === undefined) { x3 = 128; }\r\n        if (y3 === undefined) { y3 = 128; }\r\n\r\n        Shape.call(this, scene, 'Triangle', new GeomTriangle(x1, y1, x2, y2, x3, y3));\r\n\r\n        var width = this.geom.right - this.geom.left;\r\n        var height = this.geom.bottom - this.geom.top;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(width, height);\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the data for the lines that make up this Triangle shape.\r\n     *\r\n     * @method Phaser.GameObjects.Triangle#setTo\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} [x1=0] - The horizontal position of the first point in the triangle.\r\n     * @param {number} [y1=0] - The vertical position of the first point in the triangle.\r\n     * @param {number} [x2=0] - The horizontal position of the second point in the triangle.\r\n     * @param {number} [y2=0] - The vertical position of the second point in the triangle.\r\n     * @param {number} [x3=0] - The horizontal position of the third point in the triangle.\r\n     * @param {number} [y3=0] - The vertical position of the third point in the triangle.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setTo: function (x1, y1, x2, y2, x3, y3)\r\n    {\r\n        this.geom.setTo(x1, y1, x2, y2, x3, y3);\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Triangle#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var path = [];\r\n        var tri = this.geom;\r\n        var line = this._tempLine;\r\n\r\n        tri.getLineA(line);\r\n\r\n        path.push(line.x1, line.y1, line.x2, line.y2);\r\n\r\n        tri.getLineB(line);\r\n\r\n        path.push(line.x2, line.y2);\r\n\r\n        tri.getLineC(line);\r\n\r\n        path.push(line.x2, line.y2);\r\n\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Triangle;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Circle = require('../../geom/circle/Circle');\nvar Class = require('../../utils/Class');\nvar Components = require('../components');\nvar RGB = require('../../display/RGB');\nvar Utils = require('../../renderer/webgl/Utils');\n\n/**\n * @classdesc\n * A 2D point light.\n *\n * These are typically created by a {@link Phaser.GameObjects.LightsManager}, available from within a scene via `this.lights`.\n *\n * Any Game Objects using the Light2D pipeline will then be affected by these Lights as long as they have a normal map.\n *\n * They can also simply be used to represent a point light for your own purposes.\n *\n * @class Light\n * @extends Phaser.Geom.Circle\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @extends Phaser.GameObjects.Components.ScrollFactor\n * @extends Phaser.GameObjects.Components.Visible\n *\n * @param {number} x - The horizontal position of the light.\n * @param {number} y - The vertical position of the light.\n * @param {number} radius - The radius of the light.\n * @param {number} r - The red color of the light. A value between 0 and 1.\n * @param {number} g - The green color of the light. A value between 0 and 1.\n * @param {number} b - The blue color of the light. A value between 0 and 1.\n * @param {number} intensity - The intensity of the light.\n */\nvar Light = new Class({\n\n    Extends: Circle,\n\n    Mixins: [\n        Components.ScrollFactor,\n        Components.Visible\n    ],\n\n    initialize:\n\n    function Light (x, y, radius, r, g, b, intensity)\n    {\n        Circle.call(this, x, y, radius);\n\n        /**\n         * The color of the light.\n         *\n         * @name Phaser.GameObjects.Light#color\n         * @type {Phaser.Display.RGB}\n         * @since 3.50.0\n         */\n        this.color = new RGB(r, g, b);\n\n        /**\n         * The intensity of the light.\n         *\n         * @name Phaser.GameObjects.Light#intensity\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.intensity = intensity;\n\n        /**\n         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.\n         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.\n         * If those components are not used by your custom class then you can use this bitmask as you wish.\n         *\n         * @name Phaser.GameObjects.GameObject#renderFlags\n         * @type {number}\n         * @default 15\n         * @since 3.0.0\n         */\n        this.renderFlags = 15;\n\n        /**\n         * A bitmask that controls if this Game Object is drawn by a Camera or not.\n         * Not usually set directly, instead call `Camera.ignore`, however you can\n         * set this property directly using the Camera.id property:\n         *\n         * @example\n         * this.cameraFilter |= camera.id\n         *\n         * @name Phaser.GameObjects.GameObject#cameraFilter\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.cameraFilter = 0;\n\n        this.setScrollFactor(1, 1);\n    },\n\n    /**\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\n     * Also checks the Game Object against the given Cameras exclusion list.\n     *\n     * @method Phaser.GameObjects.Light#willRender\n     * @since 3.50.0\n     *\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\n     *\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\n     */\n    willRender: function (camera)\n    {\n        return !(Light.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));\n    },\n\n    /**\n     * Set the color of the light from a single integer RGB value.\n     *\n     * @method Phaser.GameObjects.Light#setColor\n     * @since 3.0.0\n     *\n     * @param {number} rgb - The integer RGB color of the light.\n     *\n     * @return {this} This Light object.\n     */\n    setColor: function (rgb)\n    {\n        var color = Utils.getFloatsFromUintRGB(rgb);\n\n        this.color.set(color[0], color[1], color[2]);\n\n        return this;\n    },\n\n    /**\n     * Set the intensity of the light.\n     *\n     * @method Phaser.GameObjects.Light#setIntensity\n     * @since 3.0.0\n     *\n     * @param {number} intensity - The intensity of the light.\n     *\n     * @return {this} This Light object.\n     */\n    setIntensity: function (intensity)\n    {\n        this.intensity = intensity;\n\n        return this;\n    },\n\n    /**\n     * Set the radius of the light.\n     *\n     * @method Phaser.GameObjects.Light#setRadius\n     * @since 3.0.0\n     *\n     * @param {number} radius - The radius of the light.\n     *\n     * @return {this} This Light object.\n     */\n    setRadius: function (radius)\n    {\n        this.radius = radius;\n\n        return this;\n    }\n\n});\n\n/**\n * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.\n *\n * @constant {number} RENDER_MASK\n * @memberof Phaser.GameObjects.Light\n * @default\n */\nLight.RENDER_MASK = 15;\n\nmodule.exports = Light;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CircleToRectangle = require('../../geom/intersects/CircleToRectangle');\r\nvar Class = require('../../utils/Class');\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\nvar Light = require('./Light');\r\nvar PointLight = require('../pointlight/PointLight');\r\nvar RGB = require('../../display/RGB');\r\nvar SpliceOne = require('../../utils/array/SpliceOne');\r\nvar StableSort = require('../../utils/array/StableSort');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * @callback LightForEach\r\n *\r\n * @param {Phaser.GameObjects.Light} light - The Light.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Manages Lights for a Scene.\r\n *\r\n * Affects the rendering of Game Objects using the `Light2D` pipeline.\r\n *\r\n * @class LightsManager\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n */\r\nvar LightsManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function LightsManager ()\r\n    {\r\n        /**\r\n         * The Lights in the Scene.\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#lights\r\n         * @type {Phaser.GameObjects.Light[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.lights = [];\r\n\r\n        /**\r\n         * The ambient color.\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#ambientColor\r\n         * @type {Phaser.Display.RGB}\r\n         * @since 3.50.0\r\n         */\r\n        this.ambientColor = new RGB(0.1, 0.1, 0.1);\r\n\r\n        /**\r\n         * Whether the Lights Manager is enabled.\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#active\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.active = false;\r\n\r\n        /**\r\n         * The maximum number of lights that a single Camera and the lights shader can process.\r\n         * Change this via the `maxLights` property in your game config, as it cannot be changed at runtime.\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#maxLights\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.15.0\r\n         */\r\n        this.maxLights = -1;\r\n\r\n        /**\r\n         * The number of lights that the LightPipeline processed in the _previous_ frame.\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#visibleLights\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.visibleLights = 0;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Point Light Game Object and adds it to the Scene.\r\n     *\r\n     * Note: This method will only be available if the Point Light Game Object has been built into Phaser.\r\n     *\r\n     * The Point Light Game Object provides a way to add a point light effect into your game,\r\n     * without the expensive shader processing requirements of the traditional Light Game Object.\r\n     *\r\n     * The difference is that the Point Light renders using a custom shader, designed to give the\r\n     * impression of a point light source, of variable radius, intensity and color, in your game.\r\n     * However, unlike the Light Game Object, it does not impact any other Game Objects, or use their\r\n     * normal maps for calcuations. This makes them extremely fast to render compared to Lights\r\n     * and perfect for special effects, such as flickering torches or muzzle flashes.\r\n     *\r\n     * For maximum performance you should batch Point Light Game Objects together. This means\r\n     * ensuring they follow each other consecutively on the display list. Ideally, use a Layer\r\n     * Game Object and then add just Point Lights to it, so that it can batch together the rendering\r\n     * of the lights. You don't _have_ to do this, and if you've only a handful of Point Lights in\r\n     * your game then it's perfectly safe to mix them into the dislay list as normal. However, if\r\n     * you're using a large number of them, please consider how they are mixed into the display list.\r\n     *\r\n     * The renderer will automatically cull Point Lights. Those with a radius that does not intersect\r\n     * with the Camera will be skipped in the rendering list. This happens automatically and the\r\n     * culled state is refreshed every frame, for every camera.\r\n     *\r\n     * The origin of a Point Light is always 0.5 and it cannot be changed.\r\n     *\r\n     * Point Lights are a WebGL only feature and do not have a Canvas counterpart.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#addPointLight\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Point Light in the world.\r\n     * @param {number} y - The vertical position of this Point Light in the world.\r\n     * @param {number} [color=0xffffff] - The color of the Point Light, given as a hex value.\r\n     * @param {number} [radius=128] - The radius of the Point Light.\r\n     * @param {number} [intensity=1] - The intensity, or colr blend, of the Point Light.\r\n     * @param {number} [attenuation=0.1] - The attenuation  of the Point Light. This is the reduction of light from the center point.\r\n     *\r\n     * @return {Phaser.GameObjects.PointLight} The Game Object that was created.\r\n     */\r\n    addPointLight: function (x, y, color, radius, intensity, attenuation)\r\n    {\r\n        return this.systems.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));\r\n    },\r\n\r\n    /**\r\n     * Enable the Lights Manager.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Lights Manager instance.\r\n     */\r\n    enable: function ()\r\n    {\r\n        if (this.maxLights === -1)\r\n        {\r\n            this.maxLights = this.systems.renderer.config.maxLights;\r\n        }\r\n\r\n        this.active = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Disable the Lights Manager.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Lights Manager instance.\r\n     */\r\n    disable: function ()\r\n    {\r\n        this.active = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Get all lights that can be seen by the given Camera.\r\n     *\r\n     * It will automatically cull lights that are outside the world view of the Camera.\r\n     *\r\n     * If more lights are returned than supported by the pipeline, the lights are then culled\r\n     * based on the distance from the center of the camera. Only those closest are rendered.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#getLights\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to cull Lights for.\r\n     *\r\n     * @return {Phaser.GameObjects.Light[]} The culled Lights.\r\n     */\r\n    getLights: function (camera)\r\n    {\r\n        var lights = this.lights;\r\n        var worldView = camera.worldView;\r\n\r\n        var visibleLights = [];\r\n\r\n        for (var i = 0; i < lights.length; i++)\r\n        {\r\n            var light = lights[i];\r\n\r\n            if (light.willRender(camera) && CircleToRectangle(light, worldView))\r\n            {\r\n                visibleLights.push({\r\n                    light: light,\r\n                    distance: DistanceBetween(light.x, light.y, worldView.centerX, worldView.centerY)\r\n                });\r\n            }\r\n        }\r\n\r\n        if (visibleLights.length > this.maxLights)\r\n        {\r\n            //  We've got too many lights, so sort by distance from camera and cull those far away\r\n            //  This isn't ideal because it doesn't factor in the radius of the lights, but it'll do for now\r\n            //  and is significantly better than we had before!\r\n\r\n            StableSort(visibleLights, this.sortByDistance);\r\n\r\n            visibleLights = visibleLights.slice(0, this.maxLights);\r\n        }\r\n\r\n        this.visibleLights = visibleLights.length;\r\n\r\n        return visibleLights;\r\n    },\r\n\r\n    sortByDistance: function (a, b)\r\n    {\r\n        return (a.distance >= b.distance);\r\n    },\r\n\r\n    /**\r\n     * Set the ambient light color.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#setAmbientColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rgb - The integer RGB color of the ambient light.\r\n     *\r\n     * @return {this} This Lights Manager instance.\r\n     */\r\n    setAmbientColor: function (rgb)\r\n    {\r\n        var color = Utils.getFloatsFromUintRGB(rgb);\r\n\r\n        this.ambientColor.set(color[0], color[1], color[2]);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the maximum number of Lights allowed to appear at once.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#getMaxVisibleLights\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The maximum number of Lights allowed to appear at once.\r\n     */\r\n    getMaxVisibleLights: function ()\r\n    {\r\n        return this.maxLights;\r\n    },\r\n\r\n    /**\r\n     * Get the number of Lights managed by this Lights Manager.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#getLightCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The number of Lights managed by this Lights Manager.\r\n     */\r\n    getLightCount: function ()\r\n    {\r\n        return this.lights.length;\r\n    },\r\n\r\n    /**\r\n     * Add a Light.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#addLight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal position of the Light.\r\n     * @param {number} [y=0] - The vertical position of the Light.\r\n     * @param {number} [radius=128] - The radius of the Light.\r\n     * @param {number} [rgb=0xffffff] - The integer RGB color of the light.\r\n     * @param {number} [intensity=1] - The intensity of the Light.\r\n     *\r\n     * @return {Phaser.GameObjects.Light} The Light that was added.\r\n     */\r\n    addLight: function (x, y, radius, rgb, intensity)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (radius === undefined) { radius = 128; }\r\n        if (rgb === undefined) { rgb = 0xffffff; }\r\n        if (intensity === undefined) { intensity = 1; }\r\n\r\n        var color = Utils.getFloatsFromUintRGB(rgb);\r\n\r\n        var light = new Light(x, y, radius, color[0], color[1], color[2], intensity);\r\n\r\n        this.lights.push(light);\r\n\r\n        return light;\r\n    },\r\n\r\n    /**\r\n     * Remove a Light.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#removeLight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Light} light - The Light to remove.\r\n     *\r\n     * @return {this} This Lights Manager instance.\r\n     */\r\n    removeLight: function (light)\r\n    {\r\n        var index = this.lights.indexOf(light);\r\n\r\n        if (index >= 0)\r\n        {\r\n            SpliceOne(this.lights, index);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shut down the Lights Manager.\r\n     *\r\n     * Recycles all active Lights into the Light pool, resets ambient light color and clears the lists of Lights and\r\n     * culled Lights.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.lights.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Destroy the Lights Manager.\r\n     *\r\n     * Cleans up all references by calling {@link Phaser.GameObjects.LightsManager#shutdown}.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = LightsManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sets the fillStyle on the target context based on the given Shape.\r\n *\r\n * @method Phaser.GameObjects.Shape#FillStyleCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {CanvasRenderingContext2D} ctx - The context to set the fill style on.\r\n * @param {Phaser.GameObjects.Shape} src - The Game Object to set the fill style from.\r\n * @param {number} [altColor] - An alternative color to render with.\r\n * @param {number} [altAlpha] - An alternative alpha to render with.\r\n */\r\nvar FillStyleCanvas = function (ctx, src, altColor, altAlpha)\r\n{\r\n    var fillColor = (altColor) ? altColor : src.fillColor;\r\n    var fillAlpha = (altAlpha) ? altAlpha : src.fillAlpha;\r\n\r\n    var red = ((fillColor & 0xFF0000) >>> 16);\r\n    var green = ((fillColor & 0xFF00) >>> 8);\r\n    var blue = (fillColor & 0xFF);\r\n\r\n    ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';\r\n};\r\n\r\nmodule.exports = FillStyleCanvas;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sets the strokeStyle and lineWidth on the target context based on the given Shape.\r\n *\r\n * @method Phaser.GameObjects.Shape#LineStyleCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {CanvasRenderingContext2D} ctx - The context to set the stroke style on.\r\n * @param {Phaser.GameObjects.Shape} src - The Game Object to set the stroke style from.\r\n * @param {number} [altColor] - An alternative color to render with.\r\n * @param {number} [altAlpha] - An alternative alpha to render with.\r\n */\r\nvar LineStyleCanvas = function (ctx, src, altColor, altAlpha)\r\n{\r\n    var strokeColor = (altColor) ? altColor : src.strokeColor;\r\n    var strokeAlpha = (altAlpha) ? altAlpha : src.strokeAlpha;\r\n\r\n    var red = ((strokeColor & 0xFF0000) >>> 16);\r\n    var green = ((strokeColor & 0xFF00) >>> 8);\r\n    var blue = (strokeColor & 0xFF);\r\n\r\n    ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + strokeAlpha + ')';\r\n    ctx.lineWidth = src.lineWidth;\r\n};\r\n\r\nmodule.exports = LineStyleCanvas;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders a stroke outline around the given Shape.\r\n *\r\n * @method Phaser.GameObjects.Shape#StrokePathWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The WebGL Pipeline used to render this Shape.\r\n * @param {Phaser.GameObjects.Shape} src - The Game Object shape being rendered in this call.\r\n * @param {number} alpha - The base alpha value.\r\n * @param {number} dx - The source displayOriginX.\r\n * @param {number} dy - The source displayOriginY.\r\n */\r\nvar StrokePathWebGL = function (pipeline, src, alpha, dx, dy)\r\n{\r\n    var strokeTint = pipeline.strokeTint;\r\n    var strokeTintColor = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);\r\n\r\n    strokeTint.TL = strokeTintColor;\r\n    strokeTint.TR = strokeTintColor;\r\n    strokeTint.BL = strokeTintColor;\r\n    strokeTint.BR = strokeTintColor;\r\n\r\n    var path = src.pathData;\r\n    var pathLength = path.length - 1;\r\n    var lineWidth = src.lineWidth;\r\n    var halfLineWidth = lineWidth / 2;\r\n\r\n    var px1 = path[0] - dx;\r\n    var py1 = path[1] - dy;\r\n\r\n    if (!src.closePath)\r\n    {\r\n        pathLength -= 2;\r\n    }\r\n\r\n    for (var i = 2; i < pathLength; i += 2)\r\n    {\r\n        var px2 = path[i] - dx;\r\n        var py2 = path[i + 1] - dy;\r\n\r\n        pipeline.batchLine(\r\n            px1,\r\n            py1,\r\n            px2,\r\n            py2,\r\n            halfLineWidth,\r\n            halfLineWidth,\r\n            lineWidth,\r\n            i - 2,\r\n            (src.closePath) ? (i === pathLength - 1) : false\r\n        );\r\n\r\n        px1 = px2;\r\n        py1 = py2;\r\n    }\r\n};\r\n\r\nmodule.exports = StrokePathWebGL;\r\n"],"sourceRoot":""}