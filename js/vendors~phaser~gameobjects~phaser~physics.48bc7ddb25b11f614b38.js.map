{"version":3,"sources":["webpack:///./node_modules/phaser/src/gameobjects/image/ImageRender.js","webpack:///./node_modules/phaser/src/gameobjects/image/ImageWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/image/ImageCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/group/Group.js","webpack:///./node_modules/phaser/src/gameobjects/image/Image.js","webpack:///./node_modules/phaser/src/gameobjects/sprite/SpriteRender.js","webpack:///./node_modules/phaser/src/gameobjects/sprite/SpriteWebGLRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/sprite/SpriteCanvasRenderer.js","webpack:///./node_modules/phaser/src/gameobjects/sprite/Sprite.js"],"names":["renderWebGL","renderCanvas","module","exports","renderer","src","camera","parentMatrix","addToRenderList","this","pipeline","batchSprite","frame","Actions","Class","Events","EventEmitter","GetAll","GetFastValue","GetValue","IsPlainObject","Range","Set","Sprite","Group","Extends","initialize","scene","children","config","call","Array","isArray","isParent","type","classType","name","active","maxSize","defaultKey","defaultFrame","runChildUpdate","createCallback","removeCallback","createMultipleCallback","internalCreateCallback","internalRemoveCallback","addMultiple","createMultiple","on","ADDED_TO_SCENE","addedToScene","REMOVED_FROM_SCENE","removedFromScene","sys","updateList","add","remove","create","x","y","key","visible","undefined","isFull","child","addToDisplayList","displayList","addToUpdateList","setActive","output","i","length","entries","createFromConfig","concat","options","repeat","randomKey","randomFrame","yoyo","quantity","frameQuantity","max","range","qty","random","randomB","c","created","a","b","push","stepX","stepY","SetXY","rotation","stepRotation","SetRotation","scaleX","scaleY","stepScaleX","stepScaleY","SetScale","originX","originY","stepOriginX","stepOriginY","SetOrigin","alpha","stepAlpha","SetAlpha","depth","stepDepth","SetDepth","scrollFactorX","scrollFactorY","stepScrollFactorX","stepScrollFactorY","SetScrollFactor","hitArea","hitAreaCallback","SetHitArea","grid","GridAlign","preUpdate","time","delta","size","temp","slice","item","update","addToScene","set","DESTROY","removeFromScene","destroyChild","contains","delete","off","destroy","removeFromDisplayList","removeFromUpdateList","clear","gameObject","getChildren","getLength","getMatching","property","value","startIndex","endIndex","getFirst","state","createIfNull","getHandler","getFirstNth","nth","getLast","getLastNth","forwards","total","get","getFirstAlive","getFirstDead","playAnimation","startFrame","PlayAnimation","countActive","getTotalUsed","getTotalFree","used","setName","propertyValueSet","step","index","direction","PropertyValueSet","propertyValueInc","PropertyValueInc","setX","SetX","setY","SetY","setXY","incX","IncX","incY","IncY","incXY","IncXY","shiftPosition","ShiftPosition","angle","Angle","rotate","Rotate","rotateAround","point","RotateAround","rotateAroundDistance","distance","RotateAroundDistance","setAlpha","setTint","topLeft","topRight","bottomLeft","bottomRight","SetTint","setOrigin","ScaleX","ScaleY","scaleXY","ScaleXY","setDepth","setBlendMode","SetBlendMode","setHitArea","shuffle","Shuffle","kill","killAndHide","setVisible","SetVisible","toggleVisible","ToggleVisible","destroyChildren","ignoreDestroy","emit","removeAllListeners","Components","GameObject","ImageRender","Image","Mixins","Alpha","BlendMode","Depth","Flip","GetBounds","Mask","Origin","Pipeline","ScrollFactor","Size","TextureCrop","Tint","Transform","Visible","texture","_crop","resetCropObject","setTexture","setPosition","setSizeToFrame","setOriginFromFrame","initPipeline","AnimationState","SpriteRender","anims","play","ignoreIfPlaying","playReverse","playAfterDelay","delay","playAfterRepeat","repeatCount","chain","stop","stopAfterDelay","stopAfterRepeat","stopOnFrame","toJSON","ToJSON","preDestroy"],"mappings":"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","file":"js/vendors~phaser~gameobjects~phaser~physics.48bc7ddb25b11f614b38.js","sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./ImageWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./ImageCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Image#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Image} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ImageWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    this.pipeline.batchSprite(src, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = ImageWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Image#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Image} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ImageCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = ImageCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Actions = require('../../actions/');\r\nvar Class = require('../../utils/Class');\r\nvar Events = require('../events');\r\nvar EventEmitter = require('eventemitter3');\r\nvar GetAll = require('../../utils/array/GetAll');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar Range = require('../../utils/array/Range');\r\nvar Set = require('../../structs/Set');\r\nvar Sprite = require('../sprite/Sprite');\r\n\r\n/**\r\n * @classdesc\r\n * A Group is a way for you to create, manipulate, or recycle similar Game Objects.\r\n *\r\n * Group membership is non-exclusive. A Game Object can belong to several groups, one group, or none.\r\n *\r\n * Groups themselves aren't displayable, and can't be positioned, rotated, scaled, or hidden.\r\n *\r\n * @class Group\r\n * @memberof Phaser.GameObjects\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n * @param {Phaser.Scene} scene - The scene this group belongs to.\r\n * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.\r\n * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group. If `key` is set, Phaser.GameObjects.Group#createMultiple is also called with these settings.\r\n *\r\n * @see Phaser.Physics.Arcade.Group\r\n * @see Phaser.Physics.Arcade.StaticGroup\r\n */\r\nvar Group = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function Group (scene, children, config)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        //  They can pass in any of the following as the first argument:\r\n\r\n        //  1) A single child\r\n        //  2) An array of children\r\n        //  3) A config object\r\n        //  4) An array of config objects\r\n\r\n        //  Or they can pass in a child, or array of children AND a config object\r\n\r\n        if (config)\r\n        {\r\n            //  config has been set, are the children an array?\r\n\r\n            if (children && !Array.isArray(children))\r\n            {\r\n                children = [ children ];\r\n            }\r\n        }\r\n        else if (Array.isArray(children))\r\n        {\r\n            //  No config, so let's check the children argument\r\n\r\n            if (IsPlainObject(children[0]))\r\n            {\r\n                //  It's an array of plain config objects\r\n                config = children;\r\n                children = null;\r\n            }\r\n        }\r\n        else if (IsPlainObject(children))\r\n        {\r\n            //  Children isn't an array. Is it a config object though?\r\n            config = children;\r\n            children = null;\r\n        }\r\n\r\n        /**\r\n         * This scene this group belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.Group#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Members of this group.\r\n         *\r\n         * @name Phaser.GameObjects.Group#children\r\n         * @type {Phaser.Structs.Set.<Phaser.GameObjects.GameObject>}\r\n         * @since 3.0.0\r\n         */\r\n        this.children = new Set();\r\n\r\n        /**\r\n         * A flag identifying this object as a group.\r\n         *\r\n         * @name Phaser.GameObjects.Group#isParent\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.isParent = true;\r\n\r\n        /**\r\n         * A textual representation of this Game Object.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.GameObjects.Group#type\r\n         * @type {string}\r\n         * @default 'Group'\r\n         * @since 3.21.0\r\n         */\r\n        this.type = 'Group';\r\n\r\n        /**\r\n         * The class to create new group members from.\r\n         *\r\n         * @name Phaser.GameObjects.Group#classType\r\n         * @type {Function}\r\n         * @since 3.0.0\r\n         * @default Phaser.GameObjects.Sprite\r\n         */\r\n        this.classType = GetFastValue(config, 'classType', Sprite);\r\n\r\n        /**\r\n         * The name of this group.\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.Group#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.18.0\r\n         */\r\n        this.name = GetFastValue(config, 'name', '');\r\n\r\n        /**\r\n         * Whether this group runs its {@link Phaser.GameObjects.Group#preUpdate} method (which may update any members).\r\n         *\r\n         * @name Phaser.GameObjects.Group#active\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.active = GetFastValue(config, 'active', true);\r\n\r\n        /**\r\n         * The maximum size of this group, if used as a pool. -1 is no limit.\r\n         *\r\n         * @name Phaser.GameObjects.Group#maxSize\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         * @default -1\r\n         */\r\n        this.maxSize = GetFastValue(config, 'maxSize', -1);\r\n\r\n        /**\r\n         * A default texture key to use when creating new group members.\r\n         *\r\n         * This is used in {@link Phaser.GameObjects.Group#create}\r\n         * but not in {@link Phaser.GameObjects.Group#createMultiple}.\r\n         *\r\n         * @name Phaser.GameObjects.Group#defaultKey\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultKey = GetFastValue(config, 'defaultKey', null);\r\n\r\n        /**\r\n         * A default texture frame to use when creating new group members.\r\n         *\r\n         * @name Phaser.GameObjects.Group#defaultFrame\r\n         * @type {(string|number)}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultFrame = GetFastValue(config, 'defaultFrame', null);\r\n\r\n        /**\r\n         * Whether to call the update method of any members.\r\n         *\r\n         * @name Phaser.GameObjects.Group#runChildUpdate\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Group#preUpdate\r\n         */\r\n        this.runChildUpdate = GetFastValue(config, 'runChildUpdate', false);\r\n\r\n        /**\r\n         * A function to be called when adding or creating group members.\r\n         *\r\n         * @name Phaser.GameObjects.Group#createCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.createCallback = GetFastValue(config, 'createCallback', null);\r\n\r\n        /**\r\n         * A function to be called when removing group members.\r\n         *\r\n         * @name Phaser.GameObjects.Group#removeCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.removeCallback = GetFastValue(config, 'removeCallback', null);\r\n\r\n        /**\r\n         * A function to be called when creating several group members at once.\r\n         *\r\n         * @name Phaser.GameObjects.Group#createMultipleCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupMultipleCreateCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.createMultipleCallback = GetFastValue(config, 'createMultipleCallback', null);\r\n\r\n        /**\r\n         * A function to be called when adding or creating group members.\r\n         * For internal use only by a Group, or any class that extends it.\r\n         *\r\n         * @name Phaser.GameObjects.Group#internalCreateCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n         * @private\r\n         * @since 3.22.0\r\n         */\r\n        this.internalCreateCallback = GetFastValue(config, 'internalCreateCallback', null);\r\n\r\n        /**\r\n         * A function to be called when removing group members.\r\n         * For internal use only by a Group, or any class that extends it.\r\n         *\r\n         * @name Phaser.GameObjects.Group#internalRemoveCallback\r\n         * @type {?Phaser.Types.GameObjects.Group.GroupCallback}\r\n         * @private\r\n         * @since 3.22.0\r\n         */\r\n        this.internalRemoveCallback = GetFastValue(config, 'internalRemoveCallback', null);\r\n\r\n        if (children)\r\n        {\r\n            this.addMultiple(children);\r\n        }\r\n\r\n        if (config)\r\n        {\r\n            this.createMultiple(config);\r\n        }\r\n\r\n        this.on(Events.ADDED_TO_SCENE, this.addedToScene, this);\r\n        this.on(Events.REMOVED_FROM_SCENE, this.removedFromScene, this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * Creates a new Game Object and adds it to this group, unless the group {@link Phaser.GameObjects.Group#isFull is full}.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#createCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal position of the new Game Object in the world.\r\n     * @param {number} [y=0] - The vertical position of the new Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key of the new Game Object.\r\n     * @param {(string|number)} [frame=defaultFrame] - The texture frame of the new Game Object.\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of the new Game Object.\r\n     * @param {boolean} [active=true] - The {@link Phaser.GameObjects.GameObject#active} state of the new Game Object.\r\n     *\r\n     * @return {any} The new Game Object (usually a Sprite, etc.).\r\n     */\r\n    create: function (x, y, key, frame, visible, active)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (key === undefined) { key = this.defaultKey; }\r\n        if (frame === undefined) { frame = this.defaultFrame; }\r\n        if (visible === undefined) { visible = true; }\r\n        if (active === undefined) { active = true; }\r\n\r\n        //  Pool?\r\n        if (this.isFull())\r\n        {\r\n            return null;\r\n        }\r\n\r\n        var child = new this.classType(this.scene, x, y, key, frame);\r\n\r\n        child.addToDisplayList(this.scene.sys.displayList);\r\n        child.addToUpdateList();\r\n\r\n        child.visible = visible;\r\n        child.setActive(active);\r\n\r\n        this.add(child);\r\n\r\n        return child;\r\n    },\r\n\r\n    /**\r\n     * Creates several Game Objects and adds them to this group.\r\n     *\r\n     * If the group becomes {@link Phaser.GameObjects.Group#isFull}, no further Game Objects are created.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#createMultipleCallback} and {@link Phaser.GameObjects.Group#createCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#createMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Group.GroupCreateConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig[]} config - Creation settings. This can be a single configuration object or an array of such objects, which will be applied in turn.\r\n     *\r\n     * @return {any[]} The newly created Game Objects.\r\n     */\r\n    createMultiple: function (config)\r\n    {\r\n        if (this.isFull())\r\n        {\r\n            return [];\r\n        }\r\n\r\n        if (!Array.isArray(config))\r\n        {\r\n            config = [ config ];\r\n        }\r\n\r\n        var output = [];\r\n\r\n        if (config[0].key)\r\n        {\r\n            for (var i = 0; i < config.length; i++)\r\n            {\r\n                var entries = this.createFromConfig(config[i]);\r\n\r\n                output = output.concat(entries);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * A helper for {@link Phaser.GameObjects.Group#createMultiple}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#createFromConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Group.GroupCreateConfig} options - Creation settings.\r\n     *\r\n     * @return {any[]} The newly created Game Objects.\r\n     */\r\n    createFromConfig: function (options)\r\n    {\r\n        if (this.isFull())\r\n        {\r\n            return [];\r\n        }\r\n\r\n        this.classType = GetFastValue(options, 'classType', this.classType);\r\n\r\n        var key = GetFastValue(options, 'key', undefined);\r\n        var frame = GetFastValue(options, 'frame', null);\r\n        var visible = GetFastValue(options, 'visible', true);\r\n        var active = GetFastValue(options, 'active', true);\r\n\r\n        var entries = [];\r\n\r\n        //  Can't do anything without at least a key\r\n        if (key === undefined)\r\n        {\r\n            return entries;\r\n        }\r\n        else\r\n        {\r\n            if (!Array.isArray(key))\r\n            {\r\n                key = [ key ];\r\n            }\r\n\r\n            if (!Array.isArray(frame))\r\n            {\r\n                frame = [ frame ];\r\n            }\r\n        }\r\n\r\n        //  Build an array of key frame pairs to loop through\r\n\r\n        var repeat = GetFastValue(options, 'repeat', 0);\r\n        var randomKey = GetFastValue(options, 'randomKey', false);\r\n        var randomFrame = GetFastValue(options, 'randomFrame', false);\r\n        var yoyo = GetFastValue(options, 'yoyo', false);\r\n        var quantity = GetFastValue(options, 'quantity', false);\r\n        var frameQuantity = GetFastValue(options, 'frameQuantity', 1);\r\n        var max = GetFastValue(options, 'max', 0);\r\n\r\n        //  If a quantity value is set we use that to override the frameQuantity\r\n\r\n        var range = Range(key, frame, {\r\n            max: max,\r\n            qty: (quantity) ? quantity : frameQuantity,\r\n            random: randomKey,\r\n            randomB: randomFrame,\r\n            repeat: repeat,\r\n            yoyo: yoyo\r\n        });\r\n\r\n        if (options.createCallback)\r\n        {\r\n            this.createCallback = options.createCallback;\r\n        }\r\n\r\n        if (options.removeCallback)\r\n        {\r\n            this.removeCallback = options.removeCallback;\r\n        }\r\n\r\n        for (var c = 0; c < range.length; c++)\r\n        {\r\n            var created = this.create(0, 0, range[c].a, range[c].b, visible, active);\r\n\r\n            if (!created)\r\n            {\r\n                break;\r\n            }\r\n\r\n            entries.push(created);\r\n        }\r\n\r\n        //  Post-creation options (applied only to those items created in this call):\r\n\r\n        var x = GetValue(options, 'setXY.x', 0);\r\n        var y = GetValue(options, 'setXY.y', 0);\r\n        var stepX = GetValue(options, 'setXY.stepX', 0);\r\n        var stepY = GetValue(options, 'setXY.stepY', 0);\r\n\r\n        Actions.SetXY(entries, x, y, stepX, stepY);\r\n\r\n        var rotation = GetValue(options, 'setRotation.value', 0);\r\n        var stepRotation = GetValue(options, 'setRotation.step', 0);\r\n\r\n        Actions.SetRotation(entries, rotation, stepRotation);\r\n\r\n        var scaleX = GetValue(options, 'setScale.x', 1);\r\n        var scaleY = GetValue(options, 'setScale.y', scaleX);\r\n        var stepScaleX = GetValue(options, 'setScale.stepX', 0);\r\n        var stepScaleY = GetValue(options, 'setScale.stepY', 0);\r\n\r\n        Actions.SetScale(entries, scaleX, scaleY, stepScaleX, stepScaleY);\r\n\r\n        var originX = GetValue(options, 'setOrigin.x', 0.5);\r\n        var originY = GetValue(options, 'setOrigin.y', originX);\r\n        var stepOriginX = GetValue(options, 'setOrigin.stepX', 0);\r\n        var stepOriginY = GetValue(options, 'setOrigin.stepY', 0);\r\n\r\n        Actions.SetOrigin(entries, originX, originY, stepOriginX, stepOriginY);\r\n\r\n        var alpha = GetValue(options, 'setAlpha.value', 1);\r\n        var stepAlpha = GetValue(options, 'setAlpha.step', 0);\r\n\r\n        Actions.SetAlpha(entries, alpha, stepAlpha);\r\n\r\n        var depth = GetValue(options, 'setDepth.value', 0);\r\n        var stepDepth = GetValue(options, 'setDepth.step', 0);\r\n\r\n        Actions.SetDepth(entries, depth, stepDepth);\r\n\r\n        var scrollFactorX = GetValue(options, 'setScrollFactor.x', 1);\r\n        var scrollFactorY = GetValue(options, 'setScrollFactor.y', scrollFactorX);\r\n        var stepScrollFactorX = GetValue(options, 'setScrollFactor.stepX', 0);\r\n        var stepScrollFactorY = GetValue(options, 'setScrollFactor.stepY', 0);\r\n\r\n        Actions.SetScrollFactor(entries, scrollFactorX, scrollFactorY, stepScrollFactorX, stepScrollFactorY);\r\n\r\n        var hitArea = GetFastValue(options, 'hitArea', null);\r\n        var hitAreaCallback = GetFastValue(options, 'hitAreaCallback', null);\r\n\r\n        if (hitArea)\r\n        {\r\n            Actions.SetHitArea(entries, hitArea, hitAreaCallback);\r\n        }\r\n\r\n        var grid = GetFastValue(options, 'gridAlign', false);\r\n\r\n        if (grid)\r\n        {\r\n            Actions.GridAlign(entries, grid);\r\n        }\r\n\r\n        if (this.createMultipleCallback)\r\n        {\r\n            this.createMultipleCallback.call(this, entries);\r\n        }\r\n\r\n        return entries;\r\n    },\r\n\r\n    /**\r\n     * Updates any group members, if {@link Phaser.GameObjects.Group#runChildUpdate} is enabled.\r\n     *\r\n     * @method Phaser.GameObjects.Group#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time elapsed since the last frame.\r\n     */\r\n    preUpdate: function (time, delta)\r\n    {\r\n        if (!this.runChildUpdate || this.children.size === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Because a Group child may mess with the length of the Group during its update\r\n        var temp = this.children.entries.slice();\r\n\r\n        for (var i = 0; i < temp.length; i++)\r\n        {\r\n            var item = temp[i];\r\n\r\n            if (item.active)\r\n            {\r\n                item.update(time, delta);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a Game Object to this group.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#createCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.\r\n     * @param {boolean} [addToScene=false] - Also add the Game Object to the scene.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    add: function (child, addToScene)\r\n    {\r\n        if (addToScene === undefined) { addToScene = false; }\r\n\r\n        if (this.isFull())\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.children.set(child);\r\n\r\n        if (this.internalCreateCallback)\r\n        {\r\n            this.internalCreateCallback.call(this, child);\r\n        }\r\n\r\n        if (this.createCallback)\r\n        {\r\n            this.createCallback.call(this, child);\r\n        }\r\n\r\n        if (addToScene)\r\n        {\r\n            child.addToDisplayList(this.scene.sys.displayList);\r\n            child.addToUpdateList();\r\n        }\r\n\r\n        child.on(Events.DESTROY, this.remove, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds several Game Objects to this group.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#createCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#addMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} children - The Game Objects to add.\r\n     * @param {boolean} [addToScene=false] - Also add the Game Objects to the scene.\r\n     *\r\n     * @return {this} This group.\r\n     */\r\n    addMultiple: function (children, addToScene)\r\n    {\r\n        if (addToScene === undefined) { addToScene = false; }\r\n\r\n        if (Array.isArray(children))\r\n        {\r\n            for (var i = 0; i < children.length; i++)\r\n            {\r\n                this.add(children[i], addToScene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a member of this Group and optionally removes it from the Scene and / or destroys it.\r\n     *\r\n     * Calls {@link Phaser.GameObjects.Group#removeCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.\r\n     * @param {boolean} [removeFromScene=false] - Optionally remove the Group member from the Scene it belongs to.\r\n     * @param {boolean} [destroyChild=false] - Optionally call destroy on the removed Group member.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    remove: function (child, removeFromScene, destroyChild)\r\n    {\r\n        if (removeFromScene === undefined) { removeFromScene = false; }\r\n        if (destroyChild === undefined) { destroyChild = false; }\r\n\r\n        if (!this.children.contains(child))\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.children.delete(child);\r\n\r\n        if (this.internalRemoveCallback)\r\n        {\r\n            this.internalRemoveCallback.call(this, child);\r\n        }\r\n\r\n        if (this.removeCallback)\r\n        {\r\n            this.removeCallback.call(this, child);\r\n        }\r\n\r\n        child.off(Events.DESTROY, this.remove, this);\r\n\r\n        if (destroyChild)\r\n        {\r\n            child.destroy();\r\n        }\r\n        else if (removeFromScene)\r\n        {\r\n            child.removeFromDisplayList();\r\n            child.removeFromUpdateList();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all members of this Group and optionally removes them from the Scene and / or destroys them.\r\n     *\r\n     * Does not call {@link Phaser.GameObjects.Group#removeCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [removeFromScene=false] - Optionally remove each Group member from the Scene.\r\n     * @param {boolean} [destroyChild=false] - Optionally call destroy on the removed Group members.\r\n     *\r\n     * @return {this} This group.\r\n     */\r\n    clear: function (removeFromScene, destroyChild)\r\n    {\r\n        if (removeFromScene === undefined) { removeFromScene = false; }\r\n        if (destroyChild === undefined) { destroyChild = false; }\r\n\r\n        var children = this.children;\r\n\r\n        for (var i = 0; i < children.size; i++)\r\n        {\r\n            var gameObject = children.entries[i];\r\n\r\n            gameObject.off(Events.DESTROY, this.remove, this);\r\n\r\n            if (destroyChild)\r\n            {\r\n                gameObject.destroy();\r\n            }\r\n            else if (removeFromScene)\r\n            {\r\n                gameObject.removeFromDisplayList();\r\n                gameObject.removeFromUpdateList();\r\n            }\r\n        }\r\n\r\n        this.children.clear();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Tests if a Game Object is a member of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#contains\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - A Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object is a member of this group.\r\n     */\r\n    contains: function (child)\r\n    {\r\n        return this.children.contains(child);\r\n    },\r\n\r\n    /**\r\n     * All members of the group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getChildren\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The group members.\r\n     */\r\n    getChildren: function ()\r\n    {\r\n        return this.children.entries;\r\n    },\r\n\r\n    /**\r\n     * The number of members of the group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number}\r\n     */\r\n    getLength: function ()\r\n    {\r\n        return this.children.size;\r\n    },\r\n\r\n    /**\r\n     * Returns all children in this Group that match the given criteria based on the `property` and `value` arguments.\r\n     *\r\n     * For example: `getMatching('visible', true)` would return only children that have their `visible` property set.\r\n     *\r\n     * Optionally, you can specify a start and end index. For example if the Group has 100 elements,\r\n     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n     * the first 50.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getMatching\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} [property] - The property to test on each array element.\r\n     * @param {*} [value] - The value to test the property against. Must pass a strict (`===`) comparison check.\r\n     * @param {number} [startIndex] - An optional start index to search from.\r\n     * @param {number} [endIndex] - An optional end index to search to.\r\n     *\r\n     * @return {any[]} An array of matching Group members. The array will be empty if nothing matched.\r\n     */\r\n    getMatching: function (property, value, startIndex, endIndex)\r\n    {\r\n        return GetAll(this.children.entries, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Scans the Group, from top to bottom, for the first member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirst\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getFirst: function (state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getHandler(true, 1, state, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the Group, from top to bottom, for the nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirstNth\r\n     * @since 3.6.0\r\n     *\r\n     * @param {number} nth - The nth matching Group member to search for.\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getFirstNth: function (nth, state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getHandler(true, nth, state, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the Group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getLast\r\n     * @since 3.6.0\r\n     *\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getLast: function (state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getHandler(false, 1, state, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the Group for the last nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getLastNth\r\n     * @since 3.6.0\r\n     *\r\n     * @param {number} nth - The nth matching Group member to search for.\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getLastNth: function (nth, state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getHandler(false, nth, state, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getHandler\r\n     * @private\r\n     * @since 3.6.0\r\n     *\r\n     * @param {boolean} forwards - Search front to back or back to front?\r\n     * @param {number} nth - Stop matching after nth successful matches.\r\n     * @param {boolean} [state=false] - The {@link Phaser.GameObjects.GameObject#active} value to match.\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first matching group member, or a newly created member, or null.\r\n     */\r\n    getHandler: function (forwards, nth, state, createIfNull, x, y, key, frame, visible)\r\n    {\r\n        if (state === undefined) { state = false; }\r\n        if (createIfNull === undefined) { createIfNull = false; }\r\n\r\n        var gameObject;\r\n\r\n        var i;\r\n        var total = 0;\r\n        var children = this.children.entries;\r\n\r\n        if (forwards)\r\n        {\r\n            for (i = 0; i < children.length; i++)\r\n            {\r\n                gameObject = children[i];\r\n\r\n                if (gameObject.active === state)\r\n                {\r\n                    total++;\r\n\r\n                    if (total === nth)\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    gameObject = null;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (i = children.length - 1; i >= 0; i--)\r\n            {\r\n                gameObject = children[i];\r\n\r\n                if (gameObject.active === state)\r\n                {\r\n                    total++;\r\n\r\n                    if (total === nth)\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    gameObject = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (gameObject)\r\n        {\r\n            if (typeof(x) === 'number')\r\n            {\r\n                gameObject.x = x;\r\n            }\r\n\r\n            if (typeof(y) === 'number')\r\n            {\r\n                gameObject.y = y;\r\n            }\r\n\r\n            return gameObject;\r\n        }\r\n\r\n        //  Got this far? We need to create or bail\r\n        if (createIfNull)\r\n        {\r\n            return this.create(x, y, key, frame, visible);\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no inactive member is found and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * The new Game Object will have its active state set to `true`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#get\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {?any} The first inactive group member, or a newly created member, or null.\r\n     */\r\n    get: function (x, y, key, frame, visible)\r\n    {\r\n        return this.getFirst(false, true, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `true`,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no active member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirstAlive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {any} The first active group member, or a newly created member, or null.\r\n     */\r\n    getFirstAlive: function (createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getFirst(true, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,\r\n     * assigns `x` and `y`, and returns the member.\r\n     *\r\n     * If no inactive member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.\r\n     * The new Game Object will have an active state set to `true`.\r\n     * Unless a new member is created, `key`, `frame`, and `visible` are ignored.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getFirstDead\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [createIfNull=false] - Create a new Game Object if no matching members are found, using the following arguments.\r\n     * @param {number} [x] - The horizontal position of the Game Object in the world.\r\n     * @param {number} [y] - The vertical position of the Game Object in the world.\r\n     * @param {string} [key=defaultKey] - The texture key assigned to a new Game Object (if one is created).\r\n     * @param {(string|number)} [frame=defaultFrame] - A texture frame assigned to a new Game Object (if one is created).\r\n     * @param {boolean} [visible=true] - The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created).\r\n     *\r\n     * @return {any} The first inactive group member, or a newly created member, or null.\r\n     */\r\n    getFirstDead: function (createIfNull, x, y, key, frame, visible)\r\n    {\r\n        return this.getFirst(false, createIfNull, x, y, key, frame, visible);\r\n    },\r\n\r\n    /**\r\n     * {@link Phaser.GameObjects.Components.Animation#play Plays} an animation for all members of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#playAnimation\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The string-based key of the animation to play.\r\n     * @param {string} [startFrame=0] - Optionally start the animation playing from this frame index.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    playAnimation: function (key, startFrame)\r\n    {\r\n        Actions.PlayAnimation(this.children.entries, key, startFrame);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Whether this group's size at its {@link Phaser.GameObjects.Group#maxSize maximum}.\r\n     *\r\n     * @method Phaser.GameObjects.Group#isFull\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} True if the number of members equals {@link Phaser.GameObjects.Group#maxSize}.\r\n     */\r\n    isFull: function ()\r\n    {\r\n        if (this.maxSize === -1)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return (this.children.size >= this.maxSize);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Counts the number of active (or inactive) group members.\r\n     *\r\n     * @method Phaser.GameObjects.Group#countActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - Count active (true) or inactive (false) group members.\r\n     *\r\n     * @return {number} The number of group members with an active state matching the `active` argument.\r\n     */\r\n    countActive: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        var total = 0;\r\n\r\n        for (var i = 0; i < this.children.size; i++)\r\n        {\r\n            if (this.children.entries[i].active === value)\r\n            {\r\n                total++;\r\n            }\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * Counts the number of in-use (active) group members.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getTotalUsed\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The number of group members with an active state of true.\r\n     */\r\n    getTotalUsed: function ()\r\n    {\r\n        return this.countActive();\r\n    },\r\n\r\n    /**\r\n     * The difference of {@link Phaser.GameObjects.Group#maxSize} and the number of active group members.\r\n     *\r\n     * This represents the number of group members that could be created or reactivated before reaching the size limit.\r\n     *\r\n     * @method Phaser.GameObjects.Group#getTotalFree\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} maxSize minus the number of active group numbers; or a large number (if maxSize is -1).\r\n     */\r\n    getTotalFree: function ()\r\n    {\r\n        var used = this.getTotalUsed();\r\n        var capacity = (this.maxSize === -1) ? 999999999999 : this.maxSize;\r\n\r\n        return (capacity - used);\r\n    },\r\n\r\n    /**\r\n     * Sets the `active` property of this Group.\r\n     * When active, this Group runs its `preUpdate` method.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setActive\r\n     * @since 3.24.0\r\n     *\r\n     * @param {boolean} value - True if this Group should be set as active, false if not.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setActive: function (value)\r\n    {\r\n        this.active = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `name` property of this Group.\r\n     * The `name` property is not populated by Phaser and is presented for your own use.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setName\r\n     * @since 3.24.0\r\n     *\r\n     * @param {string} value - The name to be given to this Group.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setName: function (value)\r\n    {\r\n        this.name = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the property as defined in `key` of each group member to the given value.\r\n     *\r\n     * @method Phaser.GameObjects.Group#propertyValueSet\r\n     * @since 3.21.0\r\n     *\r\n     * @param {string} key - The property to be updated.\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n     * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    propertyValueSet: function (key, value, step, index, direction)\r\n    {\r\n        Actions.PropertyValueSet(this.children.entries, key, value, step, index, direction);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given value to the property as defined in `key` of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#propertyValueInc\r\n     * @since 3.21.0\r\n     *\r\n     * @param {string} key - The property to be updated.\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n     * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    propertyValueInc: function (key, value, step, index, direction)\r\n    {\r\n        Actions.PropertyValueInc(this.children.entries, key, value, step, index, direction);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the x of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setX\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setX: function (value, step)\r\n    {\r\n        Actions.SetX(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the y of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setY: function (value, step)\r\n    {\r\n        Actions.SetY(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the x, y of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setXY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} x - The amount to set the `x` property to.\r\n     * @param {number} [y=x] - The amount to set the `y` property to. If `undefined` or `null` it uses the `x` value.\r\n     * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.\r\n     * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setXY: function (x, y, stepX, stepY)\r\n    {\r\n        Actions.SetXY(this.children.entries, x, y, stepX, stepY);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given value to the x of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#incX\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to be added to the `x` property.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    incX: function (value, step)\r\n    {\r\n        Actions.IncX(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given value to the y of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#incY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to be added to the `y` property.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    incY: function (value, step)\r\n    {\r\n        Actions.IncY(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given value to the x, y of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#incXY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} x - The amount to be added to the `x` property.\r\n     * @param {number} [y=x] - The amount to be added to the `y` property. If `undefined` or `null` it uses the `x` value.\r\n     * @param {number} [stepX=0] - This is added to the `x` amount, multiplied by the iteration counter.\r\n     * @param {number} [stepY=0] - This is added to the `y` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    incXY: function (x, y, stepX, stepY)\r\n    {\r\n        Actions.IncXY(this.children.entries, x, y, stepX, stepY);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Iterate through the group members changing the position of each element to be that of the element that came before\r\n     * it in the array (or after it if direction = 1)\r\n     *\r\n     * The first group member position is set to x/y.\r\n     *\r\n     * @method Phaser.GameObjects.Group#shiftPosition\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} x - The x coordinate to place the first item in the array at.\r\n     * @param {number} y - The y coordinate to place the first item in the array at.\r\n     * @param {number} [direction=0] - The iteration direction. 0 = first to last and 1 = last to first.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    shiftPosition: function (x, y, direction)\r\n    {\r\n        Actions.ShiftPosition(this.children.entries, x, y, direction);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angle of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#angle\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the angle to, in degrees.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    angle: function (value, step)\r\n    {\r\n        Actions.Angle(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the rotation of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#rotate\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the rotation to, in radians.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    rotate: function (value, step)\r\n    {\r\n        Actions.Rotate(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotates each group member around the given point by the given angle.\r\n     *\r\n     * @method Phaser.GameObjects.Group#rotateAround\r\n     * @since 3.21.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} point - Any object with public `x` and `y` properties.\r\n     * @param {number} angle - The angle to rotate by, in radians.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    rotateAround: function (point, angle)\r\n    {\r\n        Actions.RotateAround(this.children.entries, point, angle);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Rotates each group member around the given point by the given angle and distance.\r\n     *\r\n     * @method Phaser.GameObjects.Group#rotateAroundDistance\r\n     * @since 3.21.0\r\n     *\r\n     * @param {Phaser.Types.Math.Vector2Like} point - Any object with public `x` and `y` properties.\r\n     * @param {number} angle - The angle to rotate by, in radians.\r\n     * @param {number} distance - The distance from the point of rotation in pixels.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    rotateAroundDistance: function (point, angle, distance)\r\n    {\r\n        Actions.RotateAroundDistance(this.children.entries, point, angle, distance);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the alpha of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setAlpha\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the alpha to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setAlpha: function (value, step)\r\n    {\r\n        Actions.SetAlpha(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tint of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setTint\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} topLeft - The tint being applied to top-left corner of item. If other parameters are given no value, this tint will be applied to whole item.\r\n     * @param {number} [topRight] - The tint to be applied to top-right corner of item.\r\n     * @param {number} [bottomLeft] - The tint to be applied to the bottom-left corner of item.\r\n     * @param {number} [bottomRight] - The tint to be applied to the bottom-right corner of item.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setTint: function (topLeft, topRight, bottomLeft, bottomRight)\r\n    {\r\n        Actions.SetTint(this.children.entries, topLeft, topRight, bottomLeft, bottomRight);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the originX, originY of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setOrigin\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} originX - The amount to set the `originX` property to.\r\n     * @param {number} [originY] - The amount to set the `originY` property to. If `undefined` or `null` it uses the `originX` value.\r\n     * @param {number} [stepX=0] - This is added to the `originX` amount, multiplied by the iteration counter.\r\n     * @param {number} [stepY=0] - This is added to the `originY` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setOrigin: function (originX, originY, stepX, stepY)\r\n    {\r\n        Actions.SetOrigin(this.children.entries, originX, originY, stepX, stepY);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scaleX of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#scaleX\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    scaleX: function (value, step)\r\n    {\r\n        Actions.ScaleX(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scaleY of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#scaleY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    scaleY: function (value, step)\r\n    {\r\n        Actions.ScaleY(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scaleX, scaleY of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#scaleXY\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} scaleX - The amount to be added to the `scaleX` property.\r\n     * @param {number} [scaleY] - The amount to be added to the `scaleY` property. If `undefined` or `null` it uses the `scaleX` value.\r\n     * @param {number} [stepX=0] - This is added to the `scaleX` amount, multiplied by the iteration counter.\r\n     * @param {number} [stepY=0] - This is added to the `scaleY` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    scaleXY: function (scaleX, scaleY, stepX, stepY)\r\n    {\r\n        Actions.ScaleXY(this.children.entries, scaleX, scaleY, stepX, stepY);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the depth of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setDepth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     * @param {number} [step=0] - This is added to the `value` amount, multiplied by the iteration counter.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setDepth: function (value, step)\r\n    {\r\n        Actions.SetDepth(this.children.entries, value, step);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the blendMode of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setBlendMode\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The amount to set the property to.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setBlendMode: function (value)\r\n    {\r\n        Actions.SetBlendMode(this.children.entries, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes all group members to the Input Manager to enable them for input with identical areas and callbacks.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setHitArea\r\n     * @since 3.21.0\r\n     *\r\n     * @param {*} hitArea - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} hitAreaCallback - A callback to be invoked when the Game Object is interacted with. If you provide a shape you must also provide a callback.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setHitArea: function (hitArea, hitAreaCallback)\r\n    {\r\n        Actions.SetHitArea(this.children.entries, hitArea, hitAreaCallback);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the group members in place.\r\n     *\r\n     * @method Phaser.GameObjects.Group#shuffle\r\n     * @since 3.21.0\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    shuffle: function ()\r\n    {\r\n        Actions.Shuffle(this.children.entries);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deactivates a member of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#kill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - A member of this group.\r\n     */\r\n    kill: function (gameObject)\r\n    {\r\n        if (this.children.contains(gameObject))\r\n        {\r\n            gameObject.setActive(false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Deactivates and hides a member of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#killAndHide\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - A member of this group.\r\n     */\r\n    killAndHide: function (gameObject)\r\n    {\r\n        if (this.children.contains(gameObject))\r\n        {\r\n            gameObject.setActive(false);\r\n            gameObject.setVisible(false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the visible of each group member.\r\n     *\r\n     * @method Phaser.GameObjects.Group#setVisible\r\n     * @since 3.21.0\r\n     *\r\n     * @param {boolean} value - The value to set the property to.\r\n     * @param {number} [index=0] - An optional offset to start searching from within the items array.\r\n     * @param {number} [direction=1] - The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning.\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    setVisible: function (value, index, direction)\r\n    {\r\n        Actions.SetVisible(this.children.entries, value, index, direction);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Toggles (flips) the visible state of each member of this group.\r\n     *\r\n     * @method Phaser.GameObjects.Group#toggleVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Group object.\r\n     */\r\n    toggleVisible: function ()\r\n    {\r\n        Actions.ToggleVisible(this.children.entries);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Empties this Group of all children and removes it from the Scene.\r\n     *\r\n     * Does not call {@link Phaser.GameObjects.Group#removeCallback}.\r\n     *\r\n     * Children of this Group will _not_ be removed from the Scene by calling this method\r\n     * unless you specify the `removeFromScene` parameter.\r\n     *\r\n     * Children of this Group will also _not_ be destroyed by calling this method\r\n     * unless you specify the `destroyChildren` parameter.\r\n     *\r\n     * @method Phaser.GameObjects.Group#destroy\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [destroyChildren=false] - Also {@link Phaser.GameObjects.GameObject#destroy} each Group member.\r\n     * @param {boolean} [removeFromScene=false] - Optionally remove each Group member from the Scene.\r\n     */\r\n    destroy: function (destroyChildren, removeFromScene)\r\n    {\r\n        if (destroyChildren === undefined) { destroyChildren = false; }\r\n        if (removeFromScene === undefined) { removeFromScene = false; }\r\n\r\n        //  This Game Object had already been destroyed\r\n        if (!this.scene || this.ignoreDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.emit(Events.DESTROY, this);\r\n\r\n        this.removeAllListeners();\r\n\r\n        this.scene.sys.updateList.remove(this);\r\n\r\n        this.clear(removeFromScene, destroyChildren);\r\n\r\n        this.scene = undefined;\r\n        this.children = undefined;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Group;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar Components = require('../components');\nvar GameObject = require('../GameObject');\nvar ImageRender = require('./ImageRender');\n\n/**\n * @classdesc\n * An Image Game Object.\n *\n * An Image is a light-weight Game Object useful for the display of static images in your game,\n * such as logos, backgrounds, scenery or other non-animated elements. Images can have input\n * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an\n * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.\n *\n * @class Image\n * @extends Phaser.GameObjects.GameObject\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @extends Phaser.GameObjects.Components.Alpha\n * @extends Phaser.GameObjects.Components.BlendMode\n * @extends Phaser.GameObjects.Components.Depth\n * @extends Phaser.GameObjects.Components.Flip\n * @extends Phaser.GameObjects.Components.GetBounds\n * @extends Phaser.GameObjects.Components.Mask\n * @extends Phaser.GameObjects.Components.Origin\n * @extends Phaser.GameObjects.Components.Pipeline\n * @extends Phaser.GameObjects.Components.ScrollFactor\n * @extends Phaser.GameObjects.Components.Size\n * @extends Phaser.GameObjects.Components.TextureCrop\n * @extends Phaser.GameObjects.Components.Tint\n * @extends Phaser.GameObjects.Components.Transform\n * @extends Phaser.GameObjects.Components.Visible\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n */\nvar Image = new Class({\n\n    Extends: GameObject,\n\n    Mixins: [\n        Components.Alpha,\n        Components.BlendMode,\n        Components.Depth,\n        Components.Flip,\n        Components.GetBounds,\n        Components.Mask,\n        Components.Origin,\n        Components.Pipeline,\n        Components.ScrollFactor,\n        Components.Size,\n        Components.TextureCrop,\n        Components.Tint,\n        Components.Transform,\n        Components.Visible,\n        ImageRender\n    ],\n\n    initialize:\n\n    function Image (scene, x, y, texture, frame)\n    {\n        GameObject.call(this, scene, 'Image');\n\n        /**\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\n         *\n         * @name Phaser.GameObjects.Image#_crop\n         * @type {object}\n         * @private\n         * @since 3.11.0\n         */\n        this._crop = this.resetCropObject();\n\n        this.setTexture(texture, frame);\n        this.setPosition(x, y);\n        this.setSizeToFrame();\n        this.setOriginFromFrame();\n        this.initPipeline();\n    }\n\n});\n\nmodule.exports = Image;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./SpriteWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./SpriteCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Sprite#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Sprite} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar SpriteWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    src.pipeline.batchSprite(src, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = SpriteWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Sprite#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Sprite} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar SpriteCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = SpriteCanvasRenderer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar AnimationState = require('../../animations/AnimationState');\nvar Class = require('../../utils/Class');\nvar Components = require('../components');\nvar GameObject = require('../GameObject');\nvar SpriteRender = require('./SpriteRender');\n\n/**\n * @classdesc\n * A Sprite Game Object.\n *\n * A Sprite Game Object is used for the display of both static and animated images in your game.\n * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\n * and animated.\n *\n * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.\n * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\n * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.\n *\n * @class Sprite\n * @extends Phaser.GameObjects.GameObject\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @extends Phaser.GameObjects.Components.Alpha\n * @extends Phaser.GameObjects.Components.BlendMode\n * @extends Phaser.GameObjects.Components.Depth\n * @extends Phaser.GameObjects.Components.Flip\n * @extends Phaser.GameObjects.Components.GetBounds\n * @extends Phaser.GameObjects.Components.Mask\n * @extends Phaser.GameObjects.Components.Origin\n * @extends Phaser.GameObjects.Components.Pipeline\n * @extends Phaser.GameObjects.Components.ScrollFactor\n * @extends Phaser.GameObjects.Components.Size\n * @extends Phaser.GameObjects.Components.TextureCrop\n * @extends Phaser.GameObjects.Components.Tint\n * @extends Phaser.GameObjects.Components.Transform\n * @extends Phaser.GameObjects.Components.Visible\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n */\nvar Sprite = new Class({\n\n    Extends: GameObject,\n\n    Mixins: [\n        Components.Alpha,\n        Components.BlendMode,\n        Components.Depth,\n        Components.Flip,\n        Components.GetBounds,\n        Components.Mask,\n        Components.Origin,\n        Components.Pipeline,\n        Components.ScrollFactor,\n        Components.Size,\n        Components.TextureCrop,\n        Components.Tint,\n        Components.Transform,\n        Components.Visible,\n        SpriteRender\n    ],\n\n    initialize:\n\n    function Sprite (scene, x, y, texture, frame)\n    {\n        GameObject.call(this, scene, 'Sprite');\n\n        /**\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\n         *\n         * @name Phaser.GameObjects.Sprite#_crop\n         * @type {object}\n         * @private\n         * @since 3.11.0\n         */\n        this._crop = this.resetCropObject();\n\n        /**\n         * The Animation State component of this Sprite.\n         *\n         * This component provides features to apply animations to this Sprite.\n         * It is responsible for playing, loading, queuing animations for later playback,\n         * mixing between animations and setting the current animation frame to this Sprite.\n         *\n         * @name Phaser.GameObjects.Sprite#anims\n         * @type {Phaser.Animations.AnimationState}\n         * @since 3.0.0\n         */\n        this.anims = new AnimationState(this);\n\n        this.setTexture(texture, frame);\n        this.setPosition(x, y);\n        this.setSizeToFrame();\n        this.setOriginFromFrame();\n        this.initPipeline();\n    },\n\n    //  Overrides Game Object method\n    addedToScene: function ()\n    {\n        this.scene.sys.updateList.add(this);\n    },\n\n    //  Overrides Game Object method\n    removedFromScene: function ()\n    {\n        this.scene.sys.updateList.remove(this);\n    },\n\n    /**\n     * Update this Sprite's animations.\n     *\n     * @method Phaser.GameObjects.Sprite#preUpdate\n     * @protected\n     * @since 3.0.0\n     *\n     * @param {number} time - The current timestamp.\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\n     */\n    preUpdate: function (time, delta)\n    {\n        this.anims.update(time, delta);\n    },\n\n    /**\n     * Start playing the given animation on this Sprite.\n     *\n     * Animations in Phaser can either belong to the global Animation Manager, or specifically to this Sprite.\n     *\n     * The benefit of a global animation is that multiple Sprites can all play the same animation, without\n     * having to duplicate the data. You can just create it once and then play it on any Sprite.\n     *\n     * The following code shows how to create a global repeating animation. The animation will be created\n     * from all of the frames within the sprite sheet that was loaded with the key 'muybridge':\n     *\n     * ```javascript\n     * var config = {\n     *     key: 'run',\n     *     frames: 'muybridge',\n     *     frameRate: 15,\n     *     repeat: -1\n     * };\n     *\n     * //  This code should be run from within a Scene:\n     * this.anims.create(config);\n     * ```\n     *\n     * However, if you wish to create an animation that is unique to this Sprite, and this Sprite alone,\n     * you can call the `Animation.create` method instead. It accepts the exact same parameters as when\n     * creating a global animation, however the resulting data is kept locally in this Sprite.\n     *\n     * With the animation created, either globally or locally, you can now play it on this Sprite:\n     *\n     * ```javascript\n     * this.add.sprite(x, y).play('run');\n     * ```\n     *\n     * Alternatively, if you wish to run it at a different frame rate, for example, you can pass a config\n     * object instead:\n     *\n     * ```javascript\n     * this.add.sprite(x, y).play({ key: 'run', frameRate: 24 });\n     * ```\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * If you need a Sprite to be able to play both local and global animations, make sure they don't\n     * have conflicting keys.\n     *\n     * See the documentation for the `PlayAnimationConfig` config object for more details about this.\n     *\n     * Also, see the documentation in the Animation Manager for further details on creating animations.\n     *\n     * @method Phaser.GameObjects.Sprite#play\n     * @fires Phaser.Animations.Events#ANIMATION_START\n     * @since 3.0.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\n     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.\n     *\n     * @return {this} This Game Object.\n     */\n    play: function (key, ignoreIfPlaying)\n    {\n        return this.anims.play(key, ignoreIfPlaying);\n    },\n\n    /**\n     * Start playing the given animation on this Sprite, in reverse.\n     *\n     * Animations in Phaser can either belong to the global Animation Manager, or specifically to this Sprite.\n     *\n     * The benefit of a global animation is that multiple Sprites can all play the same animation, without\n     * having to duplicate the data. You can just create it once and then play it on any Sprite.\n     *\n     * The following code shows how to create a global repeating animation. The animation will be created\n     * from all of the frames within the sprite sheet that was loaded with the key 'muybridge':\n     *\n     * ```javascript\n     * var config = {\n     *     key: 'run',\n     *     frames: 'muybridge',\n     *     frameRate: 15,\n     *     repeat: -1\n     * };\n     *\n     * //  This code should be run from within a Scene:\n     * this.anims.create(config);\n     * ```\n     *\n     * However, if you wish to create an animation that is unique to this Sprite, and this Sprite alone,\n     * you can call the `Animation.create` method instead. It accepts the exact same parameters as when\n     * creating a global animation, however the resulting data is kept locally in this Sprite.\n     *\n     * With the animation created, either globally or locally, you can now play it on this Sprite:\n     *\n     * ```javascript\n     * this.add.sprite(x, y).playReverse('run');\n     * ```\n     *\n     * Alternatively, if you wish to run it at a different frame rate, for example, you can pass a config\n     * object instead:\n     *\n     * ```javascript\n     * this.add.sprite(x, y).playReverse({ key: 'run', frameRate: 24 });\n     * ```\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * If you need a Sprite to be able to play both local and global animations, make sure they don't\n     * have conflicting keys.\n     *\n     * See the documentation for the `PlayAnimationConfig` config object for more details about this.\n     *\n     * Also, see the documentation in the Animation Manager for further details on creating animations.\n     *\n     * @method Phaser.GameObjects.Sprite#playReverse\n     * @fires Phaser.Animations.Events#ANIMATION_START\n     * @since 3.50.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\n     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.\n     *\n     * @return {this} This Game Object.\n     */\n    playReverse: function (key, ignoreIfPlaying)\n    {\n        return this.anims.playReverse(key, ignoreIfPlaying);\n    },\n\n    /**\n     * Waits for the specified delay, in milliseconds, then starts playback of the given animation.\n     *\n     * If the animation _also_ has a delay value set in its config, it will be **added** to the delay given here.\n     *\n     * If an animation is already running and a new animation is given to this method, it will wait for\n     * the given delay before starting the new animation.\n     *\n     * If no animation is currently running, the given one begins after the delay.\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * Prior to Phaser 3.50 this method was called 'delayedPlay'.\n     *\n     * @method Phaser.GameObjects.Sprite#playAfterDelay\n     * @fires Phaser.Animations.Events#ANIMATION_START\n     * @since 3.50.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\n     * @param {number} delay - The delay, in milliseconds, to wait before starting the animation playing.\n     *\n     * @return {this} This Game Object.\n     */\n    playAfterDelay: function (key, delay)\n    {\n        return this.anims.playAfterDelay(key, delay);\n    },\n\n    /**\n     * Waits for the current animation to complete the `repeatCount` number of repeat cycles, then starts playback\n     * of the given animation.\n     *\n     * You can use this to ensure there are no harsh jumps between two sets of animations, i.e. going from an\n     * idle animation to a walking animation, by making them blend smoothly into each other.\n     *\n     * If no animation is currently running, the given one will start immediately.\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * @method Phaser.GameObjects.Sprite#playAfterRepeat\n     * @fires Phaser.Animations.Events#ANIMATION_START\n     * @since 3.50.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig)} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object.\n     * @param {number} [repeatCount=1] - How many times should the animation repeat before the next one starts?\n     *\n     * @return {this} This Game Object.\n     */\n    playAfterRepeat: function (key, repeatCount)\n    {\n        return this.anims.playAfterRepeat(key, repeatCount);\n    },\n\n    /**\n     * Sets an animation, or an array of animations, to be played immediately after the current one completes or stops.\n     *\n     * The current animation must enter a 'completed' state for this to happen, i.e. finish all of its repeats, delays, etc,\n     * or have the `stop` method called directly on it.\n     *\n     * An animation set to repeat forever will never enter a completed state.\n     *\n     * You can chain a new animation at any point, including before the current one starts playing, during it,\n     * or when it ends (via its `animationcomplete` event).\n     *\n     * Chained animations are specific to a Game Object, meaning different Game Objects can have different chained\n     * animations without impacting the animation they're playing.\n     *\n     * Call this method with no arguments to reset all currently chained animations.\n     *\n     * When playing an animation on a Sprite it will first check to see if it can find a matching key\n     * locally within the Sprite. If it can, it will play the local animation. If not, it will then\n     * search the global Animation Manager and look for it there.\n     *\n     * @method Phaser.GameObjects.Sprite#chain\n     * @since 3.50.0\n     *\n     * @param {(string|Phaser.Animations.Animation|Phaser.Types.Animations.PlayAnimationConfig|string[]|Phaser.Animations.Animation[]|Phaser.Types.Animations.PlayAnimationConfig[])} key - The string-based key of the animation to play, or an Animation instance, or a `PlayAnimationConfig` object, or an array of them.\n     *\n     * @return {this} This Game Object.\n     */\n    chain: function (key)\n    {\n        return this.anims.chain(key);\n    },\n\n    /**\n     * Immediately stops the current animation from playing and dispatches the `ANIMATION_STOP` events.\n     *\n     * If no animation is playing, no event will be dispatched.\n     *\n     * If there is another animation queued (via the `chain` method) then it will start playing immediately.\n     *\n     * @method Phaser.GameObjects.Sprite#stop\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\n     * @since 3.50.0\n     *\n     * @return {this} This Game Object.\n     */\n    stop: function ()\n    {\n        return this.anims.stop();\n    },\n\n    /**\n     * Stops the current animation from playing after the specified time delay, given in milliseconds.\n     *\n     * It then dispatches the `ANIMATION_STOP` event.\n     *\n     * If no animation is running, no events will be dispatched.\n     *\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\n     * when the current one stops.\n     *\n     * @method Phaser.GameObjects.Sprite#stopAfterDelay\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\n     * @since 3.50.0\n     *\n     * @param {number} delay - The number of milliseconds to wait before stopping this animation.\n     *\n     * @return {this} This Game Object.\n     */\n    stopAfterDelay: function (delay)\n    {\n        return this.anims.stopAfterDelay(delay);\n    },\n\n    /**\n     * Stops the current animation from playing after the given number of repeats.\n     *\n     * It then dispatches the `ANIMATION_STOP` event.\n     *\n     * If no animation is running, no events will be dispatched.\n     *\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\n     * when the current one stops.\n     *\n     * @method Phaser.GameObjects.Sprite#stopAfterRepeat\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\n     * @since 3.50.0\n     *\n     * @param {number} [repeatCount=1] - How many times should the animation repeat before stopping?\n     *\n     * @return {this} This Game Object.\n     */\n    stopAfterRepeat: function (repeatCount)\n    {\n        return this.anims.stopAfterRepeat(repeatCount);\n    },\n\n    /**\n     * Stops the current animation from playing when it next sets the given frame.\n     * If this frame doesn't exist within the animation it will not stop it from playing.\n     *\n     * It then dispatches the `ANIMATION_STOP` event.\n     *\n     * If no animation is running, no events will be dispatched.\n     *\n     * If there is another animation in the queue (set via the `chain` method) then it will start playing,\n     * when the current one stops.\n     *\n     * @method Phaser.GameObjects.Sprite#stopOnFrame\n     * @fires Phaser.Animations.Events#ANIMATION_STOP\n     * @since 3.50.0\n     *\n     * @param {Phaser.Animations.AnimationFrame} frame - The frame to check before stopping this animation.\n     *\n     * @return {this} This Game Object.\n     */\n    stopOnFrame: function (frame)\n    {\n        return this.anims.stopOnFrame(frame);\n    },\n\n    /**\n     * Build a JSON representation of this Sprite.\n     *\n     * @method Phaser.GameObjects.Sprite#toJSON\n     * @since 3.0.0\n     *\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\n     */\n    toJSON: function ()\n    {\n        return Components.ToJSON(this);\n    },\n\n    /**\n     * Handles the pre-destroy step for the Sprite, which removes the Animation component.\n     *\n     * @method Phaser.GameObjects.Sprite#preDestroy\n     * @private\n     * @since 3.14.0\n     */\n    preDestroy: function ()\n    {\n        this.anims.destroy();\n\n        this.anims = undefined;\n    }\n\n});\n\nmodule.exports = Sprite;\n"],"sourceRoot":""}