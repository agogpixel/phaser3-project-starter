{"version":3,"file":"js/phaser~input.42d73e7d39cd98a6a4ba.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/CreateInteractiveObject.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/CreatePixelPerfectHandler.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/InputPlugin.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/InputPluginCache.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/Axis.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/Button.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/Gamepad.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/GamepadPlugin.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/configs/SNES_USB_Controller.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/configs/Sony_PlayStation_DualShock_4.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/configs/XBox360_Controller.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/configs/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/events/BUTTON_DOWN_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/events/BUTTON_UP_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/events/CONNECTED_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/events/DISCONNECTED_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/events/GAMEPAD_BUTTON_DOWN_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/events/GAMEPAD_BUTTON_UP_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/events/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/gamepad/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/KeyboardPlugin.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/combo/AdvanceKeyCombo.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/combo/KeyCombo.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/combo/ProcessKeyCombo.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/combo/ResetKeyCombo.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/events/ANY_KEY_DOWN_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/events/ANY_KEY_UP_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/events/COMBO_MATCH_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/events/DOWN_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/events/KEY_DOWN_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/events/KEY_UP_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/events/UP_EVENT.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/events/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/keys/DownDuration.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/keys/JustDown.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/keys/JustUp.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/keys/Key.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/keys/KeyMap.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/keyboard/keys/UpDuration.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/mouse/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/input/touch/index.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Creates a new Interactive Object.\r\n * \r\n * This is called automatically by the Input Manager when you enable a Game Object for input.\r\n *\r\n * The resulting Interactive Object is mapped to the Game Object's `input` property.\r\n *\r\n * @function Phaser.Input.CreateInteractiveObject\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to which this Interactive Object is bound.\r\n * @param {any} hitArea - The hit area for this Interactive Object. Typically a geometry shape, like a Rectangle or Circle.\r\n * @param {Phaser.Types.Input.HitAreaCallback} hitAreaCallback - The 'contains' check callback that the hit area shape will use for all hit tests.\r\n *\r\n * @return {Phaser.Types.Input.InteractiveObject} The new Interactive Object.\r\n */\r\nvar CreateInteractiveObject = function (gameObject, hitArea, hitAreaCallback)\r\n{\r\n    return {\r\n\r\n        gameObject: gameObject,\r\n\r\n        enabled: true,\r\n        alwaysEnabled: false,\r\n        draggable: false,\r\n        dropZone: false,\r\n        cursor: false,\r\n\r\n        target: null,\r\n\r\n        camera: null,\r\n\r\n        hitArea: hitArea,\r\n        hitAreaCallback: hitAreaCallback,\r\n        hitAreaDebug: null,\r\n\r\n        //  Has the dev specified their own shape, or is this bound to the texture size?\r\n        customHitArea: false,\r\n\r\n        localX: 0,\r\n        localY: 0,\r\n\r\n        //  0 = Not being dragged\r\n        //  1 = Being checked for dragging\r\n        //  2 = Being dragged\r\n        dragState: 0,\r\n\r\n        dragStartX: 0,\r\n        dragStartY: 0,\r\n        dragStartXGlobal: 0,\r\n        dragStartYGlobal: 0,\r\n\r\n        dragX: 0,\r\n        dragY: 0\r\n\r\n    };\r\n};\r\n\r\nmodule.exports = CreateInteractiveObject;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Creates a new Pixel Perfect Handler function.\r\n *\r\n * Access via `InputPlugin.makePixelPerfect` rather than calling it directly.\r\n *\r\n * @function Phaser.Input.CreatePixelPerfectHandler\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Textures.TextureManager} textureManager - A reference to the Texture Manager.\r\n * @param {number} alphaTolerance - The alpha level that the pixel should be above to be included as a successful interaction.\r\n *\r\n * @return {function} The new Pixel Perfect Handler function.\r\n */\r\nvar CreatePixelPerfectHandler = function (textureManager, alphaTolerance)\r\n{\r\n    return function (hitArea, x, y, gameObject)\r\n    {\r\n        var alpha = textureManager.getPixelAlpha(x, y, gameObject.texture.key, gameObject.frame.name);\r\n\r\n        return (alpha && alpha >= alphaTolerance);\r\n    };\r\n};\r\n\r\nmodule.exports = CreatePixelPerfectHandler;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Circle = require('../geom/circle/Circle');\r\nvar CircleContains = require('../geom/circle/Contains');\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar CreateInteractiveObject = require('./CreateInteractiveObject');\r\nvar CreatePixelPerfectHandler = require('./CreatePixelPerfectHandler');\r\nvar DistanceBetween = require('../math/distance/DistanceBetween');\r\nvar Ellipse = require('../geom/ellipse/Ellipse');\r\nvar EllipseContains = require('../geom/ellipse/Contains');\r\nvar Events = require('./events');\r\nvar EventEmitter = require('eventemitter3');\r\nvar GetFastValue = require('../utils/object/GetFastValue');\r\nvar GEOM_CONST = require('../geom/const');\r\nvar InputPluginCache = require('./InputPluginCache');\r\nvar IsPlainObject = require('../utils/object/IsPlainObject');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar RectangleContains = require('../geom/rectangle/Contains');\r\nvar SceneEvents = require('../scene/events');\r\nvar Triangle = require('../geom/triangle/Triangle');\r\nvar TriangleContains = require('../geom/triangle/Contains');\r\n\r\n/**\r\n * @classdesc\r\n * The Input Plugin belongs to a Scene and handles all input related events and operations for it.\r\n *\r\n * You can access it from within a Scene using `this.input`.\r\n *\r\n * It emits events directly. For example, you can do:\r\n *\r\n * ```javascript\r\n * this.input.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * To listen for a pointer down event anywhere on the game canvas.\r\n *\r\n * Game Objects can be enabled for input by calling their `setInteractive` method. After which they\r\n * will directly emit input events:\r\n *\r\n * ```javascript\r\n * var sprite = this.add.sprite(x, y, texture);\r\n * sprite.setInteractive();\r\n * sprite.on('pointerdown', callback, context);\r\n * ```\r\n *\r\n * There are lots of game configuration options available relating to input.\r\n * See the [Input Config object]{@linkcode Phaser.Types.Core.InputConfig} for more details, including how to deal with Phaser\r\n * listening for input events outside of the canvas, how to set a default number of pointers, input\r\n * capture settings and more.\r\n *\r\n * Please also see the Input examples and tutorials for further information.\r\n *\r\n * **Incorrect input coordinates with Angular**\r\n *\r\n * If you are using Phaser within Angular, and use nglf or the router, to make the component in which the Phaser game resides\r\n * change state (i.e. appear or disappear) then you'll need to notify the Scale Manager about this, as Angular will mess with\r\n * the DOM in a way in which Phaser can't detect directly. Call `this.scale.updateBounds()` as part of your game init in order\r\n * to refresh the canvas DOM bounds values, which Phaser uses for input point position calculations.\r\n *\r\n * @class InputPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene that this Input Plugin is responsible for.\r\n */\r\nvar InputPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function InputPlugin (scene)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Scene that this Input Plugin is responsible for.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems class.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A reference to the Scene Systems Settings.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.5.0\r\n         */\r\n        this.settings = scene.sys.settings;\r\n\r\n        /**\r\n         * A reference to the Game Input Manager.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#manager\r\n         * @type {Phaser.Input.InputManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = scene.sys.game.input;\r\n\r\n        /**\r\n         * Internal event queue used for plugins only.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#pluginEvents\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.pluginEvents = new EventEmitter();\r\n\r\n        /**\r\n         * If `true` this Input Plugin will process DOM input events.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.5.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * A reference to the Scene Display List. This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#displayList\r\n         * @type {Phaser.GameObjects.DisplayList}\r\n         * @since 3.0.0\r\n         */\r\n        this.displayList;\r\n\r\n        /**\r\n         * A reference to the Scene Cameras Manager. This property is set during the `boot` method.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#cameras\r\n         * @type {Phaser.Cameras.Scene2D.CameraManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.cameras;\r\n\r\n        //  Inject the available input plugins into this class\r\n        InputPluginCache.install(this);\r\n\r\n        /**\r\n         * A reference to the Mouse Manager.\r\n         *\r\n         * This property is only set if Mouse support has been enabled in your Game Configuration file.\r\n         *\r\n         * If you just wish to get access to the mouse pointer, use the `mousePointer` property instead.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#mouse\r\n         * @type {?Phaser.Input.Mouse.MouseManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.mouse = this.manager.mouse;\r\n\r\n        /**\r\n         * When set to `true` (the default) the Input Plugin will emulate DOM behavior by only emitting events from\r\n         * the top-most Game Objects in the Display List.\r\n         *\r\n         * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#topOnly\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.topOnly = true;\r\n\r\n        /**\r\n         * How often should the Pointers be checked?\r\n         *\r\n         * The value is a time, given in ms, and is the time that must have elapsed between game steps before\r\n         * the Pointers will be polled again. When a pointer is polled it runs a hit test to see which Game\r\n         * Objects are currently below it, or being interacted with it.\r\n         *\r\n         * Pointers will *always* be checked if they have been moved by the user, or press or released.\r\n         *\r\n         * This property only controls how often they will be polled if they have not been updated.\r\n         * You should set this if you want to have Game Objects constantly check against the pointers, even\r\n         * if the pointer didn't itself move.\r\n         *\r\n         * Set to 0 to poll constantly. Set to -1 to only poll on user movement.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#pollRate\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.pollRate = -1;\r\n\r\n        /**\r\n         * Internal poll timer value.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pollTimer\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._pollTimer = 0;\r\n\r\n        var _eventData = { cancelled: false };\r\n\r\n        /**\r\n         * Internal event propagation callback container.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_eventContainer\r\n         * @type {Phaser.Types.Input.EventData}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._eventContainer = {\r\n            stopPropagation: function ()\r\n            {\r\n                _eventData.cancelled = true;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Internal event propagation data object.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_eventData\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._eventData = _eventData;\r\n\r\n        /**\r\n         * The distance, in pixels, a pointer has to move while being held down, before it thinks it is being dragged.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#dragDistanceThreshold\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.dragDistanceThreshold = 0;\r\n\r\n        /**\r\n         * The amount of time, in ms, a pointer has to be held down before it thinks it is dragging.\r\n         *\r\n         * The default polling rate is to poll only on move so once the time threshold is reached the\r\n         * drag event will not start until you move the mouse. If you want it to start immediately\r\n         * when the time threshold is reached, you must increase the polling rate by calling\r\n         * [setPollAlways]{@linkcode Phaser.Input.InputPlugin#setPollAlways} or\r\n         * [setPollRate]{@linkcode Phaser.Input.InputPlugin#setPollRate}.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#dragTimeThreshold\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.dragTimeThreshold = 0;\r\n\r\n        /**\r\n         * Used to temporarily store the results of the Hit Test\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_temp\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._temp = [];\r\n\r\n        /**\r\n         * Used to temporarily store the results of the Hit Test dropZones\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_tempZones\r\n         * @type {array}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._tempZones = [];\r\n\r\n        /**\r\n         * A list of all Game Objects that have been set to be interactive in the Scene this Input Plugin is managing.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_list\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._list = [];\r\n\r\n        /**\r\n         * Objects waiting to be inserted to the list on the next call to 'begin'.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pendingInsertion\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._pendingInsertion = [];\r\n\r\n        /**\r\n         * Objects waiting to be removed from the list on the next call to 'begin'.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_pendingRemoval\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._pendingRemoval = [];\r\n\r\n        /**\r\n         * A list of all Game Objects that have been enabled for dragging.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_draggable\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @private\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this._draggable = [];\r\n\r\n        /**\r\n         * A list of all Interactive Objects currently considered as being 'draggable' by any pointer, indexed by pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_drag\r\n         * @type {{0:Array,1:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array,10:Array}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };\r\n\r\n        /**\r\n         * A array containing the dragStates, for this Scene, index by the Pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_dragState\r\n         * @type {number[]}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._dragState = [];\r\n\r\n        /**\r\n         * A list of all Interactive Objects currently considered as being 'over' by any pointer, indexed by pointer ID.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_over\r\n         * @type {{0:Array,1:Array,2:Array,3:Array,4:Array,5:Array,6:Array,7:Array,8:Array,9:Array,10:Array}}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._over = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] };\r\n\r\n        /**\r\n         * A list of valid DOM event types.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_validTypes\r\n         * @type {string[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._validTypes = [ 'onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop' ];\r\n\r\n        /**\r\n         * Internal property that tracks frame event state.\r\n         *\r\n         * @name Phaser.Input.InputPlugin#_updatedThisFrame\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.18.0\r\n         */\r\n        this._updatedThisFrame = false;\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#boot\r\n     * @fires Phaser.Input.Events#BOOT\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.cameras = this.systems.cameras;\r\n\r\n        this.displayList = this.systems.displayList;\r\n\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.BOOT);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#start\r\n     * @fires Phaser.Input.Events#START\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.TRANSITION_START, this.transitionIn, this);\r\n        eventEmitter.on(SceneEvents.TRANSITION_OUT, this.transitionOut, this);\r\n        eventEmitter.on(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);\r\n        eventEmitter.on(SceneEvents.PRE_UPDATE, this.preUpdate, this);\r\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n\r\n        this.manager.events.on(Events.GAME_OUT, this.onGameOut, this);\r\n        this.manager.events.on(Events.GAME_OVER, this.onGameOver, this);\r\n\r\n        this.enabled = true;\r\n\r\n        //  Populate the pointer drag states\r\n        this._dragState = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.START);\r\n    },\r\n\r\n    /**\r\n     * Game Over handler.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#onGameOver\r\n     * @fires Phaser.Input.Events#GAME_OVER\r\n     * @private\r\n     * @since 3.16.2\r\n     */\r\n    onGameOver: function (event)\r\n    {\r\n        if (this.isActive())\r\n        {\r\n            this.emit(Events.GAME_OVER, event.timeStamp, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Game Out handler.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#onGameOut\r\n     * @fires Phaser.Input.Events#GAME_OUT\r\n     * @private\r\n     * @since 3.16.2\r\n     */\r\n    onGameOut: function (event)\r\n    {\r\n        if (this.isActive())\r\n        {\r\n            this.emit(Events.GAME_OUT, event.timeStamp, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The pre-update handler is responsible for checking the pending removal and insertion lists and\r\n     * deleting old Game Objects.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#preUpdate\r\n     * @private\r\n     * @fires Phaser.Input.Events#PRE_UPDATE\r\n     * @since 3.0.0\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.PRE_UPDATE);\r\n\r\n        var removeList = this._pendingRemoval;\r\n        var insertList = this._pendingInsertion;\r\n\r\n        var toRemove = removeList.length;\r\n        var toInsert = insertList.length;\r\n\r\n        if (toRemove === 0 && toInsert === 0)\r\n        {\r\n            //  Quick bail\r\n            return;\r\n        }\r\n\r\n        var current = this._list;\r\n\r\n        //  Delete old gameObjects\r\n        for (var i = 0; i < toRemove; i++)\r\n        {\r\n            var gameObject = removeList[i];\r\n\r\n            var index = current.indexOf(gameObject);\r\n\r\n            if (index > -1)\r\n            {\r\n                current.splice(index, 1);\r\n\r\n                this.clear(gameObject, true);\r\n            }\r\n        }\r\n\r\n        //  Clear the removal list\r\n        removeList.length = 0;\r\n        this._pendingRemoval.length = 0;\r\n\r\n        //  Move pendingInsertion to list (also clears pendingInsertion at the same time)\r\n        this._list = current.concat(insertList.splice(0));\r\n    },\r\n\r\n    /**\r\n     * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#isActive\r\n     * @since 3.10.0\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.enabled && this.scene.sys.isActive());\r\n    },\r\n\r\n    /**\r\n     * This is called automatically by the Input Manager.\r\n     * It emits events for plugins to listen to and also handles polling updates, if enabled.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#updatePoll\r\n     * @since 3.18.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    updatePoll: function (time, delta)\r\n    {\r\n        if (!this.isActive())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //  The plugins should update every frame, regardless if there has been\r\n        //  any DOM input events or not (such as the Gamepad and Keyboard)\r\n        this.pluginEvents.emit(Events.UPDATE, time, delta);\r\n\r\n        //  We can leave now if we've already updated once this frame via the immediate DOM event handlers\r\n        if (this._updatedThisFrame)\r\n        {\r\n            this._updatedThisFrame = false;\r\n\r\n            return false;\r\n        }\r\n\r\n        var i;\r\n        var manager = this.manager;\r\n\r\n        var pointers = manager.pointers;\r\n        var pointersTotal = manager.pointersTotal;\r\n\r\n        for (i = 0; i < pointersTotal; i++)\r\n        {\r\n            pointers[i].updateMotion();\r\n        }\r\n\r\n        //  No point going any further if there aren't any interactive objects\r\n        if (this._list.length === 0)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var rate = this.pollRate;\r\n\r\n        if (rate === -1)\r\n        {\r\n            return false;\r\n        }\r\n        else if (rate > 0)\r\n        {\r\n            this._pollTimer -= delta;\r\n\r\n            if (this._pollTimer < 0)\r\n            {\r\n                //  Discard timer diff, we're ready to poll again\r\n                this._pollTimer = this.pollRate;\r\n            }\r\n            else\r\n            {\r\n                //  Not enough time has elapsed since the last poll, so abort now\r\n                return false;\r\n            }\r\n        }\r\n\r\n        //  We got this far? Then we should poll for movement\r\n        var captured = false;\r\n\r\n        for (i = 0; i < pointersTotal; i++)\r\n        {\r\n            var total = 0;\r\n\r\n            var pointer = pointers[i];\r\n\r\n            //  Always reset this array\r\n            this._tempZones = [];\r\n\r\n            //  _temp contains a hit tested and camera culled list of IO objects\r\n            this._temp = this.hitTestPointer(pointer);\r\n\r\n            this.sortGameObjects(this._temp, pointer);\r\n            this.sortDropZones(this._tempZones);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                //  Only the top-most one counts now, so safely ignore the rest\r\n                if (this._temp.length)\r\n                {\r\n                    this._temp.splice(1);\r\n                }\r\n\r\n                if (this._tempZones.length)\r\n                {\r\n                    this._tempZones.splice(1);\r\n                }\r\n            }\r\n\r\n            total += this.processOverOutEvents(pointer);\r\n\r\n            if (this.getDragState(pointer) === 2)\r\n            {\r\n                this.processDragThresholdEvent(pointer, time);\r\n            }\r\n\r\n            if (total > 0)\r\n            {\r\n                //  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\r\n                captured = true;\r\n            }\r\n        }\r\n\r\n        return captured;\r\n    },\r\n\r\n    /**\r\n     * This method is called when a DOM Event is received by the Input Manager. It handles dispatching the events\r\n     * to relevant input enabled Game Objects in this scene.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#update\r\n     * @private\r\n     * @fires Phaser.Input.Events#UPDATE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} type - The type of event to process.\r\n     * @param {Phaser.Input.Pointer[]} pointers - An array of Pointers on which the event occurred.\r\n     *\r\n     * @return {boolean} `true` if this Scene has captured the input events from all other Scenes, otherwise `false`.\r\n     */\r\n    update: function (type, pointers)\r\n    {\r\n        if (!this.isActive())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var pointersTotal = pointers.length;\r\n        var captured = false;\r\n\r\n        for (var i = 0; i < pointersTotal; i++)\r\n        {\r\n            var total = 0;\r\n            var pointer = pointers[i];\r\n\r\n            //  Always reset this array\r\n            this._tempZones = [];\r\n\r\n            //  _temp contains a hit tested and camera culled list of IO objects\r\n            this._temp = this.hitTestPointer(pointer);\r\n\r\n            this.sortGameObjects(this._temp, pointer);\r\n            this.sortDropZones(this._tempZones);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                //  Only the top-most one counts now, so safely ignore the rest\r\n                if (this._temp.length)\r\n                {\r\n                    this._temp.splice(1);\r\n                }\r\n\r\n                if (this._tempZones.length)\r\n                {\r\n                    this._tempZones.splice(1);\r\n                }\r\n            }\r\n\r\n            switch (type)\r\n            {\r\n                case CONST.MOUSE_DOWN:\r\n                    total += this.processDragDownEvent(pointer);\r\n                    total += this.processDownEvents(pointer);\r\n                    total += this.processOverOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.MOUSE_UP:\r\n                    total += this.processDragUpEvent(pointer);\r\n                    total += this.processUpEvents(pointer);\r\n                    total += this.processOverOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.TOUCH_START:\r\n                    total += this.processDragDownEvent(pointer);\r\n                    total += this.processDownEvents(pointer);\r\n                    total += this.processOverEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.TOUCH_END:\r\n                case CONST.TOUCH_CANCEL:\r\n                    total += this.processDragUpEvent(pointer);\r\n                    total += this.processUpEvents(pointer);\r\n                    total += this.processOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.MOUSE_MOVE:\r\n                case CONST.TOUCH_MOVE:\r\n                    total += this.processDragMoveEvent(pointer);\r\n                    total += this.processMoveEvents(pointer);\r\n                    total += this.processOverOutEvents(pointer);\r\n                    break;\r\n\r\n                case CONST.MOUSE_WHEEL:\r\n                    total += this.processWheelEvent(pointer);\r\n                    break;\r\n            }\r\n\r\n            if (total > 0)\r\n            {\r\n                //  We interacted with an event in this Scene, so block any Scenes below us from doing the same this frame\r\n                captured = true;\r\n            }\r\n        }\r\n\r\n        this._updatedThisFrame = true;\r\n\r\n        return captured;\r\n    },\r\n\r\n    /**\r\n     * Clears a Game Object so it no longer has an Interactive Object associated with it.\r\n     * The Game Object is then queued for removal from the Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that will have its Interactive Object removed.\r\n     * @param {boolean} [skipQueue=false] - Skip adding this Game Object into the removal queue?\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject} The Game Object that had its Interactive Object removed.\r\n     */\r\n    clear: function (gameObject, skipQueue)\r\n    {\r\n        if (skipQueue === undefined) { skipQueue = false; }\r\n\r\n        var input = gameObject.input;\r\n\r\n        // If GameObject.input already cleared from higher class\r\n        if (!input)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (!skipQueue)\r\n        {\r\n            this.queueForRemoval(gameObject);\r\n        }\r\n\r\n        input.gameObject = undefined;\r\n        input.target = undefined;\r\n        input.hitArea = undefined;\r\n        input.hitAreaCallback = undefined;\r\n        input.callbackContext = undefined;\r\n\r\n        gameObject.input = null;\r\n\r\n        //  Clear from _draggable, _drag and _over\r\n        var index = this._draggable.indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._draggable.splice(index, 1);\r\n        }\r\n\r\n        index = this._drag[0].indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._drag[0].splice(index, 1);\r\n        }\r\n\r\n        index = this._over[0].indexOf(gameObject);\r\n\r\n        if (index > -1)\r\n        {\r\n            this._over[0].splice(index, 1);\r\n\r\n            this.manager.resetCursor(input);\r\n        }\r\n\r\n        return gameObject;\r\n    },\r\n\r\n    /**\r\n     * Disables Input on a single Game Object.\r\n     *\r\n     * An input disabled Game Object still retains its Interactive Object component and can be re-enabled\r\n     * at any time, by passing it to `InputPlugin.enable`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to have its input system disabled.\r\n     */\r\n    disable: function (gameObject)\r\n    {\r\n        gameObject.input.enabled = false;\r\n    },\r\n\r\n    /**\r\n     * Enable a Game Object for interaction.\r\n     *\r\n     * If the Game Object already has an Interactive Object component, it is enabled and returned.\r\n     *\r\n     * Otherwise, a new Interactive Object component is created and assigned to the Game Object's `input` property.\r\n     *\r\n     * Input works by using hit areas, these are nearly always geometric shapes, such as rectangles or circles, that act as the hit area\r\n     * for the Game Object. However, you can provide your own hit area shape and callback, should you wish to handle some more advanced\r\n     * input detection.\r\n     *\r\n     * If no arguments are provided it will try and create a rectangle hit area based on the texture frame the Game Object is using. If\r\n     * this isn't a texture-bound object, such as a Graphics or BitmapText object, this will fail, and you'll need to provide a specific\r\n     * shape for it to use.\r\n     *\r\n     * You can also provide an Input Configuration Object as the only argument to this method.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to be enabled for input.\r\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [hitArea] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [hitAreaCallback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n     * @param {boolean} [dropZone=false] - Is this Game Object a drop zone or not?\r\n     *\r\n     * @return {this} This Input Plugin.\r\n     */\r\n    enable: function (gameObject, hitArea, hitAreaCallback, dropZone)\r\n    {\r\n        if (dropZone === undefined) { dropZone = false; }\r\n\r\n        if (gameObject.input)\r\n        {\r\n            //  If it is already has an InteractiveObject then just enable it and return\r\n            gameObject.input.enabled = true;\r\n        }\r\n        else\r\n        {\r\n            //  Create an InteractiveObject and enable it\r\n            this.setHitArea(gameObject, hitArea, hitAreaCallback);\r\n        }\r\n\r\n        if (gameObject.input && dropZone && !gameObject.input.dropZone)\r\n        {\r\n            gameObject.input.dropZone = dropZone;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes the given Pointer and performs a hit test against it, to see which interactive Game Objects\r\n     * it is currently above.\r\n     *\r\n     * The hit test is performed against which-ever Camera the Pointer is over. If it is over multiple\r\n     * cameras, it starts checking the camera at the top of the camera list, and if nothing is found, iterates down the list.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#hitTestPointer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array of all the interactive Game Objects the Pointer was above.\r\n     */\r\n    hitTestPointer: function (pointer)\r\n    {\r\n        var cameras = this.cameras.getCamerasBelowPointer(pointer);\r\n\r\n        for (var c = 0; c < cameras.length; c++)\r\n        {\r\n            var camera = cameras[c];\r\n\r\n            //  Get a list of all objects that can be seen by the camera below the pointer in the scene and store in 'over' array.\r\n            //  All objects in this array are input enabled, as checked by the hitTest method, so we don't need to check later on as well.\r\n            var over = this.manager.hitTest(pointer, this._list, camera);\r\n\r\n            //  Filter out the drop zones\r\n            for (var i = 0; i < over.length; i++)\r\n            {\r\n                var obj = over[i];\r\n\r\n                if (obj.input.dropZone)\r\n                {\r\n                    this._tempZones.push(obj);\r\n                }\r\n            }\r\n\r\n            if (over.length > 0)\r\n            {\r\n                pointer.camera = camera;\r\n\r\n                return over;\r\n            }\r\n        }\r\n\r\n        //  If we got this far then there were no Game Objects below the pointer, but it was still over\r\n        //  a camera, so set that the top-most one into the pointer\r\n\r\n        pointer.camera = cameras[0];\r\n\r\n        return [];\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer down event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDownEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_DOWN\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DOWN\r\n     * @fires Phaser.Input.Events#POINTER_DOWN\r\n     * @fires Phaser.Input.Events#POINTER_DOWN_OUTSIDE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer being tested.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processDownEvents: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_DOWN, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_DOWN, pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //  If they released outside the canvas, but pressed down inside it, we'll still dispatch the event.\r\n        if (!aborted && this.manager)\r\n        {\r\n            if (pointer.downElement === this.manager.game.canvas)\r\n            {\r\n                this.emit(Events.POINTER_DOWN, pointer, currentlyOver);\r\n            }\r\n            else\r\n            {\r\n                this.emit(Events.POINTER_DOWN_OUTSIDE, pointer);\r\n            }\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * Returns the drag state of the given Pointer for this Input Plugin.\r\n     *\r\n     * The state will be one of the following:\r\n     *\r\n     * 0 = Not dragging anything\r\n     * 1 = Primary button down and objects below, so collect a draglist\r\n     * 2 = Pointer being checked if meets drag criteria\r\n     * 3 = Pointer meets criteria, notify the draglist\r\n     * 4 = Pointer actively dragging the draglist and has moved\r\n     * 5 = Pointer actively dragging but has been released, notify draglist\r\n     *\r\n     * @method Phaser.Input.InputPlugin#getDragState\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to get the drag state for.\r\n     *\r\n     * @return {number} The drag state of the given Pointer.\r\n     */\r\n    getDragState: function (pointer)\r\n    {\r\n        return this._dragState[pointer.id];\r\n    },\r\n\r\n    /**\r\n     * Sets the drag state of the given Pointer for this Input Plugin.\r\n     *\r\n     * The state must be one of the following values:\r\n     *\r\n     * 0 = Not dragging anything\r\n     * 1 = Primary button down and objects below, so collect a draglist\r\n     * 2 = Pointer being checked if meets drag criteria\r\n     * 3 = Pointer meets criteria, notify the draglist\r\n     * 4 = Pointer actively dragging the draglist and has moved\r\n     * 5 = Pointer actively dragging but has been released, notify draglist\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDragState\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to set the drag state for.\r\n     * @param {number} state - The drag state value. An integer between 0 and 5.\r\n     */\r\n    setDragState: function (pointer, state)\r\n    {\r\n        this._dragState[pointer.id] = state;\r\n    },\r\n\r\n    /**\r\n     * Checks to see if a Pointer is ready to drag the objects below it, based on either a distance\r\n     * or time threshold.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragThresholdEvent\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check the drag thresholds on.\r\n     * @param {number} time - The current time.\r\n     */\r\n    processDragThresholdEvent: function (pointer, time)\r\n    {\r\n        var passed = false;\r\n        var timeThreshold = this.dragTimeThreshold;\r\n        var distanceThreshold = this.dragDistanceThreshold;\r\n\r\n        if (distanceThreshold > 0 && DistanceBetween(pointer.x, pointer.y, pointer.downX, pointer.downY) >= distanceThreshold)\r\n        {\r\n            //  It has moved far enough to be considered a drag\r\n            passed = true;\r\n        }\r\n        else if (timeThreshold > 0 && (time >= pointer.downTime + timeThreshold))\r\n        {\r\n            //  It has been held down long enough to be considered a drag\r\n            passed = true;\r\n        }\r\n\r\n        if (passed)\r\n        {\r\n            this.setDragState(pointer, 3);\r\n\r\n            return this.processDragStartList(pointer);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Processes the drag list for the given pointer and dispatches the start events for each object on it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragStartList\r\n     * @private\r\n     * @fires Phaser.Input.Events#DRAG_START\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_START\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {number} The number of items that DRAG_START was called on.\r\n     */\r\n    processDragStartList: function (pointer)\r\n    {\r\n        //  3 = Pointer meets criteria and is freshly down, notify the draglist\r\n        if (this.getDragState(pointer) !== 3)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        var list = this._drag[pointer.id];\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            var input = gameObject.input;\r\n\r\n            input.dragState = 2;\r\n\r\n            input.dragStartX = gameObject.x;\r\n            input.dragStartY = gameObject.y;\r\n\r\n            input.dragStartXGlobal = pointer.worldX;\r\n            input.dragStartYGlobal = pointer.worldY;\r\n\r\n            input.dragX = input.dragStartXGlobal - input.dragStartX;\r\n            input.dragY = input.dragStartYGlobal - input.dragStartY;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_DRAG_START, pointer, input.dragX, input.dragY);\r\n\r\n            this.emit(Events.DRAG_START, pointer, gameObject);\r\n        }\r\n\r\n        this.setDragState(pointer, 4);\r\n\r\n        return list.length;\r\n    },\r\n\r\n    /**\r\n     * Processes a 'drag down' event for the given pointer. Checks the pointer state, builds-up the drag list\r\n     * and prepares them all for interaction.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragDownEvent\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {number} The number of items that were collected on the drag list.\r\n     */\r\n    processDragDownEvent: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        if (this._draggable.length === 0 || currentlyOver.length === 0 || !pointer.primaryDown || this.getDragState(pointer) !== 0)\r\n        {\r\n            //  There are no draggable items, no over items or the pointer isn't down, so let's not even bother going further\r\n            return 0;\r\n        }\r\n\r\n        //  1 = Primary button down and objects below, so collect a draglist\r\n        this.setDragState(pointer, 1);\r\n\r\n        //  Get draggable objects, sort them, pick the top (or all) and store them somewhere\r\n        var draglist = [];\r\n\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (gameObject.input.draggable && (gameObject.input.dragState === 0))\r\n            {\r\n                draglist.push(gameObject);\r\n            }\r\n        }\r\n\r\n        if (draglist.length === 0)\r\n        {\r\n            this.setDragState(pointer, 0);\r\n\r\n            return 0;\r\n        }\r\n        else if (draglist.length > 1)\r\n        {\r\n            this.sortGameObjects(draglist, pointer);\r\n\r\n            if (this.topOnly)\r\n            {\r\n                draglist.splice(1);\r\n            }\r\n        }\r\n\r\n        //  draglist now contains all potential candidates for dragging\r\n        this._drag[pointer.id] = draglist;\r\n\r\n        if (this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0)\r\n        {\r\n            //  No drag criteria, so snap immediately to mode 3\r\n            this.setDragState(pointer, 3);\r\n\r\n            return this.processDragStartList(pointer);\r\n        }\r\n        else\r\n        {\r\n            //  Check the distance / time on the next event\r\n            this.setDragState(pointer, 2);\r\n\r\n            return 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Processes a 'drag move' event for the given pointer.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragMoveEvent\r\n     * @private\r\n     * @fires Phaser.Input.Events#DRAG_ENTER\r\n     * @fires Phaser.Input.Events#DRAG\r\n     * @fires Phaser.Input.Events#DRAG_LEAVE\r\n     * @fires Phaser.Input.Events#DRAG_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_ENTER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_LEAVE\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_OVER\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {number} The number of items that were updated by this drag event.\r\n     */\r\n    processDragMoveEvent: function (pointer)\r\n    {\r\n        //  2 = Pointer being checked if meets drag criteria\r\n        if (this.getDragState(pointer) === 2)\r\n        {\r\n            this.processDragThresholdEvent(pointer, this.manager.game.loop.now);\r\n        }\r\n\r\n        if (this.getDragState(pointer) !== 4)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        //  4 = Pointer actively dragging the draglist and has moved\r\n        var dropZones = this._tempZones;\r\n\r\n        var list = this._drag[pointer.id];\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            var input = gameObject.input;\r\n\r\n            var target = input.target;\r\n\r\n            //  If this GO has a target then let's check it\r\n            if (target)\r\n            {\r\n                var index = dropZones.indexOf(target);\r\n\r\n                //  Got a target, are we still over it?\r\n                if (index === 0)\r\n                {\r\n                    //  We're still over it, and it's still the top of the display list, phew ...\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_OVER, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_OVER, pointer, gameObject, target);\r\n                }\r\n                else if (index > 0)\r\n                {\r\n                    //  Still over it but it's no longer top of the display list (targets must always be at the top)\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);\r\n\r\n                    input.target = dropZones[0];\r\n\r\n                    target = input.target;\r\n\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\r\n                }\r\n                else\r\n                {\r\n                    //  Nope, we've moved on (or the target has!), leave the old target\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_LEAVE, pointer, target);\r\n\r\n                    this.emit(Events.DRAG_LEAVE, pointer, gameObject, target);\r\n\r\n                    //  Anything new to replace it?\r\n                    //  Yup!\r\n                    if (dropZones[0])\r\n                    {\r\n                        input.target = dropZones[0];\r\n\r\n                        target = input.target;\r\n\r\n                        gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\r\n\r\n                        this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\r\n                    }\r\n                    else\r\n                    {\r\n                        //  Nope\r\n                        input.target = null;\r\n                    }\r\n                }\r\n            }\r\n            else if (!target && dropZones[0])\r\n            {\r\n                input.target = dropZones[0];\r\n\r\n                target = input.target;\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_DRAG_ENTER, pointer, target);\r\n\r\n                this.emit(Events.DRAG_ENTER, pointer, gameObject, target);\r\n            }\r\n\r\n            var dragX;\r\n            var dragY;\r\n\r\n            if (!gameObject.parentContainer)\r\n            {\r\n                dragX = pointer.worldX - input.dragX;\r\n                dragY = pointer.worldY - input.dragY;\r\n            }\r\n            else\r\n            {\r\n                var dx = pointer.worldX - input.dragStartXGlobal;\r\n                var dy = pointer.worldY - input.dragStartYGlobal;\r\n\r\n                var rotation = gameObject.getParentRotation();\r\n\r\n                var dxRotated = dx * Math.cos(rotation) + dy * Math.sin(rotation);\r\n                var dyRotated = dy * Math.cos(rotation) - dx * Math.sin(rotation);\r\n\r\n                dxRotated *= (1 / gameObject.parentContainer.scaleX);\r\n                dyRotated *= (1 / gameObject.parentContainer.scaleY);\r\n\r\n                dragX = dxRotated + input.dragStartX;\r\n                dragY = dyRotated + input.dragStartY;\r\n            }\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_DRAG, pointer, dragX, dragY);\r\n\r\n            this.emit(Events.DRAG, pointer, gameObject, dragX, dragY);\r\n        }\r\n\r\n        return list.length;\r\n    },\r\n\r\n    /**\r\n     * Processes a 'drag down' event for the given pointer. Checks the pointer state, builds-up the drag list\r\n     * and prepares them all for interaction.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processDragUpEvent\r\n     * @fires Phaser.Input.Events#DRAG_END\r\n     * @fires Phaser.Input.Events#DROP\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DRAG_END\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_DROP\r\n     * @private\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to process the drag event on.\r\n     *\r\n     * @return {number} The number of items that were updated by this drag event.\r\n     */\r\n    processDragUpEvent: function (pointer)\r\n    {\r\n        //  5 = Pointer was actively dragging but has been released, notify draglist\r\n        var list = this._drag[pointer.id];\r\n\r\n        for (var i = 0; i < list.length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            var input = gameObject.input;\r\n\r\n            if (input && input.dragState === 2)\r\n            {\r\n                input.dragState = 0;\r\n\r\n                input.dragX = input.localX - gameObject.displayOriginX;\r\n                input.dragY = input.localY - gameObject.displayOriginY;\r\n\r\n                var dropped = false;\r\n\r\n                var target = input.target;\r\n\r\n                if (target)\r\n                {\r\n                    gameObject.emit(Events.GAMEOBJECT_DROP, pointer, target);\r\n\r\n                    this.emit(Events.DROP, pointer, gameObject, target);\r\n\r\n                    input.target = null;\r\n\r\n                    dropped = true;\r\n                }\r\n\r\n                //  And finally the dragend event\r\n\r\n                if (gameObject.input)\r\n                {\r\n                    gameObject.emit(Events.GAMEOBJECT_DRAG_END, pointer, input.dragX, input.dragY, dropped);\r\n\r\n                    this.emit(Events.DRAG_END, pointer, gameObject, dropped);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setDragState(pointer, 0);\r\n\r\n        list.splice(0);\r\n\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer movement event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processMoveEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_MOVE\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_MOVE\r\n     * @fires Phaser.Input.Events#POINTER_MOVE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processMoveEvents: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_MOVE, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_MOVE, pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            if (this.topOnly)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!aborted)\r\n        {\r\n            this.emit(Events.POINTER_MOVE, pointer, currentlyOver);\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles a mouse wheel event.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processWheelEvent\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_WHEEL\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_WHEEL\r\n     * @fires Phaser.Input.Events#POINTER_WHEEL\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processWheelEvent: function (pointer)\r\n    {\r\n        var total = 0;\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        var dx = pointer.deltaX;\r\n        var dy = pointer.deltaY;\r\n        var dz = pointer.deltaZ;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            total++;\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_WHEEL, pointer, dx, dy, dz, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_WHEEL, pointer, gameObject, dx, dy, dz, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!aborted)\r\n        {\r\n            this.emit(Events.POINTER_WHEEL, pointer, currentlyOver, dx, dy, dz);\r\n        }\r\n\r\n        return total;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer over events.\r\n     * This is called when a touch input hits the canvas, having previously been off of it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOverEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OVER\r\n     * @fires Phaser.Input.Events#POINTER_OVER\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processOverEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var total = currentlyOver.length;\r\n\r\n        var justOver = [];\r\n\r\n        if (total > 0)\r\n        {\r\n            var manager = this.manager;\r\n\r\n            var _eventData = this._eventData;\r\n            var _eventContainer = this._eventContainer;\r\n\r\n            _eventData.cancelled = false;\r\n\r\n            var aborted = false;\r\n\r\n            for (var i = 0; i < total; i++)\r\n            {\r\n                var gameObject = currentlyOver[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                justOver.push(gameObject);\r\n\r\n                manager.setCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit(Events.POINTER_OVER, pointer, justOver);\r\n            }\r\n        }\r\n\r\n        //  Then sort it into display list order\r\n        this._over[pointer.id] = justOver;\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer out events.\r\n     * This is called when a touch input leaves the canvas, as it can never be 'over' in this case.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOutEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OUT\r\n     * @fires Phaser.Input.Events#POINTER_OUT\r\n     * @since 3.18.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processOutEvents: function (pointer)\r\n    {\r\n        var previouslyOver = this._over[pointer.id];\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var total = previouslyOver.length;\r\n\r\n        if (total > 0)\r\n        {\r\n            var manager = this.manager;\r\n\r\n            var _eventData = this._eventData;\r\n            var _eventContainer = this._eventContainer;\r\n\r\n            _eventData.cancelled = false;\r\n\r\n            var aborted = false;\r\n\r\n            this.sortGameObjects(previouslyOver, pointer);\r\n\r\n            for (var i = 0; i < total; i++)\r\n            {\r\n                var gameObject = previouslyOver[i];\r\n\r\n                //  Call onOut for everything in the previouslyOver array\r\n                gameObject = previouslyOver[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                manager.resetCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                if (!aborted)\r\n                {\r\n                    this.emit(Events.POINTER_OUT, pointer, previouslyOver);\r\n                }\r\n            }\r\n\r\n            this._over[pointer.id] = [];\r\n        }\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer over and out events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processOverOutEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OVER\r\n     * @fires Phaser.Input.Events#POINTER_OVER\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_OUT\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_OUT\r\n     * @fires Phaser.Input.Events#POINTER_OUT\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processOverOutEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var i;\r\n        var gameObject;\r\n        var justOut = [];\r\n        var justOver = [];\r\n        var stillOver = [];\r\n        var previouslyOver = this._over[pointer.id];\r\n        var currentlyDragging = this._drag[pointer.id];\r\n\r\n        var manager = this.manager;\r\n\r\n        //  Go through all objects the pointer was previously over, and see if it still is.\r\n        //  Splits the previouslyOver array into two parts: justOut and stillOver\r\n\r\n        for (i = 0; i < previouslyOver.length; i++)\r\n        {\r\n            gameObject = previouslyOver[i];\r\n\r\n            if (currentlyOver.indexOf(gameObject) === -1 && currentlyDragging.indexOf(gameObject) === -1)\r\n            {\r\n                //  Not in the currentlyOver array, so must be outside of this object now\r\n                justOut.push(gameObject);\r\n            }\r\n            else\r\n            {\r\n                //  In the currentlyOver array\r\n                stillOver.push(gameObject);\r\n            }\r\n        }\r\n\r\n        //  Go through all objects the pointer is currently over (the hit test results)\r\n        //  and if not in the previouslyOver array we know it's a new entry, so add to justOver\r\n        for (i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            gameObject = currentlyOver[i];\r\n\r\n            //  Is this newly over?\r\n\r\n            if (previouslyOver.indexOf(gameObject) === -1)\r\n            {\r\n                justOver.push(gameObject);\r\n            }\r\n        }\r\n\r\n        //  By this point the arrays are filled, so now we can process what happened...\r\n\r\n        //  Process the Just Out objects\r\n        var total = justOut.length;\r\n\r\n        var totalInteracted = 0;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        if (total > 0)\r\n        {\r\n            this.sortGameObjects(justOut, pointer);\r\n\r\n            //  Call onOut for everything in the justOut array\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                gameObject = justOut[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  Reset cursor before we emit the event, in case they want to change it during the event\r\n                manager.resetCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OUT, pointer, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OUT, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit(Events.POINTER_OUT, pointer, justOut);\r\n            }\r\n        }\r\n\r\n        //  Process the Just Over objects\r\n        total = justOver.length;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        aborted = false;\r\n\r\n        if (total > 0)\r\n        {\r\n            this.sortGameObjects(justOver, pointer);\r\n\r\n            //  Call onOver for everything in the justOver array\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                gameObject = justOver[i];\r\n\r\n                if (!gameObject.input)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                //  Set cursor before we emit the event, in case they want to change it during the event\r\n                manager.setCursor(gameObject.input);\r\n\r\n                gameObject.emit(Events.GAMEOBJECT_POINTER_OVER, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n                totalInteracted++;\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n\r\n                this.emit(Events.GAMEOBJECT_OVER, pointer, gameObject, _eventContainer);\r\n\r\n                if (_eventData.cancelled || !gameObject.input)\r\n                {\r\n                    aborted = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!aborted)\r\n            {\r\n                this.emit(Events.POINTER_OVER, pointer, justOver);\r\n            }\r\n        }\r\n\r\n        //  Add the contents of justOver to the previously over array\r\n        previouslyOver = stillOver.concat(justOver);\r\n\r\n        //  Then sort it into display list order\r\n        this._over[pointer.id] = this.sortGameObjects(previouslyOver, pointer);\r\n\r\n        return totalInteracted;\r\n    },\r\n\r\n    /**\r\n     * An internal method that handles the Pointer up events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#processUpEvents\r\n     * @private\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_POINTER_UP\r\n     * @fires Phaser.Input.Events#GAMEOBJECT_UP\r\n     * @fires Phaser.Input.Events#POINTER_UP\r\n     * @fires Phaser.Input.Events#POINTER_UP_OUTSIDE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - The pointer to check for events against.\r\n     *\r\n     * @return {number} The total number of objects interacted with.\r\n     */\r\n    processUpEvents: function (pointer)\r\n    {\r\n        var currentlyOver = this._temp;\r\n\r\n        var _eventData = this._eventData;\r\n        var _eventContainer = this._eventContainer;\r\n\r\n        _eventData.cancelled = false;\r\n\r\n        var aborted = false;\r\n\r\n        //  Go through all objects the pointer was over and fire their events / callbacks\r\n        for (var i = 0; i < currentlyOver.length; i++)\r\n        {\r\n            var gameObject = currentlyOver[i];\r\n\r\n            if (!gameObject.input)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            gameObject.emit(Events.GAMEOBJECT_POINTER_UP, pointer, gameObject.input.localX, gameObject.input.localY, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n\r\n            this.emit(Events.GAMEOBJECT_UP, pointer, gameObject, _eventContainer);\r\n\r\n            if (_eventData.cancelled || !gameObject.input)\r\n            {\r\n                aborted = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //  If they released outside the canvas, but pressed down inside it, we'll still dispatch the event.\r\n        if (!aborted && this.manager)\r\n        {\r\n            if (pointer.upElement === this.manager.game.canvas)\r\n            {\r\n                this.emit(Events.POINTER_UP, pointer, currentlyOver);\r\n            }\r\n            else\r\n            {\r\n                this.emit(Events.POINTER_UP_OUTSIDE, pointer);\r\n            }\r\n        }\r\n\r\n        return currentlyOver.length;\r\n    },\r\n\r\n    /**\r\n     * Queues a Game Object for insertion into this Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#queueForInsertion\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to add.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    queueForInsertion: function (child)\r\n    {\r\n        if (this._pendingInsertion.indexOf(child) === -1 && this._list.indexOf(child) === -1)\r\n        {\r\n            this._pendingInsertion.push(child);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Queues a Game Object for removal from this Input Plugin on the next update.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#queueForRemoval\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to remove.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    queueForRemoval: function (child)\r\n    {\r\n        this._pendingRemoval.push(child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the draggable state of the given array of Game Objects.\r\n     *\r\n     * They can either be set to be draggable, or can have their draggable state removed by passing `false`.\r\n     *\r\n     * A Game Object will not fire drag events unless it has been specifically enabled for drag.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDraggable\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to change the draggable state on.\r\n     * @param {boolean} [value=true] - Set to `true` if the Game Objects should be made draggable, `false` if they should be unset.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setDraggable: function (gameObjects, value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            gameObject.input.draggable = value;\r\n\r\n            var index = this._draggable.indexOf(gameObject);\r\n\r\n            if (value && index === -1)\r\n            {\r\n                this._draggable.push(gameObject);\r\n            }\r\n            else if (!value && index > -1)\r\n            {\r\n                this._draggable.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a function that can be passed to `setInteractive`, `enable` or `setHitArea` that will handle\r\n     * pixel-perfect input detection on an Image or Sprite based Game Object, or any custom class that extends them.\r\n     *\r\n     * The following will create a sprite that is clickable on any pixel that has an alpha value >= 1.\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect());\r\n     * ```\r\n     *\r\n     * The following will create a sprite that is clickable on any pixel that has an alpha value >= 150.\r\n     *\r\n     * ```javascript\r\n     * this.add.sprite(x, y, key).setInteractive(this.input.makePixelPerfect(150));\r\n     * ```\r\n     *\r\n     * Once you have made an Interactive Object pixel perfect it impacts all input related events for it: down, up,\r\n     * dragstart, drag, etc.\r\n     *\r\n     * As a pointer interacts with the Game Object it will constantly poll the texture, extracting a single pixel from\r\n     * the given coordinates and checking its color values. This is an expensive process, so should only be enabled on\r\n     * Game Objects that really need it.\r\n     *\r\n     * You cannot make non-texture based Game Objects pixel perfect. So this will not work on Graphics, BitmapText,\r\n     * Render Textures, Text, Tilemaps, Containers or Particles.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#makePixelPerfect\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} [alphaTolerance=1] - The alpha level that the pixel should be above to be included as a successful interaction.\r\n     *\r\n     * @return {function} A Pixel Perfect Handler for use as a hitArea shape callback.\r\n     */\r\n    makePixelPerfect: function (alphaTolerance)\r\n    {\r\n        if (alphaTolerance === undefined) { alphaTolerance = 1; }\r\n\r\n        var textureManager = this.systems.textures;\r\n\r\n        return CreatePixelPerfectHandler(textureManager, alphaTolerance);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for the given array of Game Objects.\r\n     *\r\n     * A hit area is typically one of the geometric shapes Phaser provides, such as a `Phaser.Geom.Rectangle`\r\n     * or `Phaser.Geom.Circle`. However, it can be any object as long as it works with the provided callback.\r\n     *\r\n     * If no hit area is provided a Rectangle is created based on the size of the Game Object, if possible\r\n     * to calculate.\r\n     *\r\n     * The hit area callback is the function that takes an `x` and `y` coordinate and returns a boolean if\r\n     * those values fall within the area of the shape or not. All of the Phaser geometry objects provide this,\r\n     * such as `Phaser.Geom.Rectangle.Contains`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitArea\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set the hit area on.\r\n     * @param {(Phaser.Types.Input.InputConfiguration|any)} [hitArea] - Either an input configuration object, or a geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [hitAreaCallback] - The 'contains' function to invoke to check if the pointer is within the hit area.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitArea: function (gameObjects, hitArea, hitAreaCallback)\r\n    {\r\n        if (hitArea === undefined)\r\n        {\r\n            return this.setHitAreaFromTexture(gameObjects);\r\n        }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        var draggable = false;\r\n        var dropZone = false;\r\n        var cursor = false;\r\n        var useHandCursor = false;\r\n        var pixelPerfect = false;\r\n        var customHitArea = true;\r\n\r\n        //  Config object?\r\n        if (IsPlainObject(hitArea))\r\n        {\r\n            var config = hitArea;\r\n\r\n            hitArea = GetFastValue(config, 'hitArea', null);\r\n            hitAreaCallback = GetFastValue(config, 'hitAreaCallback', null);\r\n            draggable = GetFastValue(config, 'draggable', false);\r\n            dropZone = GetFastValue(config, 'dropZone', false);\r\n            cursor = GetFastValue(config, 'cursor', false);\r\n            useHandCursor = GetFastValue(config, 'useHandCursor', false);\r\n\r\n            pixelPerfect = GetFastValue(config, 'pixelPerfect', false);\r\n            var alphaTolerance = GetFastValue(config, 'alphaTolerance', 1);\r\n\r\n            if (pixelPerfect)\r\n            {\r\n                hitArea = {};\r\n                hitAreaCallback = this.makePixelPerfect(alphaTolerance);\r\n            }\r\n\r\n            //  Still no hitArea or callback?\r\n            if (!hitArea || !hitAreaCallback)\r\n            {\r\n                this.setHitAreaFromTexture(gameObjects);\r\n                customHitArea = false;\r\n            }\r\n        }\r\n        else if (typeof hitArea === 'function' && !hitAreaCallback)\r\n        {\r\n            hitAreaCallback = hitArea;\r\n            hitArea = {};\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            if (pixelPerfect && gameObject.type === 'Container')\r\n            {\r\n                console.warn('Cannot pixelPerfect test a Container. Use a custom callback.');\r\n                continue;\r\n            }\r\n\r\n            var io = (!gameObject.input) ? CreateInteractiveObject(gameObject, hitArea, hitAreaCallback) : gameObject.input;\r\n\r\n            io.customHitArea = customHitArea;\r\n            io.dropZone = dropZone;\r\n            io.cursor = (useHandCursor) ? 'pointer' : cursor;\r\n\r\n            gameObject.input = io;\r\n\r\n            if (draggable)\r\n            {\r\n                this.setDraggable(gameObject);\r\n            }\r\n\r\n            this.queueForInsertion(gameObject);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Circle` shape, using\r\n     * the given coordinates and radius to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a circle hit area.\r\n     * @param {number} x - The center of the circle.\r\n     * @param {number} y - The center of the circle.\r\n     * @param {number} radius - The radius of the circle.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Circle.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaCircle: function (gameObjects, x, y, radius, callback)\r\n    {\r\n        if (callback === undefined) { callback = CircleContains; }\r\n\r\n        var shape = new Circle(x, y, radius);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Ellipse` shape, using\r\n     * the given coordinates and dimensions to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaEllipse\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n     * @param {number} x - The center of the ellipse.\r\n     * @param {number} y - The center of the ellipse.\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Ellipse.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaEllipse: function (gameObjects, x, y, width, height, callback)\r\n    {\r\n        if (callback === undefined) { callback = EllipseContains; }\r\n\r\n        var shape = new Ellipse(x, y, width, height);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n     * the Game Objects texture frame to define the position and size of the hit area.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaFromTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having an ellipse hit area.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaFromTexture: function (gameObjects, callback)\r\n    {\r\n        if (callback === undefined) { callback = RectangleContains; }\r\n\r\n        if (!Array.isArray(gameObjects))\r\n        {\r\n            gameObjects = [ gameObjects ];\r\n        }\r\n\r\n        for (var i = 0; i < gameObjects.length; i++)\r\n        {\r\n            var gameObject = gameObjects[i];\r\n\r\n            var frame = gameObject.frame;\r\n\r\n            var width = 0;\r\n            var height = 0;\r\n\r\n            if (gameObject.width)\r\n            {\r\n                width = gameObject.width;\r\n                height = gameObject.height;\r\n            }\r\n            else if (frame)\r\n            {\r\n                width = frame.realWidth;\r\n                height = frame.realHeight;\r\n            }\r\n\r\n            if (gameObject.type === 'Container' && (width === 0 || height === 0))\r\n            {\r\n                console.warn('Container.setInteractive must specify a Shape or call setSize() first');\r\n                continue;\r\n            }\r\n\r\n            if (width !== 0 && height !== 0)\r\n            {\r\n                gameObject.input = CreateInteractiveObject(gameObject, new Rectangle(0, 0, width, height), callback);\r\n\r\n                this.queueForInsertion(gameObject);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Rectangle` shape, using\r\n     * the given coordinates and dimensions to control its position and size.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a rectangular hit area.\r\n     * @param {number} x - The top-left of the rectangle.\r\n     * @param {number} y - The top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Rectangle.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaRectangle: function (gameObjects, x, y, width, height, callback)\r\n    {\r\n        if (callback === undefined) { callback = RectangleContains; }\r\n\r\n        var shape = new Rectangle(x, y, width, height);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets the hit area for an array of Game Objects to be a `Phaser.Geom.Triangle` shape, using\r\n     * the given coordinates to control the position of its points.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setHitAreaTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[])} gameObjects - An array of Game Objects to set as having a  triangular hit area.\r\n     * @param {number} x1 - The x coordinate of the first point of the triangle.\r\n     * @param {number} y1 - The y coordinate of the first point of the triangle.\r\n     * @param {number} x2 - The x coordinate of the second point of the triangle.\r\n     * @param {number} y2 - The y coordinate of the second point of the triangle.\r\n     * @param {number} x3 - The x coordinate of the third point of the triangle.\r\n     * @param {number} y3 - The y coordinate of the third point of the triangle.\r\n     * @param {Phaser.Types.Input.HitAreaCallback} [callback] - The hit area callback. If undefined it uses Triangle.Contains.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setHitAreaTriangle: function (gameObjects, x1, y1, x2, y2, x3, y3, callback)\r\n    {\r\n        if (callback === undefined) { callback = TriangleContains; }\r\n\r\n        var shape = new Triangle(x1, y1, x2, y2, x3, y3);\r\n\r\n        return this.setHitArea(gameObjects, shape, callback);\r\n    },\r\n\r\n    /**\r\n     * Creates an Input Debug Shape for the given Game Object.\r\n     *\r\n     * The Game Object must have _already_ been enabled for input prior to calling this method.\r\n     *\r\n     * This is intended to assist you during development and debugging.\r\n     *\r\n     * Debug Shapes can only be created for Game Objects that are using standard Phaser Geometry for input,\r\n     * including: Circle, Ellipse, Line, Polygon, Rectangle and Triangle.\r\n     *\r\n     * Game Objects that are using their automatic hit areas are using Rectangles by default, so will also work.\r\n     *\r\n     * The Debug Shape is created and added to the display list and is then kept in sync with the Game Object\r\n     * it is connected with. Should you need to modify it yourself, such as to hide it, you can access it via\r\n     * the Game Object property: `GameObject.input.hitAreaDebug`.\r\n     *\r\n     * Calling this method on a Game Object that already has a Debug Shape will first destroy the old shape,\r\n     * before creating a new one. If you wish to remove the Debug Shape entirely, you should call the\r\n     * method `InputPlugin.removeDebug`.\r\n     *\r\n     * Note that the debug shape will only show the outline of the input area. If the input test is using a\r\n     * pixel perfect check, for example, then this is not displayed. If you are using a custom shape, that\r\n     * doesn't extend one of the base Phaser Geometry objects, as your hit area, then this method will not\r\n     * work.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#enableDebug\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to create the input debug shape for.\r\n     * @param {number} [color=0x00ff00] - The outline color of the debug shape.\r\n     *\r\n     * @return {this} This Input Plugin.\r\n     */\r\n    enableDebug: function (gameObject, color)\r\n    {\r\n        if (color === undefined) { color = 0x00ff00; }\r\n\r\n        var input = gameObject.input;\r\n\r\n        if (!input || !input.hitArea)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var shape = input.hitArea;\r\n        var shapeType = shape.type;\r\n        var debug = input.hitAreaDebug;\r\n        var factory = this.systems.add;\r\n        var updateList = this.systems.updateList;\r\n\r\n        if (debug)\r\n        {\r\n            updateList.remove(debug);\r\n\r\n            debug.destroy();\r\n\r\n            debug = null;\r\n        }\r\n\r\n        var offsetx = 0;\r\n        var offsety = 0;\r\n        switch (shapeType)\r\n        {\r\n            case GEOM_CONST.CIRCLE:\r\n                debug = factory.arc(0, 0, shape.radius);\r\n                offsetx = shape.x - shape.radius;\r\n                offsety = shape.y - shape.radius;\r\n                break;\r\n\r\n            case GEOM_CONST.ELLIPSE:\r\n                debug = factory.ellipse(0, 0, shape.width, shape.height);\r\n                offsetx = shape.x - shape.width / 2;\r\n                offsety = shape.y - shape.height / 2;\r\n                break;\r\n\r\n            case GEOM_CONST.LINE:\r\n                debug = factory.line(0, 0, shape.x1, shape.y1, shape.x2, shape.y2);\r\n                break;\r\n\r\n            case GEOM_CONST.POLYGON:\r\n                debug = factory.polygon(0, 0, shape.points);\r\n                break;\r\n\r\n            case GEOM_CONST.RECTANGLE:\r\n                debug = factory.rectangle(0, 0, shape.width, shape.height);\r\n                offsetx = shape.x;\r\n                offsety = shape.y;\r\n                break;\r\n\r\n            case GEOM_CONST.TRIANGLE:\r\n                debug = factory.triangle(0, 0, shape.x1, shape.y1, shape.x2, shape.y2, shape.x3, shape.y3);\r\n                break;\r\n        }\r\n\r\n        if (debug)\r\n        {\r\n            debug.isFilled = false;\r\n\r\n            debug.preUpdate = function ()\r\n            {\r\n                debug.setStrokeStyle(1 / gameObject.scale, color);\r\n\r\n                debug.setDisplayOrigin(gameObject.displayOriginX, gameObject.displayOriginY);\r\n\r\n                var x = gameObject.x;\r\n                var y = gameObject.y;\r\n                var rotation = gameObject.rotation;\r\n                var scaleX = gameObject.scaleX;\r\n                var scaleY = gameObject.scaleY;\r\n\r\n                if (gameObject.parentContainer)\r\n                {\r\n                    var matrix = gameObject.getWorldTransformMatrix();\r\n\r\n                    x = matrix.tx;\r\n                    y = matrix.ty;\r\n                    rotation = matrix.rotation;\r\n                    scaleX = matrix.scaleX;\r\n                    scaleY = matrix.scaleY;\r\n                }\r\n\r\n                debug.setRotation(rotation);\r\n                debug.setScale(scaleX, scaleY);\r\n                debug.setPosition(x + offsetx, y + offsety);\r\n                debug.setScrollFactor(gameObject.scrollFactorX, gameObject.scrollFactorY);\r\n                debug.setDepth(gameObject.depth);\r\n            };\r\n\r\n            updateList.add(debug);\r\n\r\n            input.hitAreaDebug = debug;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes an Input Debug Shape from the given Game Object.\r\n     *\r\n     * The shape is destroyed immediately and the `hitAreaDebug` property is set to `null`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#removeDebug\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to remove the input debug shape from.\r\n     *\r\n     * @return {this} This Input Plugin.\r\n     */\r\n    removeDebug: function (gameObject)\r\n    {\r\n        var input = gameObject.input;\r\n\r\n        if (input && input.hitAreaDebug)\r\n        {\r\n            var debug = input.hitAreaDebug;\r\n\r\n            this.systems.updateList.remove(debug);\r\n\r\n            debug.destroy();\r\n\r\n            input.hitAreaDebug = null;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the Pointers to always poll.\r\n     *\r\n     * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n     * or being interacted with it, regardless if the Pointer has actually moved or not.\r\n     *\r\n     * You should enable this if you want objects in your game to fire over / out events, and the objects\r\n     * are constantly moving, but the pointer may not have. Polling every frame has additional computation\r\n     * costs, especially if there are a large number of interactive objects in your game.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollAlways\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setPollAlways: function ()\r\n    {\r\n        return this.setPollRate(0);\r\n    },\r\n\r\n    /**\r\n     * Sets the Pointers to only poll when they are moved or updated.\r\n     *\r\n     * When a pointer is polled it runs a hit test to see which Game Objects are currently below it,\r\n     * or being interacted with it.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollOnMove\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setPollOnMove: function ()\r\n    {\r\n        return this.setPollRate(-1);\r\n    },\r\n\r\n    /**\r\n     * Sets the poll rate value. This is the amount of time that should have elapsed before a pointer\r\n     * will be polled again. See the `setPollAlways` and `setPollOnMove` methods.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setPollRate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The amount of time, in ms, that should elapsed before re-polling the pointers.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setPollRate: function (value)\r\n    {\r\n        this.pollRate = value;\r\n        this._pollTimer = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When set to `true` the global Input Manager will emulate DOM behavior by only emitting events from\r\n     * the top-most Scene in the Scene List. By default, if a Scene receives an input event it will then stop the event\r\n     * from flowing down to any Scenes below it in the Scene list. To disable this behavior call this method with `false`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setGlobalTopOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - Set to `true` to stop processing input events on the Scene that receives it, or `false` to let the event continue down the Scene list.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setGlobalTopOnly: function (value)\r\n    {\r\n        this.manager.globalTopOnly = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * When set to `true` this Input Plugin will emulate DOM behavior by only emitting events from\r\n     * the top-most Game Objects in the Display List.\r\n     *\r\n     * If set to `false` it will emit events from all Game Objects below a Pointer, not just the top one.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setTopOnly\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - `true` to only include the top-most Game Object, or `false` to include all Game Objects in a hit test.\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    setTopOnly: function (value)\r\n    {\r\n        this.topOnly = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Given an array of Game Objects and a Pointer, sort the array and return it,\r\n     * so that the objects are in render order with the lowest at the bottom.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortGameObjects\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} gameObjects - An array of Game Objects to be sorted.\r\n     * @param {Phaser.Input.Pointer} pointer - The Pointer to check against the Game Objects.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The sorted array of Game Objects.\r\n     */\r\n    sortGameObjects: function (gameObjects, pointer)\r\n    {\r\n        if (gameObjects.length < 2)\r\n        {\r\n            return gameObjects;\r\n        }\r\n\r\n        var list = pointer.camera.renderList;\r\n\r\n        return gameObjects.sort(function (childA, childB)\r\n        {\r\n            return list.indexOf(childB) - list.indexOf(childA);\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Given an array of Drop Zone Game Objects, sort the array and return it,\r\n     * so that the objects are in depth index order with the lowest at the bottom.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortDropZones\r\n     * @since 3.52.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject[]} gameObjects - An array of Game Objects to be sorted.\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The sorted array of Game Objects.\r\n     */\r\n    sortDropZones: function (gameObjects)\r\n    {\r\n        if (gameObjects.length < 2)\r\n        {\r\n            return gameObjects;\r\n        }\r\n\r\n        this.scene.sys.depthSort();\r\n\r\n        return gameObjects.sort(this.sortDropZoneHandler.bind(this));\r\n    },\r\n\r\n    /**\r\n     * Return the child lowest down the display list (with the smallest index)\r\n     * Will iterate through all parent containers, if present.\r\n     *\r\n     * Prior to version 3.52.0 this method was called `sortHandlerGO`.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#sortDropZoneHandler\r\n     * @private\r\n     * @since 3.52.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - The first Game Object to compare.\r\n     * @param {Phaser.GameObjects.GameObject} childB - The second Game Object to compare.\r\n     *\r\n     * @return {number} Returns either a negative or positive integer, or zero if they match.\r\n     */\r\n    sortDropZoneHandler: function (childA, childB)\r\n    {\r\n        if (!childA.parentContainer && !childB.parentContainer)\r\n        {\r\n            //  Quick bail out when neither child has a container\r\n            return this.displayList.getIndex(childB) - this.displayList.getIndex(childA);\r\n        }\r\n        else if (childA.parentContainer === childB.parentContainer)\r\n        {\r\n            //  Quick bail out when both children have the same container\r\n            return childB.parentContainer.getIndex(childB) - childA.parentContainer.getIndex(childA);\r\n        }\r\n        else if (childA.parentContainer === childB)\r\n        {\r\n            //  Quick bail out when childA is a child of childB\r\n            return -1;\r\n        }\r\n        else if (childB.parentContainer === childA)\r\n        {\r\n            //  Quick bail out when childA is a child of childB\r\n            return 1;\r\n        }\r\n        else\r\n        {\r\n            //  Container index check\r\n            var listA = childA.getIndexList();\r\n            var listB = childB.getIndexList();\r\n            var len = Math.min(listA.length, listB.length);\r\n\r\n            for (var i = 0; i < len; i++)\r\n            {\r\n                var indexA = listA[i];\r\n                var indexB = listB[i];\r\n\r\n                if (indexA === indexB)\r\n                {\r\n                    //  Go to the next level down\r\n                    continue;\r\n                }\r\n                else\r\n                {\r\n                    //  Non-matching parents, so return\r\n                    return indexB - indexA;\r\n                }\r\n            }\r\n\r\n            return listB.length - listA.length;\r\n        }\r\n\r\n        //  Technically this shouldn't happen, but ...\r\n        // eslint-disable-next-line no-unreachable\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * This method should be called from within an input event handler, such as `pointerdown`.\r\n     *\r\n     * When called, it stops the Input Manager from allowing _this specific event_ to be processed by any other Scene\r\n     * not yet handled in the scene list.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#stopPropagation\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This InputPlugin object.\r\n     */\r\n    stopPropagation: function ()\r\n    {\r\n        this.manager._tempSkip = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds new Pointer objects to the Input Manager.\r\n     *\r\n     * By default Phaser creates 2 pointer objects: `mousePointer` and `pointer1`.\r\n     *\r\n     * You can create more either by calling this method, or by setting the `input.activePointers` property\r\n     * in the Game Config, up to a maximum of 10 pointers.\r\n     *\r\n     * The first 10 pointers are available via the `InputPlugin.pointerX` properties, once they have been added\r\n     * via this method.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#addPointer\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} [quantity=1] The number of new Pointers to create. A maximum of 10 is allowed in total.\r\n     *\r\n     * @return {Phaser.Input.Pointer[]} An array containing all of the new Pointer objects that were created.\r\n     */\r\n    addPointer: function (quantity)\r\n    {\r\n        return this.manager.addPointer(quantity);\r\n    },\r\n\r\n    /**\r\n     * Tells the Input system to set a custom cursor.\r\n     *\r\n     * This cursor will be the default cursor used when interacting with the game canvas.\r\n     *\r\n     * If an Interactive Object also sets a custom cursor, this is the cursor that is reset after its use.\r\n     *\r\n     * Any valid CSS cursor value is allowed, including paths to image files, i.e.:\r\n     *\r\n     * ```javascript\r\n     * this.input.setDefaultCursor('url(assets/cursors/sword.cur), pointer');\r\n     * ```\r\n     *\r\n     * Please read about the differences between browsers when it comes to the file formats and sizes they support:\r\n     *\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_User_Interface/Using_URL_values_for_the_cursor_property\r\n     *\r\n     * It's up to you to pick a suitable cursor format that works across the range of browsers you need to support.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#setDefaultCursor\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} cursor - The CSS to be used when setting the default cursor.\r\n     *\r\n     * @return {this} This Input instance.\r\n     */\r\n    setDefaultCursor: function (cursor)\r\n    {\r\n        this.manager.setDefaultCursor(cursor);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is transitioning in.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionIn\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionIn: function ()\r\n    {\r\n        this.enabled = this.settings.transitionAllowInput;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin has finished transitioning in.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionComplete\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionComplete: function ()\r\n    {\r\n        if (!this.settings.transitionAllowInput)\r\n        {\r\n            this.enabled = true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is transitioning out.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#transitionOut\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    transitionOut: function ()\r\n    {\r\n        this.enabled = this.settings.transitionAllowInput;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#shutdown\r\n     * @fires Phaser.Input.Events#SHUTDOWN\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.SHUTDOWN);\r\n\r\n        this._temp.length = 0;\r\n        this._list.length = 0;\r\n        this._draggable.length = 0;\r\n        this._pendingRemoval.length = 0;\r\n        this._pendingInsertion.length = 0;\r\n        this._dragState.length = 0;\r\n\r\n        for (var i = 0; i < 10; i++)\r\n        {\r\n            this._drag[i] = [];\r\n            this._over[i] = [];\r\n        }\r\n\r\n        this.removeAllListeners();\r\n\r\n        var manager = this.manager;\r\n\r\n        manager.canvas.style.cursor = manager.defaultCursor;\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(SceneEvents.TRANSITION_START, this.transitionIn, this);\r\n        eventEmitter.off(SceneEvents.TRANSITION_OUT, this.transitionOut, this);\r\n        eventEmitter.off(SceneEvents.TRANSITION_COMPLETE, this.transitionComplete, this);\r\n        eventEmitter.off(SceneEvents.PRE_UPDATE, this.preUpdate, this);\r\n\r\n        manager.events.off(Events.GAME_OUT, this.onGameOut, this);\r\n        manager.events.off(Events.GAME_OVER, this.onGameOver, this);\r\n\r\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.Input.InputPlugin#destroy\r\n     * @fires Phaser.Input.Events#DESTROY\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        //  Registered input plugins listen for this\r\n        this.pluginEvents.emit(Events.DESTROY);\r\n\r\n        this.pluginEvents.removeAllListeners();\r\n\r\n        this.scene.sys.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.cameras = null;\r\n        this.manager = null;\r\n        this.events = null;\r\n        this.mouse = null;\r\n    },\r\n\r\n    /**\r\n     * The x coordinates of the ActivePointer based on the first camera in the camera list.\r\n     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#x\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    x: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer.x;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The y coordinates of the ActivePointer based on the first camera in the camera list.\r\n     * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#y\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer.y;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Are any mouse or touch pointers currently over the game canvas?\r\n     *\r\n     * @name Phaser.Input.InputPlugin#isOver\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isOver: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.isOver;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The mouse has its own unique Pointer object, which you can reference directly if making a _desktop specific game_.\r\n     * If you are supporting both desktop and touch devices then do not use this property, instead use `activePointer`\r\n     * which will always map to the most recently interacted pointer.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#mousePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    mousePointer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.mousePointer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The current active input Pointer.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#activePointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    activePointer: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.activePointer;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer1\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[1];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer2\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[2];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer3\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer3: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[3];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer4\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer4: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[4];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer5\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer5: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[5];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer6\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer6: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[6];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer7\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer7: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[7];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer8\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer8: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[8];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer9\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer9: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[9];\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A touch-based Pointer object.\r\n     * This will be `undefined` by default unless you add a new Pointer using `addPointer`.\r\n     *\r\n     * @name Phaser.Input.InputPlugin#pointer10\r\n     * @type {Phaser.Input.Pointer}\r\n     * @readonly\r\n     * @since 3.10.0\r\n     */\r\n    pointer10: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.manager.pointers[10];\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('InputPlugin', InputPlugin, 'input');\r\n\r\nmodule.exports = InputPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetValue = require('../utils/object/GetValue');\r\n\r\n//  Contains the plugins that Phaser uses globally and locally.\r\n//  These are the source objects, not instantiated.\r\nvar inputPlugins = {};\r\n\r\n/**\r\n * @namespace Phaser.Input.InputPluginCache\r\n */\r\n\r\nvar InputPluginCache = {};\r\n\r\n/**\r\n * Static method called directly by the Core internal Plugins.\r\n * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)\r\n * Plugin is the object to instantiate to create the plugin\r\n * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)\r\n *\r\n * @function Phaser.Input.InputPluginCache.register\r\n * @static\r\n * @since 3.10.0\r\n *\r\n * @param {string} key - A reference used to get this plugin from the plugin cache.\r\n * @param {function} plugin - The plugin to be stored. Should be the core object, not instantiated.\r\n * @param {string} mapping - If this plugin is to be injected into the Input Plugin, this is the property key used.\r\n * @param {string} settingsKey - The key in the Scene Settings to check to see if this plugin should install or not.\r\n * @param {string} configKey - The key in the Game Config to check to see if this plugin should install or not.\r\n */\r\nInputPluginCache.register = function (key, plugin, mapping, settingsKey, configKey)\r\n{\r\n    inputPlugins[key] = { plugin: plugin, mapping: mapping, settingsKey: settingsKey, configKey: configKey };\r\n};\r\n\r\n/**\r\n * Returns the input plugin object from the cache based on the given key.\r\n *\r\n * @function Phaser.Input.InputPluginCache.getPlugin\r\n * @static\r\n * @since 3.10.0\r\n *\r\n * @param {string} key - The key of the input plugin to get.\r\n *\r\n * @return {Phaser.Types.Input.InputPluginContainer} The input plugin object.\r\n */\r\nInputPluginCache.getPlugin = function (key)\r\n{\r\n    return inputPlugins[key];\r\n};\r\n\r\n/**\r\n * Installs all of the registered Input Plugins into the given target.\r\n *\r\n * @function Phaser.Input.InputPluginCache.install\r\n * @static\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Input.InputPlugin} target - The target InputPlugin to install the plugins into.\r\n */\r\nInputPluginCache.install = function (target)\r\n{\r\n    var sys = target.scene.sys;\r\n    var settings = sys.settings.input;\r\n    var config = sys.game.config;\r\n\r\n    for (var key in inputPlugins)\r\n    {\r\n        var source = inputPlugins[key].plugin;\r\n        var mapping = inputPlugins[key].mapping;\r\n        var settingsKey = inputPlugins[key].settingsKey;\r\n        var configKey = inputPlugins[key].configKey;\r\n\r\n        if (GetValue(settings, settingsKey, config[configKey]))\r\n        {\r\n            target[mapping] = new source(target);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Removes an input plugin based on the given key.\r\n *\r\n * @function Phaser.Input.InputPluginCache.remove\r\n * @static\r\n * @since 3.10.0\r\n *\r\n * @param {string} key - The key of the input plugin to remove.\r\n */\r\nInputPluginCache.remove = function (key)\r\n{\r\n    if (inputPlugins.hasOwnProperty(key))\r\n    {\r\n        delete inputPlugins[key];\r\n    }\r\n};\r\n\r\nmodule.exports = InputPluginCache;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * Contains information about a specific Gamepad Axis.\r\n * Axis objects are created automatically by the Gamepad as they are needed.\r\n *\r\n * @class Axis\r\n * @memberof Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Gamepad.Gamepad} pad - A reference to the Gamepad that this Axis belongs to.\r\n * @param {number} index - The index of this Axis.\r\n */\r\nvar Axis = new Class({\r\n\r\n    initialize:\r\n\r\n    function Axis (pad, index)\r\n    {\r\n        /**\r\n         * A reference to the Gamepad that this Axis belongs to.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#pad\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @since 3.0.0\r\n         */\r\n        this.pad = pad;\r\n\r\n        /**\r\n         * An event emitter to use to emit the axis events.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events = pad.events;\r\n\r\n        /**\r\n         * The index of this Axis.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = index;\r\n\r\n        /**\r\n         * The raw axis value, between -1 and 1 with 0 being dead center.\r\n         * Use the method `getValue` to get a normalized value with the threshold applied.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#value\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.value = 0;\r\n\r\n        /**\r\n         * Movement tolerance threshold below which axis values are ignored in `getValue`.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Axis#threshold\r\n         * @type {number}\r\n         * @default 0.1\r\n         * @since 3.0.0\r\n         */\r\n        this.threshold = 0.1;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler for this Axis.\r\n     * Called automatically by the Gamepad as part of its update.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Axis#update\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value of the axis movement.\r\n     */\r\n    update: function (value)\r\n    {\r\n        this.value = value;\r\n    },\r\n\r\n    /**\r\n     * Applies the `threshold` value to the axis and returns it.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Axis#getValue\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The axis value, adjusted for the movement threshold.\r\n     */\r\n    getValue: function ()\r\n    {\r\n        return (Math.abs(this.value) < this.threshold) ? 0 : this.value;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Axis instance and releases external references it holds.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Axis#destroy\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.pad = null;\r\n        this.events = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Axis;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Events = require('./events');\r\n\r\n/**\r\n * @classdesc\r\n * Contains information about a specific button on a Gamepad.\r\n * Button objects are created automatically by the Gamepad as they are needed.\r\n *\r\n * @class Button\r\n * @memberof Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Gamepad.Gamepad} pad - A reference to the Gamepad that this Button belongs to.\r\n * @param {number} index - The index of this Button.\r\n */\r\nvar Button = new Class({\r\n\r\n    initialize:\r\n\r\n    function Button (pad, index)\r\n    {\r\n        /**\r\n         * A reference to the Gamepad that this Button belongs to.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#pad\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @since 3.0.0\r\n         */\r\n        this.pad = pad;\r\n\r\n        /**\r\n         * An event emitter to use to emit the button events.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.events = pad.manager;\r\n\r\n        /**\r\n         * The index of this Button.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = index;\r\n\r\n        /**\r\n         * Between 0 and 1.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#value\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.value = 0;\r\n\r\n        /**\r\n         * Can be set for analogue buttons to enable a 'pressure' threshold,\r\n         * before a button is considered as being 'pressed'.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#threshold\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.threshold = 1;\r\n\r\n        /**\r\n         * Is the Button being pressed down or not?\r\n         *\r\n         * @name Phaser.Input.Gamepad.Button#pressed\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.pressed = false;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler for this Button.\r\n     * Called automatically by the Gamepad as part of its update.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Button#update\r\n     * @fires Phaser.Input.Gamepad.Events#BUTTON_DOWN\r\n     * @fires Phaser.Input.Gamepad.Events#BUTTON_UP\r\n     * @fires Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_DOWN\r\n     * @fires Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_UP\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value of the button. Between 0 and 1.\r\n     */\r\n    update: function (value)\r\n    {\r\n        this.value = value;\r\n\r\n        var pad = this.pad;\r\n        var index = this.index;\r\n\r\n        if (value >= this.threshold)\r\n        {\r\n            if (!this.pressed)\r\n            {\r\n                this.pressed = true;\r\n                this.events.emit(Events.BUTTON_DOWN, pad, this, value);\r\n                this.pad.emit(Events.GAMEPAD_BUTTON_DOWN, index, value, this);\r\n            }\r\n        }\r\n        else if (this.pressed)\r\n        {\r\n            this.pressed = false;\r\n            this.events.emit(Events.BUTTON_UP, pad, this, value);\r\n            this.pad.emit(Events.GAMEPAD_BUTTON_UP, index, value, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Button instance and releases external references it holds.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Button#destroy\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.pad = null;\r\n        this.events = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Button;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Axis = require('./Axis');\r\nvar Button = require('./Button');\r\nvar Class = require('../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A single Gamepad.\r\n *\r\n * These are created, updated and managed by the Gamepad Plugin.\r\n *\r\n * @class Gamepad\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Gamepad.GamepadPlugin} manager - A reference to the Gamepad Plugin.\r\n * @param {Phaser.Types.Input.Gamepad.Pad} pad - The Gamepad object, as extracted from GamepadEvent.\r\n */\r\nvar Gamepad = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function Gamepad (manager, pad)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Gamepad Plugin.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#manager\r\n         * @type {Phaser.Input.Gamepad.GamepadPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = manager;\r\n\r\n        /**\r\n         * A reference to the native Gamepad object that is connected to the browser.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#pad\r\n         * @type {any}\r\n         * @since 3.10.0\r\n         */\r\n        this.pad = pad;\r\n\r\n        /**\r\n         * A string containing some information about the controller.\r\n         *\r\n         * This is not strictly specified, but in Firefox it will contain three pieces of information\r\n         * separated by dashes (-): two 4-digit hexadecimal strings containing the USB vendor and\r\n         * product id of the controller, and the name of the controller as provided by the driver.\r\n         * In Chrome it will contain the name of the controller as provided by the driver,\r\n         * followed by vendor and product 4-digit hexadecimal strings.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#id\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.id = pad.id;\r\n\r\n        /**\r\n         * An integer that is unique for each Gamepad currently connected to the system.\r\n         * This can be used to distinguish multiple controllers.\r\n         * Note that disconnecting a device and then connecting a new device may reuse the previous index.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#index\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.index = pad.index;\r\n\r\n        var buttons = [];\r\n\r\n        for (var i = 0; i < pad.buttons.length; i++)\r\n        {\r\n            buttons.push(new Button(this, i));\r\n        }\r\n\r\n        /**\r\n         * An array of Gamepad Button objects, corresponding to the different buttons available on the Gamepad.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#buttons\r\n         * @type {Phaser.Input.Gamepad.Button[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.buttons = buttons;\r\n\r\n        var axes = [];\r\n\r\n        for (i = 0; i < pad.axes.length; i++)\r\n        {\r\n            axes.push(new Axis(this, i));\r\n        }\r\n\r\n        /**\r\n         * An array of Gamepad Axis objects, corresponding to the different axes available on the Gamepad, if any.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#axes\r\n         * @type {Phaser.Input.Gamepad.Axis[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.axes = axes;\r\n\r\n        /**\r\n         * The Gamepad's Haptic Actuator (Vibration / Rumble support).\r\n         * This is highly experimental and only set if both present on the device,\r\n         * and exposed by both the hardware and browser.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#vibration\r\n         * @type {GamepadHapticActuator}\r\n         * @since 3.10.0\r\n         */\r\n        this.vibration = pad.vibrationActuator;\r\n\r\n        // https://w3c.github.io/gamepad/#remapping\r\n\r\n        var _noButton = { value: 0, pressed: false };\r\n\r\n        /**\r\n         * A reference to the Left Button in the Left Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_LCLeft\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._LCLeft = (buttons[14]) ? buttons[14] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Right Button in the Left Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_LCRight\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._LCRight = (buttons[15]) ? buttons[15] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Top Button in the Left Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_LCTop\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._LCTop = (buttons[12]) ? buttons[12] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Bottom Button in the Left Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_LCBottom\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._LCBottom = (buttons[13]) ? buttons[13] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Left Button in the Right Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_RCLeft\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._RCLeft = (buttons[2]) ? buttons[2] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Right Button in the Right Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_RCRight\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._RCRight = (buttons[1]) ? buttons[1] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Top Button in the Right Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_RCTop\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._RCTop = (buttons[3]) ? buttons[3] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Bottom Button in the Right Cluster.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_RCBottom\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._RCBottom = (buttons[0]) ? buttons[0] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Top Left Front Button (L1 Shoulder Button)\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_FBLeftTop\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._FBLeftTop = (buttons[4]) ? buttons[4] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Bottom Left Front Button (L2 Shoulder Button)\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_FBLeftBottom\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._FBLeftBottom = (buttons[6]) ? buttons[6] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Top Right Front Button (R1 Shoulder Button)\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_FBRightTop\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._FBRightTop = (buttons[5]) ? buttons[5] : _noButton;\r\n\r\n        /**\r\n         * A reference to the Bottom Right Front Button (R2 Shoulder Button)\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_FBRightBottom\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._FBRightBottom = (buttons[7]) ? buttons[7] : _noButton;\r\n\r\n        var _noAxis = { value: 0 };\r\n\r\n        /**\r\n         * A reference to the Horizontal Axis for the Left Stick.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_HAxisLeft\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._HAxisLeft = (axes[0]) ? axes[0] : _noAxis;\r\n\r\n        /**\r\n         * A reference to the Vertical Axis for the Left Stick.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_VAxisLeft\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._VAxisLeft = (axes[1]) ? axes[1] : _noAxis;\r\n\r\n        /**\r\n         * A reference to the Horizontal Axis for the Right Stick.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_HAxisRight\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._HAxisRight = (axes[2]) ? axes[2] : _noAxis;\r\n\r\n        /**\r\n         * A reference to the Vertical Axis for the Right Stick.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_VAxisRight\r\n         * @type {Phaser.Input.Gamepad.Button}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._VAxisRight = (axes[3]) ? axes[3] : _noAxis;\r\n\r\n        /**\r\n         * A Vector2 containing the most recent values from the Gamepad's left axis stick.\r\n         * This is updated automatically as part of the Gamepad.update cycle.\r\n         * The H Axis is mapped to the `Vector2.x` property, and the V Axis to the `Vector2.y` property.\r\n         * The values are based on the Axis thresholds.\r\n         * If the Gamepad does not have a left axis stick, the values will always be zero.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#leftStick\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.10.0\r\n         */\r\n        this.leftStick = new Vector2();\r\n\r\n        /**\r\n         * A Vector2 containing the most recent values from the Gamepad's right axis stick.\r\n         * This is updated automatically as part of the Gamepad.update cycle.\r\n         * The H Axis is mapped to the `Vector2.x` property, and the V Axis to the `Vector2.y` property.\r\n         * The values are based on the Axis thresholds.\r\n         * If the Gamepad does not have a right axis stick, the values will always be zero.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#rightStick\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.10.0\r\n         */\r\n        this.rightStick = new Vector2();\r\n\r\n        /**\r\n         * When was this Gamepad created? Used to avoid duplicate event spamming in the update loop.\r\n         *\r\n         * @name Phaser.Input.Gamepad.Gamepad#_created\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this._created = performance.now();\r\n    },\r\n\r\n    /**\r\n     * Gets the total number of axis this Gamepad claims to support.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#getAxisTotal\r\n     * @since 3.10.0\r\n     *\r\n     * @return {number} The total number of axes this Gamepad claims to support.\r\n     */\r\n    getAxisTotal: function ()\r\n    {\r\n        return this.axes.length;\r\n    },\r\n\r\n    /**\r\n     * Gets the value of an axis based on the given index.\r\n     * The index must be valid within the range of axes supported by this Gamepad.\r\n     * The return value will be a float between 0 and 1.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#getAxisValue\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} index - The index of the axes to get the value for.\r\n     *\r\n     * @return {number} The value of the axis, between 0 and 1.\r\n     */\r\n    getAxisValue: function (index)\r\n    {\r\n        return this.axes[index].getValue();\r\n    },\r\n\r\n    /**\r\n     * Sets the threshold value of all axis on this Gamepad.\r\n     * The value is a float between 0 and 1 and is the amount below which the axis is considered as not having been moved.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#setAxisThreshold\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} value - A value between 0 and 1.\r\n     */\r\n    setAxisThreshold: function (value)\r\n    {\r\n        for (var i = 0; i < this.axes.length; i++)\r\n        {\r\n            this.axes[i].threshold = value;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Gets the total number of buttons this Gamepad claims to have.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#getButtonTotal\r\n     * @since 3.10.0\r\n     *\r\n     * @return {number} The total number of buttons this Gamepad claims to have.\r\n     */\r\n    getButtonTotal: function ()\r\n    {\r\n        return this.buttons.length;\r\n    },\r\n\r\n    /**\r\n     * Gets the value of a button based on the given index.\r\n     * The index must be valid within the range of buttons supported by this Gamepad.\r\n     *\r\n     * The return value will be either 0 or 1 for an analogue button, or a float between 0 and 1\r\n     * for a pressure-sensitive digital button, such as the shoulder buttons on a Dual Shock.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#getButtonValue\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} index - The index of the button to get the value for.\r\n     *\r\n     * @return {number} The value of the button, between 0 and 1.\r\n     */\r\n    getButtonValue: function (index)\r\n    {\r\n        return this.buttons[index].value;\r\n    },\r\n\r\n    /**\r\n     * Returns if the button is pressed down or not.\r\n     * The index must be valid within the range of buttons supported by this Gamepad.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#isButtonDown\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} index - The index of the button to get the value for.\r\n     *\r\n     * @return {boolean} `true` if the button is considered as being pressed down, otherwise `false`.\r\n     */\r\n    isButtonDown: function (index)\r\n    {\r\n        return this.buttons[index].pressed;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler for this Gamepad.\r\n     * Called automatically by the Gamepad Manager as part of its update.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#update\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    update: function (pad)\r\n    {\r\n        if (pad.timestamp < this._created)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n\r\n        //  Sync the button values\r\n\r\n        var localButtons = this.buttons;\r\n        var gamepadButtons = pad.buttons;\r\n\r\n        var len = localButtons.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            localButtons[i].update(gamepadButtons[i].value);\r\n        }\r\n\r\n        //  Sync the axis values\r\n\r\n        var localAxes = this.axes;\r\n        var gamepadAxes = pad.axes;\r\n\r\n        len = localAxes.length;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            localAxes[i].update(gamepadAxes[i]);\r\n        }\r\n\r\n        if (len >= 2)\r\n        {\r\n            this.leftStick.set(localAxes[0].getValue(), localAxes[1].getValue());\r\n\r\n            if (len >= 4)\r\n            {\r\n                this.rightStick.set(localAxes[2].getValue(), localAxes[3].getValue());\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Gamepad instance, its buttons and axes, and releases external references it holds.\r\n     *\r\n     * @method Phaser.Input.Gamepad.Gamepad#destroy\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.manager = null;\r\n        this.pad = null;\r\n\r\n        var i;\r\n\r\n        for (i = 0; i < this.buttons.length; i++)\r\n        {\r\n            this.buttons[i].destroy();\r\n        }\r\n\r\n        for (i = 0; i < this.axes.length; i++)\r\n        {\r\n            this.axes[i].destroy();\r\n        }\r\n\r\n        this.buttons = [];\r\n        this.axes = [];\r\n    },\r\n\r\n    /**\r\n     * Is this Gamepad currently connected or not?\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#connected\r\n     * @type {boolean}\r\n     * @default true\r\n     * @since 3.0.0\r\n     */\r\n    connected: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.pad.connected;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A timestamp containing the most recent time this Gamepad was updated.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#timestamp\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    timestamp: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.pad.timestamp;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's Left button being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * This is the d-pad left button under standard Gamepad mapping.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#left\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    left: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._LCLeft.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's Right button being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * This is the d-pad right button under standard Gamepad mapping.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#right\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    right: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._LCRight.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's Up button being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * This is the d-pad up button under standard Gamepad mapping.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#up\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    up: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._LCTop.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's Down button being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * This is the d-pad down button under standard Gamepad mapping.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#down\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    down: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._LCBottom.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's bottom button in the right button cluster being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * On a Dual Shock controller it's the X button.\r\n     * On an XBox controller it's the A button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#A\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    A: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._RCBottom.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's top button in the right button cluster being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * On a Dual Shock controller it's the Triangle button.\r\n     * On an XBox controller it's the Y button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#Y\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    Y: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._RCTop.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's left button in the right button cluster being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * On a Dual Shock controller it's the Square button.\r\n     * On an XBox controller it's the X button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#X\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    X: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._RCLeft.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Gamepad's right button in the right button cluster being pressed?\r\n     * If the Gamepad doesn't have this button it will always return false.\r\n     * On a Dual Shock controller it's the Circle button.\r\n     * On an XBox controller it's the B button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#B\r\n     * @type {boolean}\r\n     * @since 3.10.0\r\n     */\r\n    B: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._RCRight.pressed;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of the Gamepad's top left shoulder button.\r\n     * If the Gamepad doesn't have this button it will always return zero.\r\n     * The value is a float between 0 and 1, corresponding to how depressed the button is.\r\n     * On a Dual Shock controller it's the L1 button.\r\n     * On an XBox controller it's the LB button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#L1\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    L1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._FBLeftTop.value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of the Gamepad's bottom left shoulder button.\r\n     * If the Gamepad doesn't have this button it will always return zero.\r\n     * The value is a float between 0 and 1, corresponding to how depressed the button is.\r\n     * On a Dual Shock controller it's the L2 button.\r\n     * On an XBox controller it's the LT button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#L2\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    L2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._FBLeftBottom.value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of the Gamepad's top right shoulder button.\r\n     * If the Gamepad doesn't have this button it will always return zero.\r\n     * The value is a float between 0 and 1, corresponding to how depressed the button is.\r\n     * On a Dual Shock controller it's the R1 button.\r\n     * On an XBox controller it's the RB button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#R1\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    R1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._FBRightTop.value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the value of the Gamepad's bottom right shoulder button.\r\n     * If the Gamepad doesn't have this button it will always return zero.\r\n     * The value is a float between 0 and 1, corresponding to how depressed the button is.\r\n     * On a Dual Shock controller it's the R2 button.\r\n     * On an XBox controller it's the RT button.\r\n     *\r\n     * @name Phaser.Input.Gamepad.Gamepad#R2\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    R2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._FBRightBottom.value;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Gamepad;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar Gamepad = require('./Gamepad');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar InputPluginCache = require('../InputPluginCache');\r\nvar InputEvents = require('../events');\r\n\r\n/**\r\n * @classdesc\r\n * The Gamepad Plugin is an input plugin that belongs to the Scene-owned Input system.\r\n *\r\n * Its role is to listen for native DOM Gamepad Events and then process them.\r\n *\r\n * You do not need to create this class directly, the Input system will create an instance of it automatically.\r\n *\r\n * You can access it from within a Scene using `this.input.gamepad`.\r\n *\r\n * To listen for a gamepad being connected:\r\n *\r\n * ```javascript\r\n * this.input.gamepad.once('connected', function (pad) {\r\n *     //   'pad' is a reference to the gamepad that was just connected\r\n * });\r\n * ```\r\n *\r\n * Note that the browser may require you to press a button on a gamepad before it will allow you to access it,\r\n * this is for security reasons. However, it may also trust the page already, in which case you won't get the\r\n * 'connected' event and instead should check `GamepadPlugin.total` to see if it thinks there are any gamepads\r\n * already connected.\r\n *\r\n * Once you have received the connected event, or polled the gamepads and found them enabled, you can access\r\n * them via the built-in properties `GamepadPlugin.pad1` to `pad4`, for up to 4 game pads. With a reference\r\n * to the gamepads you can poll its buttons and axis sticks. See the properties and methods available on\r\n * the `Gamepad` class for more details.\r\n *\r\n * As of September 2020 Chrome, and likely other browsers, will soon start to require that games requesting\r\n * access to the Gamepad API are running under SSL. They will actively block API access if they are not.\r\n *\r\n * For more information about Gamepad support in browsers see the following resources:\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API\r\n * https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API\r\n * https://www.smashingmagazine.com/2015/11/gamepad-api-in-web-games/\r\n * http://html5gamepad.com/\r\n *\r\n * @class GamepadPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Gamepad\r\n * @constructor\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Input.InputPlugin} sceneInputPlugin - A reference to the Scene Input Plugin that the KeyboardPlugin belongs to.\r\n */\r\nvar GamepadPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function GamepadPlugin (sceneInputPlugin)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Scene that this Input Plugin is responsible for.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.10.0\r\n         */\r\n        this.scene = sceneInputPlugin.scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems Settings.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.10.0\r\n         */\r\n        this.settings = this.scene.sys.settings;\r\n\r\n        /**\r\n         * A reference to the Scene Input Plugin that created this Keyboard Plugin.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#sceneInputPlugin\r\n         * @type {Phaser.Input.InputPlugin}\r\n         * @since 3.10.0\r\n         */\r\n        this.sceneInputPlugin = sceneInputPlugin;\r\n\r\n        /**\r\n         * A boolean that controls if the Gamepad Manager is enabled or not.\r\n         * Can be toggled on the fly.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.10.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * The Gamepad Event target, as defined in the Game Config.\r\n         * Typically the browser window, but can be any interactive DOM element.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#target\r\n         * @type {any}\r\n         * @since 3.10.0\r\n         */\r\n        this.target;\r\n\r\n        /**\r\n         * An array of the connected Gamepads.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#gamepads\r\n         * @type {Phaser.Input.Gamepad.Gamepad[]}\r\n         * @default []\r\n         * @since 3.10.0\r\n         */\r\n        this.gamepads = [];\r\n\r\n        /**\r\n         * An internal event queue.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#queue\r\n         * @type {GamepadEvent[]}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.queue = [];\r\n\r\n        /**\r\n         * Internal event handler.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#onGamepadHandler\r\n         * @type {function}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this.onGamepadHandler;\r\n\r\n        /**\r\n         * Internal Gamepad reference.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad1\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._pad1;\r\n\r\n        /**\r\n         * Internal Gamepad reference.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad2\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._pad2;\r\n\r\n        /**\r\n         * Internal Gamepad reference.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad3\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._pad3;\r\n\r\n        /**\r\n         * Internal Gamepad reference.\r\n         *\r\n         * @name Phaser.Input.Gamepad.GamepadPlugin#_pad4\r\n         * @type {Phaser.Input.Gamepad.Gamepad}\r\n         * @private\r\n         * @since 3.10.0\r\n         */\r\n        this._pad4;\r\n\r\n        sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);\r\n        sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#boot\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var game = this.scene.sys.game;\r\n        var settings = this.settings.input;\r\n        var config = game.config;\r\n\r\n        this.enabled = GetValue(settings, 'gamepad', config.inputGamepad) && game.device.input.gamepads;\r\n        this.target = GetValue(settings, 'gamepad.target', config.inputGamepadEventTarget);\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#start\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    start: function ()\r\n    {\r\n        if (this.enabled)\r\n        {\r\n            this.startListeners();\r\n\r\n            this.refreshPads();\r\n        }\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#isActive\r\n     * @since 3.10.0\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.enabled && this.scene.sys.isActive());\r\n    },\r\n\r\n    /**\r\n     * Starts the Gamepad Event listeners running.\r\n     * This is called automatically and does not need to be manually invoked.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#startListeners\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    startListeners: function ()\r\n    {\r\n        var _this = this;\r\n        var target = this.target;\r\n\r\n        var handler = function (event)\r\n        {\r\n            if (event.defaultPrevented || !_this.isActive())\r\n            {\r\n                // Do nothing if event already handled\r\n                return;\r\n            }\r\n\r\n            _this.refreshPads();\r\n\r\n            _this.queue.push(event);\r\n        };\r\n\r\n        this.onGamepadHandler = handler;\r\n\r\n        target.addEventListener('gamepadconnected', handler, false);\r\n        target.addEventListener('gamepaddisconnected', handler, false);\r\n\r\n        //  FF also supports gamepadbuttondown, gamepadbuttonup and gamepadaxismove but\r\n        //  nothing else does, and we can get those values via the gamepads anyway, so we will\r\n        //  until more browsers support this\r\n\r\n        //  Finally, listen for an update event from the Input Plugin\r\n        this.sceneInputPlugin.pluginEvents.on(InputEvents.UPDATE, this.update, this);\r\n    },\r\n\r\n    /**\r\n     * Stops the Gamepad Event listeners.\r\n     * This is called automatically and does not need to be manually invoked.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#stopListeners\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    stopListeners: function ()\r\n    {\r\n        this.target.removeEventListener('gamepadconnected', this.onGamepadHandler);\r\n        this.target.removeEventListener('gamepaddisconnected', this.onGamepadHandler);\r\n\r\n        this.sceneInputPlugin.pluginEvents.off(InputEvents.UPDATE, this.update);\r\n\r\n        for (var i = 0; i < this.gamepads.length; i++)\r\n        {\r\n            this.gamepads[i].removeAllListeners();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Disconnects all current Gamepads.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#disconnectAll\r\n     * @since 3.10.0\r\n     */\r\n    disconnectAll: function ()\r\n    {\r\n        for (var i = 0; i < this.gamepads.length; i++)\r\n        {\r\n            this.gamepads[i].pad.connected = false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Refreshes the list of connected Gamepads.\r\n     *\r\n     * This is called automatically when a gamepad is connected or disconnected,\r\n     * and during the update loop.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#refreshPads\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    refreshPads: function ()\r\n    {\r\n        var connectedPads = navigator.getGamepads();\r\n\r\n        if (!connectedPads)\r\n        {\r\n            this.disconnectAll();\r\n        }\r\n        else\r\n        {\r\n            var currentPads = this.gamepads;\r\n\r\n            for (var i = 0; i < connectedPads.length; i++)\r\n            {\r\n                var livePad = connectedPads[i];\r\n\r\n                //  Because sometimes they're null (yes, really)\r\n                if (!livePad)\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                var id = livePad.id;\r\n                var index = livePad.index;\r\n                var currentPad = currentPads[index];\r\n\r\n                if (!currentPad)\r\n                {\r\n                    //  A new Gamepad, not currently stored locally\r\n                    var newPad = new Gamepad(this, livePad);\r\n\r\n                    currentPads[index] = newPad;\r\n\r\n                    if (!this._pad1)\r\n                    {\r\n                        this._pad1 = newPad;\r\n                    }\r\n                    else if (!this._pad2)\r\n                    {\r\n                        this._pad2 = newPad;\r\n                    }\r\n                    else if (!this._pad3)\r\n                    {\r\n                        this._pad3 = newPad;\r\n                    }\r\n                    else if (!this._pad4)\r\n                    {\r\n                        this._pad4 = newPad;\r\n                    }\r\n                }\r\n                else if (currentPad.id !== id)\r\n                {\r\n                    //  A new Gamepad with a different vendor string, but it has got the same index as an old one\r\n                    currentPad.destroy();\r\n\r\n                    currentPads[index] = new Gamepad(this, livePad);\r\n                }\r\n                else\r\n                {\r\n                    //  If neither of these, it's a pad we've already got, so update it\r\n                    currentPad.update(livePad);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an array of all currently connected Gamepads.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#getAll\r\n     * @since 3.10.0\r\n     *\r\n     * @return {Phaser.Input.Gamepad.Gamepad[]} An array of all currently connected Gamepads.\r\n     */\r\n    getAll: function ()\r\n    {\r\n        var out = [];\r\n        var pads = this.gamepads;\r\n\r\n        for (var i = 0; i < pads.length; i++)\r\n        {\r\n            if (pads[i])\r\n            {\r\n                out.push(pads[i]);\r\n            }\r\n        }\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Looks-up a single Gamepad based on the given index value.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#getPad\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} index - The index of the Gamepad to get.\r\n     *\r\n     * @return {Phaser.Input.Gamepad.Gamepad} The Gamepad matching the given index, or undefined if none were found.\r\n     */\r\n    getPad: function (index)\r\n    {\r\n        var pads = this.gamepads;\r\n\r\n        for (var i = 0; i < pads.length; i++)\r\n        {\r\n            if (pads[i] && pads[i].index === index)\r\n            {\r\n                return pads[i];\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The internal update loop. Refreshes all connected gamepads and processes their events.\r\n     *\r\n     * Called automatically by the Input Manager, invoked from the Game step.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#update\r\n     * @private\r\n     * @fires Phaser.Input.Gamepad.Events#CONNECTED\r\n     * @fires Phaser.Input.Gamepad.Events#DISCONNECTED\r\n     * @since 3.10.0\r\n     */\r\n    update: function ()\r\n    {\r\n        if (!this.enabled)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.refreshPads();\r\n\r\n        var len = this.queue.length;\r\n\r\n        if (len === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var queue = this.queue.splice(0, len);\r\n\r\n        //  Process the event queue, dispatching all of the events that have stored up\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            var event = queue[i];\r\n            var pad = this.getPad(event.gamepad.index);\r\n\r\n            if (event.type === 'gamepadconnected')\r\n            {\r\n                this.emit(Events.CONNECTED, pad, event);\r\n            }\r\n            else if (event.type === 'gamepaddisconnected')\r\n            {\r\n                this.emit(Events.DISCONNECTED, pad, event);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Shuts the Gamepad Plugin down.\r\n     * All this does is remove any listeners bound to it.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#shutdown\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.stopListeners();\r\n\r\n        this.removeAllListeners();\r\n    },\r\n\r\n    /**\r\n     * Destroys this Gamepad Plugin, disconnecting all Gamepads and releasing internal references.\r\n     *\r\n     * @method Phaser.Input.Gamepad.GamepadPlugin#destroy\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        for (var i = 0; i < this.gamepads.length; i++)\r\n        {\r\n            if (this.gamepads[i])\r\n            {\r\n                this.gamepads[i].destroy();\r\n            }\r\n        }\r\n\r\n        this.gamepads = [];\r\n\r\n        this.scene = null;\r\n        this.settings = null;\r\n        this.sceneInputPlugin = null;\r\n        this.target = null;\r\n    },\r\n\r\n    /**\r\n     * The total number of connected game pads.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#total\r\n     * @type {number}\r\n     * @since 3.10.0\r\n     */\r\n    total: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.gamepads.length;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A reference to the first connected Gamepad.\r\n     *\r\n     * This will be undefined if either no pads are connected, or the browser\r\n     * has not yet issued a gamepadconnect, which can happen even if a Gamepad\r\n     * is plugged in, but hasn't yet had any buttons pressed on it.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#pad1\r\n     * @type {Phaser.Input.Gamepad.Gamepad}\r\n     * @since 3.10.0\r\n     */\r\n    pad1: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._pad1;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A reference to the second connected Gamepad.\r\n     *\r\n     * This will be undefined if either no pads are connected, or the browser\r\n     * has not yet issued a gamepadconnect, which can happen even if a Gamepad\r\n     * is plugged in, but hasn't yet had any buttons pressed on it.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#pad2\r\n     * @type {Phaser.Input.Gamepad.Gamepad}\r\n     * @since 3.10.0\r\n     */\r\n    pad2: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._pad2;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A reference to the third connected Gamepad.\r\n     *\r\n     * This will be undefined if either no pads are connected, or the browser\r\n     * has not yet issued a gamepadconnect, which can happen even if a Gamepad\r\n     * is plugged in, but hasn't yet had any buttons pressed on it.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#pad3\r\n     * @type {Phaser.Input.Gamepad.Gamepad}\r\n     * @since 3.10.0\r\n     */\r\n    pad3: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._pad3;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * A reference to the fourth connected Gamepad.\r\n     *\r\n     * This will be undefined if either no pads are connected, or the browser\r\n     * has not yet issued a gamepadconnect, which can happen even if a Gamepad\r\n     * is plugged in, but hasn't yet had any buttons pressed on it.\r\n     *\r\n     * @name Phaser.Input.Gamepad.GamepadPlugin#pad4\r\n     * @type {Phaser.Input.Gamepad.Gamepad}\r\n     * @since 3.10.0\r\n     */\r\n    pad4: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._pad4;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * An instance of the Gamepad Plugin class, if enabled via the `input.gamepad` Scene or Game Config property.\r\n * Use this to create access Gamepads connected to the browser and respond to gamepad buttons.\r\n *\r\n * @name Phaser.Input.InputPlugin#gamepad\r\n * @type {?Phaser.Input.Gamepad.GamepadPlugin}\r\n * @since 3.10.0\r\n */\r\nInputPluginCache.register('GamepadPlugin', GamepadPlugin, 'gamepad', 'gamepad', 'inputGamepad');\r\n\r\nmodule.exports = GamepadPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Tatar SNES USB Controller Gamepad Configuration.\r\n * USB Gamepad  (STANDARD GAMEPAD Vendor: 0079 Product: 0011)\r\n *\r\n * @name Phaser.Input.Gamepad.Configs.SNES_USB\r\n * @type {object}\r\n * @since 3.0.0\r\n */\r\nmodule.exports = {\r\n\r\n    UP: 12,\r\n    DOWN: 13,\r\n    LEFT: 14,\r\n    RIGHT: 15,\r\n\r\n    SELECT: 8,\r\n    START: 9,\r\n\r\n    B: 0,\r\n    A: 1,\r\n    Y: 2,\r\n    X: 3,\r\n\r\n    LEFT_SHOULDER: 4,\r\n    RIGHT_SHOULDER: 5\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * PlayStation DualShock 4 Gamepad Configuration.\r\n * Sony PlayStation DualShock 4 (v2) wireless controller\r\n *\r\n * @name Phaser.Input.Gamepad.Configs.DUALSHOCK_4\r\n * @type {object}\r\n * @since 3.0.0\r\n */\r\nmodule.exports = {\r\n\r\n    UP: 12,\r\n    DOWN: 13,\r\n    LEFT: 14,\r\n    RIGHT: 15,\r\n\r\n    SHARE: 8,\r\n    OPTIONS: 9,\r\n    PS: 16,\r\n    TOUCHBAR: 17,\r\n\r\n    X: 0,\r\n    CIRCLE: 1,\r\n    SQUARE: 2,\r\n    TRIANGLE: 3,\r\n\r\n    L1: 4,\r\n    R1: 5,\r\n    L2: 6,\r\n    R2: 7,\r\n    L3: 10,\r\n    R3: 11,\r\n\r\n    LEFT_STICK_H: 0,\r\n    LEFT_STICK_V: 1,\r\n    RIGHT_STICK_H: 2,\r\n    RIGHT_STICK_V: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * XBox 360 Gamepad Configuration.\r\n *\r\n * @name Phaser.Input.Gamepad.Configs.XBOX_360\r\n * @type {object}\r\n * @since 3.0.0\r\n */\r\nmodule.exports = {\r\n\r\n    UP: 12,\r\n    DOWN: 13,\r\n    LEFT: 14,\r\n    RIGHT: 15,\r\n\r\n    MENU: 16,\r\n\r\n    A: 0,\r\n    B: 1,\r\n    X: 2,\r\n    Y: 3,\r\n\r\n    LB: 4,\r\n    RB: 5,\r\n\r\n    LT: 6,\r\n    RT: 7,\r\n\r\n    BACK: 8,\r\n    START: 9,\r\n\r\n    LS: 10,\r\n    RS: 11,\r\n\r\n    LEFT_STICK_H: 0,\r\n    LEFT_STICK_V: 1,\r\n    RIGHT_STICK_H: 2,\r\n    RIGHT_STICK_V: 3\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Gamepad.Configs\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    DUALSHOCK_4: require('./Sony_PlayStation_DualShock_4'),\r\n    SNES_USB: require('./SNES_USB_Controller'),\r\n    XBOX_360: require('./XBox360_Controller')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Button Down Event.\r\n * \r\n * This event is dispatched by the Gamepad Plugin when a button has been pressed on any active Gamepad.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.gamepad.on('down', listener)`.\r\n * \r\n * You can also listen for a DOWN event from a Gamepad instance. See the [GAMEPAD_BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_DOWN} event for details.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#BUTTON_DOWN\r\n * @since 3.10.0\r\n * \r\n * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad on which the button was pressed.\r\n * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was pressed.\r\n * @param {number} value - The value of the button at the time it was pressed. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.\r\n */\r\nmodule.exports = 'down';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Button Up Event.\r\n * \r\n * This event is dispatched by the Gamepad Plugin when a button has been released on any active Gamepad.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.gamepad.on('up', listener)`.\r\n * \r\n * You can also listen for an UP event from a Gamepad instance. See the [GAMEPAD_BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:GAMEPAD_BUTTON_UP} event for details.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#BUTTON_UP\r\n * @since 3.10.0\r\n * \r\n * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad on which the button was released.\r\n * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was released.\r\n * @param {number} value - The value of the button at the time it was released. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.\r\n */\r\nmodule.exports = 'up';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Connected Event.\r\n * \r\n * This event is dispatched by the Gamepad Plugin when a Gamepad has been connected.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.gamepad.once('connected', listener)`.\r\n * \r\n * Note that the browser may require you to press a button on a gamepad before it will allow you to access it,\r\n * this is for security reasons. However, it may also trust the page already, in which case you won't get the\r\n * 'connected' event and instead should check `GamepadPlugin.total` to see if it thinks there are any gamepads\r\n * already connected.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#CONNECTED\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad which was connected.\r\n * @param {Event} event - The native DOM Event that triggered the connection.\r\n */\r\nmodule.exports = 'connected';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Disconnected Event.\r\n * \r\n * This event is dispatched by the Gamepad Plugin when a Gamepad has been disconnected.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.gamepad.once('disconnected', listener)`.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#DISCONNECTED\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Gamepad} pad - A reference to the Gamepad which was disconnected.\r\n * @param {Event} event - The native DOM Event that triggered the disconnection.\r\n */\r\nmodule.exports = 'disconnected';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Button Down Event.\r\n * \r\n * This event is dispatched by a Gamepad instance when a button has been pressed on it.\r\n * \r\n * Listen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:\r\n * `this.input.gamepad.pad1.on('down', listener)`.\r\n * \r\n * Note that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.\r\n * \r\n * You can also listen for a DOWN event from the Gamepad Plugin. See the [BUTTON_DOWN]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_DOWN} event for details.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_DOWN\r\n * @since 3.10.0\r\n * \r\n * @param {number} index - The index of the button that was pressed.\r\n * @param {number} value - The value of the button at the time it was pressed. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.\r\n * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was pressed.\r\n */\r\nmodule.exports = 'down';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Gamepad Button Up Event.\r\n * \r\n * This event is dispatched by a Gamepad instance when a button has been released on it.\r\n * \r\n * Listen to this event from a Gamepad instance. Once way to get this is from the `pad1`, `pad2`, etc properties on the Gamepad Plugin:\r\n * `this.input.gamepad.pad1.on('up', listener)`.\r\n * \r\n * Note that you will not receive any Gamepad button events until the browser considers the Gamepad as being 'connected'.\r\n * \r\n * You can also listen for an UP event from the Gamepad Plugin. See the [BUTTON_UP]{@linkcode Phaser.Input.Gamepad.Events#event:BUTTON_UP} event for details.\r\n *\r\n * @event Phaser.Input.Gamepad.Events#GAMEPAD_BUTTON_UP\r\n * @since 3.10.0\r\n * \r\n * @param {number} index - The index of the button that was released.\r\n * @param {number} value - The value of the button at the time it was released. Between 0 and 1. Some Gamepads have pressure-sensitive buttons.\r\n * @param {Phaser.Input.Gamepad.Button} button - A reference to the Button which was released.\r\n */\r\nmodule.exports = 'up';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Gamepad.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    BUTTON_DOWN: require('./BUTTON_DOWN_EVENT'),\r\n    BUTTON_UP: require('./BUTTON_UP_EVENT'),\r\n    CONNECTED: require('./CONNECTED_EVENT'),\r\n    DISCONNECTED: require('./DISCONNECTED_EVENT'),\r\n    GAMEPAD_BUTTON_DOWN: require('./GAMEPAD_BUTTON_DOWN_EVENT'),\r\n    GAMEPAD_BUTTON_UP: require('./GAMEPAD_BUTTON_UP_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Gamepad\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Axis: require('./Axis'),\r\n    Button: require('./Button'),\r\n    Events: require('./events'),\r\n    Gamepad: require('./Gamepad'),\r\n    GamepadPlugin: require('./GamepadPlugin'),\r\n    \r\n    Configs: require('./configs/')\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.Input\r\n */\r\n\r\nvar Input = {\r\n\r\n    CreatePixelPerfectHandler: require('./CreatePixelPerfectHandler'),\r\n    CreateInteractiveObject: require('./CreateInteractiveObject'),\r\n    Events: require('./events'),\r\n    Gamepad: require('./gamepad'),\r\n    InputManager: require('./InputManager'),\r\n    InputPlugin: require('./InputPlugin'),\r\n    InputPluginCache: require('./InputPluginCache'),\r\n    Keyboard: require('./keyboard'),\r\n    Mouse: require('./mouse'),\r\n    Pointer: require('./Pointer'),\r\n    Touch: require('./touch')\r\n\r\n};\r\n\r\n//   Merge in the consts\r\nInput = Extend(false, Input, CONST);\r\n\r\nmodule.exports = Input;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../../core/events');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar InputEvents = require('../events');\r\nvar InputPluginCache = require('../InputPluginCache');\r\nvar Key = require('./keys/Key');\r\nvar KeyCodes = require('./keys/KeyCodes');\r\nvar KeyCombo = require('./combo/KeyCombo');\r\nvar KeyMap = require('./keys/KeyMap');\r\nvar SceneEvents = require('../../scene/events');\r\nvar SnapFloor = require('../../math/snap/SnapFloor');\r\n\r\n/**\r\n * @classdesc\r\n * The Keyboard Plugin is an input plugin that belongs to the Scene-owned Input system.\r\n *\r\n * Its role is to listen for native DOM Keyboard Events and then process them.\r\n *\r\n * You do not need to create this class directly, the Input system will create an instance of it automatically.\r\n *\r\n * You can access it from within a Scene using `this.input.keyboard`. For example, you can do:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.on('keydown', callback, context);\r\n * ```\r\n *\r\n * Or, to listen for a specific key:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.on('keydown-A', callback, context);\r\n * ```\r\n *\r\n * You can also create Key objects, which you can then poll in your game loop:\r\n *\r\n * ```javascript\r\n * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\r\n * ```\r\n *\r\n * If you have multiple parallel Scenes, each trying to get keyboard input, be sure to disable capture on them to stop them from\r\n * stealing input from another Scene in the list. You can do this with `this.input.keyboard.enabled = false` within the\r\n * Scene to stop all input, or `this.input.keyboard.preventDefault = false` to stop a Scene halting input on another Scene.\r\n *\r\n * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\r\n * See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.\r\n *\r\n * Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.\r\n * For example the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\r\n * And there are others. So, please check your extensions before opening Phaser issues about keys that don't work.\r\n *\r\n * @class KeyboardPlugin\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @since 3.10.0\r\n *\r\n * @param {Phaser.Input.InputPlugin} sceneInputPlugin - A reference to the Scene Input Plugin that the KeyboardPlugin belongs to.\r\n */\r\nvar KeyboardPlugin = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function KeyboardPlugin (sceneInputPlugin)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the core game, so we can listen for visibility events.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.16.0\r\n         */\r\n        this.game = sceneInputPlugin.systems.game;\r\n\r\n        /**\r\n         * A reference to the Scene that this Input Plugin is responsible for.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.10.0\r\n         */\r\n        this.scene = sceneInputPlugin.scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems Settings.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#settings\r\n         * @type {Phaser.Types.Scenes.SettingsObject}\r\n         * @since 3.10.0\r\n         */\r\n        this.settings = this.scene.sys.settings;\r\n\r\n        /**\r\n         * A reference to the Scene Input Plugin that created this Keyboard Plugin.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#sceneInputPlugin\r\n         * @type {Phaser.Input.InputPlugin}\r\n         * @since 3.10.0\r\n         */\r\n        this.sceneInputPlugin = sceneInputPlugin;\r\n\r\n        /**\r\n         * A reference to the global Keyboard Manager.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#manager\r\n         * @type {Phaser.Input.Keyboard.KeyboardManager}\r\n         * @since 3.16.0\r\n         */\r\n        this.manager = sceneInputPlugin.manager.keyboard;\r\n\r\n        /**\r\n         * A boolean that controls if this Keyboard Plugin is enabled or not.\r\n         * Can be toggled on the fly.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.10.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * An array of Key objects to process.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#keys\r\n         * @type {Phaser.Input.Keyboard.Key[]}\r\n         * @since 3.10.0\r\n         */\r\n        this.keys = [];\r\n\r\n        /**\r\n         * An array of KeyCombo objects to process.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#combos\r\n         * @type {Phaser.Input.Keyboard.KeyCombo[]}\r\n         * @since 3.10.0\r\n         */\r\n        this.combos = [];\r\n\r\n        /**\r\n         * Internal repeat key flag.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#prevCode\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.prevCode = null;\r\n\r\n        /**\r\n         * Internal repeat key flag.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#prevTime\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.prevTime = 0;\r\n\r\n        /**\r\n         * Internal repeat key flag.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyboardPlugin#prevType\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.50.1\r\n         */\r\n        this.prevType = null;\r\n\r\n        sceneInputPlugin.pluginEvents.once(InputEvents.BOOT, this.boot, this);\r\n        sceneInputPlugin.pluginEvents.on(InputEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#boot\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var settings = this.settings.input;\r\n\r\n        this.enabled = GetValue(settings, 'keyboard', true);\r\n\r\n        var captures = GetValue(settings, 'keyboard.capture', null);\r\n\r\n        if (captures)\r\n        {\r\n            this.addCaptures(captures);\r\n        }\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#start\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    start: function ()\r\n    {\r\n        this.sceneInputPlugin.manager.events.on(InputEvents.MANAGER_PROCESS, this.update, this);\r\n\r\n        this.sceneInputPlugin.pluginEvents.once(InputEvents.SHUTDOWN, this.shutdown, this);\r\n\r\n        this.game.events.on(GameEvents.BLUR, this.resetKeys, this);\r\n\r\n        this.scene.sys.events.on(SceneEvents.PAUSE, this.resetKeys, this);\r\n        this.scene.sys.events.on(SceneEvents.SLEEP, this.resetKeys, this);\r\n    },\r\n\r\n    /**\r\n     * Checks to see if both this plugin and the Scene to which it belongs is active.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#isActive\r\n     * @since 3.10.0\r\n     *\r\n     * @return {boolean} `true` if the plugin and the Scene it belongs to is active.\r\n     */\r\n    isActive: function ()\r\n    {\r\n        return (this.enabled && this.scene.sys.isActive());\r\n    },\r\n\r\n    /**\r\n     * By default when a key is pressed Phaser will not stop the event from propagating up to the browser.\r\n     * There are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.\r\n     *\r\n     * This `addCapture` method enables consuming keyboard events for specific keys, so they don't bubble up the browser\r\n     * and cause the default behaviors.\r\n     *\r\n     * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to say prevent\r\n     * the SPACE BAR from triggering a page scroll, then it will prevent it for any Scene in your game, not just the calling one.\r\n     *\r\n     * You can pass a single key code value:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addCapture(62);\r\n     * ```\r\n     *\r\n     * An array of key codes:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addCapture([ 62, 63, 64 ]);\r\n     * ```\r\n     *\r\n     * Or, a comma-delimited string:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addCapture('W,S,A,D');\r\n     * ```\r\n     *\r\n     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n     *\r\n     * You can also provide an array mixing both strings and key code integers.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#addCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(string|number|number[]|any[])} keycode - The Key Codes to enable event capture for.\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    addCapture: function (keycode)\r\n    {\r\n        this.manager.addCapture(keycode);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes an existing key capture.\r\n     *\r\n     * Please note that keyboard captures are global. This means that if you call this method from within a Scene, to remove\r\n     * the capture of a key, then it will remove it for any Scene in your game, not just the calling one.\r\n     *\r\n     * You can pass a single key code value:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.removeCapture(62);\r\n     * ```\r\n     *\r\n     * An array of key codes:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.removeCapture([ 62, 63, 64 ]);\r\n     * ```\r\n     *\r\n     * Or, a comma-delimited string:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.removeCapture('W,S,A,D');\r\n     * ```\r\n     *\r\n     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n     *\r\n     * You can also provide an array mixing both strings and key code integers.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @param {(string|number|number[]|any[])} keycode - The Key Codes to disable event capture for.\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    removeCapture: function (keycode)\r\n    {\r\n        this.manager.removeCapture(keycode);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns an array that contains all of the keyboard captures currently enabled.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#getCaptures\r\n     * @since 3.16.0\r\n     *\r\n     * @return {number[]} An array of all the currently capturing key codes.\r\n     */\r\n    getCaptures: function ()\r\n    {\r\n        return this.manager.captures;\r\n    },\r\n\r\n    /**\r\n     * Allows Phaser to prevent any key captures you may have defined from bubbling up the browser.\r\n     * You can use this to re-enable event capturing if you had paused it via `disableGlobalCapture`.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#enableGlobalCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    enableGlobalCapture: function ()\r\n    {\r\n        this.manager.preventDefault = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Disables Phaser from preventing any key captures you may have defined, without actually removing them.\r\n     * You can use this to temporarily disable event capturing if, for example, you swap to a DOM element.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#disableGlobalCapture\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    disableGlobalCapture: function ()\r\n    {\r\n        this.manager.preventDefault = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all keyboard captures.\r\n     *\r\n     * Note that this is a global change. It will clear all event captures across your game, not just for this specific Scene.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#clearCaptures\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    clearCaptures: function ()\r\n    {\r\n        this.manager.clearCaptures();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right, and also Space Bar and shift.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#createCursorKeys\r\n     * @since 3.10.0\r\n     *\r\n     * @return {Phaser.Types.Input.Keyboard.CursorKeys} An object containing the properties: `up`, `down`, `left`, `right`, `space` and `shift`.\r\n     */\r\n    createCursorKeys: function ()\r\n    {\r\n        return this.addKeys({\r\n            up: KeyCodes.UP,\r\n            down: KeyCodes.DOWN,\r\n            left: KeyCodes.LEFT,\r\n            right: KeyCodes.RIGHT,\r\n            space: KeyCodes.SPACE,\r\n            shift: KeyCodes.SHIFT\r\n        });\r\n    },\r\n\r\n    /**\r\n     * A practical way to create an object containing user selected hotkeys.\r\n     *\r\n     * For example:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addKeys({ 'up': Phaser.Input.Keyboard.KeyCodes.W, 'down': Phaser.Input.Keyboard.KeyCodes.S });\r\n     * ```\r\n     *\r\n     * would return an object containing the properties (`up` and `down`) mapped to W and S {@link Phaser.Input.Keyboard.Key} objects.\r\n     *\r\n     * You can also pass in a comma-separated string:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.addKeys('W,S,A,D');\r\n     * ```\r\n     *\r\n     * Which will return an object with the properties W, S, A and D mapped to the relevant Key objects.\r\n     *\r\n     * To use non-alpha numeric keys, use a string, such as 'UP', 'SPACE' or 'LEFT'.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#addKeys\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(object|string)} keys - An object containing Key Codes, or a comma-separated string.\r\n     * @param {boolean} [enableCapture=true] - Automatically call `preventDefault` on the native DOM browser event for the key codes being added.\r\n     * @param {boolean} [emitOnRepeat=false] - Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default).\r\n     *\r\n     * @return {object} An object containing Key objects mapped to the input properties.\r\n     */\r\n    addKeys: function (keys, enableCapture, emitOnRepeat)\r\n    {\r\n        if (enableCapture === undefined) { enableCapture = true; }\r\n        if (emitOnRepeat === undefined) { emitOnRepeat = false; }\r\n\r\n        var output = {};\r\n\r\n        if (typeof keys === 'string')\r\n        {\r\n            keys = keys.split(',');\r\n\r\n            for (var i = 0; i < keys.length; i++)\r\n            {\r\n                var currentKey = keys[i].trim();\r\n\r\n                if (currentKey)\r\n                {\r\n                    output[currentKey] = this.addKey(currentKey, enableCapture, emitOnRepeat);\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (var key in keys)\r\n            {\r\n                output[key] = this.addKey(keys[key], enableCapture, emitOnRepeat);\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Adds a Key object to this Keyboard Plugin.\r\n     *\r\n     * The given argument can be either an existing Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     *\r\n     * If a Key object is given, and one already exists matching the same key code, the existing one is replaced with the new one.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#addKey\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(Phaser.Input.Keyboard.Key|string|number)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     * @param {boolean} [enableCapture=true] - Automatically call `preventDefault` on the native DOM browser event for the key codes being added.\r\n     * @param {boolean} [emitOnRepeat=false] - Controls if the Key will continuously emit a 'down' event while being held down (true), or emit the event just once (false, the default).\r\n     *\r\n     * @return {Phaser.Input.Keyboard.Key} The newly created Key object, or a reference to it if it already existed in the keys array.\r\n     */\r\n    addKey: function (key, enableCapture, emitOnRepeat)\r\n    {\r\n        if (enableCapture === undefined) { enableCapture = true; }\r\n        if (emitOnRepeat === undefined) { emitOnRepeat = false; }\r\n\r\n        var keys = this.keys;\r\n\r\n        if (key instanceof Key)\r\n        {\r\n            var idx = keys.indexOf(key);\r\n\r\n            if (idx > -1)\r\n            {\r\n                keys[idx] = key;\r\n            }\r\n            else\r\n            {\r\n                keys[key.keyCode] = key;\r\n            }\r\n\r\n            if (enableCapture)\r\n            {\r\n                this.addCapture(key.keyCode);\r\n            }\r\n\r\n            key.setEmitOnRepeat(emitOnRepeat);\r\n\r\n            return key;\r\n        }\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            key = KeyCodes[key.toUpperCase()];\r\n        }\r\n\r\n        if (!keys[key])\r\n        {\r\n            keys[key] = new Key(this, key);\r\n\r\n            if (enableCapture)\r\n            {\r\n                this.addCapture(key);\r\n            }\r\n\r\n            keys[key].setEmitOnRepeat(emitOnRepeat);\r\n        }\r\n\r\n        return keys[key];\r\n    },\r\n\r\n    /**\r\n     * Removes a Key object from this Keyboard Plugin.\r\n     *\r\n     * The given argument can be either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeKey\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(Phaser.Input.Keyboard.Key|string|number)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     * @param {boolean} [destroy=false] - Call `Key.destroy` on the removed Key object?\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    removeKey: function (key, destroy)\r\n    {\r\n        if (destroy === undefined) { destroy = false; }\r\n\r\n        var keys = this.keys;\r\n        var ref;\r\n\r\n        if (key instanceof Key)\r\n        {\r\n            var idx = keys.indexOf(key);\r\n\r\n            if (idx > -1)\r\n            {\r\n                ref = this.keys[idx];\r\n\r\n                this.keys[idx] = undefined;\r\n            }\r\n        }\r\n        else if (typeof key === 'string')\r\n        {\r\n            key = KeyCodes[key.toUpperCase()];\r\n        }\r\n\r\n        if (keys[key])\r\n        {\r\n            ref = keys[key];\r\n\r\n            keys[key] = undefined;\r\n        }\r\n\r\n        if (ref)\r\n        {\r\n            ref.plugin = null;\r\n\r\n            if (destroy)\r\n            {\r\n                ref.destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all Key objects created by _this_ Keyboard Plugin.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#removeAllKeys\r\n     * @since 3.24.0\r\n     *\r\n     * @param {boolean} [destroy=false] - Call `Key.destroy` on each removed Key object?\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    removeAllKeys: function (destroy)\r\n    {\r\n        var keys = this.keys;\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            var key = keys[i];\r\n\r\n            if (key)\r\n            {\r\n                keys[i] = undefined;\r\n\r\n                if (destroy)\r\n                {\r\n                    key.destroy();\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a new KeyCombo.\r\n     *\r\n     * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them\r\n     * it will emit a `keycombomatch` event from this Keyboard Plugin.\r\n     *\r\n     * The keys to be listened for can be defined as:\r\n     *\r\n     * A string (i.e. 'ATARI')\r\n     * An array of either integers (key codes) or strings, or a mixture of both\r\n     * An array of objects (such as Key objects) with a public 'keyCode' property\r\n     *\r\n     * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)\r\n     * you could pass the following array of key codes:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n     *\r\n     * this.input.keyboard.on('keycombomatch', function (event) {\r\n     *     console.log('Konami Code entered!');\r\n     * });\r\n     * ```\r\n     *\r\n     * Or, to listen for the user entering the word PHASER:\r\n     *\r\n     * ```javascript\r\n     * this.input.keyboard.createCombo('PHASER');\r\n     * ```\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#createCombo\r\n     * @since 3.10.0\r\n     *\r\n     * @param {(string|number[]|object[])} keys - The keys that comprise this combo.\r\n     * @param {Phaser.Types.Input.Keyboard.KeyComboConfig} [config] - A Key Combo configuration object.\r\n     *\r\n     * @return {Phaser.Input.Keyboard.KeyCombo} The new KeyCombo object.\r\n     */\r\n    createCombo: function (keys, config)\r\n    {\r\n        return new KeyCombo(this, keys, config);\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Key object is currently being held down.\r\n     *\r\n     * The difference between this method and checking the `Key.isDown` property directly is that you can provide\r\n     * a duration to this method. For example, if you wanted a key press to fire a bullet, but you only wanted\r\n     * it to be able to fire every 100ms, then you can call this method with a `duration` of 100 and it\r\n     * will only return `true` every 100ms.\r\n     *\r\n     * If the Keyboard Plugin has been disabled, this method will always return `false`.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#checkDown\r\n     * @since 3.11.0\r\n     *\r\n     * @param {Phaser.Input.Keyboard.Key} key - A Key object.\r\n     * @param {number} [duration=0] - The duration which must have elapsed before this Key is considered as being down.\r\n     *\r\n     * @return {boolean} `true` if the Key is down within the duration specified, otherwise `false`.\r\n     */\r\n    checkDown: function (key, duration)\r\n    {\r\n        if (duration === undefined) { duration = 0; }\r\n\r\n        if (this.enabled && key.isDown)\r\n        {\r\n            var t = SnapFloor(this.time - key.timeDown, duration);\r\n\r\n            if (t > key._tick)\r\n            {\r\n                key._tick = t;\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler called by the Input Plugin, which is in turn invoked by the Game step.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#update\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    update: function ()\r\n    {\r\n        var queue = this.manager.queue;\r\n        var len = queue.length;\r\n\r\n        if (!this.isActive() || len === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var keys = this.keys;\r\n\r\n        //  Process the event queue, dispatching all of the events that have stored up\r\n        for (var i = 0; i < len; i++)\r\n        {\r\n            var event = queue[i];\r\n            var code = event.keyCode;\r\n            var key = keys[code];\r\n            var repeat = false;\r\n\r\n            //  Override the default functions (it's too late for the browser to use them anyway, so we may as well)\r\n            if (event.cancelled === undefined)\r\n            {\r\n                //  Event allowed to flow across all handlers in this Scene, and any other Scene in the Scene list\r\n                event.cancelled = 0;\r\n\r\n                //  Won't reach any more local (Scene level) handlers\r\n                event.stopImmediatePropagation = function ()\r\n                {\r\n                    event.cancelled = 1;\r\n                };\r\n\r\n                //  Won't reach any more handlers in any Scene further down the Scene list\r\n                event.stopPropagation = function ()\r\n                {\r\n                    event.cancelled = -1;\r\n                };\r\n            }\r\n\r\n            if (event.cancelled === -1)\r\n            {\r\n                //  This event has been stopped from broadcasting to any other Scene, so abort.\r\n                continue;\r\n            }\r\n\r\n            //  Duplicate event bailout\r\n            if (code === this.prevCode && event.timeStamp === this.prevTime && event.type === this.prevType)\r\n            {\r\n                //  On some systems, the exact same event will fire multiple times. This prevents it.\r\n                continue;\r\n            }\r\n\r\n            this.prevCode = code;\r\n            this.prevTime = event.timeStamp;\r\n            this.prevType = event.type;\r\n\r\n            if (event.type === 'keydown')\r\n            {\r\n                //  Key specific callback first\r\n                if (key)\r\n                {\r\n                    repeat = key.isDown;\r\n\r\n                    key.onDown(event);\r\n                }\r\n\r\n                if (!event.cancelled && (!key || !repeat))\r\n                {\r\n                    if (KeyMap[code])\r\n                    {\r\n                        this.emit(Events.KEY_DOWN + KeyMap[code], event);\r\n                    }\r\n\r\n                    if (!event.cancelled)\r\n                    {\r\n                        this.emit(Events.ANY_KEY_DOWN, event);\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Key specific callback first\r\n                if (key)\r\n                {\r\n                    key.onUp(event);\r\n                }\r\n\r\n                if (!event.cancelled)\r\n                {\r\n                    if (KeyMap[code])\r\n                    {\r\n                        this.emit(Events.KEY_UP + KeyMap[code], event);\r\n                    }\r\n\r\n                    if (!event.cancelled)\r\n                    {\r\n                        this.emit(Events.ANY_KEY_UP, event);\r\n                    }\r\n                }\r\n            }\r\n\r\n            //  Reset the cancel state for other Scenes to use\r\n            if (event.cancelled === 1)\r\n            {\r\n                event.cancelled = 0;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resets all Key objects created by _this_ Keyboard Plugin back to their default un-pressed states.\r\n     * This can only reset keys created via the `addKey`, `addKeys` or `createCursorKeys` methods.\r\n     * If you have created a Key object directly you'll need to reset it yourself.\r\n     *\r\n     * This method is called automatically when the Keyboard Plugin shuts down, but can be\r\n     * invoked directly at any time you require.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#resetKeys\r\n     * @since 3.15.0\r\n     *\r\n     * @return {this} This KeyboardPlugin object.\r\n     */\r\n    resetKeys: function ()\r\n    {\r\n        var keys = this.keys;\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            //  Because it's a sparsely populated array\r\n            if (keys[i])\r\n            {\r\n                keys[i].reset();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuts this Keyboard Plugin down. This performs the following tasks:\r\n     *\r\n     * 1 - Removes all keys created by this Keyboard plugin.\r\n     * 2 - Stops and removes the keyboard event listeners.\r\n     * 3 - Clears out any pending requests in the queue, without processing them.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#shutdown\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.removeAllKeys(true);\r\n        this.removeAllListeners();\r\n\r\n        this.sceneInputPlugin.manager.events.off(InputEvents.MANAGER_PROCESS, this.update, this);\r\n\r\n        this.game.events.off(GameEvents.BLUR, this.resetKeys);\r\n\r\n        this.scene.sys.events.off(SceneEvents.PAUSE, this.resetKeys, this);\r\n        this.scene.sys.events.off(SceneEvents.SLEEP, this.resetKeys, this);\r\n\r\n        this.queue = [];\r\n    },\r\n\r\n    /**\r\n     * Destroys this Keyboard Plugin instance and all references it holds, plus clears out local arrays.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyboardPlugin#destroy\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        var keys = this.keys;\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            //  Because it's a sparsely populated array\r\n            if (keys[i])\r\n            {\r\n                keys[i].destroy();\r\n            }\r\n        }\r\n\r\n        this.keys = [];\r\n        this.combos = [];\r\n        this.queue = [];\r\n\r\n        this.scene = null;\r\n        this.settings = null;\r\n        this.sceneInputPlugin = null;\r\n        this.manager = null;\r\n    },\r\n\r\n    /**\r\n     * Internal time value.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyboardPlugin#time\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.11.0\r\n     */\r\n    time: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.sceneInputPlugin.manager.time;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * An instance of the Keyboard Plugin class, if enabled via the `input.keyboard` Scene or Game Config property.\r\n * Use this to create Key objects and listen for keyboard specific events.\r\n *\r\n * @name Phaser.Input.InputPlugin#keyboard\r\n * @type {?Phaser.Input.Keyboard.KeyboardPlugin}\r\n * @since 3.10.0\r\n */\r\nInputPluginCache.register('KeyboardPlugin', KeyboardPlugin, 'keyboard', 'keyboard', 'inputKeyboard');\r\n\r\nmodule.exports = KeyboardPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Used internally by the KeyCombo class.\r\n * Return `true` if it reached the end of the combo, `false` if not.\r\n *\r\n * @function Phaser.Input.Keyboard.AdvanceKeyCombo\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {KeyboardEvent} event - The native Keyboard Event.\r\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - The KeyCombo object to advance.\r\n *\r\n * @return {boolean} `true` if it reached the end of the combo, `false` if not.\r\n */\r\nvar AdvanceKeyCombo = function (event, combo)\r\n{\r\n    combo.timeLastMatched = event.timeStamp;\r\n    combo.index++;\r\n\r\n    if (combo.index === combo.size)\r\n    {\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        combo.current = combo.keyCodes[combo.index];\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = AdvanceKeyCombo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Events = require('../events');\r\nvar GetFastValue = require('../../../utils/object/GetFastValue');\r\nvar ProcessKeyCombo = require('./ProcessKeyCombo');\r\nvar ResetKeyCombo = require('./ResetKeyCombo');\r\n\r\n/**\r\n * @classdesc\r\n * A KeyCombo will listen for a specific string of keys from the Keyboard, and when it receives them\r\n * it will emit a `keycombomatch` event from the Keyboard Manager.\r\n *\r\n * The keys to be listened for can be defined as:\r\n *\r\n * A string (i.e. 'ATARI')\r\n * An array of either integers (key codes) or strings, or a mixture of both\r\n * An array of objects (such as Key objects) with a public 'keyCode' property\r\n *\r\n * For example, to listen for the Konami code (up, up, down, down, left, right, left, right, b, a, enter)\r\n * you could pass the following array of key codes:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n *\r\n * this.input.keyboard.on('keycombomatch', function (event) {\r\n *     console.log('Konami Code entered!');\r\n * });\r\n * ```\r\n *\r\n * Or, to listen for the user entering the word PHASER:\r\n *\r\n * ```javascript\r\n * this.input.keyboard.createCombo('PHASER');\r\n * ```\r\n *\r\n * @class KeyCombo\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @listens Phaser.Input.Keyboard.Events#ANY_KEY_DOWN\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyboardPlugin} keyboardPlugin - A reference to the Keyboard Plugin.\r\n * @param {(string|number[]|object[])} keys - The keys that comprise this combo.\r\n * @param {Phaser.Types.Input.Keyboard.KeyComboConfig} [config] - A Key Combo configuration object.\r\n */\r\nvar KeyCombo = new Class({\r\n\r\n    initialize:\r\n\r\n    function KeyCombo (keyboardPlugin, keys, config)\r\n    {\r\n        if (config === undefined) { config = {}; }\r\n\r\n        //  Can't have a zero or single length combo (string or array based)\r\n        if (keys.length < 2)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * A reference to the Keyboard Manager\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#manager\r\n         * @type {Phaser.Input.Keyboard.KeyboardPlugin}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = keyboardPlugin;\r\n\r\n        /**\r\n         * A flag that controls if this Key Combo is actively processing keys or not.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * An array of the keycodes that comprise this combo.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#keyCodes\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.keyCodes = [];\r\n\r\n        //  if 'keys' is a string we need to get the keycode of each character in it\r\n\r\n        for (var i = 0; i < keys.length; i++)\r\n        {\r\n            var char = keys[i];\r\n\r\n            if (typeof char === 'string')\r\n            {\r\n                this.keyCodes.push(char.toUpperCase().charCodeAt(0));\r\n            }\r\n            else if (typeof char === 'number')\r\n            {\r\n                this.keyCodes.push(char);\r\n            }\r\n            else if (char.hasOwnProperty('keyCode'))\r\n            {\r\n                this.keyCodes.push(char.keyCode);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The current keyCode the combo is waiting for.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#current\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.current = this.keyCodes[0];\r\n\r\n        /**\r\n         * The current index of the key being waited for in the 'keys' string.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#index\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.index = 0;\r\n\r\n        /**\r\n         * The length of this combo (in keycodes)\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#size\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.size = this.keyCodes.length;\r\n\r\n        /**\r\n         * The time the previous key in the combo was matched.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#timeLastMatched\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeLastMatched = 0;\r\n\r\n        /**\r\n         * Has this Key Combo been matched yet?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#matched\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.matched = false;\r\n\r\n        /**\r\n         * The time the entire combo was matched.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#timeMatched\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeMatched = 0;\r\n\r\n        /**\r\n         * If they press the wrong key do we reset the combo?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#resetOnWrongKey\r\n         * @type {boolean}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.resetOnWrongKey = GetFastValue(config, 'resetOnWrongKey', true);\r\n\r\n        /**\r\n         * The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#maxKeyDelay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.maxKeyDelay = GetFastValue(config, 'maxKeyDelay', 0);\r\n\r\n        /**\r\n         * If previously matched and they press the first key of the combo again, will it reset?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#resetOnMatch\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.resetOnMatch = GetFastValue(config, 'resetOnMatch', false);\r\n\r\n        /**\r\n         * If the combo matches, will it delete itself?\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#deleteOnMatch\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.deleteOnMatch = GetFastValue(config, 'deleteOnMatch', false);\r\n\r\n        var _this = this;\r\n\r\n        var onKeyDownHandler = function (event)\r\n        {\r\n            if (_this.matched || !_this.enabled)\r\n            {\r\n                return;\r\n            }\r\n\r\n            var matched = ProcessKeyCombo(event, _this);\r\n\r\n            if (matched)\r\n            {\r\n                _this.manager.emit(Events.COMBO_MATCH, _this, event);\r\n\r\n                if (_this.resetOnMatch)\r\n                {\r\n                    ResetKeyCombo(_this);\r\n                }\r\n                else if (_this.deleteOnMatch)\r\n                {\r\n                    _this.destroy();\r\n                }\r\n            }\r\n        };\r\n\r\n        /**\r\n         * The internal Key Down handler.\r\n         *\r\n         * @name Phaser.Input.Keyboard.KeyCombo#onKeyDown\r\n         * @private\r\n         * @type {KeyboardKeydownCallback}\r\n         * @fires Phaser.Input.Keyboard.Events#COMBO_MATCH\r\n         * @since 3.0.0\r\n         */\r\n        this.onKeyDown = onKeyDownHandler;\r\n\r\n        this.manager.on(Events.ANY_KEY_DOWN, this.onKeyDown);\r\n    },\r\n\r\n    /**\r\n     * How far complete is this combo? A value between 0 and 1.\r\n     *\r\n     * @name Phaser.Input.Keyboard.KeyCombo#progress\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    progress: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.index / this.size;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Destroys this Key Combo and all of its references.\r\n     *\r\n     * @method Phaser.Input.Keyboard.KeyCombo#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.enabled = false;\r\n        this.keyCodes = [];\r\n\r\n        this.manager.off(Events.ANY_KEY_DOWN, this.onKeyDown);\r\n\r\n        this.manager = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = KeyCombo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AdvanceKeyCombo = require('./AdvanceKeyCombo');\r\n\r\n/**\r\n * Used internally by the KeyCombo class.\r\n *\r\n * @function Phaser.Input.Keyboard.ProcessKeyCombo\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {KeyboardEvent} event - The native Keyboard Event.\r\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - The KeyCombo object to be processed.\r\n *\r\n * @return {boolean} `true` if the combo was matched, otherwise `false`.\r\n */\r\nvar ProcessKeyCombo = function (event, combo)\r\n{\r\n    if (combo.matched)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    var comboMatched = false;\r\n    var keyMatched = false;\r\n\r\n    if (event.keyCode === combo.current)\r\n    {\r\n        //  Key was correct\r\n\r\n        if (combo.index > 0 && combo.maxKeyDelay > 0)\r\n        {\r\n            //  We have to check to see if the delay between\r\n            //  the new key and the old one was too long (if enabled)\r\n\r\n            var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;\r\n\r\n            //  Check if they pressed it in time or not\r\n            if (event.timeStamp <= timeLimit)\r\n            {\r\n                keyMatched = true;\r\n                comboMatched = AdvanceKeyCombo(event, combo);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            keyMatched = true;\r\n\r\n            //  We don't check the time for the first key pressed, so just advance it\r\n            comboMatched = AdvanceKeyCombo(event, combo);\r\n        }\r\n    }\r\n\r\n    if (!keyMatched && combo.resetOnWrongKey)\r\n    {\r\n        //  Wrong key was pressed\r\n        combo.index = 0;\r\n        combo.current = combo.keyCodes[0];\r\n    }\r\n\r\n    if (comboMatched)\r\n    {\r\n        combo.timeLastMatched = event.timeStamp;\r\n        combo.matched = true;\r\n        combo.timeMatched = event.timeStamp;\r\n    }\r\n\r\n    return comboMatched;\r\n};\r\n\r\nmodule.exports = ProcessKeyCombo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Used internally by the KeyCombo class.\r\n *\r\n * @function Phaser.Input.Keyboard.ResetKeyCombo\r\n * @private\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - The KeyCombo to reset.\r\n *\r\n * @return {Phaser.Input.Keyboard.KeyCombo} The KeyCombo.\r\n */\r\nvar ResetKeyCombo = function (combo)\r\n{\r\n    combo.current = combo.keyCodes[0];\r\n    combo.index = 0;\r\n    combo.timeLastMatched = 0;\r\n    combo.matched = false;\r\n    combo.timeMatched = 0;\r\n\r\n    return combo;\r\n};\r\n\r\nmodule.exports = ResetKeyCombo;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Global Key Down Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.keyboard.on('keydown', listener)`.\r\n * \r\n * You can also listen for a specific key being pressed. See [Keyboard.Events.KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_DOWN} for details.\r\n * \r\n * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.\r\n * \r\n * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\r\n * Read [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.\r\n *\r\n * Also, please be aware that some browser extensions can disable or override Phaser keyboard handling.\r\n * For example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\r\n * There are others. So, please check your extensions if you find you have specific keys that don't work.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#ANY_KEY_DOWN\r\n * @since 3.0.0\r\n * \r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was pressed, any modifiers, etc.\r\n */\r\nmodule.exports = 'keydown';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Global Key Up Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when any key on the keyboard is released.\r\n * \r\n * Listen to this event from within a Scene using: `this.input.keyboard.on('keyup', listener)`.\r\n * \r\n * You can also listen for a specific key being released. See [Keyboard.Events.KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:KEY_UP} for details.\r\n * \r\n * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#ANY_KEY_UP\r\n * @since 3.0.0\r\n * \r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was released, any modifiers, etc.\r\n */\r\nmodule.exports = 'keyup';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Combo Match Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when a [Key Combo]{@link Phaser.Input.Keyboard.KeyCombo} is matched.\r\n * \r\n * Listen for this event from the Key Plugin after a combo has been created:\r\n * \r\n * ```javascript\r\n * this.input.keyboard.createCombo([ 38, 38, 40, 40, 37, 39, 37, 39, 66, 65, 13 ], { resetOnMatch: true });\r\n *\r\n * this.input.keyboard.on('keycombomatch', function (event) {\r\n *     console.log('Konami Code entered!');\r\n * });\r\n * ```\r\n *\r\n * @event Phaser.Input.Keyboard.Events#COMBO_MATCH\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Keyboard.KeyCombo} keycombo - The Key Combo object that was matched.\r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event of the final key in the combo. You can inspect this to learn more about any modifiers, etc.\r\n */\r\nmodule.exports = 'keycombomatch';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Down Event.\r\n * \r\n * This event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is pressed.\r\n * \r\n * Listen for this event from the Key object instance directly:\r\n * \r\n * ```javascript\r\n * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\r\n * \r\n * spaceBar.on('down', listener)\r\n * ```\r\n * \r\n * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#DOWN\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Keyboard.Key} key - The Key object that was pressed.\r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about any modifiers, etc.\r\n */\r\nmodule.exports = 'down';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Down Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when any key on the keyboard is pressed down.\r\n * \r\n * Unlike the `ANY_KEY_DOWN` event, this one has a special dynamic event name. For example, to listen for the `A` key being pressed\r\n * use the following from within a Scene: `this.input.keyboard.on('keydown-A', listener)`. You can replace the `-A` part of the event\r\n * name with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar: \r\n * `this.input.keyboard.on('keydown-SPACE', listener)`.\r\n * \r\n * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_DOWN} for details.\r\n * \r\n * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.DOWN]{@linkcode Phaser.Input.Keyboard.Events#event:DOWN} for details.\r\n * \r\n * _Note_: Many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.\r\n * Read [this article on ghosting]{@link http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/} for details.\r\n *\r\n * Also, please be aware that some browser extensions can disable or override Phaser keyboard handling.\r\n * For example, the Chrome extension vimium is known to disable Phaser from using the D key, while EverNote disables the backtick key.\r\n * There are others. So, please check your extensions if you find you have specific keys that don't work.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#KEY_DOWN\r\n * @since 3.0.0\r\n * \r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was pressed, any modifiers, etc.\r\n */\r\nmodule.exports = 'keydown-';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Up Event.\r\n * \r\n * This event is dispatched by the Keyboard Plugin when any key on the keyboard is released.\r\n * \r\n * Unlike the `ANY_KEY_UP` event, this one has a special dynamic event name. For example, to listen for the `A` key being released\r\n * use the following from within a Scene: `this.input.keyboard.on('keyup-A', listener)`. You can replace the `-A` part of the event\r\n * name with any valid [Key Code string]{@link Phaser.Input.Keyboard.KeyCodes}. For example, this will listen for the space bar: \r\n * `this.input.keyboard.on('keyup-SPACE', listener)`.\r\n * \r\n * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.\r\n * \r\n * Finally, you can create Key objects, which you can also listen for events from. See [Keyboard.Events.UP]{@linkcode Phaser.Input.Keyboard.Events#event:UP} for details.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#KEY_UP\r\n * @since 3.0.0\r\n * \r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about the key that was released, any modifiers, etc.\r\n */\r\nmodule.exports = 'keyup-';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The Key Up Event.\r\n * \r\n * This event is dispatched by a [Key]{@link Phaser.Input.Keyboard.Key} object when it is released.\r\n * \r\n * Listen for this event from the Key object instance directly:\r\n * \r\n * ```javascript\r\n * var spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);\r\n * \r\n * spaceBar.on('up', listener)\r\n * ```\r\n * \r\n * You can also create a generic 'global' listener. See [Keyboard.Events.ANY_KEY_UP]{@linkcode Phaser.Input.Keyboard.Events#event:ANY_KEY_UP} for details.\r\n *\r\n * @event Phaser.Input.Keyboard.Events#UP\r\n * @since 3.0.0\r\n * \r\n * @param {Phaser.Input.Keyboard.Key} key - The Key object that was released.\r\n * @param {KeyboardEvent} event - The native DOM Keyboard Event. You can inspect this to learn more about any modifiers, etc.\r\n */\r\nmodule.exports = 'up';\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Keyboard.Events\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ANY_KEY_DOWN: require('./ANY_KEY_DOWN_EVENT'),\r\n    ANY_KEY_UP: require('./ANY_KEY_UP_EVENT'),\r\n    COMBO_MATCH: require('./COMBO_MATCH_EVENT'),\r\n    DOWN: require('./DOWN_EVENT'),\r\n    KEY_DOWN: require('./KEY_DOWN_EVENT'),\r\n    KEY_UP: require('./KEY_UP_EVENT'),\r\n    UP: require('./UP_EVENT')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Keyboard\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    Events: require('./events'),\r\n\r\n    KeyboardManager: require('./KeyboardManager'),\r\n    KeyboardPlugin: require('./KeyboardPlugin'),\r\n\r\n    Key: require('./keys/Key'),\r\n    KeyCodes: require('./keys/KeyCodes'),\r\n\r\n    KeyCombo: require('./combo/KeyCombo'),\r\n\r\n    AdvanceKeyCombo: require('./combo/AdvanceKeyCombo'),\r\n    ProcessKeyCombo: require('./combo/ProcessKeyCombo'),\r\n    ResetKeyCombo: require('./combo/ResetKeyCombo'),\r\n\r\n    JustDown: require('./keys/JustDown'),\r\n    JustUp: require('./keys/JustUp'),\r\n    DownDuration: require('./keys/DownDuration'),\r\n    UpDuration: require('./keys/UpDuration')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns `true` if the Key was pressed down within the `duration` value given, based on the current\r\n * game clock time. Or `false` if it either isn't down, or was pressed down longer ago than the given duration.\r\n *\r\n * @function Phaser.Input.Keyboard.DownDuration\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - The Key object to test.\r\n * @param {number} [duration=50] - The duration, in ms, within which the key must have been pressed down.\r\n *\r\n * @return {boolean} `true` if the Key was pressed down within `duration` ms ago, otherwise `false`.\r\n */\r\nvar DownDuration = function (key, duration)\r\n{\r\n    if (duration === undefined) { duration = 50; }\r\n\r\n    var current = key.plugin.game.loop.time - key.timeDown;\r\n\r\n    return (key.isDown && current < duration);\r\n};\r\n\r\nmodule.exports = DownDuration;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The justDown value allows you to test if this Key has just been pressed down or not.\r\n * \r\n * When you check this value it will return `true` if the Key is down, otherwise `false`.\r\n * \r\n * You can only call justDown once per key press. It will only return `true` once, until the Key is released and pressed down again.\r\n * This allows you to use it in situations where you want to check if this key is down without using an event, such as in a core game loop.\r\n *\r\n * @function Phaser.Input.Keyboard.JustDown\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - The Key to check to see if it's just down or not.\r\n *\r\n * @return {boolean} `true` if the Key was just pressed, otherwise `false`.\r\n */\r\nvar JustDown = function (key)\r\n{\r\n    if (key._justDown)\r\n    {\r\n        key._justDown = false;\r\n\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = JustDown;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * The justUp value allows you to test if this Key has just been released or not.\r\n * \r\n * When you check this value it will return `true` if the Key is up, otherwise `false`.\r\n * \r\n * You can only call JustUp once per key release. It will only return `true` once, until the Key is pressed down and released again.\r\n * This allows you to use it in situations where you want to check if this key is up without using an event, such as in a core game loop.\r\n *\r\n * @function Phaser.Input.Keyboard.JustUp\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - The Key to check to see if it's just up or not.\r\n *\r\n * @return {boolean} `true` if the Key was just released, otherwise `false`.\r\n */\r\nvar JustUp = function (key)\r\n{\r\n    if (key._justUp)\r\n    {\r\n        key._justUp = false;\r\n\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = JustUp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('../events');\r\n\r\n/**\r\n * @classdesc\r\n * A generic Key object which can be passed to the Process functions (and so on)\r\n * keycode must be an integer\r\n *\r\n * @class Key\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Input.Keyboard\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.KeyboardPlugin} plugin - The Keyboard Plugin instance that owns this Key object.\r\n * @param {number} keyCode - The keycode of this key.\r\n */\r\nvar Key = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function Key (plugin, keyCode)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Keyboard Plugin instance that owns this Key object.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#plugin\r\n         * @type {Phaser.Input.Keyboard.KeyboardPlugin}\r\n         * @since 3.17.0\r\n         */\r\n        this.plugin = plugin;\r\n\r\n        /**\r\n         * The keycode of this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#keyCode\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.keyCode = keyCode;\r\n\r\n        /**\r\n         * The original DOM event.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#originalEvent\r\n         * @type {KeyboardEvent}\r\n         * @since 3.0.0\r\n         */\r\n        this.originalEvent = undefined;\r\n\r\n        /**\r\n         * Can this Key be processed?\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * The \"down\" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#isDown\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.isDown = false;\r\n\r\n        /**\r\n         * The \"up\" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#isUp\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.isUp = true;\r\n\r\n        /**\r\n         * The down state of the ALT key, if pressed at the same time as this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#altKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.altKey = false;\r\n\r\n        /**\r\n         * The down state of the CTRL key, if pressed at the same time as this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#ctrlKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.ctrlKey = false;\r\n\r\n        /**\r\n         * The down state of the SHIFT key, if pressed at the same time as this key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#shiftKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.shiftKey = false;\r\n\r\n        /**\r\n         * The down state of the Meta key, if pressed at the same time as this key.\r\n         * On a Mac the Meta Key is the Command key. On Windows keyboards, it's the Windows key.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#metaKey\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.16.0\r\n         */\r\n        this.metaKey = false;\r\n\r\n        /**\r\n         * The location of the modifier key. 0 for standard (or unknown), 1 for left, 2 for right, 3 for numpad.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#location\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.location = 0;\r\n\r\n        /**\r\n         * The timestamp when the key was last pressed down.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#timeDown\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeDown = 0;\r\n\r\n        /**\r\n         * The number of milliseconds this key was held down for in the previous down - up sequence.\r\n         * This value isn't updated every game step, only when the Key changes state.\r\n         * To get the current duration use the `getDuration` method.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#duration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.duration = 0;\r\n\r\n        /**\r\n         * The timestamp when the key was last released.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#timeUp\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.timeUp = 0;\r\n\r\n        /**\r\n         * When a key is held down should it continuously fire the `down` event each time it repeats?\r\n         * \r\n         * By default it will emit the `down` event just once, but if you wish to receive the event\r\n         * for each repeat as well, enable this property.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#emitOnRepeat\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.16.0\r\n         */\r\n        this.emitOnRepeat = false;\r\n\r\n        /**\r\n         * If a key is held down this holds down the number of times the key has 'repeated'.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#repeats\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.repeats = 0;\r\n\r\n        /**\r\n         * True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#_justDown\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this._justDown = false;\r\n\r\n        /**\r\n         * True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#_justUp\r\n         * @type {boolean}\r\n         * @private\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this._justUp = false;\r\n\r\n        /**\r\n         * Internal tick counter.\r\n         *\r\n         * @name Phaser.Input.Keyboard.Key#_tick\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._tick = -1;\r\n    },\r\n\r\n    /**\r\n     * Controls if this Key will continuously emit a `down` event while being held down (true),\r\n     * or emit the event just once, on first press, and then skip future events (false).\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#setEmitOnRepeat\r\n     * @since 3.16.0\r\n     * \r\n     * @param {boolean} value - Emit `down` events on repeated key down actions, or just once?\r\n     * \r\n     * @return {this} This Key instance.\r\n     */\r\n    setEmitOnRepeat: function (value)\r\n    {\r\n        this.emitOnRepeat = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Processes the Key Down action for this Key.\r\n     * Called automatically by the Keyboard Plugin.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#onDown\r\n     * @fires Phaser.Input.Keyboard.Events#DOWN\r\n     * @since 3.16.0\r\n     * \r\n     * @param {KeyboardEvent} event - The native DOM Keyboard event.\r\n     */\r\n    onDown: function (event)\r\n    {\r\n        this.originalEvent = event;\r\n\r\n        if (!this.enabled)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.altKey = event.altKey;\r\n        this.ctrlKey = event.ctrlKey;\r\n        this.shiftKey = event.shiftKey;\r\n        this.metaKey = event.metaKey;\r\n        this.location = event.location;\r\n    \r\n        this.repeats++;\r\n\r\n        if (!this.isDown)\r\n        {\r\n            this.isDown = true;\r\n            this.isUp = false;\r\n            this.timeDown = event.timeStamp;\r\n            this.duration = 0;\r\n            this._justDown = true;\r\n            this._justUp = false;\r\n\r\n            this.emit(Events.DOWN, this, event);\r\n        }\r\n        else if (this.emitOnRepeat)\r\n        {\r\n            this.emit(Events.DOWN, this, event);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Processes the Key Up action for this Key.\r\n     * Called automatically by the Keyboard Plugin.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#onUp\r\n     * @fires Phaser.Input.Keyboard.Events#UP\r\n     * @since 3.16.0\r\n     * \r\n     * @param {KeyboardEvent} event - The native DOM Keyboard event.\r\n     */\r\n    onUp: function (event)\r\n    {\r\n        this.originalEvent = event;\r\n\r\n        if (!this.enabled)\r\n        {\r\n            return;\r\n        }\r\n    \r\n        this.isDown = false;\r\n        this.isUp = true;\r\n        this.timeUp = event.timeStamp;\r\n        this.duration = this.timeUp - this.timeDown;\r\n        this.repeats = 0;\r\n    \r\n        this._justDown = false;\r\n        this._justUp = true;\r\n        this._tick = -1;\r\n        \r\n        this.emit(Events.UP, this, event);\r\n    },\r\n\r\n    /**\r\n     * Resets this Key object back to its default un-pressed state.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#reset\r\n     * @since 3.6.0\r\n     * \r\n     * @return {this} This Key instance.\r\n     */\r\n    reset: function ()\r\n    {\r\n        this.preventDefault = true;\r\n        this.enabled = true;\r\n        this.isDown = false;\r\n        this.isUp = true;\r\n        this.altKey = false;\r\n        this.ctrlKey = false;\r\n        this.shiftKey = false;\r\n        this.metaKey = false;\r\n        this.timeDown = 0;\r\n        this.duration = 0;\r\n        this.timeUp = 0;\r\n        this.repeats = 0;\r\n        this._justDown = false;\r\n        this._justUp = false;\r\n        this._tick = -1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the duration, in ms, that the Key has been held down for.\r\n     * \r\n     * If the key is not currently down it will return zero.\r\n     * \r\n     * The get the duration the Key was held down for in the previous up-down cycle,\r\n     * use the `Key.duration` property value instead.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#getDuration\r\n     * @since 3.17.0\r\n     * \r\n     * @return {number} The duration, in ms, that the Key has been held down for if currently down.\r\n     */\r\n    getDuration: function ()\r\n    {\r\n        if (this.isDown)\r\n        {\r\n            return (this.plugin.game.loop.time - this.timeDown);\r\n        }\r\n        else\r\n        {\r\n            return 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes any bound event handlers and removes local references.\r\n     *\r\n     * @method Phaser.Input.Keyboard.Key#destroy\r\n     * @since 3.16.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.originalEvent = null;\r\n\r\n        this.plugin = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Key;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar KeyCodes = require('./KeyCodes');\r\n\r\nvar KeyMap = {};\r\n\r\nfor (var key in KeyCodes)\r\n{\r\n    KeyMap[KeyCodes[key]] = key;\r\n}\r\n\r\nmodule.exports = KeyMap;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns `true` if the Key was released within the `duration` value given, based on the current\r\n * game clock time. Or returns `false` if it either isn't up, or was released longer ago than the given duration.\r\n *\r\n * @function Phaser.Input.Keyboard.UpDuration\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Input.Keyboard.Key} key - The Key object to test.\r\n * @param {number} [duration=50] - The duration, in ms, within which the key must have been released.\r\n *\r\n * @return {boolean} `true` if the Key was released within `duration` ms ago, otherwise `false`.\r\n */\r\nvar UpDuration = function (key, duration)\r\n{\r\n    if (duration === undefined) { duration = 50; }\r\n\r\n    var current = key.plugin.game.loop.time - key.timeUp;\r\n\r\n    return (key.isUp && current < duration);\r\n};\r\n\r\nmodule.exports = UpDuration;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Mouse\r\n */\r\n\r\n/* eslint-disable */\r\nmodule.exports = {\r\n\r\n    MouseManager: require('./MouseManager')\r\n       \r\n};\r\n/* eslint-enable */\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.Input.Touch\r\n */\r\n\r\n/* eslint-disable */\r\nmodule.exports = {\r\n\r\n    TouchManager: require('./TouchManager')\r\n       \r\n};\r\n/* eslint-enable */\r\n"],"names":["module","exports","gameObject","hitArea","hitAreaCallback","enabled","alwaysEnabled","draggable","dropZone","cursor","target","camera","hitAreaDebug","customHitArea","localX","localY","dragState","dragStartX","dragStartY","dragStartXGlobal","dragStartYGlobal","dragX","dragY","textureManager","alphaTolerance","x","y","alpha","getPixelAlpha","texture","key","frame","name","Circle","CircleContains","Class","CONST","CreateInteractiveObject","CreatePixelPerfectHandler","DistanceBetween","Ellipse","EllipseContains","Events","EventEmitter","GetFastValue","GEOM_CONST","InputPluginCache","IsPlainObject","PluginCache","Rectangle","RectangleContains","SceneEvents","Triangle","TriangleContains","InputPlugin","Extends","initialize","scene","call","this","systems","sys","settings","manager","game","input","pluginEvents","displayList","cameras","install","mouse","topOnly","pollRate","_pollTimer","_eventData","cancelled","_eventContainer","stopPropagation","dragDistanceThreshold","dragTimeThreshold","_temp","_tempZones","_list","_pendingInsertion","_pendingRemoval","_draggable","_drag","_dragState","_over","_validTypes","_updatedThisFrame","events","once","BOOT","boot","on","START","start","DESTROY","destroy","emit","eventEmitter","TRANSITION_START","transitionIn","TRANSITION_OUT","transitionOut","TRANSITION_COMPLETE","transitionComplete","PRE_UPDATE","preUpdate","SHUTDOWN","shutdown","GAME_OUT","onGameOut","GAME_OVER","onGameOver","event","isActive","timeStamp","removeList","insertList","toRemove","length","toInsert","current","i","index","indexOf","splice","clear","concat","updatePoll","time","delta","UPDATE","pointers","pointersTotal","updateMotion","rate","captured","total","pointer","hitTestPointer","sortGameObjects","sortDropZones","processOverOutEvents","getDragState","processDragThresholdEvent","update","type","MOUSE_DOWN","processDragDownEvent","processDownEvents","MOUSE_UP","processDragUpEvent","processUpEvents","TOUCH_START","processOverEvents","TOUCH_END","TOUCH_CANCEL","processOutEvents","MOUSE_MOVE","TOUCH_MOVE","processDragMoveEvent","processMoveEvents","MOUSE_WHEEL","processWheelEvent","skipQueue","undefined","queueForRemoval","callbackContext","resetCursor","disable","enable","setHitArea","getCamerasBelowPointer","c","over","hitTest","obj","push","currentlyOver","aborted","GAMEOBJECT_POINTER_DOWN","GAMEOBJECT_DOWN","downElement","canvas","POINTER_DOWN","POINTER_DOWN_OUTSIDE","id","setDragState","state","passed","timeThreshold","distanceThreshold","downX","downY","downTime","processDragStartList","list","worldX","worldY","GAMEOBJECT_DRAG_START","DRAG_START","primaryDown","draglist","loop","now","dropZones","GAMEOBJECT_DRAG_OVER","DRAG_OVER","GAMEOBJECT_DRAG_LEAVE","DRAG_LEAVE","GAMEOBJECT_DRAG_ENTER","DRAG_ENTER","parentContainer","dx","dy","rotation","getParentRotation","dxRotated","Math","cos","sin","dyRotated","scaleX","scaleY","GAMEOBJECT_DRAG","DRAG","displayOriginX","displayOriginY","dropped","GAMEOBJECT_DROP","DROP","GAMEOBJECT_DRAG_END","DRAG_END","GAMEOBJECT_POINTER_MOVE","GAMEOBJECT_MOVE","POINTER_MOVE","deltaX","deltaY","dz","deltaZ","GAMEOBJECT_POINTER_WHEEL","GAMEOBJECT_WHEEL","POINTER_WHEEL","totalInteracted","justOver","setCursor","GAMEOBJECT_POINTER_OVER","GAMEOBJECT_OVER","POINTER_OVER","previouslyOver","GAMEOBJECT_POINTER_OUT","GAMEOBJECT_OUT","POINTER_OUT","justOut","stillOver","currentlyDragging","GAMEOBJECT_POINTER_UP","GAMEOBJECT_UP","upElement","POINTER_UP","POINTER_UP_OUTSIDE","queueForInsertion","child","setDraggable","gameObjects","value","Array","isArray","makePixelPerfect","textures","setHitAreaFromTexture","useHandCursor","pixelPerfect","config","console","warn","io","setHitAreaCircle","radius","callback","shape","setHitAreaEllipse","width","height","realWidth","realHeight","setHitAreaRectangle","setHitAreaTriangle","x1","y1","x2","y2","x3","y3","enableDebug","color","shapeType","debug","factory","add","updateList","remove","offsetx","offsety","CIRCLE","arc","ELLIPSE","ellipse","LINE","line","POLYGON","polygon","points","RECTANGLE","rectangle","TRIANGLE","triangle","isFilled","setStrokeStyle","scale","setDisplayOrigin","matrix","getWorldTransformMatrix","tx","ty","setRotation","setScale","setPosition","setScrollFactor","scrollFactorX","scrollFactorY","setDepth","depth","removeDebug","setPollAlways","setPollRate","setPollOnMove","setGlobalTopOnly","globalTopOnly","setTopOnly","renderList","sort","childA","childB","depthSort","sortDropZoneHandler","bind","getIndex","listA","getIndexList","listB","len","min","indexA","indexB","_tempSkip","addPointer","quantity","setDefaultCursor","transitionAllowInput","removeAllListeners","style","defaultCursor","off","get","activePointer","isOver","mousePointer","pointer1","pointer2","pointer3","pointer4","pointer5","pointer6","pointer7","pointer8","pointer9","pointer10","register","GetValue","inputPlugins","plugin","mapping","settingsKey","configKey","source","hasOwnProperty","Axis","pad","threshold","getValue","abs","Button","pressed","BUTTON_DOWN","GAMEPAD_BUTTON_DOWN","BUTTON_UP","GAMEPAD_BUTTON_UP","Vector2","Gamepad","buttons","axes","vibration","vibrationActuator","_noButton","_LCLeft","_LCRight","_LCTop","_LCBottom","_RCLeft","_RCRight","_RCTop","_RCBottom","_FBLeftTop","_FBLeftBottom","_FBRightTop","_FBRightBottom","_noAxis","_HAxisLeft","_VAxisLeft","_HAxisRight","_VAxisRight","leftStick","rightStick","_created","performance","getAxisTotal","getAxisValue","setAxisThreshold","getButtonTotal","getButtonValue","isButtonDown","timestamp","localButtons","gamepadButtons","localAxes","gamepadAxes","set","connected","left","right","up","down","A","Y","X","B","L1","L2","R1","R2","InputEvents","GamepadPlugin","sceneInputPlugin","gamepads","queue","onGamepadHandler","_pad1","_pad2","_pad3","_pad4","inputGamepad","device","inputGamepadEventTarget","startListeners","refreshPads","_this","handler","defaultPrevented","addEventListener","stopListeners","removeEventListener","disconnectAll","connectedPads","navigator","getGamepads","currentPads","livePad","currentPad","newPad","getAll","out","pads","getPad","gamepad","CONNECTED","DISCONNECTED","pad1","pad2","pad3","pad4","UP","DOWN","LEFT","RIGHT","SELECT","LEFT_SHOULDER","RIGHT_SHOULDER","SHARE","OPTIONS","PS","TOUCHBAR","SQUARE","L3","R3","LEFT_STICK_H","LEFT_STICK_V","RIGHT_STICK_H","RIGHT_STICK_V","MENU","LB","RB","LT","RT","BACK","LS","RS","DUALSHOCK_4","SNES_USB","XBOX_360","Configs","Extend","Input","InputManager","Keyboard","Mouse","Pointer","Touch","GameEvents","Key","KeyCodes","KeyCombo","KeyMap","SnapFloor","KeyboardPlugin","keyboard","keys","combos","prevCode","prevTime","prevType","captures","addCaptures","MANAGER_PROCESS","BLUR","resetKeys","PAUSE","SLEEP","addCapture","keycode","removeCapture","getCaptures","enableGlobalCapture","preventDefault","disableGlobalCapture","clearCaptures","createCursorKeys","addKeys","space","SPACE","shift","SHIFT","enableCapture","emitOnRepeat","output","split","currentKey","trim","addKey","idx","keyCode","setEmitOnRepeat","toUpperCase","removeKey","ref","removeAllKeys","createCombo","checkDown","duration","isDown","t","timeDown","_tick","code","repeat","stopImmediatePropagation","onDown","KEY_DOWN","ANY_KEY_DOWN","onUp","KEY_UP","ANY_KEY_UP","reset","combo","timeLastMatched","size","keyCodes","ProcessKeyCombo","ResetKeyCombo","keyboardPlugin","char","charCodeAt","matched","timeMatched","resetOnWrongKey","maxKeyDelay","resetOnMatch","deleteOnMatch","onKeyDown","COMBO_MATCH","progress","AdvanceKeyCombo","comboMatched","keyMatched","timeLimit","KeyboardManager","JustDown","JustUp","DownDuration","UpDuration","_justDown","_justUp","originalEvent","isUp","altKey","ctrlKey","shiftKey","metaKey","location","timeUp","repeats","getDuration","MouseManager","TouchManager"],"sourceRoot":""}