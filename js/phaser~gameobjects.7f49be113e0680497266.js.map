{"version":3,"file":"js/phaser~gameobjects.7f49be113e0680497266.js","mappings":"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","sources":["webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/BuildGameObject.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/BuildGameObjectAnimation.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/DisplayList.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/UpdateList.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/BatchChar.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/GetBitmapTextSize.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/ParseFromAtlas.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/ParseRetroFont.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/ParseXMLBitmapFont.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/RetroFont.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/const.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapText.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/dynamic/DynamicBitmapTextWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapText.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/bitmaptext/static/BitmapTextWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/blitter/Blitter.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/blitter/BlitterCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/blitter/BlitterCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/blitter/BlitterFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/blitter/BlitterRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/blitter/BlitterWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/blitter/Bob.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/container/Container.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/container/ContainerCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/container/ContainerCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/container/ContainerFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/container/ContainerRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/container/ContainerWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/domelement/CSSBlendModes.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/domelement/DOMElement.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/domelement/DOMElementCSSRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/domelement/DOMElementFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/domelement/DOMElementRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/extern/Extern.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/extern/ExternFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/extern/ExternRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/extern/ExternWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/graphics/Commands.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/graphics/Graphics.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/graphics/GraphicsCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/graphics/GraphicsCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/graphics/GraphicsFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/graphics/GraphicsRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/graphics/GraphicsWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/group/GroupCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/group/GroupFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/image/ImageCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/image/ImageFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/layer/Layer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/layer/LayerCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/layer/LayerCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/layer/LayerFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/layer/LayerRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/layer/LayerWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/lights/Light.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/lights/LightsManager.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/lights/LightsPlugin.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/mesh/Mesh.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/mesh/MeshCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/mesh/MeshCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/mesh/MeshFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/mesh/MeshRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/mesh/MeshWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/EmitterOp.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/GravityWell.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/Particle.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/ParticleEmitter.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/ParticleEmitterManager.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/ParticleManagerCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/ParticleManagerCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/ParticleManagerFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/ParticleManagerRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/ParticleManagerWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/zones/DeathZone.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/zones/EdgeZone.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/zones/RandomZone.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/particles/zones/index.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/pathfollower/PathFollower.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/pathfollower/PathFollowerFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/pointlight/PointLight.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/pointlight/PointLightCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/pointlight/PointLightFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/pointlight/PointLightRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/pointlight/PointLightWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/rendertexture/RenderTexture.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/rendertexture/RenderTextureCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/rendertexture/RenderTextureCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/rendertexture/RenderTextureFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/rendertexture/RenderTextureRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/rendertexture/RenderTextureWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/rope/Rope.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/rope/RopeCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/rope/RopeCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/rope/RopeFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/rope/RopeRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/rope/RopeWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shader/Shader.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shader/ShaderCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shader/ShaderCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shader/ShaderFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shader/ShaderRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shader/ShaderWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/FillPathWebGL.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/FillStyleCanvas.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/LineStyleCanvas.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/Shape.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/StrokePathWebGL.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/arc/Arc.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/arc/ArcCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/arc/ArcFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/arc/ArcRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/arc/ArcWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/curve/Curve.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/curve/CurveCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/curve/CurveFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/curve/CurveRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/curve/CurveWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/ellipse/Ellipse.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/ellipse/EllipseCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/ellipse/EllipseFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/ellipse/EllipseRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/ellipse/EllipseWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/grid/Grid.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/grid/GridCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/grid/GridFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/grid/GridRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/grid/GridWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/isobox/IsoBox.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/isobox/IsoBoxCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/isobox/IsoBoxFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/isobox/IsoBoxRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/isobox/IsoBoxWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangle.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangleCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangleFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangleRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/isotriangle/IsoTriangleWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/line/Line.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/line/LineCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/line/LineFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/line/LineRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/line/LineWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/polygon/Polygon.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/polygon/PolygonCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/polygon/PolygonFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/polygon/PolygonRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/polygon/PolygonWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/rectangle/Rectangle.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/rectangle/RectangleCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/rectangle/RectangleFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/rectangle/RectangleRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/rectangle/RectangleWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/star/Star.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/star/StarCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/star/StarFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/star/StarRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/star/StarWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/triangle/Triangle.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/triangle/TriangleCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/triangle/TriangleFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/triangle/TriangleRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/shape/triangle/TriangleWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/sprite/SpriteCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/sprite/SpriteFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/text/GetTextSize.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/text/MeasureText.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/text/Text.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/text/TextCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/text/TextCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/text/TextFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/text/TextRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/text/TextStyle.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/text/TextWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/tilesprite/TileSprite.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/tilesprite/TileSpriteCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/tilesprite/TileSpriteCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/tilesprite/TileSpriteFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/tilesprite/TileSpriteRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/tilesprite/TileSpriteWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/video/Video.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/video/VideoCanvasRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/video/VideoCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/video/VideoFactory.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/video/VideoRender.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/video/VideoWebGLRenderer.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/zone/ZoneCreator.js","webpack://@agogpixel/phaser3-project-starter/./node_modules/phaser/src/gameobjects/zone/ZoneFactory.js"],"sourcesContent":["/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../renderer/BlendModes');\r\nvar GetAdvancedValue = require('../utils/object/GetAdvancedValue');\r\n\r\n/**\r\n * Builds a Game Object using the provided configuration object.\r\n *\r\n * @function Phaser.GameObjects.BuildGameObject\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene.\r\n * @param {Phaser.GameObjects.GameObject} gameObject - The initial GameObject.\r\n * @param {Phaser.Types.GameObjects.GameObjectConfig} config - The config to build the GameObject with.\r\n *\r\n * @return {Phaser.GameObjects.GameObject} The built Game Object.\r\n */\r\nvar BuildGameObject = function (scene, gameObject, config)\r\n{\r\n    //  Position\r\n\r\n    gameObject.x = GetAdvancedValue(config, 'x', 0);\r\n    gameObject.y = GetAdvancedValue(config, 'y', 0);\r\n    gameObject.depth = GetAdvancedValue(config, 'depth', 0);\r\n\r\n    //  Flip\r\n\r\n    gameObject.flipX = GetAdvancedValue(config, 'flipX', false);\r\n    gameObject.flipY = GetAdvancedValue(config, 'flipY', false);\r\n\r\n    //  Scale\r\n    //  Either: { scale: 2 } or { scale: { x: 2, y: 2 }}\r\n\r\n    var scale = GetAdvancedValue(config, 'scale', null);\r\n\r\n    if (typeof scale === 'number')\r\n    {\r\n        gameObject.setScale(scale);\r\n    }\r\n    else if (scale !== null)\r\n    {\r\n        gameObject.scaleX = GetAdvancedValue(scale, 'x', 1);\r\n        gameObject.scaleY = GetAdvancedValue(scale, 'y', 1);\r\n    }\r\n\r\n    //  ScrollFactor\r\n    //  Either: { scrollFactor: 2 } or { scrollFactor: { x: 2, y: 2 }}\r\n\r\n    var scrollFactor = GetAdvancedValue(config, 'scrollFactor', null);\r\n\r\n    if (typeof scrollFactor === 'number')\r\n    {\r\n        gameObject.setScrollFactor(scrollFactor);\r\n    }\r\n    else if (scrollFactor !== null)\r\n    {\r\n        gameObject.scrollFactorX = GetAdvancedValue(scrollFactor, 'x', 1);\r\n        gameObject.scrollFactorY = GetAdvancedValue(scrollFactor, 'y', 1);\r\n    }\r\n\r\n    //  Rotation\r\n\r\n    gameObject.rotation = GetAdvancedValue(config, 'rotation', 0);\r\n\r\n    var angle = GetAdvancedValue(config, 'angle', null);\r\n\r\n    if (angle !== null)\r\n    {\r\n        gameObject.angle = angle;\r\n    }\r\n\r\n    //  Alpha\r\n\r\n    gameObject.alpha = GetAdvancedValue(config, 'alpha', 1);\r\n\r\n    //  Origin\r\n    //  Either: { origin: 0.5 } or { origin: { x: 0.5, y: 0.5 }}\r\n\r\n    var origin = GetAdvancedValue(config, 'origin', null);\r\n\r\n    if (typeof origin === 'number')\r\n    {\r\n        gameObject.setOrigin(origin);\r\n    }\r\n    else if (origin !== null)\r\n    {\r\n        var ox = GetAdvancedValue(origin, 'x', 0.5);\r\n        var oy = GetAdvancedValue(origin, 'y', 0.5);\r\n\r\n        gameObject.setOrigin(ox, oy);\r\n    }\r\n\r\n    //  BlendMode\r\n\r\n    gameObject.blendMode = GetAdvancedValue(config, 'blendMode', BlendModes.NORMAL);\r\n\r\n    //  Visible\r\n\r\n    gameObject.visible = GetAdvancedValue(config, 'visible', true);\r\n\r\n    //  Add to Scene\r\n\r\n    var add = GetAdvancedValue(config, 'add', true);\r\n\r\n    if (add)\r\n    {\r\n        scene.sys.displayList.add(gameObject);\r\n    }\r\n\r\n    if (gameObject.preUpdate)\r\n    {\r\n        scene.sys.updateList.add(gameObject);\r\n    }\r\n\r\n    return gameObject;\r\n};\r\n\r\nmodule.exports = BuildGameObject;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar GetAdvancedValue = require('../utils/object/GetAdvancedValue');\n\n/**\n * Adds an Animation component to a Sprite and populates it based on the given config.\n *\n * @function Phaser.GameObjects.BuildGameObjectAnimation\n * @since 3.0.0\n *\n * @param {Phaser.GameObjects.Sprite} sprite - The sprite to add an Animation component to.\n * @param {object} config - The animation config.\n *\n * @return {Phaser.GameObjects.Sprite} The updated Sprite.\n */\nvar BuildGameObjectAnimation = function (sprite, config)\n{\n    var animConfig = GetAdvancedValue(config, 'anims', null);\n\n    if (animConfig === null)\n    {\n        return sprite;\n    }\n\n    if (typeof animConfig === 'string')\n    {\n        //  { anims: 'key' }\n        sprite.anims.play(animConfig);\n    }\n    else if (typeof animConfig === 'object')\n    {\n        //  { anims: {\n        //              key: string\n        //              startFrame: [string|number]\n        //              delay: [float]\n        //              repeat: [integer]\n        //              repeatDelay: [float]\n        //              yoyo: [boolean]\n        //              play: [boolean]\n        //              delayedPlay: [boolean]\n        //           }\n        //  }\n\n        var anims = sprite.anims;\n\n        var key = GetAdvancedValue(animConfig, 'key', undefined);\n\n        if (key)\n        {\n            var startFrame = GetAdvancedValue(animConfig, 'startFrame', undefined);\n\n            var delay = GetAdvancedValue(animConfig, 'delay', 0);\n            var repeat = GetAdvancedValue(animConfig, 'repeat', 0);\n            var repeatDelay = GetAdvancedValue(animConfig, 'repeatDelay', 0);\n            var yoyo = GetAdvancedValue(animConfig, 'yoyo', false);\n\n            var play = GetAdvancedValue(animConfig, 'play', false);\n            var delayedPlay = GetAdvancedValue(animConfig, 'delayedPlay', 0);\n\n            var playConfig = {\n                key: key,\n                delay: delay,\n                repeat: repeat,\n                repeatDelay: repeatDelay,\n                yoyo: yoyo,\n                startFrame: startFrame\n            };\n\n            if (play)\n            {\n                anims.play(playConfig);\n            }\n            else if (delayedPlay > 0)\n            {\n                anims.playAfterDelay(playConfig, delayedPlay);\n            }\n            else\n            {\n                anims.load(playConfig);\n            }\n        }\n    }\n\n    return sprite;\n};\n\nmodule.exports = BuildGameObjectAnimation;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar List = require('../structs/List');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar GameObjectEvents = require('./events');\r\nvar SceneEvents = require('../scene/events');\r\nvar StableSort = require('../utils/array/StableSort');\r\n\r\n/**\r\n * @classdesc\r\n * The Display List plugin.\r\n *\r\n * Display Lists belong to a Scene and maintain the list of Game Objects to render every frame.\r\n *\r\n * Some of these Game Objects may also be part of the Scene's [Update List]{@link Phaser.GameObjects.UpdateList}, for updating.\r\n *\r\n * @class DisplayList\r\n * @extends Phaser.Structs.List.<Phaser.GameObjects.GameObject>\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this Display List belongs to.\r\n */\r\nvar DisplayList = new Class({\r\n\r\n    Extends: List,\r\n\r\n    initialize:\r\n\r\n    function DisplayList (scene)\r\n    {\r\n        List.call(this, scene);\r\n\r\n        /**\r\n         * The flag the determines whether Game Objects should be sorted when `depthSort()` is called.\r\n         *\r\n         * @name Phaser.GameObjects.DisplayList#sortChildrenFlag\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.sortChildrenFlag = false;\r\n\r\n        /**\r\n         * The Scene that this Display List belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.DisplayList#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The Scene's Systems.\r\n         *\r\n         * @name Phaser.GameObjects.DisplayList#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * The Scene's Event Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.DisplayList#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.50.0\r\n         */\r\n        this.events = scene.sys.events;\r\n\r\n        //  Set the List callbacks\r\n        this.addCallback = this.addChildCallback;\r\n        this.removeCallback = this.removeChildCallback;\r\n\r\n        this.events.once(SceneEvents.BOOT, this.boot, this);\r\n        this.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * Internal method called from `List.addCallback`.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#addChildCallback\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#ADDED_TO_SCENE\r\n     * @fires Phaser.GameObjects.Events#ADDED_TO_SCENE\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was added to the list.\r\n     */\r\n    addChildCallback: function (gameObject)\r\n    {\r\n        if (gameObject.displayList && gameObject.displayList !== this)\r\n        {\r\n            gameObject.removeFromDisplayList();\r\n        }\r\n\r\n        if (!gameObject.displayList)\r\n        {\r\n            this.queueDepthSort();\r\n\r\n            gameObject.displayList = this;\r\n\r\n            gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);\r\n\r\n            this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method called from `List.removeCallback`.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#removeChildCallback\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#REMOVED_FROM_SCENE\r\n     * @fires Phaser.GameObjects.Events#REMOVED_FROM_SCENE\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was removed from the list.\r\n     */\r\n    removeChildCallback: function (gameObject)\r\n    {\r\n        this.queueDepthSort();\r\n\r\n        gameObject.displayList = null;\r\n\r\n        gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);\r\n\r\n        this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        this.events.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * Force a sort of the display list on the next call to depthSort.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#queueDepthSort\r\n     * @since 3.0.0\r\n     */\r\n    queueDepthSort: function ()\r\n    {\r\n        this.sortChildrenFlag = true;\r\n    },\r\n\r\n    /**\r\n     * Immediately sorts the display list if the flag is set.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#depthSort\r\n     * @since 3.0.0\r\n     */\r\n    depthSort: function ()\r\n    {\r\n        if (this.sortChildrenFlag)\r\n        {\r\n            StableSort(this.list, this.sortByDepth);\r\n\r\n            this.sortChildrenFlag = false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Compare the depth of two Game Objects.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#sortByDepth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - The first Game Object.\r\n     * @param {Phaser.GameObjects.GameObject} childB - The second Game Object.\r\n     *\r\n     * @return {number} The difference between the depths of each Game Object.\r\n     */\r\n    sortByDepth: function (childA, childB)\r\n    {\r\n        return childA._depth - childB._depth;\r\n    },\r\n\r\n    /**\r\n     * Returns an array which contains all objects currently on the Display List.\r\n     * This is a reference to the main list array, not a copy of it, so be careful not to modify it.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#getChildren\r\n     * @since 3.12.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The group members.\r\n     */\r\n    getChildren: function ()\r\n    {\r\n        return this.list;\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     *\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#shutdown\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var list = this.list;\r\n\r\n        var i = list.length;\r\n\r\n        while (i--)\r\n        {\r\n            list[i].destroy(true);\r\n        }\r\n\r\n        list.length = 0;\r\n\r\n        this.events.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.GameObjects.DisplayList#destroy\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n        this.events = null;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('DisplayList', DisplayList, 'displayList');\r\n\r\nmodule.exports = DisplayList;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar ProcessQueue = require('../structs/ProcessQueue');\r\nvar PluginCache = require('../plugins/PluginCache');\r\nvar SceneEvents = require('../scene/events');\r\n\r\n/**\r\n * @classdesc\r\n * The Update List plugin.\r\n *\r\n * Update Lists belong to a Scene and maintain the list Game Objects to be updated every frame.\r\n *\r\n * Some or all of these Game Objects may also be part of the Scene's [Display List]{@link Phaser.GameObjects.DisplayList}, for Rendering.\r\n *\r\n * @class UpdateList\r\n * @extends Phaser.Structs.ProcessQueue.<Phaser.GameObjects.GameObject>\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that the Update List belongs to.\r\n */\r\nvar UpdateList = new Class({\r\n\r\n    Extends: ProcessQueue,\r\n\r\n    initialize:\r\n\r\n    function UpdateList (scene)\r\n    {\r\n        ProcessQueue.call(this);\r\n\r\n        //  No duplicates in this list\r\n        this.checkQueue = true;\r\n\r\n        /**\r\n         * The Scene that the Update List belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The Scene's Systems.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * The `pending` list is a selection of items which are due to be made 'active' in the next update.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_pending\r\n         * @type {Array.<*>}\r\n         * @private\r\n         * @default []\r\n         * @since 3.20.0\r\n         */\r\n\r\n        /**\r\n         * The `active` list is a selection of items which are considered active and should be updated.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_active\r\n         * @type {Array.<*>}\r\n         * @private\r\n         * @default []\r\n         * @since 3.20.0\r\n         */\r\n\r\n        /**\r\n         * The `destroy` list is a selection of items that were active and are awaiting being destroyed in the next update.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_destroy\r\n         * @type {Array.<*>}\r\n         * @private\r\n         * @default []\r\n         * @since 3.20.0\r\n         */\r\n\r\n        /**\r\n         * The total number of items awaiting processing.\r\n         *\r\n         * @name Phaser.GameObjects.UpdateList#_toProcess\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n\r\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        scene.sys.events.on(SceneEvents.START, this.start, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically, only once, when the Scene is first created.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#boot\r\n     * @private\r\n     * @since 3.5.1\r\n     */\r\n    boot: function ()\r\n    {\r\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * This method is called automatically by the Scene when it is starting up.\r\n     * It is responsible for creating local systems, properties and listening for Scene events.\r\n     * Do not invoke it directly.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#start\r\n     * @private\r\n     * @since 3.5.0\r\n     */\r\n    start: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.PRE_UPDATE, this.update, this);\r\n        eventEmitter.on(SceneEvents.UPDATE, this.sceneUpdate, this);\r\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The update step.\r\n     *\r\n     * Pre-updates every active Game Object in the list.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#sceneUpdate\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time elapsed since the last frame.\r\n     */\r\n    sceneUpdate: function (time, delta)\r\n    {\r\n        var list = this._active;\r\n        var length = list.length;\r\n\r\n        for (var i = 0; i < length; i++)\r\n        {\r\n            var gameObject = list[i];\r\n\r\n            if (gameObject.active)\r\n            {\r\n                gameObject.preUpdate.call(gameObject, time, delta);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is shutting down.\r\n     *\r\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        var i = this._active.length;\r\n\r\n        while (i--)\r\n        {\r\n            this._active[i].destroy(true);\r\n        }\r\n\r\n        i = this._pending.length;\r\n\r\n        while (i--)\r\n        {\r\n            this._pending[i].destroy(true);\r\n        }\r\n\r\n        i = this._destroy.length;\r\n\r\n        while (i--)\r\n        {\r\n            this._destroy[i].destroy(true);\r\n        }\r\n\r\n        this._toProcess = 0;\r\n\r\n        this._pending = [];\r\n        this._active = [];\r\n        this._destroy = [];\r\n\r\n        this.removeAllListeners();\r\n\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off(SceneEvents.PRE_UPDATE, this.update, this);\r\n        eventEmitter.off(SceneEvents.UPDATE, this.sceneUpdate, this);\r\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n    },\r\n\r\n    /**\r\n     * The Scene that owns this plugin is being destroyed.\r\n     *\r\n     * We need to shutdown and then kill off all external references.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.systems.events.off(SceneEvents.START, this.start, this);\r\n\r\n        this.scene = null;\r\n        this.systems = null;\r\n    }\r\n\r\n    /**\r\n     * Adds a new item to the Update List.\r\n     *\r\n     * The item is added to the pending list and made active in the next update.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} item - The item to add to the queue.\r\n     *\r\n     * @return {*} The item that was added.\r\n     */\r\n\r\n    /**\r\n     * Removes an item from the Update List.\r\n     *\r\n     * The item is added to the pending destroy and fully removed in the next update.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {*} item - The item to be removed from the queue.\r\n     *\r\n     * @return {*} The item that was removed.\r\n     */\r\n\r\n    /**\r\n     * Removes all active items from this Update List.\r\n     *\r\n     * All the items are marked as 'pending destroy' and fully removed in the next update.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#removeAll\r\n     * @since 3.20.0\r\n     *\r\n     * @return {this} This Update List object.\r\n     */\r\n\r\n    /**\r\n     * Update this queue. First it will process any items awaiting destruction, and remove them.\r\n     *\r\n     * Then it will check to see if there are any items pending insertion, and move them to an\r\n     * active state. Finally, it will return a list of active items for further processing.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#update\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Array.<*>} A list of active items.\r\n     */\r\n\r\n    /**\r\n     * Returns the current list of active items.\r\n     *\r\n     * This method returns a reference to the active list array, not a copy of it.\r\n     * Therefore, be careful to not modify this array outside of the ProcessQueue.\r\n     *\r\n     * @method Phaser.GameObjects.UpdateList#getActive\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Array.<*>} A list of active items.\r\n     */\r\n\r\n    /**\r\n     * The number of entries in the active list.\r\n     *\r\n     * @name Phaser.GameObjects.UpdateList#length\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.20.0\r\n     */\r\n});\r\n\r\nPluginCache.register('UpdateList', UpdateList, 'updateList');\r\n\r\nmodule.exports = UpdateList;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders one character of the Bitmap Text to the WebGL Pipeline.\r\n *\r\n * @function BatchChar\r\n * @since 3.50.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The WebGLPipeline. Must have a `batchQuad` method.\r\n * @param {Phaser.GameObjects.BitmapText} src - The BitmapText Game Object.\r\n * @param {Phaser.Types.GameObjects.BitmapText.BitmapTextCharacter} char - The character to render.\r\n * @param {Phaser.Types.GameObjects.BitmapText.BitmapFontCharacterData} glyph - The character glyph.\r\n * @param {number} offsetX - The x offset.\r\n * @param {number} offsetY - The y offset.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} calcMatrix - The transform matrix.\r\n * @param {boolean} roundPixels - Round the transform values or not?\r\n * @param {number} tintTL - Top-left tint value.\r\n * @param {number} tintTR - Top-right tint value.\r\n * @param {number} tintBL - Bottom-left tint value.\r\n * @param {number} tintBR - Bottom-right tint value.\r\n * @param {number} tintEffect - The tint effect mode.\r\n * @param {WebGLTexture} texture - The WebGL texture.\r\n * @param {number} textureUnit - The texture unit.\r\n */\r\nvar BatchChar = function (pipeline, src, char, glyph, offsetX, offsetY, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit)\r\n{\r\n    var x = (char.x - src.displayOriginX) + offsetX;\r\n    var y = (char.y - src.displayOriginY) + offsetY;\r\n\r\n    var xw = x + char.w;\r\n    var yh = y + char.h;\r\n\r\n    var tx0 = calcMatrix.getXRound(x, y, roundPixels);\r\n    var ty0 = calcMatrix.getYRound(x, y, roundPixels);\r\n\r\n    var tx1 = calcMatrix.getXRound(x, yh, roundPixels);\r\n    var ty1 = calcMatrix.getYRound(x, yh, roundPixels);\r\n\r\n    var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);\r\n    var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);\r\n\r\n    var tx3 = calcMatrix.getXRound(xw, y, roundPixels);\r\n    var ty3 = calcMatrix.getYRound(xw, y, roundPixels);\r\n\r\n    pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, glyph.u0, glyph.v0, glyph.u1, glyph.v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);\r\n};\r\n\r\nmodule.exports = BatchChar;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Calculate the full bounds, in local and world space, of a BitmapText Game Object.\n *\n * Returns a BitmapTextSize object that contains global and local variants of the Game Objects x and y coordinates and\n * its width and height. Also includes an array of the line lengths and all word positions.\n *\n * The global position and size take into account the Game Object's position and scale.\n *\n * The local position and size just takes into account the font data.\n *\n * @function GetBitmapTextSize\n * @since 3.0.0\n * @private\n *\n * @param {(Phaser.GameObjects.DynamicBitmapText|Phaser.GameObjects.BitmapText)} src - The BitmapText to calculate the bounds values for.\n * @param {boolean} [round=false] - Whether to round the positions to the nearest integer.\n * @param {boolean} [updateOrigin=false] - Whether to update the origin of the BitmapText after bounds calculations?\n * @param {object} [out] - Object to store the results in, to save constant object creation. If not provided an empty object is returned.\n *\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapTextSize} The calculated bounds values of the BitmapText.\n */\nvar GetBitmapTextSize = function (src, round, updateOrigin, out)\n{\n    if (updateOrigin === undefined) { updateOrigin = false; }\n\n    if (out === undefined)\n    {\n        out = {\n            local: {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n            },\n            global: {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0\n            },\n            lines: {\n                shortest: 0,\n                longest: 0,\n                lengths: null,\n                height: 0\n            },\n            wrappedText: '',\n            words: [],\n            characters: [],\n            scaleX: 0,\n            scaleY: 0\n        };\n\n        return out;\n    }\n\n    var text = src.text;\n    var textLength = text.length;\n    var maxWidth = src.maxWidth;\n    var wordWrapCharCode = src.wordWrapCharCode;\n\n    var bx = Number.MAX_VALUE;\n    var by = Number.MAX_VALUE;\n    var bw = 0;\n    var bh = 0;\n\n    var chars = src.fontData.chars;\n    var lineHeight = src.fontData.lineHeight;\n    var letterSpacing = src.letterSpacing;\n\n    var xAdvance = 0;\n    var yAdvance = 0;\n\n    var charCode = 0;\n\n    var glyph = null;\n\n    var align = src._align;\n\n    var x = 0;\n    var y = 0;\n\n    var scale = (src.fontSize / src.fontData.size);\n    var sx = scale * src.scaleX;\n    var sy = scale * src.scaleY;\n\n    var lastGlyph = null;\n    var lastCharCode = 0;\n    var lineWidths = [];\n    var shortestLine = Number.MAX_VALUE;\n    var longestLine = 0;\n    var currentLine = 0;\n    var currentLineWidth = 0;\n\n    var i;\n    var words = [];\n    var characters = [];\n    var current = null;\n\n    //  Scan for breach of maxWidth and insert carriage-returns\n    if (maxWidth > 0)\n    {\n        for (i = 0; i < textLength; i++)\n        {\n            charCode = text.charCodeAt(i);\n\n            if (charCode === 10)\n            {\n                if (current !== null)\n                {\n                    words.push({\n                        word: current.word,\n                        i: current.i,\n                        x: current.x * sx,\n                        y: current.y * sy,\n                        w: current.w * sx,\n                        h: current.h * sy,\n                        cr: true\n                    });\n\n                    current = null;\n                }\n\n                xAdvance = 0;\n                yAdvance += lineHeight;\n                lastGlyph = null;\n\n                continue;\n            }\n\n            glyph = chars[charCode];\n\n            if (!glyph)\n            {\n                continue;\n            }\n\n            if (lastGlyph !== null)\n            {\n                var glyphKerningOffset = glyph.kerning[lastCharCode];\n            }\n\n            if (charCode === wordWrapCharCode)\n            {\n                if (current !== null)\n                {\n                    words.push({\n                        word: current.word,\n                        i: current.i,\n                        x: current.x * sx,\n                        y: current.y * sy,\n                        w: current.w * sx,\n                        h: current.h * sy,\n                        cr: false\n                    });\n\n                    current = null;\n                }\n            }\n            else\n            {\n                if (current === null)\n                {\n                    //  We're starting a new word, recording the starting index, etc\n                    current = { word: '', i: i, x: xAdvance, y: yAdvance, w: 0, h: lineHeight, cr: false };\n                }\n\n                current.word = current.word.concat(text[i]);\n                current.w += glyph.xOffset + glyph.xAdvance + ((glyphKerningOffset !== undefined) ? glyphKerningOffset : 0);\n            }\n\n            xAdvance += glyph.xAdvance + letterSpacing;\n            lastGlyph = glyph;\n            lastCharCode = charCode;\n        }\n\n        //  Last word\n        if (current !== null)\n        {\n            words.push({\n                word: current.word,\n                i: current.i,\n                x: current.x * sx,\n                y: current.y * sy,\n                w: current.w * sx,\n                h: current.h * sy,\n                cr: false\n            });\n        }\n\n        //  Reset for the next loop\n        xAdvance = 0;\n        yAdvance = 0;\n        lastGlyph = null;\n        lastCharCode = 0;\n\n        //  Loop through the words array and see if we've got any > maxWidth\n        var prev;\n        var offset = 0;\n        var crs = [];\n\n        for (i = 0; i < words.length; i++)\n        {\n            var entry = words[i];\n            var left = entry.x;\n            var right = entry.x + entry.w;\n\n            if (prev)\n            {\n                var diff = left - (prev.x + prev.w);\n\n                offset = left - (diff + prev.w);\n\n                prev = null;\n            }\n\n            var checkLeft = left - offset;\n            var checkRight = right - offset;\n\n            if (checkLeft > maxWidth || checkRight > maxWidth)\n            {\n                crs.push(entry.i - 1);\n\n                if (entry.cr)\n                {\n                    crs.push(entry.i + entry.word.length);\n\n                    offset = 0;\n                    prev = null;\n                }\n                else\n                {\n                    prev = entry;\n                }\n            }\n            else if (entry.cr)\n            {\n                crs.push(entry.i + entry.word.length);\n\n                offset = 0;\n                prev = null;\n            }\n        }\n\n        var stringInsert = function (str, index, value)\n        {\n            return str.substr(0, index) + value + str.substr(index + 1);\n        };\n\n        for (i = crs.length - 1; i >= 0; i--)\n        {\n            // eslint-disable-next-line quotes\n            text = stringInsert(text, crs[i], \"\\n\");\n        }\n\n        out.wrappedText = text;\n\n        textLength = text.length;\n\n        //  Recalculated in the next loop\n        words = [];\n        current = null;\n    }\n\n    var charIndex = 0;\n\n    for (i = 0; i < textLength; i++)\n    {\n        charCode = text.charCodeAt(i);\n\n        if (charCode === 10)\n        {\n            if (current !== null)\n            {\n                words.push({\n                    word: current.word,\n                    i: current.i,\n                    x: current.x * sx,\n                    y: current.y * sy,\n                    w: current.w * sx,\n                    h: current.h * sy\n                });\n\n                current = null;\n            }\n\n            xAdvance = 0;\n            yAdvance += lineHeight;\n            lastGlyph = null;\n\n            lineWidths[currentLine] = currentLineWidth;\n\n            if (currentLineWidth > longestLine)\n            {\n                longestLine = currentLineWidth;\n            }\n\n            if (currentLineWidth < shortestLine)\n            {\n                shortestLine = currentLineWidth;\n            }\n\n            currentLine++;\n            currentLineWidth = 0;\n\n            continue;\n        }\n\n        glyph = chars[charCode];\n\n        if (!glyph)\n        {\n            continue;\n        }\n\n        x = xAdvance;\n        y = yAdvance;\n\n        if (lastGlyph !== null)\n        {\n            var kerningOffset = glyph.kerning[lastCharCode];\n\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\n        }\n\n        if (bx > x)\n        {\n            bx = x;\n        }\n\n        if (by > y)\n        {\n            by = y;\n        }\n\n        var gw = x + glyph.xAdvance;\n        var gh = y + lineHeight;\n\n        if (bw < gw)\n        {\n            bw = gw;\n        }\n\n        if (bh < gh)\n        {\n            bh = gh;\n        }\n\n        var charWidth = glyph.xOffset + glyph.xAdvance + ((kerningOffset !== undefined) ? kerningOffset : 0);\n\n        if (charCode === wordWrapCharCode)\n        {\n            if (current !== null)\n            {\n                words.push({\n                    word: current.word,\n                    i: current.i,\n                    x: current.x * sx,\n                    y: current.y * sy,\n                    w: current.w * sx,\n                    h: current.h * sy\n                });\n\n                current = null;\n            }\n        }\n        else\n        {\n            if (current === null)\n            {\n                //  We're starting a new word, recording the starting index, etc\n                current = { word: '', i: charIndex, x: xAdvance, y: yAdvance, w: 0, h: lineHeight };\n            }\n\n            current.word = current.word.concat(text[i]);\n            current.w += charWidth;\n        }\n\n        characters.push({\n            i: charIndex,\n            char: text[i],\n            code: charCode,\n            x: (glyph.xOffset + xAdvance) * scale,\n            y: (glyph.yOffset + yAdvance) * scale,\n            w: glyph.width * scale,\n            h: glyph.height * scale,\n            t: yAdvance * scale,\n            r: gw * scale,\n            b: lineHeight * scale,\n            line: currentLine,\n            glyph: glyph\n        });\n\n        xAdvance += glyph.xAdvance + letterSpacing;\n        lastGlyph = glyph;\n        lastCharCode = charCode;\n        currentLineWidth = gw * scale;\n        charIndex++;\n    }\n\n    //  Last word\n    if (current !== null)\n    {\n        words.push({\n            word: current.word,\n            i: current.i,\n            x: current.x * sx,\n            y: current.y * sy,\n            w: current.w * sx,\n            h: current.h * sy\n        });\n    }\n\n    lineWidths[currentLine] = currentLineWidth;\n\n    if (currentLineWidth > longestLine)\n    {\n        longestLine = currentLineWidth;\n    }\n\n    if (currentLineWidth < shortestLine)\n    {\n        shortestLine = currentLineWidth;\n    }\n\n    //  Adjust all of the character positions based on alignment\n    if (align > 0)\n    {\n        for (var c = 0; c < characters.length; c++)\n        {\n            var currentChar = characters[c];\n\n            if (align === 1)\n            {\n                var ax1 = ((longestLine - lineWidths[currentChar.line]) / 2);\n\n                currentChar.x += ax1;\n                currentChar.r += ax1;\n            }\n            else if (align === 2)\n            {\n                var ax2 = (longestLine - lineWidths[currentChar.line]);\n\n                currentChar.x += ax2;\n                currentChar.r += ax2;\n            }\n        }\n    }\n\n    var local = out.local;\n    var global = out.global;\n    var lines = out.lines;\n\n    local.x = bx * scale;\n    local.y = by * scale;\n    local.width = bw * scale;\n    local.height = bh * scale;\n\n    global.x = (src.x - src._displayOriginX) + (bx * sx);\n    global.y = (src.y - src._displayOriginY) + (by * sy);\n\n    global.width = bw * sx;\n    global.height = bh * sy;\n\n    lines.shortest = shortestLine;\n    lines.longest = longestLine;\n    lines.lengths = lineWidths;\n\n    if (round)\n    {\n        local.x = Math.ceil(local.x);\n        local.y = Math.ceil(local.y);\n        local.width = Math.ceil(local.width);\n        local.height = Math.ceil(local.height);\n\n        global.x = Math.ceil(global.x);\n        global.y = Math.ceil(global.y);\n        global.width = Math.ceil(global.width);\n        global.height = Math.ceil(global.height);\n\n        lines.shortest = Math.ceil(shortestLine);\n        lines.longest = Math.ceil(longestLine);\n    }\n\n    if (updateOrigin)\n    {\n        src._displayOriginX = (src.originX * local.width);\n        src._displayOriginY = (src.originY * local.height);\n\n        global.x = src.x - (src._displayOriginX * src.scaleX);\n        global.y = src.y - (src._displayOriginY * src.scaleY);\n\n        if (round)\n        {\n            global.x = Math.ceil(global.x);\n            global.y = Math.ceil(global.y);\n        }\n    }\n\n    out.words = words;\n    out.characters = characters;\n    out.lines.height = lineHeight;\n    out.scale = scale;\n    out.scaleX = src.scaleX;\n    out.scaleY = src.scaleY;\n\n    return out;\n};\n\nmodule.exports = GetBitmapTextSize;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ParseXMLBitmapFont = require('./ParseXMLBitmapFont');\r\n\r\n/**\r\n * Parse an XML Bitmap Font from an Atlas.\r\n *\r\n * Adds the parsed Bitmap Font data to the cache with the `fontName` key.\r\n *\r\n * @function ParseFromAtlas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to parse the Bitmap Font for.\r\n * @param {string} fontName - The key of the font to add to the Bitmap Font cache.\r\n * @param {string} textureKey - The key of the BitmapFont's texture.\r\n * @param {string} frameKey - The key of the BitmapFont texture's frame.\r\n * @param {string} xmlKey - The key of the XML data of the font to parse.\r\n * @param {number} [xSpacing] - The x-axis spacing to add between each letter.\r\n * @param {number} [ySpacing] - The y-axis spacing to add to the line height.\r\n *\r\n * @return {boolean} Whether the parsing was successful or not.\r\n */\r\nvar ParseFromAtlas = function (scene, fontName, textureKey, frameKey, xmlKey, xSpacing, ySpacing)\r\n{\r\n    var texture = scene.sys.textures.get(textureKey);\r\n    var frame = texture.get(frameKey);\r\n    var xml = scene.sys.cache.xml.get(xmlKey);\r\n\r\n    if (frame && xml)\r\n    {\r\n        var data = ParseXMLBitmapFont(xml, frame, xSpacing, ySpacing, texture);\r\n\r\n        scene.sys.cache.bitmapFont.add(fontName, { data: data, texture: textureKey, frame: frameKey, fromAtlas: true });\r\n\r\n        return true;\r\n    }\r\n    else\r\n    {\r\n        return false;\r\n    }\r\n};\r\n\r\nmodule.exports = ParseFromAtlas;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetValue = require('../../utils/object/GetValue');\r\n\r\n/**\r\n * Parses a Retro Font configuration object so you can pass it to the BitmapText constructor\r\n * and create a BitmapText object using a fixed-width retro font.\r\n *\r\n * @function Phaser.GameObjects.RetroFont.Parse\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Phaser Scene.\r\n * @param {Phaser.Types.GameObjects.BitmapText.RetroFontConfig} config - The font configuration object.\r\n *\r\n * @return {object} A parsed Bitmap Font data entry for the Bitmap Font cache.\r\n */\r\nvar ParseRetroFont = function (scene, config)\r\n{\r\n    var w = config.width;\r\n    var h = config.height;\r\n\r\n    var cx = Math.floor(w / 2);\r\n    var cy = Math.floor(h / 2);\r\n\r\n    var letters = GetValue(config, 'chars', '');\r\n\r\n    if (letters === '')\r\n    {\r\n        return;\r\n    }\r\n\r\n    var key = GetValue(config, 'image', '');\r\n\r\n    var frame = scene.sys.textures.getFrame(key);\r\n    var textureX = frame.cutX;\r\n    var textureY = frame.cutY;\r\n    var textureWidth = frame.source.width;\r\n    var textureHeight = frame.source.height;\r\n\r\n    var offsetX = GetValue(config, 'offset.x', 0);\r\n    var offsetY = GetValue(config, 'offset.y', 0);\r\n    var spacingX = GetValue(config, 'spacing.x', 0);\r\n    var spacingY = GetValue(config, 'spacing.y', 0);\r\n    var lineSpacing = GetValue(config, 'lineSpacing', 0);\r\n\r\n    var charsPerRow = GetValue(config, 'charsPerRow', null);\r\n\r\n    if (charsPerRow === null)\r\n    {\r\n        charsPerRow = textureWidth / w;\r\n\r\n        if (charsPerRow > letters.length)\r\n        {\r\n            charsPerRow = letters.length;\r\n        }\r\n    }\r\n\r\n    var x = offsetX;\r\n    var y = offsetY;\r\n\r\n    var data = {\r\n        retroFont: true,\r\n        font: key,\r\n        size: w,\r\n        lineHeight: h + lineSpacing,\r\n        chars: {}\r\n    };\r\n\r\n    var r = 0;\r\n\r\n    for (var i = 0; i < letters.length; i++)\r\n    {\r\n        var charCode = letters.charCodeAt(i);\r\n\r\n        var u0 = (textureX + x) / textureWidth;\r\n        var v0 = (textureY + y) / textureHeight;\r\n        var u1 = (textureX + x + w) / textureWidth;\r\n        var v1 = (textureY + y + h) / textureHeight;\r\n\r\n        data.chars[charCode] =\r\n        {\r\n            x: x,\r\n            y: y,\r\n            width: w,\r\n            height: h,\r\n            centerX: cx,\r\n            centerY: cy,\r\n            xOffset: 0,\r\n            yOffset: 0,\r\n            xAdvance: w,\r\n            data: {},\r\n            kerning: {},\r\n            u0: u0,\r\n            v0: v0,\r\n            u1: u1,\r\n            v1: v1\r\n        };\r\n\r\n        r++;\r\n\r\n        if (r === charsPerRow)\r\n        {\r\n            r = 0;\r\n            x = offsetX;\r\n            y += h + spacingY;\r\n        }\r\n        else\r\n        {\r\n            x += w + spacingX;\r\n        }\r\n    }\r\n\r\n    var entry = {\r\n        data: data,\r\n        frame: null,\r\n        texture: key\r\n    };\r\n\r\n    return entry;\r\n};\r\n\r\nmodule.exports = ParseRetroFont;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Read an integer value from an XML Node.\n *\n * @function getValue\n * @since 3.0.0\n * @private\n *\n * @param {Node} node - The XML Node.\n * @param {string} attribute - The attribute to read.\n *\n * @return {number} The parsed value.\n */\nfunction getValue (node, attribute)\n{\n    return parseInt(node.getAttribute(attribute), 10);\n}\n\n/**\n * Parse an XML font to Bitmap Font data for the Bitmap Font cache.\n *\n * @function ParseXMLBitmapFont\n * @since 3.0.0\n * @private\n *\n * @param {XMLDocument} xml - The XML Document to parse the font from.\n * @param {Phaser.Textures.Frame} frame - The texture frame to take into account when creating the uv data.\n * @param {number} [xSpacing=0] - The x-axis spacing to add between each letter.\n * @param {number} [ySpacing=0] - The y-axis spacing to add to the line height.\n * @param {Phaser.Textures.Texture} [texture] - If provided, each glyph in the Bitmap Font will be added to this texture as a frame.\n *\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapFontData} The parsed Bitmap Font data.\n */\nvar ParseXMLBitmapFont = function (xml, frame, xSpacing, ySpacing, texture)\n{\n    if (xSpacing === undefined) { xSpacing = 0; }\n    if (ySpacing === undefined) { ySpacing = 0; }\n\n    var textureX = frame.cutX;\n    var textureY = frame.cutY;\n    var textureWidth = frame.source.width;\n    var textureHeight = frame.source.height;\n    var sourceIndex = frame.sourceIndex;\n\n    var data = {};\n    var info = xml.getElementsByTagName('info')[0];\n    var common = xml.getElementsByTagName('common')[0];\n\n    data.font = info.getAttribute('face');\n    data.size = getValue(info, 'size');\n    data.lineHeight = getValue(common, 'lineHeight') + ySpacing;\n    data.chars = {};\n\n    var letters = xml.getElementsByTagName('char');\n\n    var adjustForTrim = (frame !== undefined && frame.trimmed);\n\n    if (adjustForTrim)\n    {\n        var top = frame.height;\n        var left = frame.width;\n    }\n\n    for (var i = 0; i < letters.length; i++)\n    {\n        var node = letters[i];\n\n        var charCode = getValue(node, 'id');\n        var letter = String.fromCharCode(charCode);\n        var gx = getValue(node, 'x');\n        var gy = getValue(node, 'y');\n        var gw = getValue(node, 'width');\n        var gh = getValue(node, 'height');\n\n        //  Handle frame trim issues\n\n        if (adjustForTrim)\n        {\n            if (gx < left)\n            {\n                left = gx;\n            }\n\n            if (gy < top)\n            {\n                top = gy;\n            }\n        }\n\n        if (adjustForTrim && top !== 0 && left !== 0)\n        {\n            //  Now we know the top and left coordinates of the glyphs in the original data\n            //  so we can work out how much to adjust the glyphs by\n\n            gx -= frame.x;\n            gy -= frame.y;\n        }\n\n        var u0 = (textureX + gx) / textureWidth;\n        var v0 = (textureY + gy) / textureHeight;\n        var u1 = (textureX + gx + gw) / textureWidth;\n        var v1 = (textureY + gy + gh) / textureHeight;\n\n        data.chars[charCode] =\n        {\n            x: gx,\n            y: gy,\n            width: gw,\n            height: gh,\n            centerX: Math.floor(gw / 2),\n            centerY: Math.floor(gh / 2),\n            xOffset: getValue(node, 'xoffset'),\n            yOffset: getValue(node, 'yoffset'),\n            xAdvance: getValue(node, 'xadvance') + xSpacing,\n            data: {},\n            kerning: {},\n            u0: u0,\n            v0: v0,\n            u1: u1,\n            v1: v1\n        };\n\n        if (texture && gw !== 0 && gh !== 0)\n        {\n            var charFrame = texture.add(letter, sourceIndex, gx, gy, gw, gh);\n\n            if (charFrame)\n            {\n                charFrame.setUVs(gw, gh, u0, v0, u1, v1);\n            }\n        }\n    }\n\n    var kernings = xml.getElementsByTagName('kerning');\n\n    for (i = 0; i < kernings.length; i++)\n    {\n        var kern = kernings[i];\n\n        var first = getValue(kern, 'first');\n        var second = getValue(kern, 'second');\n        var amount = getValue(kern, 'amount');\n\n        data.chars[second].kerning[first] = amount;\n    }\n\n    return data;\n};\n\nmodule.exports = ParseXMLBitmapFont;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RETRO_FONT_CONST = require('./const');\r\nvar Extend = require('../../utils/object/Extend');\r\n\r\n/**\r\n * @namespace Phaser.GameObjects.RetroFont\r\n * @since 3.6.0\r\n */\r\n\r\nvar RetroFont = { Parse: require('./ParseRetroFont') };\r\n\r\n//   Merge in the consts\r\nRetroFont = Extend(false, RetroFont, RETRO_FONT_CONST);\r\n\r\nmodule.exports = RetroFont;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar RETRO_FONT_CONST = {\r\n\r\n    /**\r\n     * Text Set 1 =  !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET1\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET1: ' !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~',\r\n\r\n    /**\r\n     * Text Set 2 =  !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET2\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET2: ' !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ',\r\n\r\n    /**\r\n     * Text Set 3 = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET3\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET3: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ',\r\n\r\n    /**\r\n     * Text Set 4 = ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET4\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET4: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789',\r\n\r\n    /**\r\n     * Text Set 5 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET5\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET5: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() \\'!?-*:0123456789',\r\n\r\n    /**\r\n     * Text Set 6 = ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' \r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET6\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET6: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.\\' ',\r\n\r\n    /**\r\n     * Text Set 7 = AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET7\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET7: 'AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-\\'39',\r\n\r\n    /**\r\n     * Text Set 8 = 0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET8\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET8: '0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ',\r\n\r\n    /**\r\n     * Text Set 9 = ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET9\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET9: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,\\'\"?!',\r\n\r\n    /**\r\n     * Text Set 10 = ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET10\r\n     * @type {string}\r\n     * @since 3.6.0\r\n     */\r\n    TEXT_SET10: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\r\n\r\n    /**\r\n     * Text Set 11 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789\r\n     * \r\n     * @name Phaser.GameObjects.RetroFont.TEXT_SET11\r\n     * @since 3.6.0\r\n     * @type {string}\r\n     */\r\n    TEXT_SET11: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()\\':;0123456789'\r\n\r\n};\r\n\r\nmodule.exports = RETRO_FONT_CONST;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar BitmapText = require('../static/BitmapText');\nvar Class = require('../../../utils/Class');\nvar Render = require('./DynamicBitmapTextRender');\n\n/**\n * @classdesc\n * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\n *\n * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\n * match the font structure.\n *\n * Dynamic Bitmap Text objects are different from Static Bitmap Text in that they invoke a callback for each\n * letter being rendered during the render pass. This callback allows you to manipulate the properties of\n * each letter being rendered, such as its position, scale or tint, allowing you to create interesting effects\n * like jiggling text, which can't be done with Static text. This means that Dynamic Text takes more processing\n * time, so only use them if you require the callback ability they have.\n *\n * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\n * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\n * processing the font texture in an image editor, applying fills and any other effects required.\n *\n * To create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\n *\n * To create a BitmapText data files you need a 3rd party app such as:\n *\n * BMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}\n * Glyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}\n * Littera (Web-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}\n *\n * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\n * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}\n *\n * @class DynamicBitmapText\n * @extends Phaser.GameObjects.BitmapText\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.\n * @param {number} x - The x coordinate of this Game Object in world space.\n * @param {number} y - The y coordinate of this Game Object in world space.\n * @param {string} font - The key of the font to use from the Bitmap Font cache.\n * @param {(string|string[])} [text] - The string, or array of strings, to be set as the content of this Bitmap Text.\n * @param {number} [size] - The font size of this Bitmap Text.\n * @param {number} [align=0] - The alignment of the text in a multi-line BitmapText object.\n */\nvar DynamicBitmapText = new Class({\n\n    Extends: BitmapText,\n\n    Mixins: [\n        Render\n    ],\n\n    initialize:\n\n    function DynamicBitmapText (scene, x, y, font, text, size, align)\n    {\n        BitmapText.call(this, scene, x, y, font, text, size, align);\n\n        this.type = 'DynamicBitmapText';\n\n        /**\n         * The horizontal scroll position of the Bitmap Text.\n         *\n         * @name Phaser.GameObjects.DynamicBitmapText#scrollX\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.scrollX = 0;\n\n        /**\n         * The vertical scroll position of the Bitmap Text.\n         *\n         * @name Phaser.GameObjects.DynamicBitmapText#scrollY\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.scrollY = 0;\n\n        /**\n         * The crop width of the Bitmap Text.\n         *\n         * @name Phaser.GameObjects.DynamicBitmapText#cropWidth\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.cropWidth = 0;\n\n        /**\n         * The crop height of the Bitmap Text.\n         *\n         * @name Phaser.GameObjects.DynamicBitmapText#cropHeight\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.cropHeight = 0;\n\n        /**\n         * A callback that alters how each character of the Bitmap Text is rendered.\n         *\n         * @name Phaser.GameObjects.DynamicBitmapText#displayCallback\n         * @type {Phaser.Types.GameObjects.BitmapText.DisplayCallback}\n         * @since 3.0.0\n         */\n        this.displayCallback;\n\n        /**\n         * The data object that is populated during rendering, then passed to the displayCallback.\n         * You should modify this object then return it back from the callback. It's updated values\n         * will be used to render the specific glyph.\n         *\n         * Please note that if you need a reference to this object locally in your game code then you\n         * should shallow copy it, as it's updated and re-used for every glyph in the text.\n         *\n         * @name Phaser.GameObjects.DynamicBitmapText#callbackData\n         * @type {Phaser.Types.GameObjects.BitmapText.DisplayCallbackConfig}\n         * @since 3.11.0\n         */\n        this.callbackData = {\n            parent: this,\n            color: 0,\n            tint: {\n                topLeft: 0,\n                topRight: 0,\n                bottomLeft: 0,\n                bottomRight: 0\n            },\n            index: 0,\n            charCode: 0,\n            x: 0,\n            y: 0,\n            scale: 0,\n            rotation: 0,\n            data: 0\n        };\n    },\n\n    /**\n     * Set the crop size of this Bitmap Text.\n     *\n     * @method Phaser.GameObjects.DynamicBitmapText#setSize\n     * @since 3.0.0\n     *\n     * @param {number} width - The width of the crop.\n     * @param {number} height - The height of the crop.\n     *\n     * @return {this} This Game Object.\n     */\n    setSize: function (width, height)\n    {\n        this.cropWidth = width;\n        this.cropHeight = height;\n\n        return this;\n    },\n\n    /**\n     * Set a callback that alters how each character of the Bitmap Text is rendered.\n     *\n     * The callback receives a {@link Phaser.Types.GameObjects.BitmapText.DisplayCallbackConfig} object that contains information about the character that's\n     * about to be rendered.\n     *\n     * It should return an object with `x`, `y`, `scale` and `rotation` properties that will be used instead of the\n     * usual values when rendering.\n     *\n     * @method Phaser.GameObjects.DynamicBitmapText#setDisplayCallback\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.GameObjects.BitmapText.DisplayCallback} callback - The display callback to set.\n     *\n     * @return {this} This Game Object.\n     */\n    setDisplayCallback: function (callback)\n    {\n        this.displayCallback = callback;\n\n        return this;\n    },\n\n    /**\n     * Set the horizontal scroll position of this Bitmap Text.\n     *\n     * @method Phaser.GameObjects.DynamicBitmapText#setScrollX\n     * @since 3.0.0\n     *\n     * @param {number} value - The horizontal scroll position to set.\n     *\n     * @return {this} This Game Object.\n     */\n    setScrollX: function (value)\n    {\n        this.scrollX = value;\n\n        return this;\n    },\n\n    /**\n     * Set the vertical scroll position of this Bitmap Text.\n     *\n     * @method Phaser.GameObjects.DynamicBitmapText#setScrollY\n     * @since 3.0.0\n     *\n     * @param {number} value - The vertical scroll position to set.\n     *\n     * @return {this} This Game Object.\n     */\n    setScrollY: function (value)\n    {\n        this.scrollY = value;\n\n        return this;\n    }\n\n});\n\nmodule.exports = DynamicBitmapText;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.DynamicBitmapText#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.DynamicBitmapText} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar DynamicBitmapTextCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var text = src._text;\r\n    var textLength = text.length;\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var textureFrame = src.fromAtlas\r\n        ? src.frame\r\n        : src.texture.frames['__BASE'];\r\n\r\n    var displayCallback = src.displayCallback;\r\n    var callbackData = src.callbackData;\r\n\r\n    var chars = src.fontData.chars;\r\n    var lineHeight = src.fontData.lineHeight;\r\n    var letterSpacing = src._letterSpacing;\r\n\r\n    var xAdvance = 0;\r\n    var yAdvance = 0;\r\n\r\n    var charCode = 0;\r\n\r\n    var glyph = null;\r\n    var glyphX = 0;\r\n    var glyphY = 0;\r\n    var glyphW = 0;\r\n    var glyphH = 0;\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n\r\n    var lastGlyph = null;\r\n    var lastCharCode = 0;\r\n\r\n    var image = src.frame.source.image;\r\n\r\n    var textureX = textureFrame.cutX;\r\n    var textureY = textureFrame.cutY;\r\n\r\n    var rotation = 0;\r\n    var scale = 0;\r\n    var baseScale = (src._fontSize / src.fontData.size);\r\n\r\n    var align = src._align;\r\n    var currentLine = 0;\r\n    var lineOffsetX = 0;\r\n\r\n    //  Update the bounds - skipped internally if not dirty\r\n    src.getTextBounds(false);\r\n\r\n    var lineData = src._bounds.lines;\r\n\r\n    if (align === 1)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\r\n    }\r\n    else if (align === 2)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]);\r\n    }\r\n\r\n    ctx.translate(-src.displayOriginX, -src.displayOriginY);\r\n\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    if (src.cropWidth > 0 && src.cropHeight > 0)\r\n    {\r\n        ctx.beginPath();\r\n        ctx.rect(0, 0, src.cropWidth, src.cropHeight);\r\n        ctx.clip();\r\n    }\r\n\r\n    for (var i = 0; i < textLength; i++)\r\n    {\r\n        //  Reset the scale (in case the callback changed it)\r\n        scale = baseScale;\r\n        rotation = 0;\r\n\r\n        charCode = text.charCodeAt(i);\r\n\r\n        if (charCode === 10)\r\n        {\r\n            currentLine++;\r\n\r\n            if (align === 1)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\r\n            }\r\n            else if (align === 2)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]);\r\n            }\r\n\r\n            xAdvance = 0;\r\n            yAdvance += lineHeight;\r\n            lastGlyph = null;\r\n\r\n            continue;\r\n        }\r\n\r\n        glyph = chars[charCode];\r\n\r\n        if (!glyph)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        glyphX = textureX + glyph.x;\r\n        glyphY = textureY + glyph.y;\r\n\r\n        glyphW = glyph.width;\r\n        glyphH = glyph.height;\r\n\r\n        x = (glyph.xOffset + xAdvance) - src.scrollX;\r\n        y = (glyph.yOffset + yAdvance) - src.scrollY;\r\n\r\n        if (lastGlyph !== null)\r\n        {\r\n            var kerningOffset = glyph.kerning[lastCharCode];\r\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\r\n        }\r\n\r\n        if (displayCallback)\r\n        {\r\n            callbackData.index = i;\r\n            callbackData.charCode = charCode;\r\n            callbackData.x = x;\r\n            callbackData.y = y;\r\n            callbackData.scale = scale;\r\n            callbackData.rotation = rotation;\r\n            callbackData.data = glyph.data;\r\n\r\n            var output = displayCallback(callbackData);\r\n\r\n            x = output.x;\r\n            y = output.y;\r\n            scale = output.scale;\r\n            rotation = output.rotation;\r\n        }\r\n\r\n        x *= scale;\r\n        y *= scale;\r\n\r\n        x += lineOffsetX;\r\n\r\n        xAdvance += glyph.xAdvance + letterSpacing;\r\n        lastGlyph = glyph;\r\n        lastCharCode = charCode;\r\n\r\n        //  Nothing to render or a space? Then skip to the next glyph\r\n        if (glyphW === 0 || glyphH === 0 || charCode === 32)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (roundPixels)\r\n        {\r\n            x = Math.round(x);\r\n            y = Math.round(y);\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        ctx.translate(x, y);\r\n\r\n        ctx.rotate(rotation);\r\n\r\n        ctx.scale(scale, scale);\r\n\r\n        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = DynamicBitmapTextCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BitmapText = require('./DynamicBitmapText');\r\nvar BuildGameObject = require('../../BuildGameObject');\r\nvar GameObjectCreator = require('../../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../../utils/object/GetAdvancedValue');\r\n\r\n/**\r\n * Creates a new Dynamic Bitmap Text Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#dynamicBitmapText\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.BitmapText.BitmapTextConfig} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.DynamicBitmapText} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('dynamicBitmapText', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var font = GetAdvancedValue(config, 'font', '');\r\n    var text = GetAdvancedValue(config, 'text', '');\r\n    var size = GetAdvancedValue(config, 'size', false);\r\n\r\n    var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, bitmapText, config);\r\n\r\n    return bitmapText;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar DynamicBitmapText = require('./DynamicBitmapText');\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Dynamic Bitmap Text Game Object and adds it to the Scene.\r\n * \r\n * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\r\n * \r\n * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\r\n * match the font structure.\r\n * \r\n * Dynamic Bitmap Text objects are different from Static Bitmap Text in that they invoke a callback for each\r\n * letter being rendered during the render pass. This callback allows you to manipulate the properties of\r\n * each letter being rendered, such as its position, scale or tint, allowing you to create interesting effects\r\n * like jiggling text, which can't be done with Static text. This means that Dynamic Text takes more processing\r\n * time, so only use them if you require the callback ability they have.\r\n *\r\n * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\r\n * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\r\n * processing the font texture in an image editor, applying fills and any other effects required.\r\n *\r\n * To create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\r\n *\r\n * To create a BitmapText data files you need a 3rd party app such as:\r\n *\r\n * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/\r\n * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner\r\n * Littera (Web-based, free): http://kvazars.com/littera/\r\n *\r\n * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\r\n * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson\r\n *\r\n * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#dynamicBitmapText\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x position of the Game Object.\r\n * @param {number} y - The y position of the Game Object.\r\n * @param {string} font - The key of the font to use from the BitmapFont cache.\r\n * @param {(string|string[])} [text] - The string, or array of strings, to be set as the content of this Bitmap Text.\r\n * @param {number} [size] - The font size to set.\r\n *\r\n * @return {Phaser.GameObjects.DynamicBitmapText} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('dynamicBitmapText', function (x, y, font, text, size)\r\n{\r\n    return this.displayList.add(new DynamicBitmapText(this.scene, x, y, font, text, size));\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./DynamicBitmapTextWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./DynamicBitmapTextCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar TransformMatrix = require('../../components/TransformMatrix');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\nvar tempMatrix = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.DynamicBitmapText#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.DynamicBitmapText} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar DynamicBitmapTextWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var text = src.text;\r\n    var textLength = text.length;\r\n\r\n    if (textLength === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var spriteMatrix = result.sprite;\r\n    var calcMatrix = result.calc;\r\n\r\n    var fontMatrix = tempMatrix;\r\n\r\n    var crop = (src.cropWidth > 0 || src.cropHeight > 0);\r\n\r\n    if (crop)\r\n    {\r\n        pipeline.flush();\r\n\r\n        renderer.pushScissor(\r\n            calcMatrix.tx,\r\n            calcMatrix.ty,\r\n            src.cropWidth * calcMatrix.scaleX,\r\n            src.cropHeight * calcMatrix.scaleY\r\n        );\r\n    }\r\n\r\n    var frame = src.frame;\r\n    var texture = frame.glTexture;\r\n\r\n    var tintEffect = src.tintFill;\r\n    var tintTL = Utils.getTintAppendFloatAlpha(src.tintTopLeft, camera.alpha * src._alphaTL);\r\n    var tintTR = Utils.getTintAppendFloatAlpha(src.tintTopRight, camera.alpha * src._alphaTR);\r\n    var tintBL = Utils.getTintAppendFloatAlpha(src.tintBottomLeft, camera.alpha * src._alphaBL);\r\n    var tintBR = Utils.getTintAppendFloatAlpha(src.tintBottomRight, camera.alpha * src._alphaBR);\r\n\r\n    var textureUnit = pipeline.setGameObject(src);\r\n\r\n    var xAdvance = 0;\r\n    var yAdvance = 0;\r\n    var charCode = 0;\r\n    var lastCharCode = 0;\r\n    var letterSpacing = src.letterSpacing;\r\n    var glyph;\r\n    var glyphW = 0;\r\n    var glyphH = 0;\r\n    var lastGlyph;\r\n    var scrollX = src.scrollX;\r\n    var scrollY = src.scrollY;\r\n\r\n    var fontData = src.fontData;\r\n    var chars = fontData.chars;\r\n    var lineHeight = fontData.lineHeight;\r\n    var scale = (src.fontSize / fontData.size);\r\n    var rotation = 0;\r\n\r\n    var align = src._align;\r\n    var currentLine = 0;\r\n    var lineOffsetX = 0;\r\n\r\n    //  Update the bounds - skipped internally if not dirty\r\n    var bounds = src.getTextBounds(false);\r\n\r\n    //  In case the method above changed it (word wrapping)\r\n    if (src.maxWidth > 0)\r\n    {\r\n        text = bounds.wrappedText;\r\n        textLength = text.length;\r\n    }\r\n\r\n    var lineData = src._bounds.lines;\r\n\r\n    if (align === 1)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\r\n    }\r\n    else if (align === 2)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]);\r\n    }\r\n\r\n    var roundPixels = camera.roundPixels;\r\n    var displayCallback = src.displayCallback;\r\n    var callbackData = src.callbackData;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    for (var i = 0; i < textLength; i++)\r\n    {\r\n        charCode = text.charCodeAt(i);\r\n\r\n        //  Carriage-return\r\n        if (charCode === 10)\r\n        {\r\n            currentLine++;\r\n\r\n            if (align === 1)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\r\n            }\r\n            else if (align === 2)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]);\r\n            }\r\n\r\n            xAdvance = 0;\r\n            yAdvance += lineHeight;\r\n            lastGlyph = null;\r\n\r\n            continue;\r\n        }\r\n\r\n        glyph = chars[charCode];\r\n\r\n        if (!glyph)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        glyphW = glyph.width;\r\n        glyphH = glyph.height;\r\n\r\n        var x = (glyph.xOffset + xAdvance) - scrollX;\r\n        var y = (glyph.yOffset + yAdvance) - scrollY;\r\n\r\n        if (lastGlyph !== null)\r\n        {\r\n            var kerningOffset = glyph.kerning[lastCharCode];\r\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\r\n        }\r\n\r\n        xAdvance += glyph.xAdvance + letterSpacing;\r\n        lastGlyph = glyph;\r\n        lastCharCode = charCode;\r\n\r\n        //  Nothing to render or a space? Then skip to the next glyph\r\n        if (glyphW === 0 || glyphH === 0 || charCode === 32)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        scale = (src.fontSize / src.fontData.size);\r\n        rotation = 0;\r\n\r\n        if (displayCallback)\r\n        {\r\n            callbackData.color = 0;\r\n            callbackData.tint.topLeft = tintTL;\r\n            callbackData.tint.topRight = tintTR;\r\n            callbackData.tint.bottomLeft = tintBL;\r\n            callbackData.tint.bottomRight = tintBR;\r\n            callbackData.index = i;\r\n            callbackData.charCode = charCode;\r\n            callbackData.x = x;\r\n            callbackData.y = y;\r\n            callbackData.scale = scale;\r\n            callbackData.rotation = rotation;\r\n            callbackData.data = glyph.data;\r\n\r\n            var output = displayCallback(callbackData);\r\n\r\n            x = output.x;\r\n            y = output.y;\r\n            scale = output.scale;\r\n            rotation = output.rotation;\r\n\r\n            if (output.color)\r\n            {\r\n                tintTL = output.color;\r\n                tintTR = output.color;\r\n                tintBL = output.color;\r\n                tintBR = output.color;\r\n            }\r\n            else\r\n            {\r\n                tintTL = output.tint.topLeft;\r\n                tintTR = output.tint.topRight;\r\n                tintBL = output.tint.bottomLeft;\r\n                tintBR = output.tint.bottomRight;\r\n            }\r\n\r\n            tintTL = Utils.getTintAppendFloatAlpha(tintTL, camera.alpha * src._alphaTL);\r\n            tintTR = Utils.getTintAppendFloatAlpha(tintTR, camera.alpha * src._alphaTR);\r\n            tintBL = Utils.getTintAppendFloatAlpha(tintBL, camera.alpha * src._alphaBL);\r\n            tintBR = Utils.getTintAppendFloatAlpha(tintBR, camera.alpha * src._alphaBR);\r\n        }\r\n\r\n        x *= scale;\r\n        y *= scale;\r\n\r\n        x -= src.displayOriginX;\r\n        y -= src.displayOriginY;\r\n\r\n        x += lineOffsetX;\r\n\r\n        fontMatrix.applyITRS(x, y, rotation, scale, scale);\r\n\r\n        calcMatrix.multiply(fontMatrix, spriteMatrix);\r\n\r\n        var u0 = glyph.u0;\r\n        var v0 = glyph.v0;\r\n        var u1 = glyph.u1;\r\n        var v1 = glyph.v1;\r\n\r\n        var xw = glyphW;\r\n        var yh = glyphH;\r\n\r\n        var tx0 = spriteMatrix.e;\r\n        var ty0 = spriteMatrix.f;\r\n\r\n        var tx1 = yh * spriteMatrix.c + spriteMatrix.e;\r\n        var ty1 = yh * spriteMatrix.d + spriteMatrix.f;\r\n\r\n        var tx2 = xw * spriteMatrix.a + yh * spriteMatrix.c + spriteMatrix.e;\r\n        var ty2 = xw * spriteMatrix.b + yh * spriteMatrix.d + spriteMatrix.f;\r\n\r\n        var tx3 = xw * spriteMatrix.a + spriteMatrix.e;\r\n        var ty3 = xw * spriteMatrix.b + spriteMatrix.f;\r\n\r\n        if (roundPixels)\r\n        {\r\n            tx0 = Math.round(tx0);\r\n            ty0 = Math.round(ty0);\r\n\r\n            tx1 = Math.round(tx1);\r\n            ty1 = Math.round(ty1);\r\n\r\n            tx2 = Math.round(tx2);\r\n            ty2 = Math.round(ty2);\r\n\r\n            tx3 = Math.round(tx3);\r\n            ty3 = Math.round(ty3);\r\n        }\r\n\r\n        pipeline.batchQuad(src, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);\r\n    }\r\n\r\n    if (crop)\r\n    {\r\n        pipeline.flush();\r\n\r\n        renderer.popScissor();\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = DynamicBitmapTextWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Clamp = require('../../../math/Clamp');\r\nvar Components = require('../../components');\r\nvar GameObject = require('../../GameObject');\r\nvar GetBitmapTextSize = require('../GetBitmapTextSize');\r\nvar ParseFromAtlas = require('../ParseFromAtlas');\r\nvar ParseXMLBitmapFont = require('../ParseXMLBitmapFont');\r\nvar Rectangle = require('../../../geom/rectangle/Rectangle');\r\nvar Render = require('./BitmapTextRender');\r\n\r\n/**\r\n * @classdesc\r\n * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\r\n *\r\n * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\r\n * match the font structure.\r\n *\r\n * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\r\n * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\r\n * processing the font texture in an image editor, applying fills and any other effects required.\r\n *\r\n * To create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\r\n *\r\n * To create a BitmapText data files you need a 3rd party app such as:\r\n *\r\n * BMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}\r\n * Glyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}\r\n * Littera (Web-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}\r\n *\r\n * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\r\n * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}\r\n *\r\n * @class BitmapText\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.\r\n * @param {number} x - The x coordinate of this Game Object in world space.\r\n * @param {number} y - The y coordinate of this Game Object in world space.\r\n * @param {string} font - The key of the font to use from the Bitmap Font cache.\r\n * @param {(string|string[])} [text] - The string, or array of strings, to be set as the content of this Bitmap Text.\r\n * @param {number} [size] - The font size of this Bitmap Text.\r\n * @param {number} [align=0] - The alignment of the text in a multi-line BitmapText object.\r\n */\r\nvar BitmapText = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Texture,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function BitmapText (scene, x, y, font, text, size, align)\r\n    {\r\n        if (text === undefined) { text = ''; }\r\n        if (align === undefined) { align = 0; }\r\n\r\n        GameObject.call(this, scene, 'BitmapText');\r\n\r\n        /**\r\n         * The key of the Bitmap Font used by this Bitmap Text.\r\n         * To change the font after creation please use `setFont`.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#font\r\n         * @type {string}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.font = font;\r\n\r\n        var entry = this.scene.sys.cache.bitmapFont.get(font);\r\n\r\n        if (!entry)\r\n        {\r\n            console.warn('Invalid BitmapText key: ' + font);\r\n        }\r\n\r\n        /**\r\n         * The data of the Bitmap Font used by this Bitmap Text.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#fontData\r\n         * @type {Phaser.Types.GameObjects.BitmapText.BitmapFontData}\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.fontData = entry.data;\r\n\r\n        /**\r\n         * The text that this Bitmap Text object displays.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_text\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._text = '';\r\n\r\n        /**\r\n         * The font size of this Bitmap Text.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_fontSize\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._fontSize = size || this.fontData.size;\r\n\r\n        /**\r\n         * Adds / Removes spacing between characters.\r\n         *\r\n         * Can be a negative or positive number.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_letterSpacing\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._letterSpacing = 0;\r\n\r\n        /**\r\n         * Controls the alignment of each line of text in this BitmapText object.\r\n         * Only has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.\r\n         * Has no effect with single-lines of text.\r\n         *\r\n         * See the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.\r\n         *\r\n         * 0 = Left aligned (default)\r\n         * 1 = Middle aligned\r\n         * 2 = Right aligned\r\n         *\r\n         * The alignment position is based on the longest line of text.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_align\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._align = align;\r\n\r\n        /**\r\n         * An object that describes the size of this Bitmap Text.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_bounds\r\n         * @type {Phaser.Types.GameObjects.BitmapText.BitmapTextSize}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._bounds = GetBitmapTextSize();\r\n\r\n        /**\r\n         * An internal dirty flag for bounds calculation.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_dirty\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.11.0\r\n         */\r\n        this._dirty = true;\r\n\r\n        /**\r\n         * Internal cache var holding the maxWidth.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#_maxWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.21.0\r\n         */\r\n        this._maxWidth = 0;\r\n\r\n        /**\r\n         * The character code used to detect for word wrapping.\r\n         * Defaults to 32 (a space character).\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#wordWrapCharCode\r\n         * @type {number}\r\n         * @since 3.21.0\r\n         */\r\n        this.wordWrapCharCode = 32;\r\n\r\n        /**\r\n         * Internal array holding the character tint color data.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#charColors\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.charColors = [];\r\n\r\n        /**\r\n         * The horizontal offset of the drop shadow.\r\n         *\r\n         * You can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#dropShadowX\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.dropShadowX = 0;\r\n\r\n        /**\r\n         * The vertical offset of the drop shadow.\r\n         *\r\n         * You can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#dropShadowY\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.dropShadowY = 0;\r\n\r\n        /**\r\n         * The color of the drop shadow.\r\n         *\r\n         * You can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#dropShadowColor\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.dropShadowColor = 0x000000;\r\n\r\n        /**\r\n         * The alpha value of the drop shadow.\r\n         *\r\n         * You can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#dropShadowAlpha\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.dropShadowAlpha = 0.5;\r\n\r\n        /**\r\n         * Indicates whether the font texture is from an atlas or not.\r\n         *\r\n         * @name Phaser.GameObjects.BitmapText#fromAtlas\r\n         * @type {boolean}\r\n         * @since 3.54.0\r\n         * @readonly\r\n         */\r\n        this.fromAtlas = entry.fromAtlas;\r\n\r\n        this.setTexture(entry.texture, entry.frame);\r\n        this.setPosition(x, y);\r\n        this.setOrigin(0, 0);\r\n        this.initPipeline();\r\n\r\n        this.setText(text);\r\n    },\r\n\r\n    /**\r\n     * Set the lines of text in this BitmapText to be left-aligned.\r\n     * This only has any effect if this BitmapText contains more than one line of text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setLeftAlign\r\n     * @since 3.11.0\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setLeftAlign: function ()\r\n    {\r\n        this._align = BitmapText.ALIGN_LEFT;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the lines of text in this BitmapText to be center-aligned.\r\n     * This only has any effect if this BitmapText contains more than one line of text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setCenterAlign\r\n     * @since 3.11.0\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setCenterAlign: function ()\r\n    {\r\n        this._align = BitmapText.ALIGN_CENTER;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the lines of text in this BitmapText to be right-aligned.\r\n     * This only has any effect if this BitmapText contains more than one line of text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setRightAlign\r\n     * @since 3.11.0\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setRightAlign: function ()\r\n    {\r\n        this._align = BitmapText.ALIGN_RIGHT;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the font size of this Bitmap Text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setFontSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} size - The font size to set.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setFontSize: function (size)\r\n    {\r\n        this._fontSize = size;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the letter spacing between each character of this Bitmap Text.\r\n     * Can be a positive value to increase the space, or negative to reduce it.\r\n     * Spacing is applied after the kerning values have been set.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setLetterSpacing\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [spacing=0] - The amount of horizontal space to add between each character.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setLetterSpacing: function (spacing)\r\n    {\r\n        if (spacing === undefined) { spacing = 0; }\r\n\r\n        this._letterSpacing = spacing;\r\n\r\n        this._dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the textual content of this BitmapText.\r\n     *\r\n     * An array of strings will be converted into multi-line text. Use the align methods to change multi-line alignment.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this BitmapText.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setText: function (value)\r\n    {\r\n        if (!value && value !== 0)\r\n        {\r\n            value = '';\r\n        }\r\n\r\n        if (Array.isArray(value))\r\n        {\r\n            value = value.join('\\n');\r\n        }\r\n\r\n        if (value !== this.text)\r\n        {\r\n            this._text = value.toString();\r\n\r\n            this._dirty = true;\r\n\r\n            this.updateDisplayOrigin();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a drop shadow effect on this Bitmap Text.\r\n     *\r\n     * This is a WebGL only feature and only works with Static Bitmap Text, not Dynamic.\r\n     *\r\n     * You can set the vertical and horizontal offset of the shadow, as well as the color and alpha.\r\n     *\r\n     * Once a shadow has been enabled you can modify the `dropShadowX` and `dropShadowY` properties of this\r\n     * Bitmap Text directly to adjust the position of the shadow in real-time.\r\n     *\r\n     * If you wish to clear the shadow, call this method with no parameters specified.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setDropShadow\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal offset of the drop shadow.\r\n     * @param {number} [y=0] - The vertical offset of the drop shadow.\r\n     * @param {number} [color=0x000000] - The color of the drop shadow, given as a hex value, i.e. `0x000000` for black.\r\n     * @param {number} [alpha=0.5] - The alpha of the drop shadow, given as a float between 0 and 1. This is combined with the Bitmap Text alpha as well.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setDropShadow: function (x, y, color, alpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (color === undefined) { color = 0x000000; }\r\n        if (alpha === undefined) { alpha = 0.5; }\r\n\r\n        this.dropShadowX = x;\r\n        this.dropShadowY = y;\r\n        this.dropShadowColor = color;\r\n        this.dropShadowAlpha = alpha;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a tint on a range of characters in this Bitmap Text, starting from the `start` parameter index\r\n     * and running for `length` quantity of characters.\r\n     *\r\n     * The `start` parameter can be negative. In this case, it starts at the end of the text and counts\r\n     * backwards `start` places.\r\n     *\r\n     * You can also pass in -1 as the `length` and it will tint all characters from `start`\r\n     * up until the end of the string.\r\n\r\n     * Remember that spaces and punctuation count as characters.\r\n     *\r\n     * This is a WebGL only feature and only works with Static Bitmap Text, not Dynamic.\r\n     *\r\n     * The tint works by taking the pixel color values from the Bitmap Text texture, and then\r\n     * multiplying it by the color value of the tint. You can provide either one color value,\r\n     * in which case the whole character will be tinted in that color. Or you can provide a color\r\n     * per corner. The colors are blended together across the extent of the character range.\r\n     *\r\n     * To swap this from being an additive tint to a fill based tint, set the `tintFill` parameter to `true`.\r\n     *\r\n     * To modify the tint color once set, call this method again with new color values.\r\n     *\r\n     * Using `setWordTint` can override tints set by this function, and vice versa.\r\n     *\r\n     * To remove a tint call this method with just the `start`, and optionally, the `length` parameters defined.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setCharacterTint\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [start=0] - The starting character to begin the tint at. If negative, it counts back from the end of the text.\r\n     * @param {number} [length=1] - The number of characters to tint. Remember that spaces count as a character too. Pass -1 to tint all characters from `start` onwards.\r\n     * @param {boolean} [tintFill=false] - Use a fill-based tint (true), or an additive tint (false)\r\n     * @param {number} [topLeft=0xffffff] - The tint being applied to the top-left of the character. If not other values are given this value is applied evenly, tinting the whole character.\r\n     * @param {number} [topRight] - The tint being applied to the top-right of the character.\r\n     * @param {number} [bottomLeft] - The tint being applied to the bottom-left of the character.\r\n     * @param {number} [bottomRight] - The tint being applied to the bottom-right of the character.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setCharacterTint: function (start, length, tintFill, topLeft, topRight, bottomLeft, bottomRight)\r\n    {\r\n        if (start === undefined) { start = 0; }\r\n        if (length === undefined) { length = 1; }\r\n        if (tintFill === undefined) { tintFill = false; }\r\n        if (topLeft === undefined) { topLeft = -1; }\r\n\r\n        if (topRight === undefined)\r\n        {\r\n            topRight = topLeft;\r\n            bottomLeft = topLeft;\r\n            bottomRight = topLeft;\r\n        }\r\n\r\n        var len = this.text.length;\r\n\r\n        if (length === -1)\r\n        {\r\n            length = len;\r\n        }\r\n\r\n        if (start < 0)\r\n        {\r\n            start = len + start;\r\n        }\r\n\r\n        start = Clamp(start, 0, len - 1);\r\n\r\n        var end = Clamp(start + length, start, len);\r\n\r\n        var charColors = this.charColors;\r\n\r\n        for (var i = start; i < end; i++)\r\n        {\r\n            var color = charColors[i];\r\n\r\n            if (topLeft === -1)\r\n            {\r\n                charColors[i] = null;\r\n            }\r\n            else\r\n            {\r\n                var tintEffect = (tintFill) ? 1 : 0;\r\n\r\n                if (color)\r\n                {\r\n                    color.tintEffect = tintEffect;\r\n                    color.tintTL = topLeft;\r\n                    color.tintTR = topRight;\r\n                    color.tintBL = bottomLeft;\r\n                    color.tintBR = bottomRight;\r\n                }\r\n                else\r\n                {\r\n                    charColors[i] = {\r\n                        tintEffect: tintEffect,\r\n                        tintTL: topLeft,\r\n                        tintTR: topRight,\r\n                        tintBL: bottomLeft,\r\n                        tintBR: bottomRight\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a tint on a matching word within this Bitmap Text.\r\n     *\r\n     * The `word` parameter can be either a string or a number.\r\n     *\r\n     * If a string, it will run a string comparison against the text contents, and if matching,\r\n     * it will tint the whole word.\r\n     *\r\n     * If a number, if till that word, based on its offset within the text contents.\r\n     *\r\n     * The `count` parameter controls how many words are replaced. Pass in -1 to replace them all.\r\n     *\r\n     * This parameter is ignored if you pass a number as the `word` to be searched for.\r\n     *\r\n     * This is a WebGL only feature and only works with Static Bitmap Text, not Dynamic.\r\n     *\r\n     * The tint works by taking the pixel color values from the Bitmap Text texture, and then\r\n     * multiplying it by the color value of the tint. You can provide either one color value,\r\n     * in which case the whole character will be tinted in that color. Or you can provide a color\r\n     * per corner. The colors are blended together across the extent of the character range.\r\n     *\r\n     * To swap this from being an additive tint to a fill based tint, set the `tintFill` parameter to `true`.\r\n     *\r\n     * To modify the tint color once set, call this method again with new color values.\r\n     *\r\n     * Using `setCharacterTint` can override tints set by this function, and vice versa.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setWordTint\r\n     * @webglOnly\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|number)} word - The word to search for. Either a string, or an index of the word in the words array.\r\n     * @param {number} [count=1] - The number of matching words to tint. Pass -1 to tint all matching words.\r\n     * @param {boolean} [tintFill=false] - Use a fill-based tint (true), or an additive tint (false)\r\n     * @param {number} [topLeft=0xffffff] - The tint being applied to the top-left of the word. If not other values are given this value is applied evenly, tinting the whole word.\r\n     * @param {number} [topRight] - The tint being applied to the top-right of the word.\r\n     * @param {number} [bottomLeft] - The tint being applied to the bottom-left of the word.\r\n     * @param {number} [bottomRight] - The tint being applied to the bottom-right of the word.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setWordTint: function (word, count, tintFill, topLeft, topRight, bottomLeft, bottomRight)\r\n    {\r\n        if (count === undefined) { count = 1; }\r\n\r\n        var bounds = this.getTextBounds();\r\n\r\n        var words = bounds.words;\r\n\r\n        var wordIsNumber = (typeof(word) === 'number');\r\n\r\n        var total = 0;\r\n\r\n        for (var i = 0; i < words.length; i++)\r\n        {\r\n            var lineword = words[i];\r\n\r\n            if ((wordIsNumber && i === word) || (!wordIsNumber && lineword.word === word))\r\n            {\r\n                this.setCharacterTint(lineword.i, lineword.word.length, tintFill, topLeft, topRight, bottomLeft, bottomRight);\r\n\r\n                total++;\r\n\r\n                if (total === count)\r\n                {\r\n                    return this;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calculate the bounds of this Bitmap Text.\r\n     *\r\n     * An object is returned that contains the position, width and height of the Bitmap Text in local and global\r\n     * contexts.\r\n     *\r\n     * Local size is based on just the font size and a [0, 0] position.\r\n     *\r\n     * Global size takes into account the Game Object's scale, world position and display origin.\r\n     *\r\n     * Also in the object is data regarding the length of each line, should this be a multi-line BitmapText.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#getTextBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [round=false] - Whether to round the results up to the nearest integer.\r\n     *\r\n     * @return {Phaser.Types.GameObjects.BitmapText.BitmapTextSize} An object that describes the size of this Bitmap Text.\r\n     */\r\n    getTextBounds: function (round)\r\n    {\r\n        //  local = The BitmapText based on fontSize and 0x0 coords\r\n        //  global = The BitmapText, taking into account scale and world position\r\n        //  lines = The BitmapText line data\r\n\r\n        var bounds = this._bounds;\r\n\r\n        if (this._dirty || round || this.scaleX !== bounds.scaleX || this.scaleY !== bounds.scaleY)\r\n        {\r\n            GetBitmapTextSize(this, round, true, bounds);\r\n\r\n            this._dirty = false;\r\n        }\r\n\r\n        return bounds;\r\n    },\r\n\r\n    /**\r\n     * Gets the character located at the given x/y coordinate within this Bitmap Text.\r\n     *\r\n     * The coordinates you pass in are translated into the local space of the\r\n     * Bitmap Text, however, it is up to you to first translate the input coordinates to world space.\r\n     *\r\n     * If you wish to use this in combination with an input event, be sure\r\n     * to pass in `Pointer.worldX` and `worldY` so they are in world space.\r\n     *\r\n     * In some cases, based on kerning, characters can overlap. When this happens,\r\n     * the first character in the word is returned.\r\n     *\r\n     * Note that this does not work for DynamicBitmapText if you have changed the\r\n     * character positions during render. It will only scan characters in their un-translated state.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#getCharacterAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The x position to check.\r\n     * @param {number} y - The y position to check.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The Camera which is being tested against. If not given will use the Scene default camera.\r\n     *\r\n     * @return {Phaser.Types.GameObjects.BitmapText.BitmapTextCharacter} The character object at the given position, or `null`.\r\n     */\r\n    getCharacterAt: function (x, y, camera)\r\n    {\r\n        var point = this.getLocalPoint(x, y, null, camera);\r\n\r\n        var bounds = this.getTextBounds();\r\n\r\n        var chars = bounds.characters;\r\n\r\n        var tempRect = new Rectangle();\r\n\r\n        for (var i = 0; i < chars.length; i++)\r\n        {\r\n            var char = chars[i];\r\n\r\n            tempRect.setTo(char.x, char.t, char.r - char.x, char.b);\r\n\r\n            if (tempRect.contains(point.x, point.y))\r\n            {\r\n                return char;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Updates the Display Origin cached values internally stored on this Game Object.\r\n     * You don't usually call this directly, but it is exposed for edge-cases where you may.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#updateDisplayOrigin\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateDisplayOrigin: function ()\r\n    {\r\n        this._dirty = true;\r\n\r\n        this.getTextBounds(false);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Changes the font this BitmapText is using to render.\r\n     *\r\n     * The new texture is loaded and applied to the BitmapText. The existing test, size and alignment are preserved,\r\n     * unless overridden via the arguments.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setFont\r\n     * @since 3.11.0\r\n     *\r\n     * @param {string} font - The key of the font to use from the Bitmap Font cache.\r\n     * @param {number} [size] - The font size of this Bitmap Text. If not specified the current size will be used.\r\n     * @param {number} [align=0] - The alignment of the text in a multi-line BitmapText object. If not specified the current alignment will be used.\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setFont: function (key, size, align)\r\n    {\r\n        if (size === undefined) { size = this._fontSize; }\r\n        if (align === undefined) { align = this._align; }\r\n\r\n        if (key !== this.font)\r\n        {\r\n            var entry = this.scene.sys.cache.bitmapFont.get(key);\r\n\r\n            if (entry)\r\n            {\r\n                this.font = key;\r\n                this.fontData = entry.data;\r\n                this._fontSize = size;\r\n                this._align = align;\r\n                this.fromAtlas = entry.fromAtlas === true;\r\n\r\n                this.setTexture(entry.texture, entry.frame);\r\n\r\n                GetBitmapTextSize(this, false, true, this._bounds);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the maximum display width of this BitmapText in pixels.\r\n     *\r\n     * If `BitmapText.text` is longer than `maxWidth` then the lines will be automatically wrapped\r\n     * based on the previous whitespace character found in the line.\r\n     *\r\n     * If no whitespace was found then no wrapping will take place and consequently the `maxWidth` value will not be honored.\r\n     *\r\n     * Disable maxWidth by setting the value to 0.\r\n     *\r\n     * You can set the whitespace character to be searched for by setting the `wordWrapCharCode` parameter or property.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#setMaxWidth\r\n     * @since 3.21.0\r\n     *\r\n     * @param {number} value - The maximum display width of this BitmapText in pixels. Set to zero to disable.\r\n     * @param {number} [wordWrapCharCode] - The character code to check for when word wrapping. Defaults to 32 (the space character).\r\n     *\r\n     * @return {this} This BitmapText Object.\r\n     */\r\n    setMaxWidth: function (value, wordWrapCharCode)\r\n    {\r\n        this._maxWidth = value;\r\n\r\n        this._dirty = true;\r\n\r\n        if (wordWrapCharCode !== undefined)\r\n        {\r\n            this.wordWrapCharCode = wordWrapCharCode;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Controls the alignment of each line of text in this BitmapText object.\r\n     *\r\n     * Only has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.\r\n     * Has no effect with single-lines of text.\r\n     *\r\n     * See the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.\r\n     *\r\n     * 0 = Left aligned (default)\r\n     * 1 = Middle aligned\r\n     * 2 = Right aligned\r\n     *\r\n     * The alignment position is based on the longest line of text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#align\r\n     * @type {number}\r\n     * @since 3.11.0\r\n     */\r\n    align: {\r\n\r\n        set: function (value)\r\n        {\r\n            this._align = value;\r\n            this._dirty = true;\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._align;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The text that this Bitmap Text object displays.\r\n     *\r\n     * You can also use the method `setText` if you want a chainable way to change the text content.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#text\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\r\n    text: {\r\n\r\n        set: function (value)\r\n        {\r\n            this.setText(value);\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._text;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The font size of this Bitmap Text.\r\n     *\r\n     * You can also use the method `setFontSize` if you want a chainable way to change the font size.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#fontSize\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    fontSize: {\r\n\r\n        set: function (value)\r\n        {\r\n            this._fontSize = value;\r\n            this._dirty = true;\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._fontSize;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Adds / Removes spacing between characters.\r\n     *\r\n     * Can be a negative or positive number.\r\n     *\r\n     * You can also use the method `setLetterSpacing` if you want a chainable way to change the letter spacing.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#letterSpacing\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    letterSpacing: {\r\n\r\n        set: function (value)\r\n        {\r\n            this._letterSpacing = value;\r\n            this._dirty = true;\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._letterSpacing;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The maximum display width of this BitmapText in pixels.\r\n     *\r\n     * If BitmapText.text is longer than maxWidth then the lines will be automatically wrapped\r\n     * based on the last whitespace character found in the line.\r\n     *\r\n     * If no whitespace was found then no wrapping will take place and consequently the maxWidth value will not be honored.\r\n     *\r\n     * Disable maxWidth by setting the value to 0.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#maxWidth\r\n     * @type {number}\r\n     * @since 3.21.0\r\n     */\r\n    maxWidth: {\r\n\r\n        set: function (value)\r\n        {\r\n            this._maxWidth = value;\r\n            this._dirty = true;\r\n        },\r\n\r\n        get: function ()\r\n        {\r\n            return this._maxWidth;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The width of this Bitmap Text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#width\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    width: {\r\n\r\n        get: function ()\r\n        {\r\n            this.getTextBounds(false);\r\n\r\n            return this._bounds.global.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The height of this bitmap text.\r\n     *\r\n     * @name Phaser.GameObjects.BitmapText#height\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    height: {\r\n\r\n        get: function ()\r\n        {\r\n            this.getTextBounds(false);\r\n\r\n            return this._bounds.global.height;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Build a JSON representation of this Bitmap Text.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.BitmapText.JSONBitmapText} A JSON representation of this Bitmap Text.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        var out = Components.ToJSON(this);\r\n\r\n        //  Extra data is added here\r\n\r\n        var data = {\r\n            font: this.font,\r\n            text: this.text,\r\n            fontSize: this.fontSize,\r\n            letterSpacing: this.letterSpacing,\r\n            align: this.align\r\n        };\r\n\r\n        out.data = data;\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.BitmapText#preDestroy\r\n     * @protected\r\n     * @since 3.50.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.charColors.length = 0;\r\n        this._bounds = null;\r\n        this.fontData = null;\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * Left align the text characters in a multi-line BitmapText object.\r\n *\r\n * @name Phaser.GameObjects.BitmapText.ALIGN_LEFT\r\n * @type {number}\r\n * @since 3.11.0\r\n */\r\nBitmapText.ALIGN_LEFT = 0;\r\n\r\n/**\r\n * Center align the text characters in a multi-line BitmapText object.\r\n *\r\n * @name Phaser.GameObjects.BitmapText.ALIGN_CENTER\r\n * @type {number}\r\n * @since 3.11.0\r\n */\r\nBitmapText.ALIGN_CENTER = 1;\r\n\r\n/**\r\n * Right align the text characters in a multi-line BitmapText object.\r\n *\r\n * @name Phaser.GameObjects.BitmapText.ALIGN_RIGHT\r\n * @type {number}\r\n * @since 3.11.0\r\n */\r\nBitmapText.ALIGN_RIGHT = 2;\r\n\r\n/**\r\n * Parse an XML Bitmap Font from an Atlas.\r\n *\r\n * Adds the parsed Bitmap Font data to the cache with the `fontName` key.\r\n *\r\n * @method Phaser.GameObjects.BitmapText.ParseFromAtlas\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to parse the Bitmap Font for.\r\n * @param {string} fontName - The key of the font to add to the Bitmap Font cache.\r\n * @param {string} textureKey - The key of the BitmapFont's texture.\r\n * @param {string} frameKey - The key of the BitmapFont texture's frame.\r\n * @param {string} xmlKey - The key of the XML data of the font to parse.\r\n * @param {number} [xSpacing] - The x-axis spacing to add between each letter.\r\n * @param {number} [ySpacing] - The y-axis spacing to add to the line height.\r\n *\r\n * @return {boolean} Whether the parsing was successful or not.\r\n */\r\nBitmapText.ParseFromAtlas = ParseFromAtlas;\r\n\r\n/**\r\n * Parse an XML font to Bitmap Font data for the Bitmap Font cache.\r\n *\r\n * @method Phaser.GameObjects.BitmapText.ParseXMLBitmapFont\r\n * @since 3.17.0\r\n *\r\n * @param {XMLDocument} xml - The XML Document to parse the font from.\r\n * @param {Phaser.Textures.Frame} frame - The texture frame to take into account when creating the uv data.\r\n * @param {number} [xSpacing=0] - The x-axis spacing to add between each letter.\r\n * @param {number} [ySpacing=0] - The y-axis spacing to add to the line height.\r\n *\r\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapFontData} The parsed Bitmap Font data.\r\n */\r\nBitmapText.ParseXMLBitmapFont = ParseXMLBitmapFont;\r\n\r\nmodule.exports = BitmapText;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.BitmapText#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.BitmapText} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar BitmapTextCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var text = src._text;\r\n    var textLength = text.length;\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (textLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var textureFrame = src.fromAtlas\r\n        ? src.frame\r\n        : src.texture.frames['__BASE'];\r\n\r\n    var chars = src.fontData.chars;\r\n    var lineHeight = src.fontData.lineHeight;\r\n    var letterSpacing = src._letterSpacing;\r\n\r\n    var xAdvance = 0;\r\n    var yAdvance = 0;\r\n\r\n    var charCode = 0;\r\n\r\n    var glyph = null;\r\n    var glyphX = 0;\r\n    var glyphY = 0;\r\n    var glyphW = 0;\r\n    var glyphH = 0;\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n\r\n    var lastGlyph = null;\r\n    var lastCharCode = 0;\r\n\r\n    var image = textureFrame.source.image;\r\n\r\n    var textureX = textureFrame.cutX;\r\n    var textureY = textureFrame.cutY;\r\n\r\n    var scale = (src._fontSize / src.fontData.size);\r\n\r\n    var align = src._align;\r\n    var currentLine = 0;\r\n    var lineOffsetX = 0;\r\n\r\n    //  Update the bounds - skipped internally if not dirty\r\n    var bounds = src.getTextBounds(false);\r\n\r\n    //  In case the method above changed it (word wrapping)\r\n    if (src.maxWidth > 0)\r\n    {\r\n        text = bounds.wrappedText;\r\n        textLength = text.length;\r\n    }\r\n\r\n    var lineData = src._bounds.lines;\r\n\r\n    if (align === 1)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]) / 2;\r\n    }\r\n    else if (align === 2)\r\n    {\r\n        lineOffsetX = (lineData.longest - lineData.lengths[0]);\r\n    }\r\n\r\n    ctx.translate(-src.displayOriginX, -src.displayOriginY);\r\n\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    for (var i = 0; i < textLength; i++)\r\n    {\r\n        charCode = text.charCodeAt(i);\r\n\r\n        if (charCode === 10)\r\n        {\r\n            currentLine++;\r\n\r\n            if (align === 1)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]) / 2;\r\n            }\r\n            else if (align === 2)\r\n            {\r\n                lineOffsetX = (lineData.longest - lineData.lengths[currentLine]);\r\n            }\r\n\r\n            xAdvance = 0;\r\n            yAdvance += lineHeight;\r\n            lastGlyph = null;\r\n\r\n            continue;\r\n        }\r\n\r\n        glyph = chars[charCode];\r\n\r\n        if (!glyph)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        glyphX = textureX + glyph.x;\r\n        glyphY = textureY + glyph.y;\r\n\r\n        glyphW = glyph.width;\r\n        glyphH = glyph.height;\r\n\r\n        x = glyph.xOffset + xAdvance;\r\n        y = glyph.yOffset + yAdvance;\r\n\r\n        if (lastGlyph !== null)\r\n        {\r\n            var kerningOffset = glyph.kerning[lastCharCode];\r\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\r\n        }\r\n\r\n        x *= scale;\r\n        y *= scale;\r\n\r\n        x += lineOffsetX;\r\n\r\n        xAdvance += glyph.xAdvance + letterSpacing;\r\n        lastGlyph = glyph;\r\n        lastCharCode = charCode;\r\n\r\n        //  Nothing to render or a space? Then skip to the next glyph\r\n        if (glyphW === 0 || glyphH === 0 || charCode === 32)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (roundPixels)\r\n        {\r\n            x = Math.round(x);\r\n            y = Math.round(y);\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        ctx.translate(x, y);\r\n\r\n        ctx.scale(scale, scale);\r\n\r\n        ctx.drawImage(image, glyphX, glyphY, glyphW, glyphH, 0, 0, glyphW, glyphH);\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = BitmapTextCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BitmapText = require('./BitmapText');\r\nvar BuildGameObject = require('../../BuildGameObject');\r\nvar GameObjectCreator = require('../../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../../utils/object/GetAdvancedValue');\r\nvar GetValue = require('../../../utils/object/GetValue');\r\n\r\n/**\r\n * Creates a new Bitmap Text Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#bitmapText\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.BitmapText.BitmapTextConfig} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n * \r\n * @return {Phaser.GameObjects.BitmapText} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('bitmapText', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var font = GetValue(config, 'font', '');\r\n    var text = GetAdvancedValue(config, 'text', '');\r\n    var size = GetAdvancedValue(config, 'size', false);\r\n    var align = GetValue(config, 'align', 0);\r\n\r\n    var bitmapText = new BitmapText(this.scene, 0, 0, font, text, size, align);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, bitmapText, config);\r\n\r\n    return bitmapText;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BitmapText = require('./BitmapText');\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Bitmap Text Game Object and adds it to the Scene.\r\n * \r\n * BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\r\n * \r\n * During rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\r\n * match the font structure.\r\n * \r\n * BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\r\n * to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\r\n * processing the font texture in an image editor, applying fills and any other effects required.\r\n *\r\n * To create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\r\n *\r\n * To create a BitmapText data files you need a 3rd party app such as:\r\n *\r\n * BMFont (Windows, free): http://www.angelcode.com/products/bmfont/\r\n * Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner\r\n * Littera (Web-based, free): http://kvazars.com/littera/\r\n *\r\n * For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\r\n * converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson\r\n *\r\n * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#bitmapText\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x position of the Game Object.\r\n * @param {number} y - The y position of the Game Object.\r\n * @param {string} font - The key of the font to use from the BitmapFont cache.\r\n * @param {(string|string[])} [text] - The string, or array of strings, to be set as the content of this Bitmap Text.\r\n * @param {number} [size] - The font size to set.\r\n * @param {number} [align=0] - The alignment of the text in a multi-line BitmapText object.\r\n *\r\n * @return {Phaser.GameObjects.BitmapText} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('bitmapText', function (x, y, font, text, size, align)\r\n{\r\n    return this.displayList.add(new BitmapText(this.scene, x, y, font, text, size, align));\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar renderWebGL = require('../../../utils/NOOP');\nvar renderCanvas = require('../../../utils/NOOP');\n\nif (typeof WEBGL_RENDERER)\n{\n    renderWebGL = require('./BitmapTextWebGLRenderer');\n}\n\nif (typeof CANVAS_RENDERER)\n{\n    renderCanvas = require('./BitmapTextCanvasRenderer');\n}\n\nmodule.exports = {\n\n    renderWebGL: renderWebGL,\n    renderCanvas: renderCanvas\n\n};\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BatchChar = require('../BatchChar');\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.BitmapText#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.BitmapText} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar BitmapTextWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var text = src._text;\r\n    var textLength = text.length;\r\n\r\n    if (textLength === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    var cameraAlpha = camera.alpha;\r\n\r\n    var charColors = src.charColors;\r\n\r\n    var tintEffect = src.tintFill;\r\n\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    var tintTL = getTint(src.tintTopLeft, cameraAlpha * src._alphaTL);\r\n    var tintTR = getTint(src.tintTopRight, cameraAlpha * src._alphaTR);\r\n    var tintBL = getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL);\r\n    var tintBR = getTint(src.tintBottomRight, cameraAlpha * src._alphaBR);\r\n\r\n    var texture = src.frame.glTexture;\r\n    var textureUnit = pipeline.setGameObject(src);\r\n\r\n    //  Update the bounds - skipped internally if not dirty\r\n    var bounds = src.getTextBounds(false);\r\n\r\n    var i;\r\n    var char;\r\n    var glyph;\r\n\r\n    var characters = bounds.characters;\r\n\r\n    var dropShadowX = src.dropShadowX;\r\n    var dropShadowY = src.dropShadowY;\r\n\r\n    var dropShadow = (dropShadowX !== 0 || dropShadowY !== 0);\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (dropShadow)\r\n    {\r\n        var srcShadowColor = src.dropShadowColor;\r\n        var srcShadowAlpha = src.dropShadowAlpha;\r\n\r\n        var shadowTL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTL);\r\n        var shadowTR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaTR);\r\n        var shadowBL = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBL);\r\n        var shadowBR = getTint(srcShadowColor, cameraAlpha * srcShadowAlpha * src._alphaBR);\r\n\r\n        for (i = 0; i < characters.length; i++)\r\n        {\r\n            char = characters[i];\r\n            glyph = char.glyph;\r\n\r\n            if (char.code === 32 || glyph.width === 0 || glyph.height === 0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            BatchChar(pipeline, src, char, glyph, dropShadowX, dropShadowY, calcMatrix, roundPixels, shadowTL, shadowTR, shadowBL, shadowBR, 1, texture, textureUnit);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < characters.length; i++)\r\n    {\r\n        char = characters[i];\r\n        glyph = char.glyph;\r\n\r\n        if (char.code === 32 || glyph.width === 0 || glyph.height === 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (charColors[char.i])\r\n        {\r\n            var color = charColors[char.i];\r\n\r\n            var charTintEffect = color.tintEffect;\r\n            var charTintTL = getTint(color.tintTL, cameraAlpha * src._alphaTL);\r\n            var charTintTR = getTint(color.tintTR, cameraAlpha * src._alphaTR);\r\n            var charTintBL = getTint(color.tintBL, cameraAlpha * src._alphaBL);\r\n            var charTintBR = getTint(color.tintBR, cameraAlpha * src._alphaBR);\r\n\r\n            BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, charTintTL, charTintTR, charTintBL, charTintBR, charTintEffect, texture, textureUnit);\r\n        }\r\n        else\r\n        {\r\n            BatchChar(pipeline, src, char, glyph, 0, 0, calcMatrix, roundPixels, tintTL, tintTR, tintBL, tintBR, tintEffect, texture, textureUnit);\r\n        }\r\n\r\n        //  Debug test if the characters are in the correct place when rendered:\r\n        // pipeline.drawFillRect(tx0, ty0, tx2 - tx0, ty2 - ty0, 0x00ff00, 0.5);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = BitmapTextWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlitterRender = require('./BlitterRender');\r\nvar Bob = require('./Bob');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar Frame = require('../../textures/Frame');\r\nvar GameObject = require('../GameObject');\r\nvar List = require('../../structs/List');\r\n\r\n/**\r\n * @callback CreateCallback\r\n *\r\n * @param {Phaser.GameObjects.Bob} bob - The Bob that was created by the Blitter.\r\n * @param {number} index - The position of the Bob within the Blitter display list.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * A Blitter Game Object.\r\n *\r\n * The Blitter Game Object is a special kind of container that creates, updates and manages Bob objects.\r\n * Bobs are designed for rendering speed rather than flexibility. They consist of a texture, or frame from a texture,\r\n * a position and an alpha value. You cannot scale or rotate them. They use a batched drawing method for speed\r\n * during rendering.\r\n *\r\n * A Blitter Game Object has one texture bound to it. Bobs created by the Blitter can use any Frame from this\r\n * Texture to render with, but they cannot use any other Texture. It is this single texture-bind that allows\r\n * them their speed.\r\n *\r\n * If you have a need to blast a large volume of frames around the screen then Blitter objects are well worth\r\n * investigating. They are especially useful for using as a base for your own special effects systems.\r\n *\r\n * @class Blitter\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.\r\n * @param {number} [x=0] - The x coordinate of this Game Object in world space.\r\n * @param {number} [y=0] - The y coordinate of this Game Object in world space.\r\n * @param {string} [texture='__DEFAULT'] - The key of the texture this Game Object will use for rendering. The Texture must already exist in the Texture Manager.\r\n * @param {(string|number)} [frame=0] - The Frame of the Texture that this Game Object will use. Only set if the Texture has multiple frames, such as a Texture Atlas or Sprite Sheet.\r\n */\r\nvar Blitter = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Size,\r\n        Components.Texture,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        BlitterRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Blitter (scene, x, y, texture, frame)\r\n    {\r\n        GameObject.call(this, scene, 'Blitter');\r\n\r\n        this.setTexture(texture, frame);\r\n        this.setPosition(x, y);\r\n        this.initPipeline();\r\n\r\n        /**\r\n         * The children of this Blitter.\r\n         * This List contains all of the Bob objects created by the Blitter.\r\n         *\r\n         * @name Phaser.GameObjects.Blitter#children\r\n         * @type {Phaser.Structs.List.<Phaser.GameObjects.Bob>}\r\n         * @since 3.0.0\r\n         */\r\n        this.children = new List();\r\n\r\n        /**\r\n         * A transient array that holds all of the Bobs that will be rendered this frame.\r\n         * The array is re-populated whenever the dirty flag is set.\r\n         *\r\n         * @name Phaser.GameObjects.Blitter#renderList\r\n         * @type {Phaser.GameObjects.Bob[]}\r\n         * @default []\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.renderList = [];\r\n\r\n        /**\r\n         * Is the Blitter considered dirty?\r\n         * A 'dirty' Blitter has had its child count changed since the last frame.\r\n         *\r\n         * @name Phaser.GameObjects.Blitter#dirty\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.dirty = false;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Bob in this Blitter.\r\n     *\r\n     * The Bob is created at the given coordinates, relative to the Blitter and uses the given frame.\r\n     * A Bob can use any frame belonging to the texture bound to the Blitter.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     * @param {number} y - The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     * @param {(string|number|Phaser.Textures.Frame)} [frame] - The Frame the Bob will use. It _must_ be part of the Texture the parent Blitter object is using.\r\n     * @param {boolean} [visible=true] - Should the created Bob render or not?\r\n     * @param {number} [index] - The position in the Blitters Display List to add the new Bob at. Defaults to the top of the list.\r\n     *\r\n     * @return {Phaser.GameObjects.Bob} The newly created Bob object.\r\n     */\r\n    create: function (x, y, frame, visible, index)\r\n    {\r\n        if (visible === undefined) { visible = true; }\r\n        if (index === undefined) { index = this.children.length; }\r\n\r\n        if (frame === undefined)\r\n        {\r\n            frame = this.frame;\r\n        }\r\n        else if (!(frame instanceof Frame))\r\n        {\r\n            frame = this.texture.get(frame);\r\n        }\r\n\r\n        var bob = new Bob(this, x, y, frame, visible);\r\n\r\n        this.children.addAt(bob, index, false);\r\n\r\n        this.dirty = true;\r\n\r\n        return bob;\r\n    },\r\n\r\n    /**\r\n     * Creates multiple Bob objects within this Blitter and then passes each of them to the specified callback.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#createFromCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {CreateCallback} callback - The callback to invoke after creating a bob. It will be sent two arguments: The Bob and the index of the Bob.\r\n     * @param {number} quantity - The quantity of Bob objects to create.\r\n     * @param {(string|number|Phaser.Textures.Frame|string[]|number[]|Phaser.Textures.Frame[])} [frame] - The Frame the Bobs will use. It must be part of the Blitter Texture.\r\n     * @param {boolean} [visible=true] - Should the created Bob render or not?\r\n     *\r\n     * @return {Phaser.GameObjects.Bob[]} An array of Bob objects that were created.\r\n     */\r\n    createFromCallback: function (callback, quantity, frame, visible)\r\n    {\r\n        var bobs = this.createMultiple(quantity, frame, visible);\r\n\r\n        for (var i = 0; i < bobs.length; i++)\r\n        {\r\n            var bob = bobs[i];\r\n\r\n            callback.call(this, bob, i);\r\n        }\r\n\r\n        return bobs;\r\n    },\r\n\r\n    /**\r\n     * Creates multiple Bobs in one call.\r\n     *\r\n     * The amount created is controlled by a combination of the `quantity` argument and the number of frames provided.\r\n     *\r\n     * If the quantity is set to 10 and you provide 2 frames, then 20 Bobs will be created. 10 with the first\r\n     * frame and 10 with the second.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#createMultiple\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} quantity - The quantity of Bob objects to create.\r\n     * @param {(string|number|Phaser.Textures.Frame|string[]|number[]|Phaser.Textures.Frame[])} [frame] - The Frame the Bobs will use. It must be part of the Blitter Texture.\r\n     * @param {boolean} [visible=true] - Should the created Bob render or not?\r\n     *\r\n     * @return {Phaser.GameObjects.Bob[]} An array of Bob objects that were created.\r\n     */\r\n    createMultiple: function (quantity, frame, visible)\r\n    {\r\n        if (frame === undefined) { frame = this.frame.name; }\r\n        if (visible === undefined) { visible = true; }\r\n\r\n        if (!Array.isArray(frame))\r\n        {\r\n            frame = [ frame ];\r\n        }\r\n\r\n        var bobs = [];\r\n        var _this = this;\r\n\r\n        frame.forEach(function (singleFrame)\r\n        {\r\n            for (var i = 0; i < quantity; i++)\r\n            {\r\n                bobs.push(_this.create(0, 0, singleFrame, visible));\r\n            }\r\n        });\r\n\r\n        return bobs;\r\n    },\r\n\r\n    /**\r\n     * Checks if the given child can render or not, by checking its `visible` and `alpha` values.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#childCanRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Bob} child - The Bob to check for rendering.\r\n     *\r\n     * @return {boolean} Returns `true` if the given child can render, otherwise `false`.\r\n     */\r\n    childCanRender: function (child)\r\n    {\r\n        return (child.visible && child.alpha > 0);\r\n    },\r\n\r\n    /**\r\n     * Returns an array of Bobs to be rendered.\r\n     * If the Blitter is dirty then a new list is generated and stored in `renderList`.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#getRenderList\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Bob[]} An array of Bob objects that will be rendered this frame.\r\n     */\r\n    getRenderList: function ()\r\n    {\r\n        if (this.dirty)\r\n        {\r\n            this.renderList = this.children.list.filter(this.childCanRender, this);\r\n            this.dirty = false;\r\n        }\r\n\r\n        return this.renderList;\r\n    },\r\n\r\n    /**\r\n     * Removes all Bobs from the children List and clears the dirty flag.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#clear\r\n     * @since 3.0.0\r\n     */\r\n    clear: function ()\r\n    {\r\n        this.children.removeAll();\r\n        this.dirty = true;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Blitter#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.children.destroy();\r\n\r\n        this.renderList = [];\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Blitter;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Blitter#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Blitter} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar BlitterCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var list = src.getRenderList();\r\n\r\n    if (list.length === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (alpha === 0)\r\n    {\r\n        //  Nothing to see, so abort early\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    //  Blend Mode + Scale Mode\r\n    ctx.globalCompositeOperation = renderer.blendModes[src.blendMode];\r\n\r\n    ctx.imageSmoothingEnabled = !(!renderer.antialias || src.frame.source.scaleMode);\r\n\r\n    var cameraScrollX = src.x - camera.scrollX * src.scrollFactorX;\r\n    var cameraScrollY = src.y - camera.scrollY * src.scrollFactorY;\r\n\r\n    ctx.save();\r\n\r\n    if (parentMatrix)\r\n    {\r\n        parentMatrix.copyToContext(ctx);\r\n    }\r\n\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    //  Render bobs\r\n    for (var i = 0; i < list.length; i++)\r\n    {\r\n        var bob = list[i];\r\n        var flip = (bob.flipX || bob.flipY);\r\n        var frame = bob.frame;\r\n        var cd = frame.canvasData;\r\n        var dx = frame.x;\r\n        var dy = frame.y;\r\n        var fx = 1;\r\n        var fy = 1;\r\n\r\n        var bobAlpha = bob.alpha * alpha;\r\n\r\n        if (bobAlpha === 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        ctx.globalAlpha = bobAlpha;\r\n\r\n        if (!flip)\r\n        {\r\n            if (roundPixels)\r\n            {\r\n                dx = Math.round(dx);\r\n                dy = Math.round(dy);\r\n            }\r\n\r\n            ctx.drawImage(\r\n                frame.source.image,\r\n                cd.x,\r\n                cd.y,\r\n                cd.width,\r\n                cd.height,\r\n                dx + bob.x + cameraScrollX,\r\n                dy + bob.y + cameraScrollY,\r\n                cd.width,\r\n                cd.height\r\n            );\r\n        }\r\n        else\r\n        {\r\n            if (bob.flipX)\r\n            {\r\n                fx = -1;\r\n                dx -= cd.width;\r\n            }\r\n\r\n            if (bob.flipY)\r\n            {\r\n                fy = -1;\r\n                dy -= cd.height;\r\n            }\r\n\r\n            ctx.save();\r\n            ctx.translate(bob.x + cameraScrollX, bob.y + cameraScrollY);\r\n            ctx.scale(fx, fy);\r\n            ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, dx, dy, cd.width, cd.height);\r\n            ctx.restore();\r\n        }\r\n    }\r\n\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = BlitterCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Blitter = require('./Blitter');\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\n\r\n/**\r\n * Creates a new Blitter Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Blitter Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#blitter\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Blitter} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('blitter', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var key = GetAdvancedValue(config, 'key', null);\r\n    var frame = GetAdvancedValue(config, 'frame', null);\r\n\r\n    var blitter = new Blitter(this.scene, 0, 0, key, frame);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, blitter, config);\r\n\r\n    return blitter;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Blitter = require('./Blitter');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Blitter Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Blitter Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#blitter\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The x position of the Game Object.\r\n * @param {number} y - The y position of the Game Object.\r\n * @param {string} key - The key of the Texture the Blitter object will use.\r\n * @param {(string|number)} [frame] - The default Frame children of the Blitter will use.\r\n *\r\n * @return {Phaser.GameObjects.Blitter} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('blitter', function (x, y, key, frame)\r\n{\r\n    return this.displayList.add(new Blitter(this.scene, x, y, key, frame));\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./BlitterWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./BlitterCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\nvar tempMatrix = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Blitter#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Blitter} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar BlitterWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var list = src.getRenderList();\r\n\r\n    if (list.length === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (alpha === 0)\r\n    {\r\n        //  Nothing to see, so abort early\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(this.pipeline, src);\r\n\r\n    var cameraScrollX = camera.scrollX * src.scrollFactorX;\r\n    var cameraScrollY = camera.scrollY * src.scrollFactorY;\r\n\r\n    var calcMatrix = tempMatrix.copyFrom(camera.matrix);\r\n\r\n    if (parentMatrix)\r\n    {\r\n        calcMatrix.multiplyWithOffset(parentMatrix, -cameraScrollX, -cameraScrollY);\r\n\r\n        cameraScrollX = 0;\r\n        cameraScrollY = 0;\r\n    }\r\n\r\n    var blitterX = src.x - cameraScrollX;\r\n    var blitterY = src.y - cameraScrollY;\r\n    var prevTextureSourceIndex = -1;\r\n    var tintEffect = false;\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    for (var index = 0; index < list.length; index++)\r\n    {\r\n        var bob = list[index];\r\n        var frame = bob.frame;\r\n        var bobAlpha = bob.alpha * alpha;\r\n\r\n        if (bobAlpha === 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var width = frame.width;\r\n        var height = frame.height;\r\n\r\n        var x = blitterX + bob.x + frame.x;\r\n        var y = blitterY + bob.y + frame.y;\r\n\r\n        if (bob.flipX)\r\n        {\r\n            width *= -1;\r\n            x += frame.width;\r\n        }\r\n\r\n        if (bob.flipY)\r\n        {\r\n            height *= -1;\r\n            y += frame.height;\r\n        }\r\n\r\n        var xw = x + width;\r\n        var yh = y + height;\r\n\r\n        var tx0 = calcMatrix.getX(x, y);\r\n        var ty0 = calcMatrix.getY(x, y);\r\n\r\n        var tx1 = calcMatrix.getX(xw, yh);\r\n        var ty1 = calcMatrix.getY(xw, yh);\r\n\r\n        var tint = Utils.getTintAppendFloatAlpha(bob.tint, bobAlpha);\r\n\r\n        //  Bind texture only if the Texture Source is different from before\r\n        if (frame.sourceIndex !== prevTextureSourceIndex)\r\n        {\r\n            var textureUnit = pipeline.setGameObject(src, frame);\r\n\r\n            prevTextureSourceIndex = frame.sourceIndex;\r\n        }\r\n\r\n        if (roundPixels)\r\n        {\r\n            tx0 = Math.round(tx0);\r\n            ty0 = Math.round(ty0);\r\n\r\n            tx1 = Math.round(tx1);\r\n            ty1 = Math.round(ty1);\r\n        }\r\n\r\n        //  TL x/y, BL x/y, BR x/y, TR x/y\r\n        if (pipeline.batchQuad(src, tx0, ty0, tx0, ty1, tx1, ty1, tx1, ty0, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, frame.glTexture, textureUnit))\r\n        {\r\n            prevTextureSourceIndex = -1;\r\n        }\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = BlitterWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Frame = require('../../textures/Frame');\r\n\r\n/**\r\n * @classdesc\r\n * A Bob Game Object.\r\n *\r\n * A Bob belongs to a Blitter Game Object. The Blitter is responsible for managing and rendering this object.\r\n *\r\n * A Bob has a position, alpha value and a frame from a texture that it uses to render with. You can also toggle\r\n * the flipped and visible state of the Bob. The Frame the Bob uses to render can be changed dynamically, but it\r\n * must be a Frame within the Texture used by the parent Blitter.\r\n *\r\n * Bob positions are relative to the Blitter parent. So if you move the Blitter parent, all Bob children will\r\n * have their positions impacted by this change as well.\r\n *\r\n * You can manipulate Bob objects directly from your game code, but the creation and destruction of them should be\r\n * handled via the Blitter parent.\r\n *\r\n * @class Bob\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Blitter} blitter - The parent Blitter object is responsible for updating this Bob.\r\n * @param {number} x - The horizontal position of this Game Object in the world, relative to the parent Blitter position.\r\n * @param {number} y - The vertical position of this Game Object in the world, relative to the parent Blitter position.\r\n * @param {(string|number)} frame - The Frame this Bob will render with, as defined in the Texture the parent Blitter is using.\r\n * @param {boolean} visible - Should the Bob render visible or not to start with?\r\n */\r\nvar Bob = new Class({\r\n\r\n    initialize:\r\n\r\n    function Bob (blitter, x, y, frame, visible)\r\n    {\r\n        /**\r\n         * The Blitter object that this Bob belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#parent\r\n         * @type {Phaser.GameObjects.Blitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.parent = blitter;\r\n\r\n        /**\r\n         * The x position of this Bob, relative to the x position of the Blitter.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.x = x;\r\n\r\n        /**\r\n         * The y position of this Bob, relative to the y position of the Blitter.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.y = y;\r\n\r\n        /**\r\n         * The frame that the Bob uses to render with.\r\n         * To change the frame use the `Bob.setFrame` method.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @protected\r\n         * @since 3.0.0\r\n         */\r\n        this.frame = frame;\r\n\r\n        /**\r\n         * A blank object which can be used to store data related to this Bob in.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#data\r\n         * @type {object}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = {};\r\n\r\n        /**\r\n         * The tint value of this Bob.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#tint\r\n         * @type {number}\r\n         * @default 0xffffff\r\n         * @since 3.20.0\r\n         */\r\n        this.tint = 0xffffff;\r\n\r\n        /**\r\n         * The visible state of this Bob.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#_visible\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._visible = visible;\r\n\r\n        /**\r\n         * The alpha value of this Bob.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#_alpha\r\n         * @type {number}\r\n         * @private\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this._alpha = 1;\r\n\r\n        /**\r\n         * The horizontally flipped state of the Bob.\r\n         * A Bob that is flipped horizontally will render inversed on the horizontal axis.\r\n         * Flipping always takes place from the middle of the texture.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#flipX\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.flipX = false;\r\n\r\n        /**\r\n         * The vertically flipped state of the Bob.\r\n         * A Bob that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\r\n         * Flipping always takes place from the middle of the texture.\r\n         *\r\n         * @name Phaser.GameObjects.Bob#flipY\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.flipY = false;\r\n    },\r\n\r\n    /**\r\n     * Changes the Texture Frame being used by this Bob.\r\n     * The frame must be part of the Texture the parent Blitter is using.\r\n     * If no value is given it will use the default frame of the Blitter parent.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number|Phaser.Textures.Frame)} [frame] - The frame to be used during rendering.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setFrame: function (frame)\r\n    {\r\n        if (frame === undefined)\r\n        {\r\n            this.frame = this.parent.frame;\r\n        }\r\n        else if (frame instanceof Frame && frame.texture === this.parent.texture)\r\n        {\r\n            this.frame = frame;\r\n        }\r\n        else\r\n        {\r\n            this.frame = this.parent.texture.get(frame);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets the horizontal and vertical flipped state of this Bob back to their default un-flipped state.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#resetFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    resetFlip: function ()\r\n    {\r\n        this.flipX = false;\r\n        this.flipY = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resets this Bob.\r\n     *\r\n     * Changes the position to the values given, and optionally changes the frame.\r\n     *\r\n     * Also resets the flipX and flipY values, sets alpha back to 1 and visible to true.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#reset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     * @param {number} y - The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     * @param {(string|number|Phaser.Textures.Frame)} [frame] - The Frame the Bob will use. It _must_ be part of the Texture the parent Blitter object is using.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    reset: function (x, y, frame)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        this.flipX = false;\r\n        this.flipY = false;\r\n\r\n        this._alpha = 1;\r\n        this._visible = true;\r\n\r\n        this.parent.dirty = true;\r\n\r\n        if (frame)\r\n        {\r\n            this.setFrame(frame);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Changes the position of this Bob to the values given.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setPosition\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} x - The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     * @param {number} y - The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setPosition: function (x, y)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal flipped state of this Bob.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setFlipX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setFlipX: function (value)\r\n    {\r\n        this.flipX = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical flipped state of this Bob.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setFlipY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The flipped state. `false` for no flip, or `true` to be flipped.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setFlipY: function (value)\r\n    {\r\n        this.flipY = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal and vertical flipped state of this Bob.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setFlip\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} x - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     * @param {boolean} y - The horizontal flipped state. `false` for no flip, or `true` to be flipped.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setFlip: function (x, y)\r\n    {\r\n        this.flipX = x;\r\n        this.flipY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the visibility of this Bob.\r\n     *\r\n     * An invisible Bob will skip rendering.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} value - The visible state of the Game Object.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setVisible: function (value)\r\n    {\r\n        this.visible = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the Alpha level of this Bob. The alpha controls the opacity of the Game Object as it renders.\r\n     * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.\r\n     *\r\n     * A Bob with alpha 0 will skip rendering.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The alpha value used for this Bob. Between 0 and 1.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setAlpha: function (value)\r\n    {\r\n        this.alpha = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the tint of this Bob.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#setTint\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} value - The tint value used for this Bob. Between 0 and 0xffffff.\r\n     *\r\n     * @return {this} This Bob Game Object.\r\n     */\r\n    setTint: function (value)\r\n    {\r\n        this.tint = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Bob instance.\r\n     * Removes itself from the Blitter and clears the parent, frame and data properties.\r\n     *\r\n     * @method Phaser.GameObjects.Bob#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.parent.dirty = true;\r\n\r\n        this.parent.children.remove(this);\r\n\r\n        this.parent = undefined;\r\n        this.frame = undefined;\r\n        this.data = undefined;\r\n    },\r\n\r\n    /**\r\n     * The visible state of the Bob.\r\n     *\r\n     * An invisible Bob will skip rendering.\r\n     *\r\n     * @name Phaser.GameObjects.Bob#visible\r\n     * @type {boolean}\r\n     * @since 3.0.0\r\n     */\r\n    visible: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._visible;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.parent.dirty |= (this._visible !== value);\r\n            this._visible = value;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The alpha value of the Bob, between 0 and 1.\r\n     *\r\n     * A Bob with alpha 0 will skip rendering.\r\n     *\r\n     * @name Phaser.GameObjects.Bob#alpha\r\n     * @type {number}\r\n     * @since 3.0.0\r\n     */\r\n    alpha: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._alpha;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.parent.dirty |= ((this._alpha > 0) !== (value > 0));\r\n            this._alpha = value;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Bob;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ArrayUtils = require('../../utils/array');\r\nvar BlendModes = require('../../renderer/BlendModes');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar Events = require('../events');\r\nvar GameObject = require('../GameObject');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar Render = require('./ContainerRender');\r\nvar Union = require('../../geom/rectangle/Union');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Container Game Object.\r\n *\r\n * A Container, as the name implies, can 'contain' other types of Game Object.\r\n * When a Game Object is added to a Container, the Container becomes responsible for the rendering of it.\r\n * By default it will be removed from the Display List and instead added to the Containers own internal list.\r\n *\r\n * The position of the Game Object automatically becomes relative to the position of the Container.\r\n *\r\n * The transform point of a Container is 0x0 (in local space) and that cannot be changed. The children you add to the\r\n * Container should be positioned with this value in mind. I.e. you should treat 0x0 as being the center of\r\n * the Container, and position children positively and negative around it as required.\r\n *\r\n * When the Container is rendered, all of its children are rendered as well, in the order in which they exist\r\n * within the Container. Container children can be repositioned using methods such as `MoveUp`, `MoveDown` and `SendToBack`.\r\n *\r\n * If you modify a transform property of the Container, such as `Container.x` or `Container.rotation` then it will\r\n * automatically influence all children as well.\r\n *\r\n * Containers can include other Containers for deeply nested transforms.\r\n *\r\n * Containers can have masks set on them and can be used as a mask too. However, Container children cannot be masked.\r\n * The masks do not 'stack up'. Only a Container on the root of the display list will use its mask.\r\n *\r\n * Containers can be enabled for input. Because they do not have a texture you need to provide a shape for them\r\n * to use as their hit area. Container children can also be enabled for input, independent of the Container.\r\n *\r\n * If input enabling a _child_ you should not set both the `origin` and a **negative** scale factor on the child,\r\n * or the input area will become misaligned.\r\n *\r\n * Containers can be given a physics body for either Arcade Physics, Impact Physics or Matter Physics. However,\r\n * if Container _children_ are enabled for physics you may get unexpected results, such as offset bodies,\r\n * if the Container itself, or any of its ancestors, is positioned anywhere other than at 0 x 0. Container children\r\n * with physics do not factor in the Container due to the excessive extra calculations needed. Please structure\r\n * your game to work around this.\r\n *\r\n * It's important to understand the impact of using Containers. They add additional processing overhead into\r\n * every one of their children. The deeper you nest them, the more the cost escalates. This is especially true\r\n * for input events. You also loose the ability to set the display depth of Container children in the same\r\n * flexible manner as those not within them. In short, don't use them for the sake of it. You pay a small cost\r\n * every time you create one, try to structure your game around avoiding that where possible.\r\n *\r\n * @class Container\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.4.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Container.\r\n */\r\nvar Container = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Container (scene, x, y, children)\r\n    {\r\n        GameObject.call(this, scene, 'Container');\r\n\r\n        /**\r\n         * An array holding the children of this Container.\r\n         *\r\n         * @name Phaser.GameObjects.Container#list\r\n         * @type {Phaser.GameObjects.GameObject[]}\r\n         * @since 3.4.0\r\n         */\r\n        this.list = [];\r\n\r\n        /**\r\n         * Does this Container exclusively manage its children?\r\n         *\r\n         * The default is `true` which means a child added to this Container cannot\r\n         * belong in another Container, which includes the Scene display list.\r\n         *\r\n         * If you disable this then this Container will no longer exclusively manage its children.\r\n         * This allows you to create all kinds of interesting graphical effects, such as replicating\r\n         * Game Objects without reparenting them all over the Scene.\r\n         * However, doing so will prevent children from receiving any kind of input event or have\r\n         * their physics bodies work by default, as they're no longer a single entity on the\r\n         * display list, but are being replicated where-ever this Container is.\r\n         *\r\n         * @name Phaser.GameObjects.Container#exclusive\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.4.0\r\n         */\r\n        this.exclusive = true;\r\n\r\n        /**\r\n         * Containers can have an optional maximum size. If set to anything above 0 it\r\n         * will constrict the addition of new Game Objects into the Container, capping off\r\n         * the maximum limit the Container can grow in size to.\r\n         *\r\n         * @name Phaser.GameObjects.Container#maxSize\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.4.0\r\n         */\r\n        this.maxSize = -1;\r\n\r\n        /**\r\n         * The cursor position.\r\n         *\r\n         * @name Phaser.GameObjects.Container#position\r\n         * @type {number}\r\n         * @since 3.4.0\r\n         */\r\n        this.position = 0;\r\n\r\n        /**\r\n         * Internal Transform Matrix used for local space conversion.\r\n         *\r\n         * @name Phaser.GameObjects.Container#localTransform\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.4.0\r\n         */\r\n        this.localTransform = new Components.TransformMatrix();\r\n\r\n        /**\r\n         * Internal temporary Transform Matrix used to avoid object creation.\r\n         *\r\n         * @name Phaser.GameObjects.Container#tempTransformMatrix\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this.tempTransformMatrix = new Components.TransformMatrix();\r\n\r\n        /**\r\n         * The property key to sort by.\r\n         *\r\n         * @name Phaser.GameObjects.Container#_sortKey\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._sortKey = '';\r\n\r\n        /**\r\n         * A reference to the Scene Systems Event Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Container#_sysEvents\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @private\r\n         * @since 3.9.0\r\n         */\r\n        this._sysEvents = scene.sys.events;\r\n\r\n        /**\r\n         * The horizontal scroll factor of this Container.\r\n         *\r\n         * The scroll factor controls the influence of the movement of a Camera upon this Container.\r\n         *\r\n         * When a camera scrolls it will change the location at which this Container is rendered on-screen.\r\n         * It does not change the Containers actual position values.\r\n         *\r\n         * For a Container, setting this value will only update the Container itself, not its children.\r\n         * If you wish to change the scrollFactor of the children as well, use the `setScrollFactor` method.\r\n         *\r\n         * A value of 1 means it will move exactly in sync with a camera.\r\n         * A value of 0 means it will not move at all, even if the camera moves.\r\n         * Other values control the degree to which the camera movement is mapped to this Container.\r\n         *\r\n         * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n         * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n         * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n         * them from physics bodies if not accounted for in your code.\r\n         *\r\n         * @name Phaser.GameObjects.Container#scrollFactorX\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.4.0\r\n         */\r\n        this.scrollFactorX = 1;\r\n\r\n        /**\r\n         * The vertical scroll factor of this Container.\r\n         *\r\n         * The scroll factor controls the influence of the movement of a Camera upon this Container.\r\n         *\r\n         * When a camera scrolls it will change the location at which this Container is rendered on-screen.\r\n         * It does not change the Containers actual position values.\r\n         *\r\n         * For a Container, setting this value will only update the Container itself, not its children.\r\n         * If you wish to change the scrollFactor of the children as well, use the `setScrollFactor` method.\r\n         *\r\n         * A value of 1 means it will move exactly in sync with a camera.\r\n         * A value of 0 means it will not move at all, even if the camera moves.\r\n         * Other values control the degree to which the camera movement is mapped to this Container.\r\n         *\r\n         * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n         * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n         * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n         * them from physics bodies if not accounted for in your code.\r\n         *\r\n         * @name Phaser.GameObjects.Container#scrollFactorY\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.4.0\r\n         */\r\n        this.scrollFactorY = 1;\r\n\r\n        this.initPipeline();\r\n\r\n        this.setPosition(x, y);\r\n\r\n        this.clearAlpha();\r\n\r\n        this.setBlendMode(BlendModes.SKIP_CHECK);\r\n\r\n        if (children)\r\n        {\r\n            this.add(children);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#originX\r\n     * @type {number}\r\n     * @readonly\r\n     * @override\r\n     * @since 3.4.0\r\n     */\r\n    originX: {\r\n\r\n        get: function ()\r\n        {\r\n            return 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#originY\r\n     * @type {number}\r\n     * @readonly\r\n     * @override\r\n     * @since 3.4.0\r\n     */\r\n    originY: {\r\n\r\n        get: function ()\r\n        {\r\n            return 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#displayOriginX\r\n     * @type {number}\r\n     * @readonly\r\n     * @override\r\n     * @since 3.4.0\r\n     */\r\n    displayOriginX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.width * 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal value to allow Containers to be used for input and physics.\r\n     * Do not change this value. It has no effect other than to break things.\r\n     *\r\n     * @name Phaser.GameObjects.Container#displayOriginY\r\n     * @type {number}\r\n     * @readonly\r\n     * @override\r\n     * @since 3.4.0\r\n     */\r\n    displayOriginY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.height * 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Does this Container exclusively manage its children?\r\n     *\r\n     * The default is `true` which means a child added to this Container cannot\r\n     * belong in another Container, which includes the Scene display list.\r\n     *\r\n     * If you disable this then this Container will no longer exclusively manage its children.\r\n     * This allows you to create all kinds of interesting graphical effects, such as replicating\r\n     * Game Objects without reparenting them all over the Scene.\r\n     * However, doing so will prevent children from receiving any kind of input event or have\r\n     * their physics bodies work by default, as they're no longer a single entity on the\r\n     * display list, but are being replicated where-ever this Container is.\r\n     *\r\n     * @method Phaser.GameObjects.Container#setExclusive\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} [value=true] - The exclusive state of this Container.\r\n     *\r\n     * @return {this} This Container.\r\n     */\r\n    setExclusive: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.exclusive = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the bounds of this Container. It works by iterating all children of the Container,\r\n     * getting their respective bounds, and then working out a min-max rectangle from that.\r\n     * It does not factor in if the children render or not, all are included.\r\n     *\r\n     * Some children are unable to return their bounds, such as Graphics objects, in which case\r\n     * they are skipped.\r\n     *\r\n     * Depending on the quantity of children in this Container it could be a really expensive call,\r\n     * so cache it and only poll it as needed.\r\n     *\r\n     * The values are stored and returned in a Rectangle object.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getBounds\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [output] - A Geom.Rectangle object to store the values in. If not provided a new Rectangle will be created.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} The values stored in the output object.\r\n     */\r\n    getBounds: function (output)\r\n    {\r\n        if (output === undefined) { output = new Rectangle(); }\r\n\r\n        output.setTo(this.x, this.y, 0, 0);\r\n\r\n        if (this.parentContainer)\r\n        {\r\n            var parentMatrix = this.parentContainer.getBoundsTransformMatrix();\r\n            var transformedPosition = parentMatrix.transformPoint(this.x, this.y);\r\n\r\n            output.setTo(transformedPosition.x, transformedPosition.y, 0, 0);\r\n        }\r\n\r\n        if (this.list.length > 0)\r\n        {\r\n            var children = this.list;\r\n            var tempRect = new Rectangle();\r\n            var hasSetFirst = false;\r\n\r\n            output.setEmpty();\r\n\r\n            for (var i = 0; i < children.length; i++)\r\n            {\r\n                var entry = children[i];\r\n\r\n                if (entry.getBounds)\r\n                {\r\n                    entry.getBounds(tempRect);\r\n\r\n                    if (!hasSetFirst)\r\n                    {\r\n                        output.setTo(tempRect.x, tempRect.y, tempRect.width, tempRect.height);\r\n                        hasSetFirst = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        Union(tempRect, output, output);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Internal add handler.\r\n     *\r\n     * @method Phaser.GameObjects.Container#addHandler\r\n     * @private\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just added to this Container.\r\n     */\r\n    addHandler: function (gameObject)\r\n    {\r\n        gameObject.once(Events.DESTROY, this.remove, this);\r\n\r\n        if (this.exclusive)\r\n        {\r\n            if (gameObject.parentContainer)\r\n            {\r\n                gameObject.parentContainer.remove(gameObject);\r\n            }\r\n\r\n            gameObject.removeFromDisplayList();\r\n\r\n            gameObject.parentContainer = this;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal remove handler.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeHandler\r\n     * @private\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was just removed from this Container.\r\n     */\r\n    removeHandler: function (gameObject)\r\n    {\r\n        gameObject.off(Events.DESTROY, this.remove);\r\n\r\n        if (this.exclusive)\r\n        {\r\n            gameObject.parentContainer = null;\r\n\r\n            gameObject.addToDisplayList();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes a Point-like object, such as a Vector2, Geom.Point or object with public x and y properties,\r\n     * and transforms it into the space of this Container, then returns it in the output object.\r\n     *\r\n     * @method Phaser.GameObjects.Container#pointToContainer\r\n     * @since 3.4.0\r\n     *\r\n     * @param {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} source - The Source Point to be transformed.\r\n     * @param {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} [output] - A destination object to store the transformed point in. If none given a Vector2 will be created and returned.\r\n     *\r\n     * @return {(object|Phaser.Geom.Point|Phaser.Math.Vector2)} The transformed point.\r\n     */\r\n    pointToContainer: function (source, output)\r\n    {\r\n        if (output === undefined) { output = new Vector2(); }\r\n\r\n        if (this.parentContainer)\r\n        {\r\n            this.parentContainer.pointToContainer(source, output);\r\n        }\r\n        else\r\n        {\r\n            output = new Vector2(source.x, source.y);\r\n        }\r\n\r\n        var tempMatrix = this.tempTransformMatrix;\r\n\r\n        //  No need to loadIdentity because applyITRS overwrites every value anyway\r\n        tempMatrix.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY);\r\n\r\n        tempMatrix.invert();\r\n\r\n        tempMatrix.transformPoint(source.x, source.y, output);\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Returns the world transform matrix as used for Bounds checks.\r\n     *\r\n     * The returned matrix is temporal and shouldn't be stored.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getBoundsTransformMatrix\r\n     * @since 3.4.0\r\n     *\r\n     * @return {Phaser.GameObjects.Components.TransformMatrix} The world transform matrix.\r\n     */\r\n    getBoundsTransformMatrix: function ()\r\n    {\r\n        return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform);\r\n    },\r\n\r\n    /**\r\n     * Adds the given Game Object, or array of Game Objects, to this Container.\r\n     *\r\n     * Each Game Object must be unique within the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#add\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to add to the Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    add: function (child)\r\n    {\r\n        ArrayUtils.Add(this.list, child, this.maxSize, this.addHandler, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds the given Game Object, or array of Game Objects, to this Container at the specified position.\r\n     *\r\n     * Existing Game Objects in the Container are shifted up.\r\n     *\r\n     * Each Game Object must be unique within the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#addAt\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to add to the Container.\r\n     * @param {number} [index=0] - The position to insert the Game Object/s at.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    addAt: function (child, index)\r\n    {\r\n        ArrayUtils.AddAt(this.list, child, index, this.maxSize, this.addHandler, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the Game Object at the given position in this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getAt\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} index - The position to get the Game Object from.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} The Game Object at the specified index, or `null` if none found.\r\n     */\r\n    getAt: function (index)\r\n    {\r\n        return this.list[index];\r\n    },\r\n\r\n    /**\r\n     * Returns the index of the given Game Object in this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getIndex\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to search for in this Container.\r\n     *\r\n     * @return {number} The index of the Game Object in this Container, or -1 if not found.\r\n     */\r\n    getIndex: function (child)\r\n    {\r\n        return this.list.indexOf(child);\r\n    },\r\n\r\n    /**\r\n     * Sort the contents of this Container so the items are in order based on the given property.\r\n     * For example: `sort('alpha')` would sort the elements based on the value of their `alpha` property.\r\n     *\r\n     * @method Phaser.GameObjects.Container#sort\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property to lexically sort by.\r\n     * @param {function} [handler] - Provide your own custom handler function. Will receive 2 children which it should compare and return a boolean.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    sort: function (property, handler)\r\n    {\r\n        if (!property)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (handler === undefined)\r\n        {\r\n            handler = function (childA, childB)\r\n            {\r\n                return childA[property] - childB[property];\r\n            };\r\n        }\r\n\r\n        ArrayUtils.StableSort(this.list, handler);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Searches for the first instance of a child with its `name` property matching the given argument.\r\n     * Should more than one child have the same name only the first is returned.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getByName\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} name - The name to search for.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} The first child with a matching name, or `null` if none were found.\r\n     */\r\n    getByName: function (name)\r\n    {\r\n        return ArrayUtils.GetFirst(this.list, 'name', name);\r\n    },\r\n\r\n    /**\r\n     * Returns a random Game Object from this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getRandom\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [startIndex=0] - An optional start index.\r\n     * @param {number} [length] - An optional length, the total number of elements (from the startIndex) to choose from.\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} A random child from the Container, or `null` if the Container is empty.\r\n     */\r\n    getRandom: function (startIndex, length)\r\n    {\r\n        return ArrayUtils.GetRandom(this.list, startIndex, length);\r\n    },\r\n\r\n    /**\r\n     * Gets the first Game Object in this Container.\r\n     *\r\n     * You can also specify a property and value to search for, in which case it will return the first\r\n     * Game Object in this Container with a matching property and / or value.\r\n     *\r\n     * For example: `getFirst('visible', true)` would return the first Game Object that had its `visible` property set.\r\n     *\r\n     * You can limit the search to the `startIndex` - `endIndex` range.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getFirst\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property to test on each Game Object in the Container.\r\n     * @param {*} value - The value to test the property against. Must pass a strict (`===`) comparison check.\r\n     * @param {number} [startIndex=0] - An optional start index to search from.\r\n     * @param {number} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {?Phaser.GameObjects.GameObject} The first matching Game Object, or `null` if none was found.\r\n     */\r\n    getFirst: function (property, value, startIndex, endIndex)\r\n    {\r\n        return ArrayUtils.GetFirst(this.list, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Returns all Game Objects in this Container.\r\n     *\r\n     * You can optionally specify a matching criteria using the `property` and `value` arguments.\r\n     *\r\n     * For example: `getAll('body')` would return only Game Objects that have a body property.\r\n     *\r\n     * You can also specify a value to compare the property to:\r\n     *\r\n     * `getAll('visible', true)` would return only Game Objects that have their visible property set to `true`.\r\n     *\r\n     * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,\r\n     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n     * the first 50 Game Objects.\r\n     *\r\n     * @method Phaser.GameObjects.Container#getAll\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} [property] - The property to test on each Game Object in the Container.\r\n     * @param {any} [value] - If property is set then the `property` must strictly equal this value to be included in the results.\r\n     * @param {number} [startIndex=0] - An optional start index to search from.\r\n     * @param {number} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} An array of matching Game Objects from this Container.\r\n     */\r\n    getAll: function (property, value, startIndex, endIndex)\r\n    {\r\n        return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Returns the total number of Game Objects in this Container that have a property\r\n     * matching the given value.\r\n     *\r\n     * For example: `count('visible', true)` would count all the elements that have their visible property set.\r\n     *\r\n     * You can optionally limit the operation to the `startIndex` - `endIndex` range.\r\n     *\r\n     * @method Phaser.GameObjects.Container#count\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property to check.\r\n     * @param {any} value - The value to check.\r\n     * @param {number} [startIndex=0] - An optional start index to search from.\r\n     * @param {number} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {number} The total number of Game Objects in this Container with a property matching the given value.\r\n     */\r\n    count: function (property, value, startIndex, endIndex)\r\n    {\r\n        return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);\r\n    },\r\n\r\n    /**\r\n     * Swaps the position of two Game Objects in this Container.\r\n     * Both Game Objects must belong to this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#swap\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child1 - The first Game Object to swap.\r\n     * @param {Phaser.GameObjects.GameObject} child2 - The second Game Object to swap.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    swap: function (child1, child2)\r\n    {\r\n        ArrayUtils.Swap(this.list, child1, child2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Game Object to a new position within this Container.\r\n     *\r\n     * The Game Object must already be a child of this Container.\r\n     *\r\n     * The Game Object is removed from its old position and inserted into the new one.\r\n     * Therefore the Container size does not change. Other children will change position accordingly.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveTo\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to move.\r\n     * @param {number} index - The new position of the Game Object in this Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    moveTo: function (child, index)\r\n    {\r\n        ArrayUtils.MoveTo(this.list, child, index);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Game Object above another one within this Container.\r\n     *\r\n     * These 2 Game Objects must already be children of this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveAbove\r\n     * @since 3.55.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child1 - The Game Object to move above base Game Object.\r\n     * @param {Phaser.GameObjects.GameObject} child2 - The base Game Object.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    moveAbove: function (child1, child2)\r\n    {\r\n        ArrayUtils.MoveAbove(this.list, child1, child2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Game Object below another one within this Container.\r\n     *\r\n     * These 2 Game Objects must already be children of this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveBelow\r\n     * @since 3.55.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child1 - The Game Object to move below base Game Object.\r\n     * @param {Phaser.GameObjects.GameObject} child2 - The base Game Object.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    moveBelow: function (child1, child2)\r\n    {\r\n        ArrayUtils.MoveBelow(this.list, child1, child2);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the given Game Object, or array of Game Objects, from this Container.\r\n     *\r\n     * The Game Objects must already be children of this Container.\r\n     *\r\n     * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#remove\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} child - The Game Object, or array of Game Objects, to be removed from the Container.\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each child successfully removed from this Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    remove: function (child, destroyChild)\r\n    {\r\n        var removed = ArrayUtils.Remove(this.list, child, this.removeHandler, this);\r\n\r\n        if (destroyChild && removed)\r\n        {\r\n            if (!Array.isArray(removed))\r\n            {\r\n                removed = [ removed ];\r\n            }\r\n\r\n            for (var i = 0; i < removed.length; i++)\r\n            {\r\n                removed[i].destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the Game Object at the given position in this Container.\r\n     *\r\n     * You can also optionally call `destroy` on the Game Object, if one is found.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeAt\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} index - The index of the Game Object to be removed.\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on the Game Object if successfully removed from this Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    removeAt: function (index, destroyChild)\r\n    {\r\n        var removed = ArrayUtils.RemoveAt(this.list, index, this.removeHandler, this);\r\n\r\n        if (destroyChild && removed)\r\n        {\r\n            removed.destroy();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the Game Objects between the given positions in this Container.\r\n     *\r\n     * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeBetween\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} [startIndex=0] - An optional start index to search from.\r\n     * @param {number} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each Game Object successfully removed from this Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    removeBetween: function (startIndex, endIndex, destroyChild)\r\n    {\r\n        var removed = ArrayUtils.RemoveBetween(this.list, startIndex, endIndex, this.removeHandler, this);\r\n\r\n        if (destroyChild)\r\n        {\r\n            for (var i = 0; i < removed.length; i++)\r\n            {\r\n                removed[i].destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes all Game Objects from this Container.\r\n     *\r\n     * You can also optionally call `destroy` on each Game Object that is removed from the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#removeAll\r\n     * @since 3.4.0\r\n     *\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on each Game Object successfully removed from this Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    removeAll: function (destroyChild)\r\n    {\r\n        var removed = ArrayUtils.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this);\r\n\r\n        if (destroyChild)\r\n        {\r\n            for (var i = 0; i < removed.length; i++)\r\n            {\r\n                removed[i].destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Brings the given Game Object to the top of this Container.\r\n     * This will cause it to render on-top of any other objects in the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#bringToTop\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to bring to the top of the Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    bringToTop: function (child)\r\n    {\r\n        ArrayUtils.BringToTop(this.list, child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sends the given Game Object to the bottom of this Container.\r\n     * This will cause it to render below any other objects in the Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#sendToBack\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to send to the bottom of the Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    sendToBack: function (child)\r\n    {\r\n        ArrayUtils.SendToBack(this.list, child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves the given Game Object up one place in this Container, unless it's already at the top.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveUp\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to be moved in the Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    moveUp: function (child)\r\n    {\r\n        ArrayUtils.MoveUp(this.list, child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves the given Game Object down one place in this Container, unless it's already at the bottom.\r\n     *\r\n     * @method Phaser.GameObjects.Container#moveDown\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to be moved in the Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    moveDown: function (child)\r\n    {\r\n        ArrayUtils.MoveDown(this.list, child);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Reverses the order of all Game Objects in this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#reverse\r\n     * @since 3.4.0\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    reverse: function ()\r\n    {\r\n        this.list.reverse();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shuffles the all Game Objects in this Container using the Fisher-Yates implementation.\r\n     *\r\n     * @method Phaser.GameObjects.Container#shuffle\r\n     * @since 3.4.0\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    shuffle: function ()\r\n    {\r\n        ArrayUtils.Shuffle(this.list);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Replaces a Game Object in this Container with the new Game Object.\r\n     * The new Game Object cannot already be a child of this Container.\r\n     *\r\n     * @method Phaser.GameObjects.Container#replace\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} oldChild - The Game Object in this Container that will be replaced.\r\n     * @param {Phaser.GameObjects.GameObject} newChild - The Game Object to be added to this Container.\r\n     * @param {boolean} [destroyChild=false] - Optionally call `destroy` on the Game Object if successfully removed from this Container.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    replace: function (oldChild, newChild, destroyChild)\r\n    {\r\n        var moved = ArrayUtils.Replace(this.list, oldChild, newChild);\r\n\r\n        if (moved)\r\n        {\r\n            this.addHandler(newChild);\r\n            this.removeHandler(oldChild);\r\n\r\n            if (destroyChild)\r\n            {\r\n                oldChild.destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns `true` if the given Game Object is a direct child of this Container.\r\n     *\r\n     * This check does not scan nested Containers.\r\n     *\r\n     * @method Phaser.GameObjects.Container#exists\r\n     * @since 3.4.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} child - The Game Object to check for within this Container.\r\n     *\r\n     * @return {boolean} True if the Game Object is an immediate child of this Container, otherwise false.\r\n     */\r\n    exists: function (child)\r\n    {\r\n        return (this.list.indexOf(child) > -1);\r\n    },\r\n\r\n    /**\r\n     * Sets the property to the given value on all Game Objects in this Container.\r\n     *\r\n     * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,\r\n     * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only\r\n     * the first 50 Game Objects.\r\n     *\r\n     * @method Phaser.GameObjects.Container#setAll\r\n     * @since 3.4.0\r\n     *\r\n     * @param {string} property - The property that must exist on the Game Object.\r\n     * @param {any} value - The value to get the property to.\r\n     * @param {number} [startIndex=0] - An optional start index to search from.\r\n     * @param {number} [endIndex=Container.length] - An optional end index to search up to (but not included)\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    setAll: function (property, value, startIndex, endIndex)\r\n    {\r\n        ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * @callback EachContainerCallback\r\n     * @generic I - [item]\r\n     *\r\n     * @param {*} item - The child Game Object of the Container.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     */\r\n\r\n    /**\r\n     * Passes all Game Objects in this Container to the given callback.\r\n     *\r\n     * A copy of the Container is made before passing each entry to your callback.\r\n     * This protects against the callback itself modifying the Container.\r\n     *\r\n     * If you know for sure that the callback will not change the size of this Container\r\n     * then you can use the more performant `Container.iterate` method instead.\r\n     *\r\n     * @method Phaser.GameObjects.Container#each\r\n     * @since 3.4.0\r\n     *\r\n     * @param {function} callback - The function to call.\r\n     * @param {object} [context] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    each: function (callback, context)\r\n    {\r\n        var args = [ null ];\r\n        var i;\r\n        var temp = this.list.slice();\r\n        var len = temp.length;\r\n\r\n        for (i = 2; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            args[0] = temp[i];\r\n\r\n            callback.apply(context, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Passes all Game Objects in this Container to the given callback.\r\n     *\r\n     * Only use this method when you absolutely know that the Container will not be modified during\r\n     * the iteration, i.e. by removing or adding to its contents.\r\n     *\r\n     * @method Phaser.GameObjects.Container#iterate\r\n     * @since 3.4.0\r\n     *\r\n     * @param {function} callback - The function to call.\r\n     * @param {object} [context] - Value to use as `this` when executing callback.\r\n     * @param {...*} [args] - Additional arguments that will be passed to the callback, after the child.\r\n     *\r\n     * @return {this} This Container instance.\r\n     */\r\n    iterate: function (callback, context)\r\n    {\r\n        var args = [ null ];\r\n        var i;\r\n\r\n        for (i = 2; i < arguments.length; i++)\r\n        {\r\n            args.push(arguments[i]);\r\n        }\r\n\r\n        for (i = 0; i < this.list.length; i++)\r\n        {\r\n            args[0] = this.list[i];\r\n\r\n            callback.apply(context, args);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scroll factor of this Container and optionally all of its children.\r\n     *\r\n     * The scroll factor controls the influence of the movement of a Camera upon this Game Object.\r\n     *\r\n     * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.\r\n     * It does not change the Game Objects actual position values.\r\n     *\r\n     * A value of 1 means it will move exactly in sync with a camera.\r\n     * A value of 0 means it will not move at all, even if the camera moves.\r\n     * Other values control the degree to which the camera movement is mapped to this Game Object.\r\n     *\r\n     * Please be aware that scroll factor values other than 1 are not taken in to consideration when\r\n     * calculating physics collisions. Bodies always collide based on their world position, but changing\r\n     * the scroll factor is a visual adjustment to where the textures are rendered, which can offset\r\n     * them from physics bodies if not accounted for in your code.\r\n     *\r\n     * @method Phaser.GameObjects.Container#setScrollFactor\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - The horizontal scroll factor of this Game Object.\r\n     * @param {number} [y=x] - The vertical scroll factor of this Game Object. If not set it will use the `x` value.\r\n     * @param {boolean} [updateChildren=false] - Apply this scrollFactor to all Container children as well?\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setScrollFactor: function (x, y, updateChildren)\r\n    {\r\n        if (y === undefined) { y = x; }\r\n        if (updateChildren === undefined) { updateChildren = false; }\r\n\r\n        this.scrollFactorX = x;\r\n        this.scrollFactorY = y;\r\n\r\n        if (updateChildren)\r\n        {\r\n            ArrayUtils.SetAll(this.list, 'scrollFactorX', x);\r\n            ArrayUtils.SetAll(this.list, 'scrollFactorY', y);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The number of Game Objects inside this Container.\r\n     *\r\n     * @name Phaser.GameObjects.Container#length\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    length: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.list.length;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the first Game Object within the Container, or `null` if it is empty.\r\n     *\r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#first\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    first: {\r\n\r\n        get: function ()\r\n        {\r\n            this.position = 0;\r\n\r\n            if (this.list.length > 0)\r\n            {\r\n                return this.list[0];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the last Game Object within the Container, or `null` if it is empty.\r\n     *\r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#last\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    last: {\r\n\r\n        get: function ()\r\n        {\r\n            if (this.list.length > 0)\r\n            {\r\n                this.position = this.list.length - 1;\r\n\r\n                return this.list[this.position];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the next Game Object within the Container, or `null` if it is empty.\r\n     *\r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#next\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    next: {\r\n\r\n        get: function ()\r\n        {\r\n            if (this.position < this.list.length)\r\n            {\r\n                this.position++;\r\n\r\n                return this.list[this.position];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Returns the previous Game Object within the Container, or `null` if it is empty.\r\n     *\r\n     * You can move the cursor by calling `Container.next` and `Container.previous`.\r\n     *\r\n     * @name Phaser.GameObjects.Container#previous\r\n     * @type {?Phaser.GameObjects.GameObject}\r\n     * @readonly\r\n     * @since 3.4.0\r\n     */\r\n    previous: {\r\n\r\n        get: function ()\r\n        {\r\n            if (this.position > 0)\r\n            {\r\n                this.position--;\r\n\r\n                return this.list[this.position];\r\n            }\r\n            else\r\n            {\r\n                return null;\r\n            }\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Container#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.removeAll(!!this.exclusive);\r\n\r\n        this.localTransform.destroy();\r\n        this.tempTransformMatrix.destroy();\r\n\r\n        this.list = [];\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Container;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Container#renderCanvas\r\n * @since 3.4.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Container} container - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ContainerCanvasRenderer = function (renderer, container, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(container);\r\n\r\n    var children = container.list;\r\n\r\n    if (children.length === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var transformMatrix = container.localTransform;\r\n\r\n    if (parentMatrix)\r\n    {\r\n        transformMatrix.loadIdentity();\r\n        transformMatrix.multiply(parentMatrix);\r\n        transformMatrix.translate(container.x, container.y);\r\n        transformMatrix.rotate(container.rotation);\r\n        transformMatrix.scale(container.scaleX, container.scaleY);\r\n    }\r\n    else\r\n    {\r\n        transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);\r\n    }\r\n\r\n    var containerHasBlendMode = (container.blendMode !== -1);\r\n\r\n    if (!containerHasBlendMode)\r\n    {\r\n        //  If Container is SKIP_TEST then set blend mode to be Normal\r\n        renderer.setBlendMode(0);\r\n    }\r\n\r\n    var alpha = container._alpha;\r\n    var scrollFactorX = container.scrollFactorX;\r\n    var scrollFactorY = container.scrollFactorY;\r\n\r\n    if (container.mask)\r\n    {\r\n        container.mask.preRenderCanvas(renderer, null, camera);\r\n    }\r\n\r\n    for (var i = 0; i < children.length; i++)\r\n    {\r\n        var child = children[i];\r\n\r\n        if (!child.willRender(camera))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var childAlpha = child.alpha;\r\n        var childScrollFactorX = child.scrollFactorX;\r\n        var childScrollFactorY = child.scrollFactorY;\r\n\r\n        if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode)\r\n        {\r\n            //  If Container doesn't have its own blend mode, then a child can have one\r\n            renderer.setBlendMode(child.blendMode);\r\n        }\r\n\r\n        //  Set parent values\r\n        child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);\r\n        child.setAlpha(childAlpha * alpha);\r\n\r\n        //  Render\r\n        child.renderCanvas(renderer, child, camera, transformMatrix);\r\n\r\n        //  Restore original values\r\n        child.setAlpha(childAlpha);\r\n        child.setScrollFactor(childScrollFactorX, childScrollFactorY);\r\n    }\r\n\r\n    if (container.mask)\r\n    {\r\n        container.mask.postRenderCanvas(renderer);\r\n    }\r\n};\r\n\r\nmodule.exports = ContainerCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar Container = require('./Container');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\n\r\n/**\r\n * Creates a new Container Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Container Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#container\r\n * @since 3.4.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Container} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('container', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var x = GetAdvancedValue(config, 'x', 0);\r\n    var y = GetAdvancedValue(config, 'y', 0);\r\n    var children = GetAdvancedValue(config, 'children', null);\r\n\r\n    var container = new Container(this.scene, x, y, children);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, container, config);\r\n\r\n    return container;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Container = require('./Container');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Container Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Container Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#container\r\n * @since 3.4.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Container.\r\n *\r\n * @return {Phaser.GameObjects.Container} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('container', function (x, y, children)\r\n{\r\n    return this.displayList.add(new Container(this.scene, x, y, children));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./ContainerWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./ContainerCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Container#renderWebGL\r\n * @since 3.4.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Container} container - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ContainerWebGLRenderer = function (renderer, container, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(container);\r\n\r\n    var children = container.list;\r\n    var childCount = children.length;\r\n\r\n    if (childCount === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var transformMatrix = container.localTransform;\r\n\r\n    if (parentMatrix)\r\n    {\r\n        transformMatrix.loadIdentity();\r\n        transformMatrix.multiply(parentMatrix);\r\n        transformMatrix.translate(container.x, container.y);\r\n        transformMatrix.rotate(container.rotation);\r\n        transformMatrix.scale(container.scaleX, container.scaleY);\r\n    }\r\n    else\r\n    {\r\n        transformMatrix.applyITRS(container.x, container.y, container.rotation, container.scaleX, container.scaleY);\r\n    }\r\n\r\n    renderer.pipelines.preBatch(container);\r\n\r\n    var containerHasBlendMode = (container.blendMode !== -1);\r\n\r\n    if (!containerHasBlendMode)\r\n    {\r\n        //  If Container is SKIP_TEST then set blend mode to be Normal\r\n        renderer.setBlendMode(0);\r\n    }\r\n\r\n    var alpha = container.alpha;\r\n\r\n    var scrollFactorX = container.scrollFactorX;\r\n    var scrollFactorY = container.scrollFactorY;\r\n\r\n    for (var i = 0; i < childCount; i++)\r\n    {\r\n        var child = children[i];\r\n\r\n        if (!child.willRender(camera))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var childAlphaTopLeft;\r\n        var childAlphaTopRight;\r\n        var childAlphaBottomLeft;\r\n        var childAlphaBottomRight;\r\n\r\n        if (child.alphaTopLeft !== undefined)\r\n        {\r\n            childAlphaTopLeft = child.alphaTopLeft;\r\n            childAlphaTopRight = child.alphaTopRight;\r\n            childAlphaBottomLeft = child.alphaBottomLeft;\r\n            childAlphaBottomRight = child.alphaBottomRight;\r\n        }\r\n        else\r\n        {\r\n            var childAlpha = child.alpha;\r\n\r\n            childAlphaTopLeft = childAlpha;\r\n            childAlphaTopRight = childAlpha;\r\n            childAlphaBottomLeft = childAlpha;\r\n            childAlphaBottomRight = childAlpha;\r\n        }\r\n\r\n        var childScrollFactorX = child.scrollFactorX;\r\n        var childScrollFactorY = child.scrollFactorY;\r\n\r\n        if (!containerHasBlendMode && child.blendMode !== renderer.currentBlendMode)\r\n        {\r\n            //  If Container doesn't have its own blend mode, then a child can have one\r\n            renderer.setBlendMode(child.blendMode);\r\n        }\r\n\r\n        var mask = child.mask;\r\n\r\n        if (mask)\r\n        {\r\n            mask.preRenderWebGL(renderer, child, camera);\r\n        }\r\n\r\n        var type = child.type;\r\n\r\n        if (type !== renderer.currentType)\r\n        {\r\n            renderer.newType = true;\r\n            renderer.currentType = type;\r\n        }\r\n\r\n        renderer.nextTypeMatch = (i < childCount - 1) ? (children[i + 1].type === renderer.currentType) : false;\r\n\r\n        //  Set parent values\r\n        child.setScrollFactor(childScrollFactorX * scrollFactorX, childScrollFactorY * scrollFactorY);\r\n\r\n        child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);\r\n\r\n        //  Render\r\n        child.renderWebGL(renderer, child, camera, transformMatrix);\r\n\r\n        //  Restore original values\r\n\r\n        child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);\r\n\r\n        child.setScrollFactor(childScrollFactorX, childScrollFactorY);\r\n\r\n        if (mask)\r\n        {\r\n            mask.postRenderWebGL(renderer, camera);\r\n        }\r\n\r\n        renderer.newType = false;\r\n    }\r\n\r\n    renderer.pipelines.postBatch(container);\r\n};\r\n\r\nmodule.exports = ContainerWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Phaser Blend Modes to CSS Blend Modes Map.\r\n *\r\n * @name Phaser.CSSBlendModes\r\n * @ignore\r\n * @enum {string}\r\n * @memberof Phaser\r\n * @readonly\r\n * @since 3.12.0\r\n */\r\n\r\nmodule.exports = [\r\n    'normal',\r\n    'multiply',\r\n    'multiply',\r\n    'screen',\r\n    'overlay',\r\n    'darken',\r\n    'lighten',\r\n    'color-dodge',\r\n    'color-burn',\r\n    'hard-light',\r\n    'soft-light',\r\n    'difference',\r\n    'exclusion',\r\n    'hue',\r\n    'saturation',\r\n    'color',\r\n    'luminosity'\r\n];\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar DOMElementRender = require('./DOMElementRender');\r\nvar GameObject = require('../GameObject');\r\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\r\nvar RemoveFromDOM = require('../../dom/RemoveFromDOM');\r\nvar SCENE_EVENTS = require('../../scene/events');\r\nvar Vector4 = require('../../math/Vector4');\r\n\r\n/**\r\n * @classdesc\r\n * DOM Element Game Objects are a way to control and manipulate HTML Elements over the top of your game.\r\n *\r\n * In order for DOM Elements to display you have to enable them by adding the following to your game\r\n * configuration object:\r\n *\r\n * ```javascript\r\n * dom {\r\n *   createContainer: true\r\n * }\r\n * ```\r\n *\r\n * When this is added, Phaser will automatically create a DOM Container div that is positioned over the top\r\n * of the game canvas. This div is sized to match the canvas, and if the canvas size changes, as a result of\r\n * settings within the Scale Manager, the dom container is resized accordingly.\r\n *\r\n * If you have not already done so, you have to provide a `parent` in the Game Configuration, or the DOM\r\n * Container will fail to be created.\r\n *\r\n * You can create a DOM Element by either passing in DOMStrings, or by passing in a reference to an existing\r\n * Element that you wish to be placed under the control of Phaser. For example:\r\n *\r\n * ```javascript\r\n * this.add.dom(x, y, 'div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');\r\n * ```\r\n *\r\n * The above code will insert a div element into the DOM Container at the given x/y coordinate. The DOMString in\r\n * the 4th argument sets the initial CSS style of the div and the final argument is the inner text. In this case,\r\n * it will create a lime colored div that is 220px by 100px in size with the text Phaser in it, in an Arial font.\r\n *\r\n * You should nearly always, without exception, use explicitly sized HTML Elements, in order to fully control\r\n * alignment and positioning of the elements next to regular game content.\r\n *\r\n * Rather than specify the CSS and HTML directly you can use the `load.html` File Loader to load it into the\r\n * cache and then use the `createFromCache` method instead. You can also use `createFromHTML` and various other\r\n * methods available in this class to help construct your elements.\r\n *\r\n * Once the element has been created you can then control it like you would any other Game Object. You can set its\r\n * position, scale, rotation, alpha and other properties. It will move as the main Scene Camera moves and be clipped\r\n * at the edge of the canvas. It's important to remember some limitations of DOM Elements: The obvious one is that\r\n * they appear above or below your game canvas. You cannot blend them into the display list, meaning you cannot have\r\n * a DOM Element, then a Sprite, then another DOM Element behind it.\r\n *\r\n * They also cannot be enabled for input. To do that, you have to use the `addListener` method to add native event\r\n * listeners directly. The final limitation is to do with cameras. The DOM Container is sized to match the game canvas\r\n * entirely and clipped accordingly. DOM Elements respect camera scrolling and scrollFactor settings, but if you\r\n * change the size of the camera so it no longer matches the size of the canvas, they won't be clipped accordingly.\r\n *\r\n * Also, all DOM Elements are inserted into the same DOM Container, regardless of which Scene they are created in.\r\n *\r\n * Note that you should only have DOM Elements in a Scene with a _single_ Camera. If you require multiple cameras,\r\n * use parallel scenes to achieve this.\r\n *\r\n * DOM Elements are a powerful way to align native HTML with your Phaser Game Objects. For example, you can insert\r\n * a login form for a multiplayer game directly into your title screen. Or a text input box for a highscore table.\r\n * Or a banner ad from a 3rd party service. Or perhaps you'd like to use them for high resolution text display and\r\n * UI. The choice is up to you, just remember that you're dealing with standard HTML and CSS floating over the top\r\n * of your game, and should treat it accordingly.\r\n *\r\n * @class DOMElement\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.17.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this DOM Element in the world.\r\n * @param {number} [y=0] - The vertical position of this DOM Element in the world.\r\n * @param {(Element|string)} [element] - An existing DOM element, or a string. If a string starting with a # it will do a `getElementById` look-up on the string (minus the hash). Without a hash, it represents the type of element to create, i.e. 'div'.\r\n * @param {(string|any)} [style] - If a string, will be set directly as the elements `style` property value. If a plain object, will be iterated and the values transferred. In both cases the values replacing whatever CSS styles may have been previously set.\r\n * @param {string} [innerText] - If given, will be set directly as the elements `innerText` property value, replacing whatever was there before.\r\n */\r\nvar DOMElement = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Origin,\r\n        Components.ScrollFactor,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        DOMElementRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function DOMElement (scene, x, y, element, style, innerText)\r\n    {\r\n        GameObject.call(this, scene, 'DOMElement');\r\n\r\n        /**\r\n         * A reference to the parent DOM Container that the Game instance created when it started.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#parent\r\n         * @type {Element}\r\n         * @since 3.17.0\r\n         */\r\n        this.parent = scene.sys.game.domContainer;\r\n\r\n        /**\r\n         * A reference to the HTML Cache.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#cache\r\n         * @type {Phaser.Cache.BaseCache}\r\n         * @since 3.17.0\r\n         */\r\n        this.cache = scene.sys.cache.html;\r\n\r\n        /**\r\n         * The actual DOM Element that this Game Object is bound to. For example, if you've created a `<div>`\r\n         * then this property is a direct reference to that element within the dom.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#node\r\n         * @type {Element}\r\n         * @since 3.17.0\r\n         */\r\n        this.node;\r\n\r\n        /**\r\n         * By default a DOM Element will have its transform, display, opacity, zIndex and blend mode properties\r\n         * updated when its rendered. If, for some reason, you don't want any of these changed other than the\r\n         * CSS transform, then set this flag to `true`. When `true` only the CSS Transform is applied and it's\r\n         * up to you to keep track of and set the other properties as required.\r\n         *\r\n         * This can be handy if, for example, you've a nested DOM Element and you don't want the opacity to be\r\n         * picked-up by any of its children.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#transformOnly\r\n         * @type {boolean}\r\n         * @since 3.17.0\r\n         */\r\n        this.transformOnly = false;\r\n\r\n        /**\r\n         * The angle, in radians, by which to skew the DOM Element on the horizontal axis.\r\n         *\r\n         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#skewX\r\n         * @type {number}\r\n         * @since 3.17.0\r\n         */\r\n        this.skewX = 0;\r\n\r\n        /**\r\n         * The angle, in radians, by which to skew the DOM Element on the vertical axis.\r\n         *\r\n         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#skewY\r\n         * @type {number}\r\n         * @since 3.17.0\r\n         */\r\n        this.skewY = 0;\r\n\r\n        /**\r\n         * A Vector4 that contains the 3D rotation of this DOM Element around a fixed axis in 3D space.\r\n         *\r\n         * All values in the Vector4 are treated as degrees, unless the `rotate3dAngle` property is changed.\r\n         *\r\n         * For more details see the following MDN page:\r\n         *\r\n         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#rotate3d\r\n         * @type {Phaser.Math.Vector4}\r\n         * @since 3.17.0\r\n         */\r\n        this.rotate3d = new Vector4();\r\n\r\n        /**\r\n         * The unit that represents the 3D rotation values. By default this is `deg` for degrees, but can\r\n         * be changed to any supported unit. See this page for further details:\r\n         *\r\n         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#rotate3dAngle\r\n         * @type {string}\r\n         * @since 3.17.0\r\n         */\r\n        this.rotate3dAngle = 'deg';\r\n\r\n        /**\r\n         * Sets the CSS `pointerEvents` attribute on the DOM Element during rendering.\r\n         *\r\n         * This is 'auto' by default. Changing it may have unintended side-effects with\r\n         * internal Phaser input handling, such as dragging, so only change this if you\r\n         * understand the implications.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#pointerEvents\r\n         * @type {string}\r\n         * @since 3.55.0\r\n         */\r\n        this.pointerEvents = 'auto';\r\n\r\n        /**\r\n         * The native (un-scaled) width of this Game Object.\r\n         *\r\n         * For a DOM Element this property is read-only.\r\n         *\r\n         * The property `displayWidth` holds the computed bounds of this DOM Element, factoring in scaling.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#width\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.width = 0;\r\n\r\n        /**\r\n         * The native (un-scaled) height of this Game Object.\r\n         *\r\n         * For a DOM Element this property is read-only.\r\n         *\r\n         * The property `displayHeight` holds the computed bounds of this DOM Element, factoring in scaling.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#height\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.height = 0;\r\n\r\n        /**\r\n         * The computed display width of this Game Object, based on the `getBoundingClientRect` DOM call.\r\n         *\r\n         * The property `width` holds the un-scaled width of this DOM Element.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#displayWidth\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.displayWidth = 0;\r\n\r\n        /**\r\n         * The computed display height of this Game Object, based on the `getBoundingClientRect` DOM call.\r\n         *\r\n         * The property `height` holds the un-scaled height of this DOM Element.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#displayHeight\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.displayHeight = 0;\r\n\r\n        /**\r\n         * Internal native event handler.\r\n         *\r\n         * @name Phaser.GameObjects.DOMElement#handler\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this.handler = this.dispatchNativeEvent.bind(this);\r\n\r\n        this.setPosition(x, y);\r\n\r\n        if (typeof element === 'string')\r\n        {\r\n            //  hash?\r\n            if (element[0] === '#')\r\n            {\r\n                this.setElement(element.substr(1), style, innerText);\r\n            }\r\n            else\r\n            {\r\n                this.createElement(element, style, innerText);\r\n            }\r\n        }\r\n        else if (element)\r\n        {\r\n            this.setElement(element, style, innerText);\r\n        }\r\n\r\n        scene.sys.events.on(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);\r\n        scene.sys.events.on(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * Handles a Scene Sleep and Wake event.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#handleSceneEvent\r\n     * @private\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.Scenes.Systems} sys - The Scene Systems.\r\n     */\r\n    handleSceneEvent: function (sys)\r\n    {\r\n        var node = this.node;\r\n        var style = node.style;\r\n\r\n        if (node)\r\n        {\r\n            style.display = (sys.settings.visible) ? 'block' : 'none';\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal and vertical skew values of this DOM Element.\r\n     *\r\n     * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/transform\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#setSkew\r\n     * @since 3.17.0\r\n     *\r\n     * @param {number} [x=0] - The angle, in radians, by which to skew the DOM Element on the horizontal axis.\r\n     * @param {number} [y=x] - The angle, in radians, by which to skew the DOM Element on the vertical axis.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    setSkew: function (x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.skewX = x;\r\n        this.skewY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the perspective CSS property of the _parent DOM Container_. This determines the distance between the z=0\r\n     * plane and the user in order to give a 3D-positioned element some perspective. Each 3D element with\r\n     * z > 0 becomes larger; each 3D-element with z < 0 becomes smaller. The strength of the effect is determined\r\n     * by the value of this property.\r\n     *\r\n     * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/perspective\r\n     *\r\n     * **Changing this value changes it globally for all DOM Elements, as they all share the same parent container.**\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#setPerspective\r\n     * @since 3.17.0\r\n     *\r\n     * @param {number} value - The perspective value, in pixels, that determines the distance between the z plane and the user.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    setPerspective: function (value)\r\n    {\r\n        this.parent.style.perspective = value + 'px';\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The perspective CSS property value of the _parent DOM Container_. This determines the distance between the z=0\r\n     * plane and the user in order to give a 3D-positioned element some perspective. Each 3D element with\r\n     * z > 0 becomes larger; each 3D-element with z < 0 becomes smaller. The strength of the effect is determined\r\n     * by the value of this property.\r\n     *\r\n     * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/perspective\r\n     *\r\n     * **Changing this value changes it globally for all DOM Elements, as they all share the same parent container.**\r\n     *\r\n     * @name Phaser.GameObjects.DOMElement#perspective\r\n     * @type {number}\r\n     * @since 3.17.0\r\n     */\r\n    perspective: {\r\n\r\n        get: function ()\r\n        {\r\n            return parseFloat(this.parent.style.perspective);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.parent.style.perspective = value + 'px';\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Adds one or more native DOM event listeners onto the underlying Element of this Game Object.\r\n     * The event is then dispatched via this Game Objects standard event emitter.\r\n     *\r\n     * For example:\r\n     *\r\n     * ```javascript\r\n     * var div = this.add.dom(x, y, element);\r\n     *\r\n     * div.addListener('click');\r\n     *\r\n     * div.on('click', handler);\r\n     * ```\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#addListener\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} events - The DOM event/s to listen for. You can specify multiple events by separating them with spaces.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    addListener: function (events)\r\n    {\r\n        if (this.node)\r\n        {\r\n            events = events.split(' ');\r\n\r\n            for (var i = 0; i < events.length; i++)\r\n            {\r\n                this.node.addEventListener(events[i], this.handler, false);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes one or more native DOM event listeners from the underlying Element of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#removeListener\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} events - The DOM event/s to stop listening for. You can specify multiple events by separating them with spaces.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    removeListener: function (events)\r\n    {\r\n        if (this.node)\r\n        {\r\n            events = events.split(' ');\r\n\r\n            for (var i = 0; i < events.length; i++)\r\n            {\r\n                this.node.removeEventListener(events[i], this.handler);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal event proxy to dispatch native DOM Events via this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#dispatchNativeEvent\r\n     * @private\r\n     * @since 3.17.0\r\n     *\r\n     * @param {any} event - The native DOM event.\r\n     */\r\n    dispatchNativeEvent: function (event)\r\n    {\r\n        this.emit(event.type, event);\r\n    },\r\n\r\n    /**\r\n     * Creates a native DOM Element, adds it to the parent DOM Container and then binds it to this Game Object,\r\n     * so you can control it. The `tagName` should be a string and is passed to `document.createElement`:\r\n     *\r\n     * ```javascript\r\n     * this.add.dom().createElement('div');\r\n     * ```\r\n     *\r\n     * For more details on acceptable tag names see: https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement\r\n     *\r\n     * You can also pass in a DOMString or style object to set the CSS on the created element, and an optional `innerText`\r\n     * value as well. Here is an example of a DOMString:\r\n     *\r\n     * ```javascript\r\n     * this.add.dom().createElement('div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');\r\n     * ```\r\n     *\r\n     * And using a style object:\r\n     *\r\n     * ```javascript\r\n     * var style = {\r\n     *   'background-color': 'lime';\r\n     *   'width': '200px';\r\n     *   'height': '100px';\r\n     *   'font': '48px Arial';\r\n     * };\r\n     *\r\n     * this.add.dom().createElement('div', style, 'Phaser');\r\n     * ```\r\n     *\r\n     * If this Game Object already has an Element, it is removed from the DOM entirely first.\r\n     * Any event listeners you may have previously created will need to be re-created after this call.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#createElement\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} tagName - A string that specifies the type of element to be created. The nodeName of the created element is initialized with the value of tagName. Don't use qualified names (like \"html:a\") with this method.\r\n     * @param {(string|any)} [style] - Either a DOMString that holds the CSS styles to be applied to the created element, or an object the styles will be ready from.\r\n     * @param {string} [innerText] - A DOMString that holds the text that will be set as the innerText of the created element.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    createElement: function (tagName, style, innerText)\r\n    {\r\n        return this.setElement(document.createElement(tagName), style, innerText);\r\n    },\r\n\r\n    /**\r\n     * Binds a new DOM Element to this Game Object. If this Game Object already has an Element it is removed from the DOM\r\n     * entirely first. Any event listeners you may have previously created will need to be re-created on the new element.\r\n     *\r\n     * The `element` argument you pass to this method can be either a string tagName:\r\n     *\r\n     * ```javascript\r\n     * <h1 id=\"heading\">Phaser</h1>\r\n     *\r\n     * this.add.dom().setElement('heading');\r\n     * ```\r\n     *\r\n     * Or a reference to an Element instance:\r\n     *\r\n     * ```javascript\r\n     * <h1 id=\"heading\">Phaser</h1>\r\n     *\r\n     * var h1 = document.getElementById('heading');\r\n     *\r\n     * this.add.dom().setElement(h1);\r\n     * ```\r\n     *\r\n     * You can also pass in a DOMString or style object to set the CSS on the created element, and an optional `innerText`\r\n     * value as well. Here is an example of a DOMString:\r\n     *\r\n     * ```javascript\r\n     * this.add.dom().setElement(h1, 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');\r\n     * ```\r\n     *\r\n     * And using a style object:\r\n     *\r\n     * ```javascript\r\n     * var style = {\r\n     *   'background-color': 'lime';\r\n     *   'width': '200px';\r\n     *   'height': '100px';\r\n     *   'font': '48px Arial';\r\n     * };\r\n     *\r\n     * this.add.dom().setElement(h1, style, 'Phaser');\r\n     * ```\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#setElement\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|Element)} element - If a string it is passed to `getElementById()`, or it should be a reference to an existing Element.\r\n     * @param {(string|any)} [style] - Either a DOMString that holds the CSS styles to be applied to the created element, or an object the styles will be ready from.\r\n     * @param {string} [innerText] - A DOMString that holds the text that will be set as the innerText of the created element.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    setElement: function (element, style, innerText)\r\n    {\r\n        //  Already got an element? Remove it first\r\n        this.removeElement();\r\n\r\n        var target;\r\n\r\n        if (typeof element === 'string')\r\n        {\r\n            //  hash?\r\n            if (element[0] === '#')\r\n            {\r\n                element = element.substr(1);\r\n            }\r\n\r\n            target = document.getElementById(element);\r\n        }\r\n        else if (typeof element === 'object' && element.nodeType === 1)\r\n        {\r\n            target = element;\r\n        }\r\n\r\n        if (!target)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.node = target;\r\n\r\n        //  style can be empty, a string or a plain object\r\n        if (style && IsPlainObject(style))\r\n        {\r\n            for (var key in style)\r\n            {\r\n                target.style[key] = style[key];\r\n            }\r\n        }\r\n        else if (typeof style === 'string')\r\n        {\r\n            target.style = style;\r\n        }\r\n\r\n        //  Add / Override the values we need\r\n\r\n        target.style.zIndex = '0';\r\n        target.style.display = 'inline';\r\n        target.style.position = 'absolute';\r\n\r\n        //  Node handler\r\n\r\n        target.phaser = this;\r\n\r\n        if (this.parent)\r\n        {\r\n            this.parent.appendChild(target);\r\n        }\r\n\r\n        //  InnerText\r\n\r\n        if (innerText)\r\n        {\r\n            target.innerText = innerText;\r\n        }\r\n\r\n        return this.updateSize();\r\n    },\r\n\r\n    /**\r\n     * Takes a block of html from the HTML Cache, that has previously been preloaded into the game, and then\r\n     * creates a DOM Element from it. The loaded HTML is set as the `innerHTML` property of the created\r\n     * element.\r\n     *\r\n     * Assume the following html is stored in a file called `loginform.html`:\r\n     *\r\n     * ```html\r\n     * <input type=\"text\" name=\"nameField\" placeholder=\"Enter your name\" style=\"font-size: 32px\">\r\n     * <input type=\"button\" name=\"playButton\" value=\"Let's Play\" style=\"font-size: 32px\">\r\n     * ```\r\n     *\r\n     * Which is loaded into your game using the cache key 'login':\r\n     *\r\n     * ```javascript\r\n     * this.load.html('login', 'assets/loginform.html');\r\n     * ```\r\n     *\r\n     * You can create a DOM Element from it using the cache key:\r\n     *\r\n     * ```javascript\r\n     * this.add.dom().createFromCache('login');\r\n     * ```\r\n     *\r\n     * The optional `elementType` argument controls the container that is created, into which the loaded html is inserted.\r\n     * The default is a plain `div` object, but any valid tagName can be given.\r\n     *\r\n     * If this Game Object already has an Element, it is removed from the DOM entirely first.\r\n     * Any event listeners you may have previously created will need to be re-created after this call.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#createFromCache\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} The key of the html cache entry to use for this DOM Element.\r\n     * @param {string} [tagName='div'] - The tag name of the element into which all of the loaded html will be inserted. Defaults to a plain div tag.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    createFromCache: function (key, tagName)\r\n    {\r\n        var html = this.cache.get(key);\r\n\r\n        if (html)\r\n        {\r\n            this.createFromHTML(html, tagName);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a string of html and then creates a DOM Element from it. The HTML is set as the `innerHTML`\r\n     * property of the created element.\r\n     *\r\n     * ```javascript\r\n     * let form = `\r\n     * <input type=\"text\" name=\"nameField\" placeholder=\"Enter your name\" style=\"font-size: 32px\">\r\n     * <input type=\"button\" name=\"playButton\" value=\"Let's Play\" style=\"font-size: 32px\">\r\n     * `;\r\n     * ```\r\n     *\r\n     * You can create a DOM Element from it using the string:\r\n     *\r\n     * ```javascript\r\n     * this.add.dom().createFromHTML(form);\r\n     * ```\r\n     *\r\n     * The optional `elementType` argument controls the type of container that is created, into which the html is inserted.\r\n     * The default is a plain `div` object, but any valid tagName can be given.\r\n     *\r\n     * If this Game Object already has an Element, it is removed from the DOM entirely first.\r\n     * Any event listeners you may have previously created will need to be re-created after this call.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#createFromHTML\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} html - A string of html to be set as the `innerHTML` property of the created element.\r\n     * @param {string} [tagName='div'] - The tag name of the element into which all of the html will be inserted. Defaults to a plain div tag.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    createFromHTML: function (html, tagName)\r\n    {\r\n        if (tagName === undefined) { tagName = 'div'; }\r\n\r\n        //  Already got an element? Remove it first\r\n        this.removeElement();\r\n\r\n        var element = document.createElement(tagName);\r\n\r\n        this.node = element;\r\n\r\n        element.style.zIndex = '0';\r\n        element.style.display = 'inline';\r\n        element.style.position = 'absolute';\r\n\r\n        //  Node handler\r\n\r\n        element.phaser = this;\r\n\r\n        if (this.parent)\r\n        {\r\n            this.parent.appendChild(element);\r\n        }\r\n\r\n        element.innerHTML = html;\r\n\r\n        return this.updateSize();\r\n    },\r\n\r\n    /**\r\n     * Removes the current DOM Element bound to this Game Object from the DOM entirely and resets the\r\n     * `node` property of this Game Object to be `null`.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#removeElement\r\n     * @since 3.17.0\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    removeElement: function ()\r\n    {\r\n        if (this.node)\r\n        {\r\n            RemoveFromDOM(this.node);\r\n\r\n            this.node = null;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that calls `getBoundingClientRect` on the `node` and then sets the bounds width\r\n     * and height into the `displayWidth` and `displayHeight` properties, and the `clientWidth` and `clientHeight`\r\n     * values into the `width` and `height` properties respectively.\r\n     *\r\n     * This is called automatically whenever a new element is created or set.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#updateSize\r\n     * @since 3.17.0\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    updateSize: function ()\r\n    {\r\n        var node = this.node;\r\n\r\n        var nodeBounds = node.getBoundingClientRect();\r\n\r\n        this.width = node.clientWidth;\r\n        this.height = node.clientHeight;\r\n\r\n        this.displayWidth = nodeBounds.width || 0;\r\n        this.displayHeight = nodeBounds.height || 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through\r\n     * them, looking for the first one that has a property matching the given key and value. It then returns this child\r\n     * if found, or `null` if not.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#getChildByProperty\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} property - The property to search the children for.\r\n     * @param {string} value - The value the property must strictly equal.\r\n     *\r\n     * @return {?Element} The first matching child DOM Element, or `null` if not found.\r\n     */\r\n    getChildByProperty: function (property, value)\r\n    {\r\n        if (this.node)\r\n        {\r\n            var children = this.node.querySelectorAll('*');\r\n\r\n            for (var i = 0; i < children.length; i++)\r\n            {\r\n                if (children[i][property] === value)\r\n                {\r\n                    return children[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through\r\n     * them, looking for the first one that has a matching id. It then returns this child if found, or `null` if not.\r\n     *\r\n     * Be aware that class and id names are case-sensitive.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#getChildByID\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} id - The id to search the children for.\r\n     *\r\n     * @return {?Element} The first matching child DOM Element, or `null` if not found.\r\n     */\r\n    getChildByID: function (id)\r\n    {\r\n        return this.getChildByProperty('id', id);\r\n    },\r\n\r\n    /**\r\n     * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through\r\n     * them, looking for the first one that has a matching name. It then returns this child if found, or `null` if not.\r\n     *\r\n     * Be aware that class and id names are case-sensitive.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#getChildByName\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} name - The name to search the children for.\r\n     *\r\n     * @return {?Element} The first matching child DOM Element, or `null` if not found.\r\n     */\r\n    getChildByName: function (name)\r\n    {\r\n        return this.getChildByProperty('name', name);\r\n    },\r\n\r\n    /**\r\n     * Sets the `className` property of the DOM Element node and updates the internal sizes.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#setClassName\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} className - A string representing the class or space-separated classes of the element.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    setClassName: function (className)\r\n    {\r\n        if (this.node)\r\n        {\r\n            this.node.className = className;\r\n\r\n            this.updateSize();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `innerText` property of the DOM Element node and updates the internal sizes.\r\n     *\r\n     * Note that only certain types of Elements can have `innerText` set on them.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#setText\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} text - A DOMString representing the rendered text content of the element.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    setText: function (text)\r\n    {\r\n        if (this.node)\r\n        {\r\n            this.node.innerText = text;\r\n\r\n            this.updateSize();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `innerHTML` property of the DOM Element node and updates the internal sizes.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#setHTML\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} html - A DOMString of html to be set as the `innerHTML` property of the element.\r\n     *\r\n     * @return {this} This DOM Element instance.\r\n     */\r\n    setHTML: function (html)\r\n    {\r\n        if (this.node)\r\n        {\r\n            this.node.innerHTML = html;\r\n\r\n            this.updateSize();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Runs internal update tasks.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#preUpdate\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        var parent = this.parentContainer;\r\n        var node = this.node;\r\n\r\n        if (node && parent && !parent.willRender())\r\n        {\r\n            node.style.display = 'none';\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     *\r\n     * DOMElements always return `true` as they need to still set values during the render pass, even if not visible.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#willRender\r\n     * @since 3.17.0\r\n     *\r\n     * @return {boolean} `true` if the Game Object should be rendered, otherwise `false`.\r\n     */\r\n    willRender: function ()\r\n    {\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Handles the pre-destroy step for the DOM Element, which removes the underlying node from the DOM.\r\n     *\r\n     * @method Phaser.GameObjects.DOMElement#preDestroy\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.removeElement();\r\n\r\n        this.scene.sys.events.off(SCENE_EVENTS.SLEEP, this.handleSceneEvent, this);\r\n        this.scene.sys.events.off(SCENE_EVENTS.WAKE, this.handleSceneEvent, this);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = DOMElement;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CSSBlendModes = require('./CSSBlendModes');\r\nvar GameObject = require('../GameObject');\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\n\r\nvar tempMatrix1 = new TransformMatrix();\r\nvar tempMatrix2 = new TransformMatrix();\r\nvar tempMatrix3 = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.DOMElement#renderWebGL\r\n * @since 3.17.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active renderer.\r\n * @param {Phaser.GameObjects.DOMElement} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar DOMElementCSSRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (!src.node)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var style = src.node.style;\r\n    var settings = src.scene.sys.settings;\r\n\r\n    if (!style || !settings.visible || GameObject.RENDER_MASK !== src.renderFlags || (src.cameraFilter !== 0 && (src.cameraFilter & camera.id)) || (src.parentContainer && !src.parentContainer.willRender()))\r\n    {\r\n        style.display = 'none';\r\n\r\n        return;\r\n    }\r\n\r\n    var parent = src.parentContainer;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (parent)\r\n    {\r\n        alpha *= parent.alpha;\r\n    }\r\n\r\n    var camMatrix = tempMatrix1;\r\n    var srcMatrix = tempMatrix2;\r\n    var calcMatrix = tempMatrix3;\r\n\r\n    var dx = 0;\r\n    var dy = 0;\r\n\r\n    var tx = '0%';\r\n    var ty = '0%';\r\n\r\n    if (parentMatrix)\r\n    {\r\n        dx = (src.width * src.scaleX) * src.originX;\r\n        dy = (src.height * src.scaleY) * src.originY;\r\n\r\n        srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);\r\n\r\n        camMatrix.copyFrom(camera.matrix);\r\n\r\n        //  Multiply the camera by the parent matrix\r\n        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);\r\n\r\n        //  Undo the camera scroll\r\n        srcMatrix.e = src.x - dx;\r\n        srcMatrix.f = src.y - dy;\r\n\r\n        //  Multiply by the src matrix, store result in calcMatrix\r\n        camMatrix.multiply(srcMatrix, calcMatrix);\r\n    }\r\n    else\r\n    {\r\n        dx = (src.width) * src.originX;\r\n        dy = (src.height) * src.originY;\r\n\r\n        srcMatrix.applyITRS(src.x - dx, src.y - dy, src.rotation, src.scaleX, src.scaleY);\r\n\r\n        camMatrix.copyFrom(camera.matrix);\r\n\r\n        tx = (100 * src.originX) + '%';\r\n        ty = (100 * src.originY) + '%';\r\n\r\n        srcMatrix.e -= camera.scrollX * src.scrollFactorX;\r\n        srcMatrix.f -= camera.scrollY * src.scrollFactorY;\r\n\r\n        //  Multiply by the src matrix, store result in calcMatrix\r\n        camMatrix.multiply(srcMatrix, calcMatrix);\r\n    }\r\n\r\n    if (!src.transformOnly)\r\n    {\r\n        style.display = 'block';\r\n        style.opacity = alpha;\r\n        style.zIndex = src._depth;\r\n        style.pointerEvents = src.pointerEvents;\r\n        style.mixBlendMode = CSSBlendModes[src._blendMode];\r\n    }\r\n\r\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/transform\r\n\r\n    style.transform =\r\n        calcMatrix.getCSSMatrix() +\r\n        ' skew(' + src.skewX + 'rad, ' + src.skewY + 'rad)' +\r\n        ' rotate3d(' + src.rotate3d.x + ',' + src.rotate3d.y + ',' + src.rotate3d.z + ',' + src.rotate3d.w + src.rotate3dAngle + ')';\r\n\r\n    style.transformOrigin = tx + ' ' + ty;\r\n};\r\n\r\nmodule.exports = DOMElementCSSRenderer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar DOMElement = require('./DOMElement');\nvar GameObjectFactory = require('../GameObjectFactory');\n\n/**\n * DOM Element Game Objects are a way to control and manipulate HTML Elements over the top of your game.\n *\n * In order for DOM Elements to display you have to enable them by adding the following to your game\n * configuration object:\n *\n * ```javascript\n * dom {\n *   createContainer: true\n * }\n * ```\n *\n * When this is added, Phaser will automatically create a DOM Container div that is positioned over the top\n * of the game canvas. This div is sized to match the canvas, and if the canvas size changes, as a result of\n * settings within the Scale Manager, the dom container is resized accordingly.\n *\n * You can create a DOM Element by either passing in DOMStrings, or by passing in a reference to an existing\n * Element that you wish to be placed under the control of Phaser. For example:\n *\n * ```javascript\n * this.add.dom(x, y, 'div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');\n * ```\n *\n * The above code will insert a div element into the DOM Container at the given x/y coordinate. The DOMString in\n * the 4th argument sets the initial CSS style of the div and the final argument is the inner text. In this case,\n * it will create a lime colored div that is 220px by 100px in size with the text Phaser in it, in an Arial font.\n *\n * You should nearly always, without exception, use explicitly sized HTML Elements, in order to fully control\n * alignment and positioning of the elements next to regular game content.\n *\n * Rather than specify the CSS and HTML directly you can use the `load.html` File Loader to load it into the\n * cache and then use the `createFromCache` method instead. You can also use `createFromHTML` and various other\n * methods available in this class to help construct your elements.\n *\n * Once the element has been created you can then control it like you would any other Game Object. You can set its\n * position, scale, rotation, alpha and other properties. It will move as the main Scene Camera moves and be clipped\n * at the edge of the canvas. It's important to remember some limitations of DOM Elements: The obvious one is that\n * they appear above or below your game canvas. You cannot blend them into the display list, meaning you cannot have\n * a DOM Element, then a Sprite, then another DOM Element behind it.\n *\n * They also cannot be enabled for input. To do that, you have to use the `addListener` method to add native event\n * listeners directly. The final limitation is to do with cameras. The DOM Container is sized to match the game canvas\n * entirely and clipped accordingly. DOM Elements respect camera scrolling and scrollFactor settings, but if you\n * change the size of the camera so it no longer matches the size of the canvas, they won't be clipped accordingly.\n *\n * Also, all DOM Elements are inserted into the same DOM Container, regardless of which Scene they are created in.\n *\n * DOM Elements are a powerful way to align native HTML with your Phaser Game Objects. For example, you can insert\n * a login form for a multiplayer game directly into your title screen. Or a text input box for a highscore table.\n * Or a banner ad from a 3rd party service. Or perhaps you'd like to use them for high resolution text display and\n * UI. The choice is up to you, just remember that you're dealing with standard HTML and CSS floating over the top\n * of your game, and should treat it accordingly.\n *\n * Note: This method will only be available if the DOM Element Game Object has been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectFactory#dom\n * @since 3.17.0\n *\n * @param {number} x - The horizontal position of this DOM Element in the world.\n * @param {number} y - The vertical position of this DOM Element in the world.\n * @param {(HTMLElement|string)} [element] - An existing DOM element, or a string. If a string starting with a # it will do a `getElementById` look-up on the string (minus the hash). Without a hash, it represents the type of element to create, i.e. 'div'.\n * @param {(string|any)} [style] - If a string, will be set directly as the elements `style` property value. If a plain object, will be iterated and the values transferred. In both cases the values replacing whatever CSS styles may have been previously set.\n * @param {string} [innerText] - If given, will be set directly as the elements `innerText` property value, replacing whatever was there before.\n *\n * @return {Phaser.GameObjects.DOMElement} The Game Object that was created.\n */\nGameObjectFactory.register('dom', function (x, y, element, style, innerText)\n{\n    var gameObject = new DOMElement(this.scene, x, y, element, style, innerText);\n\n    this.displayList.add(gameObject);\n\n    return gameObject;\n});\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./DOMElementCSSRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./DOMElementCSSRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar ExternRender = require('./ExternRender');\r\n\r\n/**\r\n * @classdesc\r\n * An Extern Game Object is a special type of Game Object that allows you to pass\r\n * rendering off to a 3rd party.\r\n *\r\n * When you create an Extern and place it in the display list of a Scene, the renderer will\r\n * process the list as usual. When it finds an Extern it will flush the current batch,\r\n * clear down the pipeline and prepare a transform matrix which your render function can\r\n * take advantage of, if required.\r\n *\r\n * The WebGL context is then left in a 'clean' state, ready for you to bind your own shaders,\r\n * or draw to it, whatever you wish to do. This should all take place in the `render` method.\r\n * The correct way to deploy an Extern object is to create a class that extends it, then\r\n * override the `render` (and optionally `preUpdate`) methods and pass off control to your\r\n * 3rd party libraries or custom WebGL code there.\r\n *\r\n * Once you've finished, you should free-up any of your resources.\r\n * The Extern will then rebind the Phaser pipeline and carry on rendering the display list.\r\n *\r\n * Although this object has lots of properties such as Alpha, Blend Mode and Tint, none of\r\n * them are used during rendering unless you take advantage of them in your own render code.\r\n *\r\n * @class Extern\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n */\r\nvar Extern = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.Origin,\r\n        Components.ScrollFactor,\r\n        Components.Size,\r\n        Components.Texture,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        ExternRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Extern (scene)\r\n    {\r\n        GameObject.call(this, scene, 'Extern');\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    preUpdate: function ()\r\n    {\r\n        //  override this!\r\n        //  Arguments: time, delta\r\n    },\r\n\r\n    render: function ()\r\n    {\r\n        //  override this!\r\n        //  Arguments: renderer, camera, calcMatrix\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Extern;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Extern = require('./Extern');\nvar GameObjectFactory = require('../GameObjectFactory');\n\n/**\n * Creates a new Extern Game Object and adds it to the Scene.\n *\n * Note: This method will only be available if the Extern Game Object has been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectFactory#extern\n * @since 3.16.0\n *\n * @return {Phaser.GameObjects.Extern} The Game Object that was created.\n */\nGameObjectFactory.register('extern', function ()\n{\n    var extern = new Extern(this.scene);\n\n    this.displayList.add(extern);\n\n    return extern;\n});\n\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./ExternWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./ExternCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Extern#renderWebGL\r\n * @since 3.16.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Extern} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ExternWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    renderer.pipelines.clear();\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    src.render.call(src, renderer, camera, calcMatrix);\r\n\r\n    renderer.pipelines.rebind();\r\n};\r\n\r\nmodule.exports = ExternWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    ARC: 0,\r\n    BEGIN_PATH: 1,\r\n    CLOSE_PATH: 2,\r\n    FILL_RECT: 3,\r\n    LINE_TO: 4,\r\n    MOVE_TO: 5,\r\n    LINE_STYLE: 6,\r\n    FILL_STYLE: 7,\r\n    FILL_PATH: 8,\r\n    STROKE_PATH: 9,\r\n    FILL_TRIANGLE: 10,\r\n    STROKE_TRIANGLE: 11,\r\n    SAVE: 14,\r\n    RESTORE: 15,\r\n    TRANSLATE: 16,\r\n    SCALE: 17,\r\n    ROTATE: 18,\r\n    GRADIENT_FILL_STYLE: 21,\r\n    GRADIENT_LINE_STYLE: 22\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BaseCamera = require('../../cameras/2d/BaseCamera.js');\r\nvar Class = require('../../utils/Class');\r\nvar Commands = require('./Commands');\r\nvar ComponentsAlpha = require('../components/AlphaSingle');\r\nvar ComponentsBlendMode = require('../components/BlendMode');\r\nvar ComponentsDepth = require('../components/Depth');\r\nvar ComponentsMask = require('../components/Mask');\r\nvar ComponentsPipeline = require('../components/Pipeline');\r\nvar ComponentsScrollFactor = require('../components/ScrollFactor');\r\nvar ComponentsTransform = require('../components/Transform');\r\nvar ComponentsVisible = require('../components/Visible');\r\nvar Ellipse = require('../../geom/ellipse/Ellipse');\r\nvar GameObject = require('../GameObject');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar MATH_CONST = require('../../math/const');\r\nvar Render = require('./GraphicsRender');\r\n\r\n/**\r\n * @classdesc\r\n * A Graphics object is a way to draw primitive shapes to your game. Primitives include forms of geometry, such as\r\n * Rectangles, Circles, and Polygons. They also include lines, arcs and curves. When you initially create a Graphics\r\n * object it will be empty.\r\n *\r\n * To draw to it you must first specify a line style or fill style (or both), draw shapes using paths, and finally\r\n * fill or stroke them. For example:\r\n *\r\n * ```javascript\r\n * graphics.lineStyle(5, 0xFF00FF, 1.0);\r\n * graphics.beginPath();\r\n * graphics.moveTo(100, 100);\r\n * graphics.lineTo(200, 200);\r\n * graphics.closePath();\r\n * graphics.strokePath();\r\n * ```\r\n *\r\n * There are also many helpful methods that draw and fill/stroke common shapes for you.\r\n *\r\n * ```javascript\r\n * graphics.lineStyle(5, 0xFF00FF, 1.0);\r\n * graphics.fillStyle(0xFFFFFF, 1.0);\r\n * graphics.fillRect(50, 50, 400, 200);\r\n * graphics.strokeRect(50, 50, 400, 200);\r\n * ```\r\n *\r\n * When a Graphics object is rendered it will render differently based on if the game is running under Canvas or WebGL.\r\n * Under Canvas it will use the HTML Canvas context drawing operations to draw the path.\r\n * Under WebGL the graphics data is decomposed into polygons. Both of these are expensive processes, especially with\r\n * complex shapes.\r\n *\r\n * If your Graphics object doesn't change much (or at all) once you've drawn your shape to it, then you will help\r\n * performance by calling {@link Phaser.GameObjects.Graphics#generateTexture}. This will 'bake' the Graphics object into\r\n * a Texture, and return it. You can then use this Texture for Sprites or other display objects. If your Graphics object\r\n * updates frequently then you should avoid doing this, as it will constantly generate new textures, which will consume\r\n * memory.\r\n *\r\n * As you can tell, Graphics objects are a bit of a trade-off. While they are extremely useful, you need to be careful\r\n * in their complexity and quantity of them in your game.\r\n *\r\n * @class Graphics\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Graphics object belongs.\r\n * @param {Phaser.Types.GameObjects.Graphics.Options} [options] - Options that set the position and default style of this Graphics object.\r\n */\r\nvar Graphics = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        ComponentsAlpha,\r\n        ComponentsBlendMode,\r\n        ComponentsDepth,\r\n        ComponentsMask,\r\n        ComponentsPipeline,\r\n        ComponentsTransform,\r\n        ComponentsVisible,\r\n        ComponentsScrollFactor,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Graphics (scene, options)\r\n    {\r\n        var x = GetValue(options, 'x', 0);\r\n        var y = GetValue(options, 'y', 0);\r\n\r\n        GameObject.call(this, scene, 'Graphics');\r\n\r\n        this.setPosition(x, y);\r\n        this.initPipeline();\r\n\r\n        /**\r\n         * The horizontal display origin of the Graphics.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#displayOriginX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.displayOriginX = 0;\r\n\r\n        /**\r\n         * The vertical display origin of the Graphics.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#displayOriginY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.displayOriginY = 0;\r\n\r\n        /**\r\n         * The array of commands used to render the Graphics.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#commandBuffer\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.commandBuffer = [];\r\n\r\n        /**\r\n         * The default fill color for shapes rendered by this Graphics object.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultFillColor\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultFillColor = -1;\r\n\r\n        /**\r\n         * The default fill alpha for shapes rendered by this Graphics object.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultFillAlpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultFillAlpha = 1;\r\n\r\n        /**\r\n         * The default stroke width for shapes rendered by this Graphics object.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultStrokeWidth\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultStrokeWidth = 1;\r\n\r\n        /**\r\n         * The default stroke color for shapes rendered by this Graphics object.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultStrokeColor\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultStrokeColor = -1;\r\n\r\n        /**\r\n         * The default stroke alpha for shapes rendered by this Graphics object.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#defaultStrokeAlpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultStrokeAlpha = 1;\r\n\r\n        /**\r\n         * Internal property that keeps track of the line width style setting.\r\n         *\r\n         * @name Phaser.GameObjects.Graphics#_lineWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._lineWidth = 1.0;\r\n\r\n        this.setDefaultStyles(options);\r\n    },\r\n\r\n    /**\r\n     * Set the default style settings for this Graphics object.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#setDefaultStyles\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Graphics.Styles} options - The styles to set as defaults.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    setDefaultStyles: function (options)\r\n    {\r\n        if (GetValue(options, 'lineStyle', null))\r\n        {\r\n            this.defaultStrokeWidth = GetValue(options, 'lineStyle.width', 1);\r\n            this.defaultStrokeColor = GetValue(options, 'lineStyle.color', 0xffffff);\r\n            this.defaultStrokeAlpha = GetValue(options, 'lineStyle.alpha', 1);\r\n\r\n            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);\r\n        }\r\n\r\n        if (GetValue(options, 'fillStyle', null))\r\n        {\r\n            this.defaultFillColor = GetValue(options, 'fillStyle.color', 0xffffff);\r\n            this.defaultFillAlpha = GetValue(options, 'fillStyle.alpha', 1);\r\n\r\n            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the current line style.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#lineStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} lineWidth - The stroke width.\r\n     * @param {number} color - The stroke color.\r\n     * @param {number} [alpha=1] - The stroke alpha.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    lineStyle: function (lineWidth, color, alpha)\r\n    {\r\n        if (alpha === undefined) { alpha = 1; }\r\n\r\n        this.commandBuffer.push(\r\n            Commands.LINE_STYLE,\r\n            lineWidth, color, alpha\r\n        );\r\n\r\n        this._lineWidth = lineWidth;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the current fill style.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} color - The fill color.\r\n     * @param {number} [alpha=1] - The fill alpha.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillStyle: function (color, alpha)\r\n    {\r\n        if (alpha === undefined) { alpha = 1; }\r\n\r\n        this.commandBuffer.push(\r\n            Commands.FILL_STYLE,\r\n            color, alpha\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a gradient fill style. This is a WebGL only feature.\r\n     *\r\n     * The gradient color values represent the 4 corners of an untransformed rectangle.\r\n     * The gradient is used to color all filled shapes and paths drawn after calling this method.\r\n     * If you wish to turn a gradient off, call `fillStyle` and provide a new single fill color.\r\n     *\r\n     * When filling a triangle only the first 3 color values provided are used for the 3 points of a triangle.\r\n     *\r\n     * This feature is best used only on rectangles and triangles. All other shapes will give strange results.\r\n     *\r\n     * Note that for objects such as arcs or ellipses, or anything which is made out of triangles, each triangle used\r\n     * will be filled with a gradient on its own. There is no ability to gradient fill a shape or path as a single\r\n     * entity at this time.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillGradientStyle\r\n     * @webglOnly\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} topLeft - The top left fill color.\r\n     * @param {number} topRight - The top right fill color.\r\n     * @param {number} bottomLeft - The bottom left fill color.\r\n     * @param {number} bottomRight - The bottom right fill color. Not used when filling triangles.\r\n     * @param {number} [alphaTopLeft=1] - The top left alpha value. If you give only this value, it's used for all corners.\r\n     * @param {number} [alphaTopRight=1] - The top right alpha value.\r\n     * @param {number} [alphaBottomLeft=1] - The bottom left alpha value.\r\n     * @param {number} [alphaBottomRight=1] - The bottom right alpha value.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillGradientStyle: function (topLeft, topRight, bottomLeft, bottomRight, alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight)\r\n    {\r\n        if (alphaTopLeft === undefined) { alphaTopLeft = 1; }\r\n        if (alphaTopRight === undefined) { alphaTopRight = alphaTopLeft; }\r\n        if (alphaBottomLeft === undefined) { alphaBottomLeft = alphaTopLeft; }\r\n        if (alphaBottomRight === undefined) { alphaBottomRight = alphaTopLeft; }\r\n\r\n        this.commandBuffer.push(\r\n            Commands.GRADIENT_FILL_STYLE,\r\n            alphaTopLeft, alphaTopRight, alphaBottomLeft, alphaBottomRight,\r\n            topLeft, topRight, bottomLeft, bottomRight\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a gradient line style. This is a WebGL only feature.\r\n     *\r\n     * The gradient color values represent the 4 corners of an untransformed rectangle.\r\n     * The gradient is used to color all stroked shapes and paths drawn after calling this method.\r\n     * If you wish to turn a gradient off, call `lineStyle` and provide a new single line color.\r\n     *\r\n     * This feature is best used only on single lines. All other shapes will give strange results.\r\n     *\r\n     * Note that for objects such as arcs or ellipses, or anything which is made out of triangles, each triangle used\r\n     * will be filled with a gradient on its own. There is no ability to gradient stroke a shape or path as a single\r\n     * entity at this time.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#lineGradientStyle\r\n     * @webglOnly\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} lineWidth - The stroke width.\r\n     * @param {number} topLeft - The tint being applied to the top-left of the Game Object.\r\n     * @param {number} topRight - The tint being applied to the top-right of the Game Object.\r\n     * @param {number} bottomLeft - The tint being applied to the bottom-left of the Game Object.\r\n     * @param {number} bottomRight - The tint being applied to the bottom-right of the Game Object.\r\n     * @param {number} [alpha=1] - The fill alpha.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    lineGradientStyle: function (lineWidth, topLeft, topRight, bottomLeft, bottomRight, alpha)\r\n    {\r\n        if (alpha === undefined) { alpha = 1; }\r\n\r\n        this.commandBuffer.push(\r\n            Commands.GRADIENT_LINE_STYLE,\r\n            lineWidth, alpha, topLeft, topRight, bottomLeft, bottomRight\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Start a new shape path.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#beginPath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    beginPath: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.BEGIN_PATH\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Close the current path.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#closePath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    closePath: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.CLOSE_PATH\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the current path.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillPath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillPath: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.FILL_PATH\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the current path.\r\n     *\r\n     * This is an alias for `Graphics.fillPath` and does the same thing.\r\n     * It was added to match the CanvasRenderingContext 2D API.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fill\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fill: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.FILL_PATH\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke the current path.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokePath\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokePath: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.STROKE_PATH\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke the current path.\r\n     *\r\n     * This is an alias for `Graphics.strokePath` and does the same thing.\r\n     * It was added to match the CanvasRenderingContext 2D API.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#stroke\r\n     * @since 3.16.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    stroke: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.STROKE_PATH\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the given circle.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillCircleShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Circle} circle - The circle to fill.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillCircleShape: function (circle)\r\n    {\r\n        return this.fillCircle(circle.x, circle.y, circle.radius);\r\n    },\r\n\r\n    /**\r\n     * Stroke the given circle.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeCircleShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Circle} circle - The circle to stroke.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeCircleShape: function (circle)\r\n    {\r\n        return this.strokeCircle(circle.x, circle.y, circle.radius);\r\n    },\r\n\r\n    /**\r\n     * Fill a circle with the given position and radius.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the center of the circle.\r\n     * @param {number} y - The y coordinate of the center of the circle.\r\n     * @param {number} radius - The radius of the circle.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillCircle: function (x, y, radius)\r\n    {\r\n        this.beginPath();\r\n        this.arc(x, y, radius, 0, MATH_CONST.PI2);\r\n        this.fillPath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke a circle with the given position and radius.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeCircle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the center of the circle.\r\n     * @param {number} y - The y coordinate of the center of the circle.\r\n     * @param {number} radius - The radius of the circle.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeCircle: function (x, y, radius)\r\n    {\r\n        this.beginPath();\r\n        this.arc(x, y, radius, 0, MATH_CONST.PI2);\r\n        this.strokePath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the given rectangle.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillRectShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} rect - The rectangle to fill.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillRectShape: function (rect)\r\n    {\r\n        return this.fillRect(rect.x, rect.y, rect.width, rect.height);\r\n    },\r\n\r\n    /**\r\n     * Stroke the given rectangle.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeRectShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} rect - The rectangle to stroke.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeRectShape: function (rect)\r\n    {\r\n        return this.strokeRect(rect.x, rect.y, rect.width, rect.height);\r\n    },\r\n\r\n    /**\r\n     * Fill a rectangle with the given position and size.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillRect\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the top-left of the rectangle.\r\n     * @param {number} y - The y coordinate of the top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillRect: function (x, y, width, height)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.FILL_RECT,\r\n            x, y, width, height\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke a rectangle with the given position and size.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeRect\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the top-left of the rectangle.\r\n     * @param {number} y - The y coordinate of the top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeRect: function (x, y, width, height)\r\n    {\r\n        var lineWidthHalf = this._lineWidth / 2;\r\n        var minx = x - lineWidthHalf;\r\n        var maxx = x + lineWidthHalf;\r\n\r\n        this.beginPath();\r\n        this.moveTo(x, y);\r\n        this.lineTo(x, y + height);\r\n        this.strokePath();\r\n\r\n        this.beginPath();\r\n        this.moveTo(x + width, y);\r\n        this.lineTo(x + width, y + height);\r\n        this.strokePath();\r\n\r\n        this.beginPath();\r\n        this.moveTo(minx, y);\r\n        this.lineTo(maxx + width, y);\r\n        this.strokePath();\r\n\r\n        this.beginPath();\r\n        this.moveTo(minx, y + height);\r\n        this.lineTo(maxx + width, y + height);\r\n        this.strokePath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill a rounded rectangle with the given position, size and radius.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillRoundedRect\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} x - The x coordinate of the top-left of the rectangle.\r\n     * @param {number} y - The y coordinate of the top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     * @param {(Phaser.Types.GameObjects.Graphics.RoundedRectRadius|number)} [radius=20] - The corner radius; It can also be an object to specify different radii for corners.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillRoundedRect: function (x, y, width, height, radius)\r\n    {\r\n        if (radius === undefined) { radius = 20; }\r\n\r\n        var tl = radius;\r\n        var tr = radius;\r\n        var bl = radius;\r\n        var br = radius;\r\n\r\n        if (typeof radius !== 'number')\r\n        {\r\n            tl = GetFastValue(radius, 'tl', 20);\r\n            tr = GetFastValue(radius, 'tr', 20);\r\n            bl = GetFastValue(radius, 'bl', 20);\r\n            br = GetFastValue(radius, 'br', 20);\r\n        }\r\n\r\n        this.beginPath();\r\n        this.moveTo(x + tl, y);\r\n        this.lineTo(x + width - tr, y);\r\n        this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);\r\n        this.lineTo(x + width, y + height - br);\r\n        this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);\r\n        this.lineTo(x + bl, y + height);\r\n        this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);\r\n        this.lineTo(x, y + tl);\r\n        this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);\r\n        this.fillPath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke a rounded rectangle with the given position, size and radius.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeRoundedRect\r\n     * @since 3.11.0\r\n     *\r\n     * @param {number} x - The x coordinate of the top-left of the rectangle.\r\n     * @param {number} y - The y coordinate of the top-left of the rectangle.\r\n     * @param {number} width - The width of the rectangle.\r\n     * @param {number} height - The height of the rectangle.\r\n     * @param {(Phaser.Types.GameObjects.Graphics.RoundedRectRadius|number)} [radius=20] - The corner radius; It can also be an object to specify different radii for corners.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeRoundedRect: function (x, y, width, height, radius)\r\n    {\r\n        if (radius === undefined) { radius = 20; }\r\n\r\n        var tl = radius;\r\n        var tr = radius;\r\n        var bl = radius;\r\n        var br = radius;\r\n\r\n        if (typeof radius !== 'number')\r\n        {\r\n            tl = GetFastValue(radius, 'tl', 20);\r\n            tr = GetFastValue(radius, 'tr', 20);\r\n            bl = GetFastValue(radius, 'bl', 20);\r\n            br = GetFastValue(radius, 'br', 20);\r\n        }\r\n\r\n        this.beginPath();\r\n        this.moveTo(x + tl, y);\r\n        this.lineTo(x + width - tr, y);\r\n        this.moveTo(x + width - tr, y);\r\n        this.arc(x + width - tr, y + tr, tr, -MATH_CONST.TAU, 0);\r\n        this.lineTo(x + width, y + height - br);\r\n        this.moveTo(x + width, y + height - br);\r\n        this.arc(x + width - br, y + height - br, br, 0, MATH_CONST.TAU);\r\n        this.lineTo(x + bl, y + height);\r\n        this.moveTo(x + bl, y + height);\r\n        this.arc(x + bl, y + height - bl, bl, MATH_CONST.TAU, Math.PI);\r\n        this.lineTo(x, y + tl);\r\n        this.moveTo(x, y + tl);\r\n        this.arc(x + tl, y + tl, tl, -Math.PI, -MATH_CONST.TAU);\r\n        this.strokePath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the given point.\r\n     *\r\n     * Draws a square at the given position, 1 pixel in size by default.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillPointShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Geom.Point|Phaser.Math.Vector2|object)} point - The point to fill.\r\n     * @param {number} [size=1] - The size of the square to draw.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillPointShape: function (point, size)\r\n    {\r\n        return this.fillPoint(point.x, point.y, size);\r\n    },\r\n\r\n    /**\r\n     * Fill a point at the given position.\r\n     *\r\n     * Draws a square at the given position, 1 pixel in size by default.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the point.\r\n     * @param {number} y - The y coordinate of the point.\r\n     * @param {number} [size=1] - The size of the square to draw.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillPoint: function (x, y, size)\r\n    {\r\n        if (!size || size < 1)\r\n        {\r\n            size = 1;\r\n        }\r\n        else\r\n        {\r\n            x -= (size / 2);\r\n            y -= (size / 2);\r\n        }\r\n\r\n        this.commandBuffer.push(\r\n            Commands.FILL_RECT,\r\n            x, y, size, size\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the given triangle.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillTriangleShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Triangle} triangle - The triangle to fill.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillTriangleShape: function (triangle)\r\n    {\r\n        return this.fillTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);\r\n    },\r\n\r\n    /**\r\n     * Stroke the given triangle.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeTriangleShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Triangle} triangle - The triangle to stroke.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeTriangleShape: function (triangle)\r\n    {\r\n        return this.strokeTriangle(triangle.x1, triangle.y1, triangle.x2, triangle.y2, triangle.x3, triangle.y3);\r\n    },\r\n\r\n    /**\r\n     * Fill a triangle with the given points.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x0 - The x coordinate of the first point.\r\n     * @param {number} y0 - The y coordinate of the first point.\r\n     * @param {number} x1 - The x coordinate of the second point.\r\n     * @param {number} y1 - The y coordinate of the second point.\r\n     * @param {number} x2 - The x coordinate of the third point.\r\n     * @param {number} y2 - The y coordinate of the third point.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillTriangle: function (x0, y0, x1, y1, x2, y2)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.FILL_TRIANGLE,\r\n            x0, y0, x1, y1, x2, y2\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke a triangle with the given points.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeTriangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x0 - The x coordinate of the first point.\r\n     * @param {number} y0 - The y coordinate of the first point.\r\n     * @param {number} x1 - The x coordinate of the second point.\r\n     * @param {number} y1 - The y coordinate of the second point.\r\n     * @param {number} x2 - The x coordinate of the third point.\r\n     * @param {number} y2 - The y coordinate of the third point.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeTriangle: function (x0, y0, x1, y1, x2, y2)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.STROKE_TRIANGLE,\r\n            x0, y0, x1, y1, x2, y2\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draw the given line.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeLineShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Line} line - The line to stroke.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeLineShape: function (line)\r\n    {\r\n        return this.lineBetween(line.x1, line.y1, line.x2, line.y2);\r\n    },\r\n\r\n    /**\r\n     * Draw a line between the given points.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#lineBetween\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x1 - The x coordinate of the start point of the line.\r\n     * @param {number} y1 - The y coordinate of the start point of the line.\r\n     * @param {number} x2 - The x coordinate of the end point of the line.\r\n     * @param {number} y2 - The y coordinate of the end point of the line.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    lineBetween: function (x1, y1, x2, y2)\r\n    {\r\n        this.beginPath();\r\n        this.moveTo(x1, y1);\r\n        this.lineTo(x2, y2);\r\n        this.strokePath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draw a line from the current drawing position to the given position.\r\n     *\r\n     * Moves the current drawing position to the given position.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#lineTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to draw the line to.\r\n     * @param {number} y - The y coordinate to draw the line to.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    lineTo: function (x, y)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.LINE_TO,\r\n            x, y\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Move the current drawing position to the given position.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#moveTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to move to.\r\n     * @param {number} y - The y coordinate to move to.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    moveTo: function (x, y)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.MOVE_TO,\r\n            x, y\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke the shape represented by the given array of points.\r\n     *\r\n     * Pass `closeShape` to automatically close the shape by joining the last to the first point.\r\n     *\r\n     * Pass `closePath` to automatically close the path before it is stroked.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokePoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(array|Phaser.Geom.Point[])} points - The points to stroke.\r\n     * @param {boolean} [closeShape=false] - When `true`, the shape is closed by joining the last point to the first point.\r\n     * @param {boolean} [closePath=false] - When `true`, the path is closed before being stroked.\r\n     * @param {number} [endIndex] - The index of `points` to stop drawing at. Defaults to `points.length`.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokePoints: function (points, closeShape, closePath, endIndex)\r\n    {\r\n        if (closeShape === undefined) { closeShape = false; }\r\n        if (closePath === undefined) { closePath = false; }\r\n        if (endIndex === undefined) { endIndex = points.length; }\r\n\r\n        this.beginPath();\r\n\r\n        this.moveTo(points[0].x, points[0].y);\r\n\r\n        for (var i = 1; i < endIndex; i++)\r\n        {\r\n            this.lineTo(points[i].x, points[i].y);\r\n        }\r\n\r\n        if (closeShape)\r\n        {\r\n            this.lineTo(points[0].x, points[0].y);\r\n        }\r\n\r\n        if (closePath)\r\n        {\r\n            this.closePath();\r\n        }\r\n\r\n        this.strokePath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Fill the shape represented by the given array of points.\r\n     *\r\n     * Pass `closeShape` to automatically close the shape by joining the last to the first point.\r\n     *\r\n     * Pass `closePath` to automatically close the path before it is filled.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(array|Phaser.Geom.Point[])} points - The points to fill.\r\n     * @param {boolean} [closeShape=false] - When `true`, the shape is closed by joining the last point to the first point.\r\n     * @param {boolean} [closePath=false] - When `true`, the path is closed before being stroked.\r\n     * @param {number} [endIndex] - The index of `points` to stop at. Defaults to `points.length`.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillPoints: function (points, closeShape, closePath, endIndex)\r\n    {\r\n        if (closeShape === undefined) { closeShape = false; }\r\n        if (closePath === undefined) { closePath = false; }\r\n        if (endIndex === undefined) { endIndex = points.length; }\r\n\r\n        this.beginPath();\r\n\r\n        this.moveTo(points[0].x, points[0].y);\r\n\r\n        for (var i = 1; i < endIndex; i++)\r\n        {\r\n            this.lineTo(points[i].x, points[i].y);\r\n        }\r\n\r\n        if (closeShape)\r\n        {\r\n            this.lineTo(points[0].x, points[0].y);\r\n        }\r\n\r\n        if (closePath)\r\n        {\r\n            this.closePath();\r\n        }\r\n\r\n        this.fillPath();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stroke the given ellipse.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeEllipseShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Ellipse} ellipse - The ellipse to stroke.\r\n     * @param {number} [smoothness=32] - The number of points to draw the ellipse with.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeEllipseShape: function (ellipse, smoothness)\r\n    {\r\n        if (smoothness === undefined) { smoothness = 32; }\r\n\r\n        var points = ellipse.getPoints(smoothness);\r\n\r\n        return this.strokePoints(points, true);\r\n    },\r\n\r\n    /**\r\n     * Stroke an ellipse with the given position and size.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#strokeEllipse\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the center of the ellipse.\r\n     * @param {number} y - The y coordinate of the center of the ellipse.\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     * @param {number} [smoothness=32] - The number of points to draw the ellipse with.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    strokeEllipse: function (x, y, width, height, smoothness)\r\n    {\r\n        if (smoothness === undefined) { smoothness = 32; }\r\n\r\n        var ellipse = new Ellipse(x, y, width, height);\r\n\r\n        var points = ellipse.getPoints(smoothness);\r\n\r\n        return this.strokePoints(points, true);\r\n    },\r\n\r\n    /**\r\n     * Fill the given ellipse.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillEllipseShape\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Ellipse} ellipse - The ellipse to fill.\r\n     * @param {number} [smoothness=32] - The number of points to draw the ellipse with.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillEllipseShape: function (ellipse, smoothness)\r\n    {\r\n        if (smoothness === undefined) { smoothness = 32; }\r\n\r\n        var points = ellipse.getPoints(smoothness);\r\n\r\n        return this.fillPoints(points, true);\r\n    },\r\n\r\n    /**\r\n     * Fill an ellipse with the given position and size.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#fillEllipse\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the center of the ellipse.\r\n     * @param {number} y - The y coordinate of the center of the ellipse.\r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     * @param {number} [smoothness=32] - The number of points to draw the ellipse with.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    fillEllipse: function (x, y, width, height, smoothness)\r\n    {\r\n        if (smoothness === undefined) { smoothness = 32; }\r\n\r\n        var ellipse = new Ellipse(x, y, width, height);\r\n\r\n        var points = ellipse.getPoints(smoothness);\r\n\r\n        return this.fillPoints(points, true);\r\n    },\r\n\r\n    /**\r\n     * Draw an arc.\r\n     *\r\n     * This method can be used to create circles, or parts of circles.\r\n     *\r\n     * Make sure you call `beginPath` before starting the arc unless you wish for the arc to automatically\r\n     * close when filled or stroked.\r\n     *\r\n     * Use the optional `overshoot` argument increase the number of iterations that take place when\r\n     * the arc is rendered in WebGL. This is useful if you're drawing an arc with an especially thick line,\r\n     * as it will allow the arc to fully join-up. Try small values at first, i.e. 0.01.\r\n     *\r\n     * Call {@link Phaser.GameObjects.Graphics#fillPath} or {@link Phaser.GameObjects.Graphics#strokePath} after calling\r\n     * this method to draw the arc.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#arc\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate of the center of the circle.\r\n     * @param {number} y - The y coordinate of the center of the circle.\r\n     * @param {number} radius - The radius of the circle.\r\n     * @param {number} startAngle - The starting angle, in radians.\r\n     * @param {number} endAngle - The ending angle, in radians.\r\n     * @param {boolean} [anticlockwise=false] - Whether the drawing should be anticlockwise or clockwise.\r\n     * @param {number} [overshoot=0] - This value allows you to increase the segment iterations in WebGL rendering. Useful if the arc has a thick stroke and needs to overshoot to join-up cleanly. Use small numbers such as 0.01 to start with and increase as needed.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    arc: function (x, y, radius, startAngle, endAngle, anticlockwise, overshoot)\r\n    {\r\n        if (anticlockwise === undefined) { anticlockwise = false; }\r\n        if (overshoot === undefined) { overshoot = 0; }\r\n\r\n        this.commandBuffer.push(\r\n            Commands.ARC,\r\n            x, y, radius, startAngle, endAngle, anticlockwise, overshoot\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a pie-chart slice shape centered at `x`, `y` with the given radius.\r\n     * You must define the start and end angle of the slice.\r\n     *\r\n     * Setting the `anticlockwise` argument to `true` creates a shape similar to Pacman.\r\n     * Setting it to `false` creates a shape like a slice of pie.\r\n     *\r\n     * This method will begin a new path and close the path at the end of it.\r\n     * To display the actual slice you need to call either `strokePath` or `fillPath` after it.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#slice\r\n     * @since 3.4.0\r\n     *\r\n     * @param {number} x - The horizontal center of the slice.\r\n     * @param {number} y - The vertical center of the slice.\r\n     * @param {number} radius - The radius of the slice.\r\n     * @param {number} startAngle - The start angle of the slice, given in radians.\r\n     * @param {number} endAngle - The end angle of the slice, given in radians.\r\n     * @param {boolean} [anticlockwise=false] - Whether the drawing should be anticlockwise or clockwise.\r\n     * @param {number} [overshoot=0] - This value allows you to overshoot the endAngle by this amount. Useful if the arc has a thick stroke and needs to overshoot to join-up cleanly.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    slice: function (x, y, radius, startAngle, endAngle, anticlockwise, overshoot)\r\n    {\r\n        if (anticlockwise === undefined) { anticlockwise = false; }\r\n        if (overshoot === undefined) { overshoot = 0; }\r\n\r\n        this.commandBuffer.push(Commands.BEGIN_PATH);\r\n\r\n        this.commandBuffer.push(Commands.MOVE_TO, x, y);\r\n\r\n        this.commandBuffer.push(Commands.ARC, x, y, radius, startAngle, endAngle, anticlockwise, overshoot);\r\n\r\n        this.commandBuffer.push(Commands.CLOSE_PATH);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Saves the state of the Graphics by pushing the current state onto a stack.\r\n     *\r\n     * The most recently saved state can then be restored with {@link Phaser.GameObjects.Graphics#restore}.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#save\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    save: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.SAVE\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Restores the most recently saved state of the Graphics by popping from the state stack.\r\n     *\r\n     * Use {@link Phaser.GameObjects.Graphics#save} to save the current state, and call this afterwards to restore that state.\r\n     *\r\n     * If there is no saved state, this command does nothing.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#restore\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    restore: function ()\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.RESTORE\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Inserts a translation command into this Graphics objects command buffer.\r\n     *\r\n     * All objects drawn _after_ calling this method will be translated\r\n     * by the given amount.\r\n     *\r\n     * This does not change the position of the Graphics object itself,\r\n     * only of the objects drawn by it after calling this method.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#translateCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal translation to apply.\r\n     * @param {number} y - The vertical translation to apply.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    translateCanvas: function (x, y)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.TRANSLATE,\r\n            x, y\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Inserts a scale command into this Graphics objects command buffer.\r\n     *\r\n     * All objects drawn _after_ calling this method will be scaled\r\n     * by the given amount.\r\n     *\r\n     * This does not change the scale of the Graphics object itself,\r\n     * only of the objects drawn by it after calling this method.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#scaleCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal scale to apply.\r\n     * @param {number} y - The vertical scale to apply.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    scaleCanvas: function (x, y)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.SCALE,\r\n            x, y\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Inserts a rotation command into this Graphics objects command buffer.\r\n     *\r\n     * All objects drawn _after_ calling this method will be rotated\r\n     * by the given amount.\r\n     *\r\n     * This does not change the rotation of the Graphics object itself,\r\n     * only of the objects drawn by it after calling this method.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#rotateCanvas\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} radians - The rotation angle, in radians.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    rotateCanvas: function (radians)\r\n    {\r\n        this.commandBuffer.push(\r\n            Commands.ROTATE,\r\n            radians\r\n        );\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clear the command buffer and reset the fill style and line style to their defaults.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#clear\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    clear: function ()\r\n    {\r\n        this.commandBuffer.length = 0;\r\n\r\n        if (this.defaultFillColor > -1)\r\n        {\r\n            this.fillStyle(this.defaultFillColor, this.defaultFillAlpha);\r\n        }\r\n\r\n        if (this.defaultStrokeColor > -1)\r\n        {\r\n            this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Generate a texture from this Graphics object.\r\n     *\r\n     * If `key` is a string it'll generate a new texture using it and add it into the\r\n     * Texture Manager (assuming no key conflict happens).\r\n     *\r\n     * If `key` is a Canvas it will draw the texture to that canvas context. Note that it will NOT\r\n     * automatically upload it to the GPU in WebGL mode.\r\n     *\r\n     * Please understand that the texture is created via the Canvas API of the browser, therefore some\r\n     * Graphics features, such as `fillGradientStyle`, will not appear on the resulting texture,\r\n     * as they're unsupported by the Canvas API.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#generateTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|HTMLCanvasElement)} key - The key to store the texture with in the Texture Manager, or a Canvas to draw to.\r\n     * @param {number} [width] - The width of the graphics to generate.\r\n     * @param {number} [height] - The height of the graphics to generate.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    generateTexture: function (key, width, height)\r\n    {\r\n        var sys = this.scene.sys;\r\n        var renderer = sys.game.renderer;\r\n\r\n        if (width === undefined) { width = sys.scale.width; }\r\n        if (height === undefined) { height = sys.scale.height; }\r\n\r\n        Graphics.TargetCamera.setScene(this.scene);\r\n        Graphics.TargetCamera.setViewport(0, 0, width, height);\r\n        Graphics.TargetCamera.scrollX = this.x;\r\n        Graphics.TargetCamera.scrollY = this.y;\r\n\r\n        var texture;\r\n        var ctx;\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            if (sys.textures.exists(key))\r\n            {\r\n                //  Key is a string, it DOES exist in the Texture Manager AND is a canvas, so draw to it\r\n\r\n                texture = sys.textures.get(key);\r\n\r\n                var src = texture.getSourceImage();\r\n\r\n                if (src instanceof HTMLCanvasElement)\r\n                {\r\n                    ctx = src.getContext('2d');\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Key is a string and doesn't exist in the Texture Manager, so generate and save it\r\n\r\n                texture = sys.textures.createCanvas(key, width, height);\r\n\r\n                ctx = texture.getSourceImage().getContext('2d');\r\n            }\r\n        }\r\n        else if (key instanceof HTMLCanvasElement)\r\n        {\r\n            //  Key is a Canvas, so draw to it\r\n\r\n            ctx = key.getContext('2d');\r\n        }\r\n\r\n        if (ctx)\r\n        {\r\n            // var GraphicsCanvasRenderer = function (renderer, src, camera, parentMatrix, renderTargetCtx, allowClip)\r\n            this.renderCanvas(renderer, this, Graphics.TargetCamera, null, ctx, false);\r\n\r\n            if (texture)\r\n            {\r\n                texture.refresh();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Graphics#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.commandBuffer = [];\r\n    }\r\n\r\n});\r\n\r\n/**\r\n * A Camera used specifically by the Graphics system for rendering to textures.\r\n *\r\n * @name Phaser.GameObjects.Graphics.TargetCamera\r\n * @type {Phaser.Cameras.Scene2D.Camera}\r\n * @since 3.1.0\r\n */\r\nGraphics.TargetCamera = new BaseCamera();\r\n\r\nmodule.exports = Graphics;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Commands = require('./Commands');\r\nvar SetTransform = require('../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Graphics#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Graphics} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n * @param {CanvasRenderingContext2D} [renderTargetCtx] - The target rendering context.\r\n * @param {boolean} allowClip - If `true` then path operations will be used instead of fill operations.\r\n */\r\nvar GraphicsCanvasRenderer = function (renderer, src, camera, parentMatrix, renderTargetCtx, allowClip)\r\n{\r\n    var commandBuffer = src.commandBuffer;\r\n    var commandBufferLength = commandBuffer.length;\r\n\r\n    var ctx = renderTargetCtx || renderer.currentContext;\r\n\r\n    if (commandBufferLength === 0 || !SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var lineAlpha = 1;\r\n    var fillAlpha = 1;\r\n    var lineColor = 0;\r\n    var fillColor = 0;\r\n    var lineWidth = 1;\r\n    var red = 0;\r\n    var green = 0;\r\n    var blue = 0;\r\n\r\n    //  Reset any currently active paths\r\n    ctx.beginPath();\r\n\r\n    for (var index = 0; index < commandBufferLength; ++index)\r\n    {\r\n        var commandID = commandBuffer[index];\r\n\r\n        switch (commandID)\r\n        {\r\n            case Commands.ARC:\r\n                ctx.arc(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2],\r\n                    commandBuffer[index + 3],\r\n                    commandBuffer[index + 4],\r\n                    commandBuffer[index + 5],\r\n                    commandBuffer[index + 6]\r\n                );\r\n\r\n                //  +7 because overshoot is the 7th value, not used in Canvas\r\n                index += 7;\r\n                break;\r\n\r\n            case Commands.LINE_STYLE:\r\n                lineWidth = commandBuffer[index + 1];\r\n                lineColor = commandBuffer[index + 2];\r\n                lineAlpha = commandBuffer[index + 3];\r\n                red = ((lineColor & 0xFF0000) >>> 16);\r\n                green = ((lineColor & 0xFF00) >>> 8);\r\n                blue = (lineColor & 0xFF);\r\n                ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + lineAlpha + ')';\r\n                ctx.lineWidth = lineWidth;\r\n                index += 3;\r\n                break;\r\n\r\n            case Commands.FILL_STYLE:\r\n                fillColor = commandBuffer[index + 1];\r\n                fillAlpha = commandBuffer[index + 2];\r\n                red = ((fillColor & 0xFF0000) >>> 16);\r\n                green = ((fillColor & 0xFF00) >>> 8);\r\n                blue = (fillColor & 0xFF);\r\n                ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';\r\n                index += 2;\r\n                break;\r\n\r\n            case Commands.BEGIN_PATH:\r\n                ctx.beginPath();\r\n                break;\r\n\r\n            case Commands.CLOSE_PATH:\r\n                ctx.closePath();\r\n                break;\r\n\r\n            case Commands.FILL_PATH:\r\n                if (!allowClip)\r\n                {\r\n                    ctx.fill();\r\n                }\r\n                break;\r\n\r\n            case Commands.STROKE_PATH:\r\n                if (!allowClip)\r\n                {\r\n                    ctx.stroke();\r\n                }\r\n                break;\r\n\r\n            case Commands.FILL_RECT:\r\n                if (!allowClip)\r\n                {\r\n                    ctx.fillRect(\r\n                        commandBuffer[index + 1],\r\n                        commandBuffer[index + 2],\r\n                        commandBuffer[index + 3],\r\n                        commandBuffer[index + 4]\r\n                    );\r\n                }\r\n                else\r\n                {\r\n                    ctx.rect(\r\n                        commandBuffer[index + 1],\r\n                        commandBuffer[index + 2],\r\n                        commandBuffer[index + 3],\r\n                        commandBuffer[index + 4]\r\n                    );\r\n                }\r\n                index += 4;\r\n                break;\r\n\r\n            case Commands.FILL_TRIANGLE:\r\n                ctx.beginPath();\r\n                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);\r\n                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);\r\n                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);\r\n                ctx.closePath();\r\n                if (!allowClip)\r\n                {\r\n                    ctx.fill();\r\n                }\r\n                index += 6;\r\n                break;\r\n\r\n            case Commands.STROKE_TRIANGLE:\r\n                ctx.beginPath();\r\n                ctx.moveTo(commandBuffer[index + 1], commandBuffer[index + 2]);\r\n                ctx.lineTo(commandBuffer[index + 3], commandBuffer[index + 4]);\r\n                ctx.lineTo(commandBuffer[index + 5], commandBuffer[index + 6]);\r\n                ctx.closePath();\r\n                if (!allowClip)\r\n                {\r\n                    ctx.stroke();\r\n                }\r\n                index += 6;\r\n                break;\r\n\r\n            case Commands.LINE_TO:\r\n                ctx.lineTo(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2]\r\n                );\r\n                index += 2;\r\n                break;\r\n\r\n            case Commands.MOVE_TO:\r\n                ctx.moveTo(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2]\r\n                );\r\n                index += 2;\r\n                break;\r\n\r\n            case Commands.LINE_FX_TO:\r\n                ctx.lineTo(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2]\r\n                );\r\n                index += 5;\r\n                break;\r\n\r\n            case Commands.MOVE_FX_TO:\r\n                ctx.moveTo(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2]\r\n                );\r\n                index += 5;\r\n                break;\r\n\r\n            case Commands.SAVE:\r\n                ctx.save();\r\n                break;\r\n\r\n            case Commands.RESTORE:\r\n                ctx.restore();\r\n                break;\r\n\r\n            case Commands.TRANSLATE:\r\n                ctx.translate(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2]\r\n                );\r\n                index += 2;\r\n                break;\r\n\r\n            case Commands.SCALE:\r\n                ctx.scale(\r\n                    commandBuffer[index + 1],\r\n                    commandBuffer[index + 2]\r\n                );\r\n                index += 2;\r\n                break;\r\n\r\n            case Commands.ROTATE:\r\n                ctx.rotate(\r\n                    commandBuffer[index + 1]\r\n                );\r\n                index += 1;\r\n                break;\r\n\r\n            case Commands.GRADIENT_FILL_STYLE:\r\n                index += 5;\r\n                break;\r\n\r\n            case Commands.GRADIENT_LINE_STYLE:\r\n                index += 6;\r\n                break;\r\n        }\r\n    }\r\n\r\n    //  Restore the context saved in SetTransform\r\n    ctx.restore();\r\n};\r\n\r\nmodule.exports = GraphicsCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar Graphics = require('./Graphics');\r\n\r\n/**\r\n * Creates a new Graphics Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Graphics Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#graphics\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Graphics} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('graphics', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    var graphics = new Graphics(this.scene, config);\r\n\r\n    if (config.add)\r\n    {\r\n        this.scene.sys.displayList.add(graphics);\r\n    }\r\n    \r\n    return graphics;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Graphics = require('./Graphics');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Graphics Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Graphics Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#graphics\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Graphics.Options} [config] - The Graphics configuration.\r\n *\r\n * @return {Phaser.GameObjects.Graphics} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('graphics', function (config)\r\n{\r\n    return this.displayList.add(new Graphics(this.scene, config));\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./GraphicsWebGLRenderer');\r\n\r\n    //  Needed for Graphics.generateTexture\r\n    renderCanvas = require('./GraphicsCanvasRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./GraphicsCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Commands = require('./Commands');\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\nvar Point = function (x, y, width)\r\n{\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n};\r\n\r\nvar Path = function (x, y, width)\r\n{\r\n    this.points = [];\r\n    this.pointsLength = 1;\r\n    this.points[0] = new Point(x, y, width);\r\n};\r\n\r\nvar matrixStack = [];\r\nvar tempMatrix = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Graphics#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Graphics} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar GraphicsWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (src.commandBuffer.length === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    var currentMatrix = tempMatrix.loadIdentity();\r\n\r\n    var commands = src.commandBuffer;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    var lineWidth = 1;\r\n    var fillTint = pipeline.fillTint;\r\n    var strokeTint = pipeline.strokeTint;\r\n\r\n    var tx = 0;\r\n    var ty = 0;\r\n    var ta = 0;\r\n    var iterStep = 0.01;\r\n    var PI2 = Math.PI * 2;\r\n\r\n    var cmd;\r\n\r\n    var path = [];\r\n    var pathIndex = 0;\r\n    var pathOpen = true;\r\n    var lastPath = null;\r\n\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    for (var cmdIndex = 0; cmdIndex < commands.length; cmdIndex++)\r\n    {\r\n        cmd = commands[cmdIndex];\r\n\r\n        switch (cmd)\r\n        {\r\n            case Commands.BEGIN_PATH:\r\n            {\r\n                path.length = 0;\r\n                lastPath = null;\r\n                pathOpen = true;\r\n                break;\r\n            }\r\n\r\n            case Commands.CLOSE_PATH:\r\n            {\r\n                pathOpen = false;\r\n\r\n                if (lastPath && lastPath.points.length)\r\n                {\r\n                    lastPath.points.push(lastPath.points[0]);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case Commands.FILL_PATH:\r\n            {\r\n                for (pathIndex = 0; pathIndex < path.length; pathIndex++)\r\n                {\r\n                    pipeline.batchFillPath(\r\n                        path[pathIndex].points,\r\n                        currentMatrix,\r\n                        calcMatrix\r\n                    );\r\n                }\r\n                break;\r\n            }\r\n\r\n            case Commands.STROKE_PATH:\r\n            {\r\n                for (pathIndex = 0; pathIndex < path.length; pathIndex++)\r\n                {\r\n                    pipeline.batchStrokePath(\r\n                        path[pathIndex].points,\r\n                        lineWidth,\r\n                        pathOpen,\r\n                        currentMatrix,\r\n                        calcMatrix\r\n                    );\r\n                }\r\n                break;\r\n            }\r\n\r\n            case Commands.LINE_STYLE:\r\n            {\r\n                lineWidth = commands[++cmdIndex];\r\n                var strokeColor = commands[++cmdIndex];\r\n                var strokeAlpha = commands[++cmdIndex] * alpha;\r\n                var strokeTintColor = getTint(strokeColor, strokeAlpha);\r\n                strokeTint.TL = strokeTintColor;\r\n                strokeTint.TR = strokeTintColor;\r\n                strokeTint.BL = strokeTintColor;\r\n                strokeTint.BR = strokeTintColor;\r\n                break;\r\n            }\r\n\r\n            case Commands.FILL_STYLE:\r\n            {\r\n                var fillColor = commands[++cmdIndex];\r\n                var fillAlpha = commands[++cmdIndex] * alpha;\r\n                var fillTintColor = getTint(fillColor, fillAlpha);\r\n                fillTint.TL = fillTintColor;\r\n                fillTint.TR = fillTintColor;\r\n                fillTint.BL = fillTintColor;\r\n                fillTint.BR = fillTintColor;\r\n                break;\r\n            }\r\n\r\n            case Commands.GRADIENT_FILL_STYLE:\r\n            {\r\n                var alphaTL = commands[++cmdIndex] * alpha;\r\n                var alphaTR = commands[++cmdIndex] * alpha;\r\n                var alphaBL = commands[++cmdIndex] * alpha;\r\n                var alphaBR = commands[++cmdIndex] * alpha;\r\n\r\n                fillTint.TL = getTint(commands[++cmdIndex], alphaTL);\r\n                fillTint.TR = getTint(commands[++cmdIndex], alphaTR);\r\n                fillTint.BL = getTint(commands[++cmdIndex], alphaBL);\r\n                fillTint.BR = getTint(commands[++cmdIndex], alphaBR);\r\n                break;\r\n            }\r\n\r\n            case Commands.GRADIENT_LINE_STYLE:\r\n            {\r\n                lineWidth = commands[++cmdIndex];\r\n                var gradientLineAlpha = commands[++cmdIndex] * alpha;\r\n                strokeTint.TL = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                strokeTint.TR = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                strokeTint.BL = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                strokeTint.BR = getTint(commands[++cmdIndex], gradientLineAlpha);\r\n                break;\r\n            }\r\n\r\n            case Commands.ARC:\r\n            {\r\n                var iteration = 0;\r\n                var x = commands[++cmdIndex];\r\n                var y = commands[++cmdIndex];\r\n                var radius = commands[++cmdIndex];\r\n                var startAngle = commands[++cmdIndex];\r\n                var endAngle = commands[++cmdIndex];\r\n                var anticlockwise = commands[++cmdIndex];\r\n                var overshoot = commands[++cmdIndex];\r\n\r\n                endAngle -= startAngle;\r\n\r\n                if (anticlockwise)\r\n                {\r\n                    if (endAngle < -PI2)\r\n                    {\r\n                        endAngle = -PI2;\r\n                    }\r\n                    else if (endAngle > 0)\r\n                    {\r\n                        endAngle = -PI2 + endAngle % PI2;\r\n                    }\r\n                }\r\n                else if (endAngle > PI2)\r\n                {\r\n                    endAngle = PI2;\r\n                }\r\n                else if (endAngle < 0)\r\n                {\r\n                    endAngle = PI2 + endAngle % PI2;\r\n                }\r\n\r\n                if (lastPath === null)\r\n                {\r\n                    lastPath = new Path(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius, lineWidth);\r\n                    path.push(lastPath);\r\n                    iteration += iterStep;\r\n                }\r\n\r\n                while (iteration < 1 + overshoot)\r\n                {\r\n                    ta = endAngle * iteration + startAngle;\r\n                    tx = x + Math.cos(ta) * radius;\r\n                    ty = y + Math.sin(ta) * radius;\r\n\r\n                    lastPath.points.push(new Point(tx, ty, lineWidth));\r\n\r\n                    iteration += iterStep;\r\n                }\r\n\r\n                ta = endAngle + startAngle;\r\n                tx = x + Math.cos(ta) * radius;\r\n                ty = y + Math.sin(ta) * radius;\r\n\r\n                lastPath.points.push(new Point(tx, ty, lineWidth));\r\n\r\n                break;\r\n            }\r\n\r\n            case Commands.FILL_RECT:\r\n            {\r\n                pipeline.batchFillRect(\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    currentMatrix,\r\n                    calcMatrix\r\n                );\r\n                break;\r\n            }\r\n\r\n            case Commands.FILL_TRIANGLE:\r\n            {\r\n                pipeline.batchFillTriangle(\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    currentMatrix,\r\n                    calcMatrix\r\n                );\r\n                break;\r\n            }\r\n\r\n            case Commands.STROKE_TRIANGLE:\r\n            {\r\n                pipeline.batchStrokeTriangle(\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    commands[++cmdIndex],\r\n                    lineWidth,\r\n                    currentMatrix,\r\n                    calcMatrix\r\n                );\r\n                break;\r\n            }\r\n\r\n            case Commands.LINE_TO:\r\n            {\r\n                if (lastPath !== null)\r\n                {\r\n                    lastPath.points.push(new Point(commands[++cmdIndex], commands[++cmdIndex], lineWidth));\r\n                }\r\n                else\r\n                {\r\n                    lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);\r\n                    path.push(lastPath);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case Commands.MOVE_TO:\r\n            {\r\n                lastPath = new Path(commands[++cmdIndex], commands[++cmdIndex], lineWidth);\r\n                path.push(lastPath);\r\n                break;\r\n            }\r\n\r\n            case Commands.SAVE:\r\n            {\r\n                matrixStack.push(currentMatrix.copyToArray());\r\n                break;\r\n            }\r\n\r\n            case Commands.RESTORE:\r\n            {\r\n                currentMatrix.copyFromArray(matrixStack.pop());\r\n                break;\r\n            }\r\n\r\n            case Commands.TRANSLATE:\r\n            {\r\n                x = commands[++cmdIndex];\r\n                y = commands[++cmdIndex];\r\n                currentMatrix.translate(x, y);\r\n                break;\r\n            }\r\n\r\n            case Commands.SCALE:\r\n            {\r\n                x = commands[++cmdIndex];\r\n                y = commands[++cmdIndex];\r\n                currentMatrix.scale(x, y);\r\n                break;\r\n            }\r\n\r\n            case Commands.ROTATE:\r\n            {\r\n                currentMatrix.rotate(commands[++cmdIndex]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = GraphicsWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar Group = require('./Group');\r\n\r\n/**\r\n * Creates a new Group Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Group Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#group\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} config - The configuration object this Game Object will use to create itself.\r\n *\r\n * @return {Phaser.GameObjects.Group} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('group', function (config)\r\n{\r\n    return new Group(this.scene, null, config);\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Group = require('./Group');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Group Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Group Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#group\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupConfig[])} [children] - Game Objects to add to this Group; or the `config` argument.\r\n * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - A Group Configuration object.\r\n *\r\n * @return {Phaser.GameObjects.Group} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('group', function (children, config)\r\n{\r\n    return this.updateList.add(new Group(this.scene, children, config));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar Image = require('./Image');\r\n\r\n/**\r\n * Creates a new Image Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Image Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#image\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Image} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('image', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var key = GetAdvancedValue(config, 'key', null);\r\n    var frame = GetAdvancedValue(config, 'frame', null);\r\n\r\n    var image = new Image(this.scene, 0, 0, key, frame);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, image, config);\r\n\r\n    return image;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Image = require('./Image');\nvar GameObjectFactory = require('../GameObjectFactory');\n\n/**\n * Creates a new Image Game Object and adds it to the Scene.\n *\n * Note: This method will only be available if the Image Game Object has been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectFactory#image\n * @since 3.0.0\n *\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n *\n * @return {Phaser.GameObjects.Image} The Game Object that was created.\n */\nGameObjectFactory.register('image', function (x, y, key, frame)\n{\n    return this.displayList.add(new Image(this.scene, x, y, key, frame));\n});\n\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.GameObjects\r\n */\r\n\r\nvar GameObjects = {\r\n\r\n    Events: require('./events'),\r\n\r\n    DisplayList: require('./DisplayList'),\r\n    GameObjectCreator: require('./GameObjectCreator'),\r\n    GameObjectFactory: require('./GameObjectFactory'),\r\n    UpdateList: require('./UpdateList'),\r\n\r\n    Components: require('./components'),\r\n    GetCalcMatrix: require('./GetCalcMatrix'),\r\n\r\n    BuildGameObject: require('./BuildGameObject'),\r\n    BuildGameObjectAnimation: require('./BuildGameObjectAnimation'),\r\n    GameObject: require('./GameObject'),\r\n    BitmapText: require('./bitmaptext/static/BitmapText'),\r\n    Blitter: require('./blitter/Blitter'),\r\n    Bob: require('./blitter/Bob'),\r\n    Container: require('./container/Container'),\r\n    DOMElement: require('./domelement/DOMElement'),\r\n    DynamicBitmapText: require('./bitmaptext/dynamic/DynamicBitmapText'),\r\n    Extern: require('./extern/Extern.js'),\r\n    Graphics: require('./graphics/Graphics.js'),\r\n    Group: require('./group/Group'),\r\n    Image: require('./image/Image'),\r\n    Layer: require('./layer/Layer'),\r\n    Particles: require('./particles'),\r\n    PathFollower: require('./pathfollower/PathFollower'),\r\n    RenderTexture: require('./rendertexture/RenderTexture'),\r\n    RetroFont: require('./bitmaptext/RetroFont'),\r\n    Rope: require('./rope/Rope'),\r\n    Sprite: require('./sprite/Sprite'),\r\n\r\n    Text: require('./text/Text'),\r\n    GetTextSize: require('./text/GetTextSize'),\r\n    MeasureText: require('./text/MeasureText'),\r\n    TextStyle: require('./text/TextStyle'),\r\n\r\n    TileSprite: require('./tilesprite/TileSprite'),\r\n    Zone: require('./zone/Zone'),\r\n    Video: require('./video/Video'),\r\n\r\n    //  Shapes\r\n\r\n    Shape: require('./shape/Shape'),\r\n    Arc: require('./shape/arc/Arc'),\r\n    Curve: require('./shape/curve/Curve'),\r\n    Ellipse: require('./shape/ellipse/Ellipse'),\r\n    Grid: require('./shape/grid/Grid'),\r\n    IsoBox: require('./shape/isobox/IsoBox'),\r\n    IsoTriangle: require('./shape/isotriangle/IsoTriangle'),\r\n    Line: require('./shape/line/Line'),\r\n    Polygon: require('./shape/polygon/Polygon'),\r\n    Rectangle: require('./shape/rectangle/Rectangle'),\r\n    Star: require('./shape/star/Star'),\r\n    Triangle: require('./shape/triangle/Triangle'),\r\n\r\n    //  Game Object Factories\r\n\r\n    Factories: {\r\n        Blitter: require('./blitter/BlitterFactory'),\r\n        Container: require('./container/ContainerFactory'),\r\n        DOMElement: require('./domelement/DOMElementFactory'),\r\n        DynamicBitmapText: require('./bitmaptext/dynamic/DynamicBitmapTextFactory'),\r\n        Extern: require('./extern/ExternFactory'),\r\n        Graphics: require('./graphics/GraphicsFactory'),\r\n        Group: require('./group/GroupFactory'),\r\n        Image: require('./image/ImageFactory'),\r\n        Layer: require('./layer/LayerFactory'),\r\n        Particles: require('./particles/ParticleManagerFactory'),\r\n        PathFollower: require('./pathfollower/PathFollowerFactory'),\r\n        RenderTexture: require('./rendertexture/RenderTextureFactory'),\r\n        Rope: require('./rope/RopeFactory'),\r\n        Sprite: require('./sprite/SpriteFactory'),\r\n        StaticBitmapText: require('./bitmaptext/static/BitmapTextFactory'),\r\n        Text: require('./text/TextFactory'),\r\n        TileSprite: require('./tilesprite/TileSpriteFactory'),\r\n        Zone: require('./zone/ZoneFactory'),\r\n        Video: require('./video/VideoFactory'),\r\n\r\n        //  Shapes\r\n        Arc: require('./shape/arc/ArcFactory'),\r\n        Curve: require('./shape/curve/CurveFactory'),\r\n        Ellipse: require('./shape/ellipse/EllipseFactory'),\r\n        Grid: require('./shape/grid/GridFactory'),\r\n        IsoBox: require('./shape/isobox/IsoBoxFactory'),\r\n        IsoTriangle: require('./shape/isotriangle/IsoTriangleFactory'),\r\n        Line: require('./shape/line/LineFactory'),\r\n        Polygon: require('./shape/polygon/PolygonFactory'),\r\n        Rectangle: require('./shape/rectangle/RectangleFactory'),\r\n        Star: require('./shape/star/StarFactory'),\r\n        Triangle: require('./shape/triangle/TriangleFactory')\r\n    },\r\n\r\n    Creators: {\r\n        Blitter: require('./blitter/BlitterCreator'),\r\n        Container: require('./container/ContainerCreator'),\r\n        DynamicBitmapText: require('./bitmaptext/dynamic/DynamicBitmapTextCreator'),\r\n        Graphics: require('./graphics/GraphicsCreator'),\r\n        Group: require('./group/GroupCreator'),\r\n        Image: require('./image/ImageCreator'),\r\n        Layer: require('./layer/LayerCreator'),\r\n        Particles: require('./particles/ParticleManagerCreator'),\r\n        RenderTexture: require('./rendertexture/RenderTextureCreator'),\r\n        Rope: require('./rope/RopeCreator'),\r\n        Sprite: require('./sprite/SpriteCreator'),\r\n        StaticBitmapText: require('./bitmaptext/static/BitmapTextCreator'),\r\n        Text: require('./text/TextCreator'),\r\n        TileSprite: require('./tilesprite/TileSpriteCreator'),\r\n        Zone: require('./zone/ZoneCreator'),\r\n        Video: require('./video/VideoCreator')\r\n    }\r\n\r\n};\r\n\r\n//  WebGL only Game Objects\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    GameObjects.Shader = require('./shader/Shader');\r\n    GameObjects.Mesh = require('./mesh/Mesh');\r\n    GameObjects.PointLight = require('./pointlight/PointLight');\r\n\r\n    GameObjects.Factories.Shader = require('./shader/ShaderFactory');\r\n    GameObjects.Factories.Mesh = require('./mesh/MeshFactory');\r\n    GameObjects.Factories.PointLight = require('./pointlight/PointLightFactory');\r\n\r\n    GameObjects.Creators.Shader = require('./shader/ShaderCreator');\r\n    GameObjects.Creators.Mesh = require('./mesh/MeshCreator');\r\n    GameObjects.Creators.PointLight = require('./pointlight/PointLightCreator');\r\n\r\n    GameObjects.Light = require('./lights/Light');\r\n    GameObjects.LightsManager = require('./lights/LightsManager');\r\n    GameObjects.LightsPlugin = require('./lights/LightsPlugin');\r\n}\r\n\r\nmodule.exports = GameObjects;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../../renderer/BlendModes');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar ComponentsToJSON = require('../components/ToJSON');\r\nvar DataManager = require('../../data/DataManager');\r\nvar EventEmitter = require('eventemitter3');\r\nvar GameObjectEvents = require('../events');\r\nvar List = require('../../structs/List');\r\nvar Render = require('./LayerRender');\r\nvar SceneEvents = require('../../scene/events');\r\nvar StableSort = require('../../utils/array/StableSort');\r\n\r\n/**\r\n * @classdesc\r\n * A Layer Game Object.\r\n *\r\n * A Layer is a special type of Game Object that acts as a Display List. You can add any type of Game Object\r\n * to a Layer, just as you would to a Scene. Layers can be used to visually group together 'layers' of Game\r\n * Objects:\r\n *\r\n * ```javascript\r\n * const spaceman = this.add.sprite(150, 300, 'spaceman');\r\n * const bunny = this.add.sprite(400, 300, 'bunny');\r\n * const elephant = this.add.sprite(650, 300, 'elephant');\r\n *\r\n * const layer = this.add.layer();\r\n *\r\n * layer.add([ spaceman, bunny, elephant ]);\r\n * ```\r\n *\r\n * The 3 sprites in the example above will now be managed by the Layer they were added to. Therefore,\r\n * if you then set `layer.setVisible(false)` they would all vanish from the display.\r\n *\r\n * You can also control the depth of the Game Objects within the Layer. For example, calling the\r\n * `setDepth` method of a child of a Layer will allow you to adjust the depth of that child _within the\r\n * Layer itself_, rather than the whole Scene. The Layer, too, can have its depth set as well.\r\n *\r\n * The Layer class also offers many different methods for manipulating the list, such as the\r\n * methods `moveUp`, `moveDown`, `sendToBack`, `bringToTop` and so on. These allow you to change the\r\n * display list position of the Layers children, causing it to adjust the order in which they are\r\n * rendered. Using `setDepth` on a child allows you to override this.\r\n *\r\n * Layers can have Post FX Pipelines set, which allows you to easily enable a post pipeline across\r\n * a whole range of children, which, depending on the effect, can often be far more efficient that doing so\r\n * on a per-child basis.\r\n *\r\n * Layers have no position or size within the Scene. This means you cannot enable a Layer for\r\n * physics or input, or change the position, rotation or scale of a Layer. They also have no scroll\r\n * factor, texture, tint, origin, crop or bounds.\r\n *\r\n * If you need those kind of features then you should use a Container instead. Containers can be added\r\n * to Layers, but Layers cannot be added to Containers.\r\n *\r\n * However, you can set the Alpha, Blend Mode, Depth, Mask and Visible state of a Layer. These settings\r\n * will impact all children being rendered by the Layer.\r\n *\r\n * @class Layer\r\n * @extends Phaser.Structs.List.<Phaser.GameObjects.GameObject>\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Layer.\r\n */\r\nvar Layer = new Class({\r\n\r\n    Extends: List,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.Visible,\r\n        EventEmitter,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Layer (scene, children)\r\n    {\r\n        List.call(this, scene);\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Scene to which this Game Object belongs.\r\n         *\r\n         * Game Objects can only belong to one Scene.\r\n         *\r\n         * You should consider this property as being read-only. You cannot move a\r\n         * Game Object to another Scene by simply changing it.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.50.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Holds a reference to the Display List that contains this Game Object.\r\n         *\r\n         * This is set automatically when this Game Object is added to a Scene or Layer.\r\n         *\r\n         * You should treat this property as being read-only.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#displayList\r\n         * @type {(Phaser.GameObjects.DisplayList|Phaser.GameObjects.Layer)}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.displayList = null;\r\n\r\n        /**\r\n         * A textual representation of this Game Object, i.e. `sprite`.\r\n         * Used internally by Phaser but is available for your own custom classes to populate.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#type\r\n         * @type {string}\r\n         * @since 3.50.0\r\n         */\r\n        this.type = 'Layer';\r\n\r\n        /**\r\n         * The current state of this Game Object.\r\n         *\r\n         * Phaser itself will never modify this value, although plugins may do so.\r\n         *\r\n         * Use this property to track the state of a Game Object during its lifetime. For example, it could change from\r\n         * a state of 'moving', to 'attacking', to 'dead'. The state value should be an integer (ideally mapped to a constant\r\n         * in your game code), or a string. These are recommended to keep it light and simple, with fast comparisons.\r\n         * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#state\r\n         * @type {(number|string)}\r\n         * @since 3.50.0\r\n         */\r\n        this.state = 0;\r\n\r\n        /**\r\n         * A Layer cannot be placed inside a Container.\r\n         *\r\n         * This property is kept purely so a Layer has the same\r\n         * shape as a Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#parentContainer\r\n         * @type {Phaser.GameObjects.Container}\r\n         * @since 3.51.0\r\n         */\r\n        this.parentContainer = null;\r\n\r\n        /**\r\n         * The name of this Game Object.\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.50.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * The active state of this Game Object.\r\n         * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.\r\n         * An active object is one which is having its logic and internal systems updated.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.50.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * The Tab Index of the Game Object.\r\n         * Reserved for future use by plugins and the Input Manager.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#tabIndex\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.51.0\r\n         */\r\n        this.tabIndex = -1;\r\n\r\n        /**\r\n         * A Data Manager.\r\n         * It allows you to store, query and get key/value paired information specific to this Game Object.\r\n         * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#data\r\n         * @type {Phaser.Data.DataManager}\r\n         * @default null\r\n         * @since 3.50.0\r\n         */\r\n        this.data = null;\r\n\r\n        /**\r\n         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.\r\n         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.\r\n         * If those components are not used by your custom class then you can use this bitmask as you wish.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#renderFlags\r\n         * @type {number}\r\n         * @default 15\r\n         * @since 3.50.0\r\n         */\r\n        this.renderFlags = 15;\r\n\r\n        /**\r\n         * A bitmask that controls if this Game Object is drawn by a Camera or not.\r\n         * Not usually set directly, instead call `Camera.ignore`, however you can\r\n         * set this property directly using the Camera.id property:\r\n         *\r\n         * @example\r\n         * this.cameraFilter |= camera.id\r\n         *\r\n         * @name Phaser.GameObjects.Layer#cameraFilter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.50.0\r\n         */\r\n        this.cameraFilter = 0;\r\n\r\n        /**\r\n         * This property is kept purely so a Layer has the same\r\n         * shape as a Game Object. You cannot input enable a Layer.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#input\r\n         * @type {?Phaser.Types.Input.InteractiveObject}\r\n         * @default null\r\n         * @since 3.51.0\r\n         */\r\n        this.input = null;\r\n\r\n        /**\r\n         * This property is kept purely so a Layer has the same\r\n         * shape as a Game Object. You cannot give a Layer a physics body.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#body\r\n         * @type {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|MatterJS.BodyType)}\r\n         * @default null\r\n         * @since 3.51.0\r\n         */\r\n        this.body = null;\r\n\r\n        /**\r\n         * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.\r\n         * This includes calls that may come from a Group, Container or the Scene itself.\r\n         * While it allows you to persist a Game Object across Scenes, please understand you are entirely\r\n         * responsible for managing references to and from this Game Object.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#ignoreDestroy\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.50.0\r\n         */\r\n        this.ignoreDestroy = false;\r\n\r\n        /**\r\n         * A reference to the Scene Systems.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.50.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * A reference to the Scene Event Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#events\r\n         * @type {Phaser.Events.EventEmitter}\r\n         * @since 3.50.0\r\n         */\r\n        this.events = scene.sys.events;\r\n\r\n        /**\r\n         * The flag the determines whether Game Objects should be sorted when `depthSort()` is called.\r\n         *\r\n         * @name Phaser.GameObjects.Layer#sortChildrenFlag\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.50.0\r\n         */\r\n        this.sortChildrenFlag = false;\r\n\r\n        //  Set the List callbacks\r\n        this.addCallback = this.addChildCallback;\r\n        this.removeCallback = this.removeChildCallback;\r\n\r\n        this.initPipeline();\r\n\r\n        this.clearAlpha();\r\n\r\n        this.setBlendMode(BlendModes.SKIP_CHECK);\r\n\r\n        if (children)\r\n        {\r\n            this.add(children);\r\n        }\r\n\r\n        //  Tell the Scene to re-sort the children\r\n        scene.sys.queueDepthSort();\r\n    },\r\n\r\n    /**\r\n     * Sets the `active` property of this Game Object and returns this Game Object for further chaining.\r\n     * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#setActive\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} value - True if this Game Object should be set as active, false if not.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setActive: function (value)\r\n    {\r\n        this.active = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the `name` property of this Game Object and returns this Game Object for further chaining.\r\n     * The `name` property is not populated by Phaser and is presented for your own use.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#setName\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} value - The name to be given to this Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setName: function (value)\r\n    {\r\n        this.name = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current state of this Game Object.\r\n     *\r\n     * Phaser itself will never modify the State of a Game Object, although plugins may do so.\r\n     *\r\n     * For example, a Game Object could change from a state of 'moving', to 'attacking', to 'dead'.\r\n     * The state value should typically be an integer (ideally mapped to a constant\r\n     * in your game code), but could also be a string. It is recommended to keep it light and simple.\r\n     * If you need to store complex data about your Game Object, look at using the Data Component instead.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#setState\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(number|string)} value - The state of the Game Object.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setState: function (value)\r\n    {\r\n        this.state = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a Data Manager component to this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#setDataEnabled\r\n     * @since 3.50.0\r\n     * @see Phaser.Data.DataManager\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setDataEnabled: function ()\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Allows you to store a key value pair within this Game Objects Data Manager.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * ```javascript\r\n     * sprite.setData('name', 'Red Gem Stone');\r\n     * ```\r\n     *\r\n     * You can also pass in an object of key value pairs as the first argument:\r\n     *\r\n     * ```javascript\r\n     * sprite.setData({ name: 'Red Gem Stone', level: 2, owner: 'Link', gold: 50 });\r\n     * ```\r\n     *\r\n     * To get a value back again you can call `getData`:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or you can access the value directly via the `values` property, where it works like any other variable:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold += 50;\r\n     * ```\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * If the key already exists, a `changedata` event is emitted instead, along an event named after the key.\r\n     * For example, if you updated an existing key called `PlayerLives` then it would emit the event `changedata-PlayerLives`.\r\n     * These events will be emitted regardless if you use this method to set the value, or the direct `values` setter.\r\n     *\r\n     * Please note that the data keys are case-sensitive and must be valid JavaScript Object property strings.\r\n     * This means the keys `gold` and `Gold` are treated as two unique values within the Data Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#setData\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|object)} key - The key to set the value for. Or an object of key value pairs. If an object the `data` argument is ignored.\r\n     * @param {*} [data] - The value to set for the given key. If an object is provided as the key this argument is ignored.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setData: function (key, value)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.set(key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Increase a value for the given key within this Game Objects Data Manager. If the key doesn't already exist in the Data Manager then it is increased from 0.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#incData\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|object)} key - The key to increase the value for.\r\n     * @param {*} [data] - The value to increase for the given key.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    incData: function (key, value)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.inc(key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Toggle a boolean value for the given key within this Game Objects Data Manager. If the key doesn't already exist in the Data Manager then it is toggled from false.\r\n     *\r\n     * If the Game Object has not been enabled for data (via `setDataEnabled`) then it will be enabled\r\n     * before setting the value.\r\n     *\r\n     * If the key doesn't already exist in the Data Manager then it is created.\r\n     *\r\n     * When the value is first set, a `setdata` event is emitted from this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#toggleData\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|object)} key - The key to toggle the value for.\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    toggleData: function (key)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        this.data.toggle(key);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the value for the given key in this Game Objects Data Manager, or undefined if it doesn't exist.\r\n     *\r\n     * You can also access values via the `values` object. For example, if you had a key called `gold` you can do either:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData('gold');\r\n     * ```\r\n     *\r\n     * Or access the value directly:\r\n     *\r\n     * ```javascript\r\n     * sprite.data.values.gold;\r\n     * ```\r\n     *\r\n     * You can also pass in an array of keys, in which case an array of values will be returned:\r\n     *\r\n     * ```javascript\r\n     * sprite.getData([ 'gold', 'armor', 'health' ]);\r\n     * ```\r\n     *\r\n     * This approach is useful for destructuring arrays in ES6.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#getData\r\n     * @since 3.50.0\r\n     *\r\n     * @param {(string|string[])} key - The key of the value to retrieve, or an array of keys.\r\n     *\r\n     * @return {*} The value belonging to the given key, or an array of values, the order of which will match the input array.\r\n     */\r\n    getData: function (key)\r\n    {\r\n        if (!this.data)\r\n        {\r\n            this.data = new DataManager(this);\r\n        }\r\n\r\n        return this.data.get(key);\r\n    },\r\n\r\n    /**\r\n     * A Layer cannot be enabled for input.\r\n     *\r\n     * This method does nothing and is kept to ensure\r\n     * the Layer has the same shape as a Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#setInteractive\r\n     * @since 3.51.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    setInteractive: function ()\r\n    {\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * A Layer cannot be enabled for input.\r\n     *\r\n     * This method does nothing and is kept to ensure\r\n     * the Layer has the same shape as a Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#disableInteractive\r\n     * @since 3.51.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    disableInteractive: function ()\r\n    {\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * A Layer cannot be enabled for input.\r\n     *\r\n     * This method does nothing and is kept to ensure\r\n     * the Layer has the same shape as a Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#removeInteractive\r\n     * @since 3.51.0\r\n     *\r\n     * @return {this} This GameObject.\r\n     */\r\n    removeInteractive: function ()\r\n    {\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This callback is invoked when this Game Object is added to a Scene.\r\n     *\r\n     * Can be overriden by custom Game Objects, but be aware of some Game Objects that\r\n     * will use this, such as Sprites, to add themselves into the Update List.\r\n     *\r\n     * You can also listen for the `ADDED_TO_SCENE` event from this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#addedToScene\r\n     * @since 3.50.0\r\n     */\r\n    addedToScene: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * This callback is invoked when this Game Object is removed from a Scene.\r\n     *\r\n     * Can be overriden by custom Game Objects, but be aware of some Game Objects that\r\n     * will use this, such as Sprites, to removed themselves from the Update List.\r\n     *\r\n     * You can also listen for the `REMOVED_FROM_SCENE` event from this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#removedFromScene\r\n     * @since 3.50.0\r\n     */\r\n    removedFromScene: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#update\r\n     * @since 3.50.0\r\n     *\r\n     * @param {...*} [args] - args\r\n     */\r\n    update: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Returns a JSON representation of the Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#toJSON\r\n     * @since 3.50.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Game Object.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return ComponentsToJSON(this);\r\n    },\r\n\r\n    /**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     * Also checks the Game Object against the given Cameras exclusion list.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#willRender\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n     */\r\n    willRender: function (camera)\r\n    {\r\n        return !(this.renderFlags !== 15 || this.list.length === 0 || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));\r\n    },\r\n\r\n    /**\r\n     * Returns an array containing the display list index of either this Game Object, or if it has one,\r\n     * its parent Container. It then iterates up through all of the parent containers until it hits the\r\n     * root of the display list (which is index 0 in the returned array).\r\n     *\r\n     * Used internally by the InputPlugin but also useful if you wish to find out the display depth of\r\n     * this Game Object and all of its ancestors.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#getIndexList\r\n     * @since 3.51.0\r\n     *\r\n     * @return {number[]} An array of display list position indexes.\r\n     */\r\n    getIndexList: function ()\r\n    {\r\n        // eslint-disable-next-line consistent-this\r\n        var child = this;\r\n        var parent = this.parentContainer;\r\n\r\n        var indexes = [];\r\n\r\n        while (parent)\r\n        {\r\n            indexes.unshift(parent.getIndex(child));\r\n\r\n            child = parent;\r\n\r\n            if (!parent.parentContainer)\r\n            {\r\n                break;\r\n            }\r\n            else\r\n            {\r\n                parent = parent.parentContainer;\r\n            }\r\n        }\r\n\r\n        indexes.unshift(this.displayList.getIndex(child));\r\n\r\n        return indexes;\r\n    },\r\n\r\n    /**\r\n     * Internal method called from `List.addCallback`.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#addChildCallback\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#ADDED_TO_SCENE\r\n     * @fires Phaser.GameObjects.Events#ADDED_TO_SCENE\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was added to the list.\r\n     */\r\n    addChildCallback: function (gameObject)\r\n    {\r\n        if (gameObject.displayList && gameObject.displayList !== this)\r\n        {\r\n            gameObject.removeFromDisplayList();\r\n        }\r\n\r\n        if (!gameObject.displayList)\r\n        {\r\n            this.queueDepthSort();\r\n\r\n            gameObject.displayList = this;\r\n\r\n            gameObject.emit(GameObjectEvents.ADDED_TO_SCENE, gameObject, this.scene);\r\n\r\n            this.events.emit(SceneEvents.ADDED_TO_SCENE, gameObject, this.scene);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method called from `List.removeCallback`.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#removeChildCallback\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#REMOVED_FROM_SCENE\r\n     * @fires Phaser.GameObjects.Events#REMOVED_FROM_SCENE\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object that was removed from the list.\r\n     */\r\n    removeChildCallback: function (gameObject)\r\n    {\r\n        this.queueDepthSort();\r\n\r\n        gameObject.displayList = null;\r\n\r\n        gameObject.emit(GameObjectEvents.REMOVED_FROM_SCENE, gameObject, this.scene);\r\n\r\n        this.events.emit(SceneEvents.REMOVED_FROM_SCENE, gameObject, this.scene);\r\n    },\r\n\r\n    /**\r\n     * Force a sort of the display list on the next call to depthSort.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#queueDepthSort\r\n     * @since 3.50.0\r\n     */\r\n    queueDepthSort: function ()\r\n    {\r\n        this.sortChildrenFlag = true;\r\n    },\r\n\r\n    /**\r\n     * Immediately sorts the display list if the flag is set.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#depthSort\r\n     * @since 3.50.0\r\n     */\r\n    depthSort: function ()\r\n    {\r\n        if (this.sortChildrenFlag)\r\n        {\r\n            StableSort(this.list, this.sortByDepth);\r\n\r\n            this.sortChildrenFlag = false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Compare the depth of two Game Objects.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#sortByDepth\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} childA - The first Game Object.\r\n     * @param {Phaser.GameObjects.GameObject} childB - The second Game Object.\r\n     *\r\n     * @return {number} The difference between the depths of each Game Object.\r\n     */\r\n    sortByDepth: function (childA, childB)\r\n    {\r\n        return childA._depth - childB._depth;\r\n    },\r\n\r\n    /**\r\n     * Returns an array which contains all Game Objects within this Layer.\r\n     *\r\n     * This is a reference to the main list array, not a copy of it, so be careful not to modify it.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#getChildren\r\n     * @since 3.50.0\r\n     *\r\n     * @return {Phaser.GameObjects.GameObject[]} The group members.\r\n     */\r\n    getChildren: function ()\r\n    {\r\n        return this.list;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Layer removing it from the Display List and Update List and\r\n     * severing all ties to parent resources.\r\n     *\r\n     * Also destroys all children of this Layer. If you do not wish for the\r\n     * children to be destroyed, you should move them from this Layer first.\r\n     *\r\n     * Use this to remove this Layer from your game if you don't ever plan to use it again.\r\n     * As long as no reference to it exists within your own code it should become free for\r\n     * garbage collection by the browser.\r\n     *\r\n     * If you just want to temporarily disable an object then look at using the\r\n     * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.\r\n     *\r\n     * @method Phaser.GameObjects.Layer#destroy\r\n     * @fires Phaser.GameObjects.Events#DESTROY\r\n     * @since 3.50.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        //  This Game Object has already been destroyed\r\n        if (!this.scene || this.ignoreDestroy)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.emit(GameObjectEvents.DESTROY, this);\r\n\r\n        var i = this.list.length;\r\n\r\n        while (i--)\r\n        {\r\n            this.list[i].destroy();\r\n        }\r\n\r\n        this.removeAllListeners();\r\n\r\n        this.resetPostPipeline(true);\r\n\r\n        if (this.displayList)\r\n        {\r\n            this.displayList.remove(this, true);\r\n\r\n            this.displayList.queueDepthSort();\r\n        }\r\n\r\n        if (this.data)\r\n        {\r\n            this.data.destroy();\r\n\r\n            this.data = undefined;\r\n        }\r\n\r\n        this.active = false;\r\n        this.visible = false;\r\n\r\n        this.list = undefined;\r\n        this.scene = undefined;\r\n        this.displayList = undefined;\r\n        this.systems = undefined;\r\n        this.events = undefined;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Layer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Renders this Game Object with the Canvas Renderer to the given Camera.\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\n * This method should not be called directly. It is a utility function of the Render module.\n *\n * @method Phaser.GameObjects.Layer#renderCanvas\n * @since 3.50.0\n * @private\n *\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\n * @param {Phaser.GameObjects.Layer} layer - The Game Object being rendered in this call.\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\n */\nvar LayerCanvasRenderer = function (renderer, layer, camera)\n{\n    var children = layer.list;\n\n    if (children.length === 0)\n    {\n        return;\n    }\n\n    layer.depthSort();\n\n    var layerHasBlendMode = (layer.blendMode !== -1);\n\n    if (!layerHasBlendMode)\n    {\n        //  If Layer is SKIP_TEST then set blend mode to be Normal\n        renderer.setBlendMode(0);\n    }\n\n    var alpha = layer._alpha;\n\n    if (layer.mask)\n    {\n        layer.mask.preRenderCanvas(renderer, null, camera);\n    }\n\n    for (var i = 0; i < children.length; i++)\n    {\n        var child = children[i];\n\n        if (!child.willRender(camera))\n        {\n            continue;\n        }\n\n        var childAlpha = child.alpha;\n\n        if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode)\n        {\n            //  If Layer doesn't have its own blend mode, then a child can have one\n            renderer.setBlendMode(child.blendMode);\n        }\n\n        //  Set parent values\n        child.setAlpha(childAlpha * alpha);\n\n        //  Render\n        child.renderCanvas(renderer, child, camera);\n\n        //  Restore original values\n        child.setAlpha(childAlpha);\n    }\n\n    if (layer.mask)\n    {\n        layer.mask.postRenderCanvas(renderer);\n    }\n};\n\nmodule.exports = LayerCanvasRenderer;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar Layer = require('./Layer');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\n\r\n/**\r\n * Creates a new Layer Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Layer Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#layer\r\n * @since 3.50.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Layer} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('layer', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var children = GetAdvancedValue(config, 'children', null);\r\n\r\n    var layer = new Layer(this.scene, children);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, layer, config);\r\n\r\n    return layer;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Layer = require('./Layer');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Layer Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Layer Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#layer\r\n * @since 3.50.0\r\n *\r\n * @param {Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]} [children] - An optional array of Game Objects to add to this Layer.\r\n *\r\n * @return {Phaser.GameObjects.Layer} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('layer', function (children)\r\n{\r\n    return this.displayList.add(new Layer(this.scene, children));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./LayerWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./LayerCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Layer#renderWebGL\r\n * @since 3.50.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Layer} layer - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */\r\nvar LayerWebGLRenderer = function (renderer, layer, camera)\r\n{\r\n    var children = layer.list;\r\n    var childCount = children.length;\r\n\r\n    if (childCount === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    layer.depthSort();\r\n\r\n    renderer.pipelines.preBatch(layer);\r\n\r\n    var layerHasBlendMode = (layer.blendMode !== -1);\r\n\r\n    if (!layerHasBlendMode)\r\n    {\r\n        //  If Layer is SKIP_TEST then set blend mode to be Normal\r\n        renderer.setBlendMode(0);\r\n    }\r\n\r\n    var alpha = layer.alpha;\r\n\r\n    for (var i = 0; i < childCount; i++)\r\n    {\r\n        var child = children[i];\r\n\r\n        if (!child.willRender(camera))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        var childAlphaTopLeft;\r\n        var childAlphaTopRight;\r\n        var childAlphaBottomLeft;\r\n        var childAlphaBottomRight;\r\n\r\n        if (child.alphaTopLeft !== undefined)\r\n        {\r\n            childAlphaTopLeft = child.alphaTopLeft;\r\n            childAlphaTopRight = child.alphaTopRight;\r\n            childAlphaBottomLeft = child.alphaBottomLeft;\r\n            childAlphaBottomRight = child.alphaBottomRight;\r\n        }\r\n        else\r\n        {\r\n            var childAlpha = child.alpha;\r\n\r\n            childAlphaTopLeft = childAlpha;\r\n            childAlphaTopRight = childAlpha;\r\n            childAlphaBottomLeft = childAlpha;\r\n            childAlphaBottomRight = childAlpha;\r\n        }\r\n\r\n        if (!layerHasBlendMode && child.blendMode !== renderer.currentBlendMode)\r\n        {\r\n            //  If Layer doesn't have its own blend mode, then a child can have one\r\n            renderer.setBlendMode(child.blendMode);\r\n        }\r\n\r\n        var mask = child.mask;\r\n\r\n        if (mask)\r\n        {\r\n            mask.preRenderWebGL(renderer, child, camera);\r\n        }\r\n\r\n        var type = child.type;\r\n\r\n        if (type !== renderer.currentType)\r\n        {\r\n            renderer.newType = true;\r\n            renderer.currentType = type;\r\n        }\r\n\r\n        renderer.nextTypeMatch = (i < childCount - 1) ? (children[i + 1].type === renderer.currentType) : false;\r\n\r\n        child.setAlpha(childAlphaTopLeft * alpha, childAlphaTopRight * alpha, childAlphaBottomLeft * alpha, childAlphaBottomRight * alpha);\r\n\r\n        //  Render\r\n        child.renderWebGL(renderer, child, camera);\r\n\r\n        //  Restore original values\r\n        child.setAlpha(childAlphaTopLeft, childAlphaTopRight, childAlphaBottomLeft, childAlphaBottomRight);\r\n\r\n        if (mask)\r\n        {\r\n            mask.postRenderWebGL(renderer, camera);\r\n        }\r\n\r\n        renderer.newType = false;\r\n    }\r\n\r\n    renderer.pipelines.postBatch(layer);\r\n};\r\n\r\nmodule.exports = LayerWebGLRenderer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Circle = require('../../geom/circle/Circle');\nvar Class = require('../../utils/Class');\nvar Components = require('../components');\nvar RGB = require('../../display/RGB');\nvar Utils = require('../../renderer/webgl/Utils');\n\n/**\n * @classdesc\n * A 2D point light.\n *\n * These are typically created by a {@link Phaser.GameObjects.LightsManager}, available from within a scene via `this.lights`.\n *\n * Any Game Objects using the Light2D pipeline will then be affected by these Lights as long as they have a normal map.\n *\n * They can also simply be used to represent a point light for your own purposes.\n *\n * @class Light\n * @extends Phaser.Geom.Circle\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @extends Phaser.GameObjects.Components.ScrollFactor\n * @extends Phaser.GameObjects.Components.Visible\n *\n * @param {number} x - The horizontal position of the light.\n * @param {number} y - The vertical position of the light.\n * @param {number} radius - The radius of the light.\n * @param {number} r - The red color of the light. A value between 0 and 1.\n * @param {number} g - The green color of the light. A value between 0 and 1.\n * @param {number} b - The blue color of the light. A value between 0 and 1.\n * @param {number} intensity - The intensity of the light.\n */\nvar Light = new Class({\n\n    Extends: Circle,\n\n    Mixins: [\n        Components.ScrollFactor,\n        Components.Visible\n    ],\n\n    initialize:\n\n    function Light (x, y, radius, r, g, b, intensity)\n    {\n        Circle.call(this, x, y, radius);\n\n        /**\n         * The color of the light.\n         *\n         * @name Phaser.GameObjects.Light#color\n         * @type {Phaser.Display.RGB}\n         * @since 3.50.0\n         */\n        this.color = new RGB(r, g, b);\n\n        /**\n         * The intensity of the light.\n         *\n         * @name Phaser.GameObjects.Light#intensity\n         * @type {number}\n         * @since 3.50.0\n         */\n        this.intensity = intensity;\n\n        /**\n         * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.\n         * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.\n         * If those components are not used by your custom class then you can use this bitmask as you wish.\n         *\n         * @name Phaser.GameObjects.GameObject#renderFlags\n         * @type {number}\n         * @default 15\n         * @since 3.0.0\n         */\n        this.renderFlags = 15;\n\n        /**\n         * A bitmask that controls if this Game Object is drawn by a Camera or not.\n         * Not usually set directly, instead call `Camera.ignore`, however you can\n         * set this property directly using the Camera.id property:\n         *\n         * @example\n         * this.cameraFilter |= camera.id\n         *\n         * @name Phaser.GameObjects.GameObject#cameraFilter\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.cameraFilter = 0;\n\n        this.setScrollFactor(1, 1);\n    },\n\n    /**\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\n     * Also checks the Game Object against the given Cameras exclusion list.\n     *\n     * @method Phaser.GameObjects.Light#willRender\n     * @since 3.50.0\n     *\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\n     *\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\n     */\n    willRender: function (camera)\n    {\n        return !(Light.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));\n    },\n\n    /**\n     * Set the color of the light from a single integer RGB value.\n     *\n     * @method Phaser.GameObjects.Light#setColor\n     * @since 3.0.0\n     *\n     * @param {number} rgb - The integer RGB color of the light.\n     *\n     * @return {this} This Light object.\n     */\n    setColor: function (rgb)\n    {\n        var color = Utils.getFloatsFromUintRGB(rgb);\n\n        this.color.set(color[0], color[1], color[2]);\n\n        return this;\n    },\n\n    /**\n     * Set the intensity of the light.\n     *\n     * @method Phaser.GameObjects.Light#setIntensity\n     * @since 3.0.0\n     *\n     * @param {number} intensity - The intensity of the light.\n     *\n     * @return {this} This Light object.\n     */\n    setIntensity: function (intensity)\n    {\n        this.intensity = intensity;\n\n        return this;\n    },\n\n    /**\n     * Set the radius of the light.\n     *\n     * @method Phaser.GameObjects.Light#setRadius\n     * @since 3.0.0\n     *\n     * @param {number} radius - The radius of the light.\n     *\n     * @return {this} This Light object.\n     */\n    setRadius: function (radius)\n    {\n        this.radius = radius;\n\n        return this;\n    }\n\n});\n\n/**\n * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.\n *\n * @constant {number} RENDER_MASK\n * @memberof Phaser.GameObjects.Light\n * @default\n */\nLight.RENDER_MASK = 15;\n\nmodule.exports = Light;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CircleToRectangle = require('../../geom/intersects/CircleToRectangle');\r\nvar Class = require('../../utils/Class');\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\nvar Light = require('./Light');\r\nvar PointLight = require('../pointlight/PointLight');\r\nvar RGB = require('../../display/RGB');\r\nvar SpliceOne = require('../../utils/array/SpliceOne');\r\nvar StableSort = require('../../utils/array/StableSort');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * @callback LightForEach\r\n *\r\n * @param {Phaser.GameObjects.Light} light - The Light.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Manages Lights for a Scene.\r\n *\r\n * Affects the rendering of Game Objects using the `Light2D` pipeline.\r\n *\r\n * @class LightsManager\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n */\r\nvar LightsManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function LightsManager ()\r\n    {\r\n        /**\r\n         * The Lights in the Scene.\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#lights\r\n         * @type {Phaser.GameObjects.Light[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.lights = [];\r\n\r\n        /**\r\n         * The ambient color.\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#ambientColor\r\n         * @type {Phaser.Display.RGB}\r\n         * @since 3.50.0\r\n         */\r\n        this.ambientColor = new RGB(0.1, 0.1, 0.1);\r\n\r\n        /**\r\n         * Whether the Lights Manager is enabled.\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#active\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.active = false;\r\n\r\n        /**\r\n         * The maximum number of lights that a single Camera and the lights shader can process.\r\n         * Change this via the `maxLights` property in your game config, as it cannot be changed at runtime.\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#maxLights\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.15.0\r\n         */\r\n        this.maxLights = -1;\r\n\r\n        /**\r\n         * The number of lights that the LightPipeline processed in the _previous_ frame.\r\n         *\r\n         * @name Phaser.GameObjects.LightsManager#visibleLights\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.visibleLights = 0;\r\n    },\r\n\r\n    /**\r\n     * Creates a new Point Light Game Object and adds it to the Scene.\r\n     *\r\n     * Note: This method will only be available if the Point Light Game Object has been built into Phaser.\r\n     *\r\n     * The Point Light Game Object provides a way to add a point light effect into your game,\r\n     * without the expensive shader processing requirements of the traditional Light Game Object.\r\n     *\r\n     * The difference is that the Point Light renders using a custom shader, designed to give the\r\n     * impression of a point light source, of variable radius, intensity and color, in your game.\r\n     * However, unlike the Light Game Object, it does not impact any other Game Objects, or use their\r\n     * normal maps for calcuations. This makes them extremely fast to render compared to Lights\r\n     * and perfect for special effects, such as flickering torches or muzzle flashes.\r\n     *\r\n     * For maximum performance you should batch Point Light Game Objects together. This means\r\n     * ensuring they follow each other consecutively on the display list. Ideally, use a Layer\r\n     * Game Object and then add just Point Lights to it, so that it can batch together the rendering\r\n     * of the lights. You don't _have_ to do this, and if you've only a handful of Point Lights in\r\n     * your game then it's perfectly safe to mix them into the dislay list as normal. However, if\r\n     * you're using a large number of them, please consider how they are mixed into the display list.\r\n     *\r\n     * The renderer will automatically cull Point Lights. Those with a radius that does not intersect\r\n     * with the Camera will be skipped in the rendering list. This happens automatically and the\r\n     * culled state is refreshed every frame, for every camera.\r\n     *\r\n     * The origin of a Point Light is always 0.5 and it cannot be changed.\r\n     *\r\n     * Point Lights are a WebGL only feature and do not have a Canvas counterpart.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#addPointLight\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The horizontal position of this Point Light in the world.\r\n     * @param {number} y - The vertical position of this Point Light in the world.\r\n     * @param {number} [color=0xffffff] - The color of the Point Light, given as a hex value.\r\n     * @param {number} [radius=128] - The radius of the Point Light.\r\n     * @param {number} [intensity=1] - The intensity, or colr blend, of the Point Light.\r\n     * @param {number} [attenuation=0.1] - The attenuation  of the Point Light. This is the reduction of light from the center point.\r\n     *\r\n     * @return {Phaser.GameObjects.PointLight} The Game Object that was created.\r\n     */\r\n    addPointLight: function (x, y, color, radius, intensity, attenuation)\r\n    {\r\n        return this.systems.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));\r\n    },\r\n\r\n    /**\r\n     * Enable the Lights Manager.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#enable\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Lights Manager instance.\r\n     */\r\n    enable: function ()\r\n    {\r\n        if (this.maxLights === -1)\r\n        {\r\n            this.maxLights = this.systems.renderer.config.maxLights;\r\n        }\r\n\r\n        this.active = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Disable the Lights Manager.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#disable\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Lights Manager instance.\r\n     */\r\n    disable: function ()\r\n    {\r\n        this.active = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Get all lights that can be seen by the given Camera.\r\n     *\r\n     * It will automatically cull lights that are outside the world view of the Camera.\r\n     *\r\n     * If more lights are returned than supported by the pipeline, the lights are then culled\r\n     * based on the distance from the center of the camera. Only those closest are rendered.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#getLights\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to cull Lights for.\r\n     *\r\n     * @return {Phaser.GameObjects.Light[]} The culled Lights.\r\n     */\r\n    getLights: function (camera)\r\n    {\r\n        var lights = this.lights;\r\n        var worldView = camera.worldView;\r\n\r\n        var visibleLights = [];\r\n\r\n        for (var i = 0; i < lights.length; i++)\r\n        {\r\n            var light = lights[i];\r\n\r\n            if (light.willRender(camera) && CircleToRectangle(light, worldView))\r\n            {\r\n                visibleLights.push({\r\n                    light: light,\r\n                    distance: DistanceBetween(light.x, light.y, worldView.centerX, worldView.centerY)\r\n                });\r\n            }\r\n        }\r\n\r\n        if (visibleLights.length > this.maxLights)\r\n        {\r\n            //  We've got too many lights, so sort by distance from camera and cull those far away\r\n            //  This isn't ideal because it doesn't factor in the radius of the lights, but it'll do for now\r\n            //  and is significantly better than we had before!\r\n\r\n            StableSort(visibleLights, this.sortByDistance);\r\n\r\n            visibleLights = visibleLights.slice(0, this.maxLights);\r\n        }\r\n\r\n        this.visibleLights = visibleLights.length;\r\n\r\n        return visibleLights;\r\n    },\r\n\r\n    sortByDistance: function (a, b)\r\n    {\r\n        return (a.distance >= b.distance);\r\n    },\r\n\r\n    /**\r\n     * Set the ambient light color.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#setAmbientColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} rgb - The integer RGB color of the ambient light.\r\n     *\r\n     * @return {this} This Lights Manager instance.\r\n     */\r\n    setAmbientColor: function (rgb)\r\n    {\r\n        var color = Utils.getFloatsFromUintRGB(rgb);\r\n\r\n        this.ambientColor.set(color[0], color[1], color[2]);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the maximum number of Lights allowed to appear at once.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#getMaxVisibleLights\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The maximum number of Lights allowed to appear at once.\r\n     */\r\n    getMaxVisibleLights: function ()\r\n    {\r\n        return this.maxLights;\r\n    },\r\n\r\n    /**\r\n     * Get the number of Lights managed by this Lights Manager.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#getLightCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The number of Lights managed by this Lights Manager.\r\n     */\r\n    getLightCount: function ()\r\n    {\r\n        return this.lights.length;\r\n    },\r\n\r\n    /**\r\n     * Add a Light.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#addLight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal position of the Light.\r\n     * @param {number} [y=0] - The vertical position of the Light.\r\n     * @param {number} [radius=128] - The radius of the Light.\r\n     * @param {number} [rgb=0xffffff] - The integer RGB color of the light.\r\n     * @param {number} [intensity=1] - The intensity of the Light.\r\n     *\r\n     * @return {Phaser.GameObjects.Light} The Light that was added.\r\n     */\r\n    addLight: function (x, y, radius, rgb, intensity)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (radius === undefined) { radius = 128; }\r\n        if (rgb === undefined) { rgb = 0xffffff; }\r\n        if (intensity === undefined) { intensity = 1; }\r\n\r\n        var color = Utils.getFloatsFromUintRGB(rgb);\r\n\r\n        var light = new Light(x, y, radius, color[0], color[1], color[2], intensity);\r\n\r\n        this.lights.push(light);\r\n\r\n        return light;\r\n    },\r\n\r\n    /**\r\n     * Remove a Light.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#removeLight\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Light} light - The Light to remove.\r\n     *\r\n     * @return {this} This Lights Manager instance.\r\n     */\r\n    removeLight: function (light)\r\n    {\r\n        var index = this.lights.indexOf(light);\r\n\r\n        if (index >= 0)\r\n        {\r\n            SpliceOne(this.lights, index);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Shut down the Lights Manager.\r\n     *\r\n     * Recycles all active Lights into the Light pool, resets ambient light color and clears the lists of Lights and\r\n     * culled Lights.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.lights.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Destroy the Lights Manager.\r\n     *\r\n     * Cleans up all references by calling {@link Phaser.GameObjects.LightsManager#shutdown}.\r\n     *\r\n     * @method Phaser.GameObjects.LightsManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = LightsManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar LightsManager = require('./LightsManager');\r\nvar PluginCache = require('../../plugins/PluginCache');\r\nvar SceneEvents = require('../../scene/events');\r\n\r\n/**\r\n * @classdesc\r\n * A Scene plugin that provides a {@link Phaser.GameObjects.LightsManager} for the Light2D pipeline.\r\n *\r\n * Available from within a Scene via `this.lights`.\r\n *\r\n * Add Lights using the {@link Phaser.GameObjects.LightsManager#addLight} method:\r\n *\r\n * ```javascript\r\n * // Enable the Lights Manager because it is disabled by default\r\n * this.lights.enable();\r\n *\r\n * // Create a Light at [400, 300] with a radius of 200\r\n * this.lights.addLight(400, 300, 200);\r\n * ```\r\n *\r\n * For Game Objects to be affected by the Lights when rendered, you will need to set them to use the `Light2D` pipeline like so:\r\n *\r\n * ```javascript\r\n * sprite.setPipeline('Light2D');\r\n * ```\r\n *\r\n * Note that you cannot use this pipeline on Graphics Game Objects or Shape Game Objects.\r\n *\r\n * @class LightsPlugin\r\n * @extends Phaser.GameObjects.LightsManager\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene that this Lights Plugin belongs to.\r\n */\r\nvar LightsPlugin = new Class({\r\n\r\n    Extends: LightsManager,\r\n\r\n    initialize:\r\n\r\n    function LightsPlugin (scene)\r\n    {\r\n        /**\r\n         * A reference to the Scene that this Lights Plugin belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.LightsPlugin#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene's systems.\r\n         *\r\n         * @name Phaser.GameObjects.LightsPlugin#systems\r\n         * @type {Phaser.Scenes.Systems}\r\n         * @since 3.0.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        if (!scene.sys.settings.isBooted)\r\n        {\r\n            scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\r\n        }\r\n\r\n        LightsManager.call(this);\r\n    },\r\n\r\n    /**\r\n     * Boot the Lights Plugin.\r\n     *\r\n     * @method Phaser.GameObjects.LightsPlugin#boot\r\n     * @since 3.0.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.on(SceneEvents.SHUTDOWN, this.shutdown, this);\r\n        eventEmitter.on(SceneEvents.DESTROY, this.destroy, this);\r\n    },\r\n\r\n    /**\r\n     * Destroy the Lights Plugin.\r\n     *\r\n     * Cleans up all references.\r\n     *\r\n     * @method Phaser.GameObjects.LightsPlugin#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.shutdown();\r\n\r\n        this.scene = undefined;\r\n        this.systems = undefined;\r\n    }\r\n\r\n});\r\n\r\nPluginCache.register('LightsPlugin', LightsPlugin, 'lights');\r\n\r\nmodule.exports = LightsPlugin;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar DegToRad = require('../../math/DegToRad');\r\nvar Face = require('../../geom/mesh/Face');\r\nvar GameObject = require('../GameObject');\r\nvar GenerateVerts = require('../../geom/mesh/GenerateVerts');\r\nvar GenerateObjVerts = require('../../geom/mesh/GenerateObjVerts');\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\nvar Matrix4 = require('../../math/Matrix4');\r\nvar MeshRender = require('./MeshRender');\r\nvar StableSort = require('../../utils/array/StableSort');\r\nvar Vector3 = require('../../math/Vector3');\r\nvar Vertex = require('../../geom/mesh/Vertex');\r\n\r\n/**\r\n * @classdesc\r\n * A Mesh Game Object.\r\n *\r\n * The Mesh Game Object allows you to render a group of textured vertices and manipulate\r\n * the view of those vertices, such as rotation, translation or scaling.\r\n *\r\n * Support for generating mesh data from grids, model data or Wavefront OBJ Files is included.\r\n *\r\n * Although you can use this to render 3D objects, its primary use is for displaying more complex\r\n * Sprites, or Sprites where you need fine-grained control over the vertex positions in order to\r\n * achieve special effects in your games. Note that rendering still takes place using Phaser's\r\n * orthographic camera (after being transformed via `projectionMesh`, see `setPerspective`,\r\n * `setOrtho`, and `panZ` methods). As a result, all depth and face tests are done in an eventually\r\n * orthographic space.\r\n *\r\n * The rendering process will iterate through the faces of this Mesh and render out each face\r\n * that is considered as being in view of the camera. No depth buffer is used, and because of this,\r\n * you should be careful not to use model data with too many vertices, or overlapping geometry,\r\n * or you'll probably encounter z-depth fighting. The Mesh was designed to allow for more advanced\r\n * 2D layouts, rather than displaying 3D objects, even though it can do this to a degree.\r\n *\r\n * In short, if you want to remake Crysis, use a 3D engine, not a Mesh. However, if you want\r\n * to easily add some small fun 3D elements into your game, or create some special effects involving\r\n * vertex warping, this is the right object for you. Mesh data becomes part of the WebGL batch,\r\n * just like standard Sprites, so doesn't introduce any additional shader overhead. Because\r\n * the Mesh just generates vertices into the WebGL batch, like any other Sprite, you can use all of\r\n * the common Game Object components on a Mesh too, such as a custom pipeline, mask, blend mode\r\n * or texture.\r\n *\r\n * Note that the Mesh object is WebGL only and does not have a Canvas counterpart.\r\n *\r\n * The Mesh origin is always 0.5 x 0.5 and cannot be changed.\r\n *\r\n * @class Mesh\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @webglOnly\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y] - The vertical position of this Game Object in the world.\r\n * @param {string|Phaser.Textures.Texture} [texture] - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {string|number} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * @param {number[]} [vertices] - The vertices array. Either `xy` pairs, or `xyz` if the `containsZ` parameter is `true` (but see note).\r\n * @param {number[]} [uvs] - The UVs pairs array.\r\n * @param {number[]} [indicies] - Optional vertex indicies array. If you don't have one, pass `null` or an empty array.\r\n * @param {boolean} [containsZ=false] - Does the vertices data include a `z` component? Note: If not, it will be assumed `z=0`, see method `panZ` or `setOrtho`.\r\n * @param {number[]} [normals] - Optional vertex normals array. If you don't have one, pass `null` or an empty array.\r\n * @param {number|number[]} [colors=0xffffff] - An array of colors, one per vertex, or a single color value applied to all vertices.\r\n * @param {number|number[]} [alphas=1] - An array of alpha values, one per vertex, or a single alpha value applied to all vertices.\r\n */\r\nvar Mesh = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.Size,\r\n        Components.Texture,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Components.ScrollFactor,\r\n        MeshRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Mesh (scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (texture === undefined) { texture = '__WHITE'; }\r\n\r\n        GameObject.call(this, scene, 'Mesh');\r\n\r\n        /**\r\n         * An array containing the Face instances belonging to this Mesh.\r\n         *\r\n         * A Face consists of 3 Vertex objects.\r\n         *\r\n         * This array is populated during calls such as `addVertices` or `addOBJ`.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#faces\r\n         * @type {Phaser.Geom.Mesh.Face[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.faces = [];\r\n\r\n        /**\r\n         * An array containing Vertex instances. One instance per vertex in this Mesh.\r\n         *\r\n         * This array is populated during calls such as `addVertex` or `addOBJ`.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#vertices\r\n         * @type {Phaser.Geom.Mesh.Vertex[]}\r\n         * @since 3.50.0\r\n         */\r\n        this.vertices = [];\r\n\r\n        /**\r\n         * The tint fill mode.\r\n         *\r\n         * `false` = An additive tint (the default), where vertices colors are blended with the texture.\r\n         * `true` = A fill tint, where the vertex colors replace the texture, but respects texture alpha.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#tintFill\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.50.0\r\n         */\r\n        this.tintFill = false;\r\n\r\n        /**\r\n         * You can optionally choose to render the vertices of this Mesh to a Graphics instance.\r\n         *\r\n         * Achieve this by setting the `debugCallback` and the `debugGraphic` properties.\r\n         *\r\n         * You can do this in a single call via the `Mesh.setDebug` method, which will use the\r\n         * built-in debug function. You can also set it to your own callback. The callback\r\n         * will be invoked _once per render_ and sent the following parameters:\r\n         *\r\n         * `debugCallback(src, meshLength, verts)`\r\n         *\r\n         * `src` is the Mesh instance being debugged.\r\n         * `meshLength` is the number of mesh vertices in total.\r\n         * `verts` is an array of the translated vertex coordinates.\r\n         *\r\n         * To disable rendering, set this property back to `null`.\r\n         *\r\n         * Please note that high vertex count Meshes will struggle to debug properly.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#debugCallback\r\n         * @type {function}\r\n         * @since 3.50.0\r\n         */\r\n        this.debugCallback = null;\r\n\r\n        /**\r\n         * The Graphics instance that the debug vertices will be drawn to, if `setDebug` has\r\n         * been called.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.50.0\r\n         */\r\n        this.debugGraphic = null;\r\n\r\n        /**\r\n         * When rendering, skip any Face that isn't counter clockwise?\r\n         *\r\n         * Enable this to hide backward-facing Faces during rendering.\r\n         *\r\n         * Disable it to render all Faces.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#hideCCW\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.hideCCW = true;\r\n\r\n        /**\r\n         * A Vector3 containing the 3D position of the vertices in this Mesh.\r\n         *\r\n         * Modifying the components of this property will allow you to reposition where\r\n         * the vertices are rendered within the Mesh. This happens in the `preUpdate` phase,\r\n         * where each vertex is transformed using the view and projection matrices.\r\n         *\r\n         * Changing this property will impact all vertices being rendered by this Mesh.\r\n         *\r\n         * You can also adjust the 'view' by using the `pan` methods.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#modelPosition\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.50.0\r\n         */\r\n        this.modelPosition = new Vector3();\r\n\r\n        /**\r\n         * A Vector3 containing the 3D scale of the vertices in this Mesh.\r\n         *\r\n         * Modifying the components of this property will allow you to scale\r\n         * the vertices within the Mesh. This happens in the `preUpdate` phase,\r\n         * where each vertex is transformed using the view and projection matrices.\r\n         *\r\n         * Changing this property will impact all vertices being rendered by this Mesh.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#modelScale\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.50.0\r\n         */\r\n        this.modelScale = new Vector3(1, 1, 1);\r\n\r\n        /**\r\n         * A Vector3 containing the 3D rotation of the vertices in this Mesh.\r\n         *\r\n         * The values should be given in radians, i.e. to rotate the vertices by 90\r\n         * degrees you can use `modelRotation.x = Phaser.Math.DegToRad(90)`.\r\n         *\r\n         * Modifying the components of this property will allow you to rotate\r\n         * the vertices within the Mesh. This happens in the `preUpdate` phase,\r\n         * where each vertex is transformed using the view and projection matrices.\r\n         *\r\n         * Changing this property will impact all vertices being rendered by this Mesh.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#modelRotation\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.50.0\r\n         */\r\n        this.modelRotation = new Vector3();\r\n\r\n        /**\r\n         * An internal cache, used to compare position, rotation, scale and face data\r\n         * each frame, to avoid math calculations in `preUpdate`.\r\n         *\r\n         * Cache structure = position xyz | rotation xyz | scale xyz | face count | view | ortho\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#dirtyCache\r\n         * @type {number[]}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.dirtyCache = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\r\n\r\n        /**\r\n         * The transformation matrix for this Mesh.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#transformMatrix\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.50.0\r\n         */\r\n        this.transformMatrix = new Matrix4();\r\n\r\n        /**\r\n         * The view position for this Mesh.\r\n         *\r\n         * Use the methods`panX`, `panY` and `panZ` to adjust the view.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#viewPosition\r\n         * @type {Phaser.Math.Vector3}\r\n         * @since 3.50.0\r\n         */\r\n        this.viewPosition = new Vector3();\r\n\r\n        /**\r\n         * The view matrix for this Mesh.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#viewMatrix\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.50.0\r\n         */\r\n        this.viewMatrix = new Matrix4();\r\n\r\n        /**\r\n         * The projection matrix for this Mesh.\r\n         *\r\n         * Update it with the `setPerspective` or `setOrtho` methods.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#projectionMatrix\r\n         * @type {Phaser.Math.Matrix4}\r\n         * @since 3.50.0\r\n         */\r\n        this.projectionMatrix = new Matrix4();\r\n\r\n        /**\r\n         * How many faces were rendered by this Mesh Game Object in the last\r\n         * draw? This is reset in the `preUpdate` method and then incremented\r\n         * each time a face is drawn. Note that in multi-camera Scenes this\r\n         * value may exceed that found in `Mesh.getFaceCount` due to\r\n         * cameras drawing the same faces more than once.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#totalRendered\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.50.0\r\n         */\r\n        this.totalRendered = 0;\r\n\r\n        /**\r\n         * Internal cache var for the total number of faces rendered this frame.\r\n         *\r\n         * See `totalRendered` instead for the actual value.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#totalFrame\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.50.0\r\n         */\r\n        this.totalFrame = 0;\r\n\r\n        /**\r\n         * By default, the Mesh will check to see if its model or view transform has\r\n         * changed each frame and only recalculate the vertex positions if they have.\r\n         *\r\n         * This avoids lots of additional math in the `preUpdate` step when not required.\r\n         *\r\n         * However, if you are performing per-Face or per-Vertex manipulation on this Mesh,\r\n         * such as tweening a Face, or moving it without moving the rest of the Mesh,\r\n         * then you may need to disable the dirty cache in order for the Mesh to re-render\r\n         * correctly. You can toggle this property to do that. Please note that leaving\r\n         * this set to `true` will cause the Mesh to recalculate the position of every single\r\n         * vertex in it, every single frame. So only really do this if you know you\r\n         * need it.\r\n         *\r\n         * @name Phaser.GameObjects.Mesh#ignoreDirtyCache\r\n         * @type {boolean}\r\n         * @since 3.50.0\r\n         */\r\n        this.ignoreDirtyCache = false;\r\n\r\n        var renderer = scene.sys.renderer;\r\n\r\n        this.setPosition(x, y);\r\n        this.setTexture(texture, frame);\r\n        this.setSize(renderer.width, renderer.height);\r\n        this.initPipeline();\r\n\r\n        this.setPerspective(renderer.width, renderer.height);\r\n\r\n        if (vertices)\r\n        {\r\n            this.addVertices(vertices, uvs, indicies, containsZ, normals, colors, alphas);\r\n        }\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * Translates the view position of this Mesh on the x axis by the given amount.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#panX\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} v - The amount to pan by.\r\n     */\r\n    panX: function (v)\r\n    {\r\n        this.viewPosition.addScale(Vector3.LEFT, v);\r\n\r\n        this.dirtyCache[10] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Translates the view position of this Mesh on the y axis by the given amount.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#panY\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} v - The amount to pan by.\r\n     */\r\n    panY: function (v)\r\n    {\r\n        this.viewPosition.y += Vector3.DOWN.y * v;\r\n\r\n        this.dirtyCache[10] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Translates the view position of this Mesh on the z axis by the given amount.\r\n     *\r\n     * As the default `panZ` value is 0, vertices with `z=0` (the default) need special care or else they will not display as they are behind the camera.\r\n     * Consider using `mesh.panZ(mesh.height / (2 * Math.tan(Math.PI / 16)))`, which will interpret vertex geometry 1:1 with pixel geometry (or see `setOrtho`).\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#panZ\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} v - The amount to pan by.\r\n     */\r\n    panZ: function (amount)\r\n    {\r\n        this.viewPosition.z += amount;\r\n\r\n        this.dirtyCache[10] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Builds a new perspective projection matrix from the given values.\r\n     *\r\n     * These are also the initial projection matrix & parameters for `Mesh` (and see `panZ` for more discussion).\r\n     *\r\n     * See also `setOrtho`.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#setPerspective\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} width - The width of the projection matrix. Typically the same as the Mesh and/or Renderer.\r\n     * @param {number} height - The height of the projection matrix. Typically the same as the Mesh and/or Renderer.\r\n     * @param {number} [fov=45] - The field of view, in degrees.\r\n     * @param {number} [near=0.01] - The near value of the view.\r\n     * @param {number} [far=1000] - The far value of the view.\r\n     */\r\n    setPerspective: function (width, height, fov, near, far)\r\n    {\r\n        if (fov === undefined) { fov = 45; }\r\n        if (near === undefined) { near = 0.01; }\r\n        if (far === undefined) { far = 1000; }\r\n\r\n        this.projectionMatrix.perspective(DegToRad(fov), width / height, near, far);\r\n\r\n        this.dirtyCache[10] = 1;\r\n        this.dirtyCache[11] = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Builds a new orthographic projection matrix from the given values.\r\n     *\r\n     * If using this mode you will often need to set `Mesh.hideCCW` to `false` as well.\r\n     *\r\n     * By default, calling this method with no parameters will set the scaleX value to\r\n     * match the renderer's aspect ratio. If you would like to render vertex positions 1:1\r\n     * to pixel positions, consider calling as `mesh.setOrtho(mesh.width, mesh.height)`.\r\n     *\r\n     * See also `setPerspective`.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#setOrtho\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} [scaleX=1] - The default horizontal scale in relation to the Mesh / Renderer dimensions.\r\n     * @param {number} [scaleY=1] - The default vertical scale in relation to the Mesh / Renderer dimensions.\r\n     * @param {number} [near=-1000] - The near value of the view.\r\n     * @param {number} [far=1000] - The far value of the view.\r\n     */\r\n    setOrtho: function (scaleX, scaleY, near, far)\r\n    {\r\n        if (scaleX === undefined) { scaleX = this.scene.sys.renderer.getAspectRatio(); }\r\n        if (scaleY === undefined) { scaleY = 1; }\r\n        if (near === undefined) { near = -1000; }\r\n        if (far === undefined) { far = 1000; }\r\n\r\n        this.projectionMatrix.ortho(-scaleX, scaleX, -scaleY, scaleY, near, far);\r\n\r\n        this.dirtyCache[10] = 1;\r\n        this.dirtyCache[11] = 1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Iterates and destroys all current Faces in this Mesh, then resets the\r\n     * `faces` and `vertices` arrays.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#clear\r\n     * @since 3.50.0\r\n     *\r\n     * @return {this} This Mesh Game Object.\r\n     */\r\n    clear: function ()\r\n    {\r\n        this.faces.forEach(function (face)\r\n        {\r\n            face.destroy();\r\n        });\r\n\r\n        this.faces = [];\r\n        this.vertices = [];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method will add the data from a triangulated Wavefront OBJ model file to this Mesh.\r\n     *\r\n     * The data should have been loaded via the OBJFile:\r\n     *\r\n     * ```javascript\r\n     * this.load.obj(key, url);\r\n     * ```\r\n     *\r\n     * Then use the same `key` as the first parameter to this method.\r\n     *\r\n     * Multiple Mesh Game Objects can use the same model data without impacting on each other.\r\n     *\r\n     * Make sure your 3D package has triangulated the model data prior to exporting it.\r\n     *\r\n     * You can add multiple models to a single Mesh, although they will act as one when\r\n     * moved or rotated. You can scale the model data, should it be too small, or too large, to see.\r\n     * You can also offset the vertices of the model via the `x`, `y` and `z` parameters.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#addVerticesFromObj\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} key - The key of the model data in the OBJ Cache to add to this Mesh.\r\n     * @param {number} [scale=1] - An amount to scale the model data by. Use this if the model has exported too small, or large, to see.\r\n     * @param {number} [x=0] - Translate the model x position by this amount.\r\n     * @param {number} [y=0] - Translate the model y position by this amount.\r\n     * @param {number} [z=0] - Translate the model z position by this amount.\r\n     * @param {number} [rotateX=0] - Rotate the model on the x axis by this amount, in radians.\r\n     * @param {number} [rotateY=0] - Rotate the model on the y axis by this amount, in radians.\r\n     * @param {number} [rotateZ=0] - Rotate the model on the z axis by this amount, in radians.\r\n     * @param {boolean} [zIsUp=true] - Is the z axis up (true), or is y axis up (false)?\r\n     *\r\n     * @return {this} This Mesh Game Object.\r\n     */\r\n    addVerticesFromObj: function (key, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp)\r\n    {\r\n        var data = this.scene.sys.cache.obj.get(key);\r\n\r\n        if (data)\r\n        {\r\n            GenerateObjVerts(data, this, scale, x, y, z, rotateX, rotateY, rotateZ, zIsUp);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Compare the depth of two Faces.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#sortByDepth\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Geom.Mesh.Face} faceA - The first Face.\r\n     * @param {Phaser.Geom.Mesh.Face} faceB - The second Face.\r\n     *\r\n     * @return {number} The difference between the depths of each Face.\r\n     */\r\n    sortByDepth: function (faceA, faceB)\r\n    {\r\n        return faceA.depth - faceB.depth;\r\n    },\r\n\r\n    /**\r\n     * Runs a depth sort across all Faces in this Mesh, comparing their averaged depth.\r\n     *\r\n     * This is called automatically if you use any of the `rotate` methods, but you can\r\n     * also invoke it to sort the Faces should you manually position them.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#depthSort\r\n     * @since 3.50.0\r\n     *\r\n     * @return {this} This Mesh Game Object.\r\n     */\r\n    depthSort: function ()\r\n    {\r\n        StableSort(this.faces, this.sortByDepth);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Vertex into the vertices array of this Mesh.\r\n     *\r\n     * Just adding a vertex isn't enough to render it. You need to also\r\n     * make it part of a Face, with 3 Vertex instances per Face.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#addVertex\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The x position of the vertex.\r\n     * @param {number} y - The y position of the vertex.\r\n     * @param {number} z - The z position of the vertex.\r\n     * @param {number} u - The UV u coordinate of the vertex.\r\n     * @param {number} v - The UV v coordinate of the vertex.\r\n     * @param {number} [color=0xffffff] - The color value of the vertex.\r\n     * @param {number} [alpha=1] - The alpha value of the vertex.\r\n     *\r\n     * @return {this} This Mesh Game Object.\r\n     */\r\n    addVertex: function (x, y, z, u, v, color, alpha)\r\n    {\r\n        var vert = new Vertex(x, y, z, u, v, color, alpha);\r\n\r\n        this.vertices.push(vert);\r\n\r\n        return vert;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Face into the faces array of this Mesh.\r\n     *\r\n     * A Face consists of references to 3 Vertex instances, which must be provided.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#addFace\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.Geom.Mesh.Vertex} vertex1 - The first vertex of the Face.\r\n     * @param {Phaser.Geom.Mesh.Vertex} vertex2 - The second vertex of the Face.\r\n     * @param {Phaser.Geom.Mesh.Vertex} vertex3 - The third vertex of the Face.\r\n     *\r\n     * @return {this} This Mesh Game Object.\r\n     */\r\n    addFace: function (vertex1, vertex2, vertex3)\r\n    {\r\n        var face = new Face(vertex1, vertex2, vertex3);\r\n\r\n        this.faces.push(face);\r\n\r\n        this.dirtyCache[9] = -1;\r\n\r\n        return face;\r\n    },\r\n\r\n    /**\r\n     * Adds new vertices to this Mesh by parsing the given data.\r\n     *\r\n     * This method will take vertex data in one of two formats, based on the `containsZ` parameter.\r\n     *\r\n     * If your vertex data are `x`, `y` pairs, then `containsZ` should be `false` (this is the default, and will result in `z=0` for each vertex).\r\n     *\r\n     * If your vertex data is groups of `x`, `y` and `z` values, then the `containsZ` parameter must be true.\r\n     *\r\n     * The `uvs` parameter is a numeric array consisting of `u` and `v` pairs.\r\n     *\r\n     * The `normals` parameter is a numeric array consisting of `x`, `y` vertex normal values and, if `containsZ` is true, `z` values as well.\r\n     *\r\n     * The `indicies` parameter is an optional array that, if given, is an indexed list of vertices to be added.\r\n     *\r\n     * The `colors` parameter is an optional array, or single value, that if given sets the color of each vertex created.\r\n     *\r\n     * The `alphas` parameter is an optional array, or single value, that if given sets the alpha of each vertex created.\r\n     *\r\n     * When providing indexed data it is assumed that _all_ of the arrays are indexed, not just the vertices.\r\n     *\r\n     * The following example will create a 256 x 256 sized quad using an index array:\r\n     *\r\n     * ```javascript\r\n     * let mesh = new Mesh(this);  // Assuming `this` is a scene!\r\n     * const vertices = [\r\n     *   -128, 128,\r\n     *   128, 128,\r\n     *   -128, -128,\r\n     *   128, -128\r\n     * ];\r\n     *\r\n     * const uvs = [\r\n     *   0, 1,\r\n     *   1, 1,\r\n     *   0, 0,\r\n     *   1, 0\r\n     * ];\r\n     *\r\n     * const indices = [ 0, 2, 1, 2, 3, 1 ];\r\n     *\r\n     * mesh.addVertices(vertices, uvs, indicies);\r\n     * // Note: Otherwise the added points will be \"behind\" the camera! This value will project vertex `x` & `y` values 1:1 to pixel values.\r\n     * mesh.hideCCW = false;\r\n     * mesh.setOrtho(mesh.width, mesh.height);\r\n     * ```\r\n     *\r\n     * If the data is not indexed, it's assumed that the arrays all contain sequential data.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#addVertices\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number[]} vertices - The vertices array. Either `xy` pairs, or `xyz` if the `containsZ` parameter is `true`.\r\n     * @param {number[]} uvs - The UVs pairs array.\r\n     * @param {number[]} [indicies] - Optional vertex indicies array. If you don't have one, pass `null` or an empty array.\r\n     * @param {boolean} [containsZ=false] - Does the vertices data include a `z` component? If not, it will be assumed `z=0`, see methods `panZ` or `setOrtho`.\r\n     * @param {number[]} [normals] - Optional vertex normals array. If you don't have one, pass `null` or an empty array.\r\n     * @param {number|number[]} [colors=0xffffff] - An array of colors, one per vertex, or a single color value applied to all vertices.\r\n     * @param {number|number[]} [alphas=1] - An array of alpha values, one per vertex, or a single alpha value applied to all vertices.\r\n     *\r\n     * @return {this} This Mesh Game Object.\r\n     */\r\n    addVertices: function (vertices, uvs, indicies, containsZ, normals, colors, alphas)\r\n    {\r\n        var result = GenerateVerts(vertices, uvs, indicies, containsZ, normals, colors, alphas);\r\n\r\n        if (result)\r\n        {\r\n            this.faces = this.faces.concat(result.faces);\r\n            this.vertices = this.vertices.concat(result.vertices);\r\n        }\r\n\r\n        this.dirtyCache[9] = -1;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the total number of Faces in this Mesh Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#getFaceCount\r\n     * @since 3.50.0\r\n     *\r\n     * @return {number} The number of Faces in this Mesh Game Object.\r\n     */\r\n    getFaceCount: function ()\r\n    {\r\n        return this.faces.length;\r\n    },\r\n\r\n    /**\r\n     * Returns the total number of Vertices in this Mesh Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#getVertexCount\r\n     * @since 3.50.0\r\n     *\r\n     * @return {number} The number of Vertices in this Mesh Game Object.\r\n     */\r\n    getVertexCount: function ()\r\n    {\r\n        return this.vertices.length;\r\n    },\r\n\r\n    /**\r\n     * Returns the Face at the given index in this Mesh Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#getFace\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} index - The index of the Face to get.\r\n     *\r\n     * @return {Phaser.Geom.Mesh.Face} The Face at the given index, or `undefined` if index out of range.\r\n     */\r\n    getFace: function (index)\r\n    {\r\n        return this.faces[index];\r\n    },\r\n\r\n    /**\r\n     * Return an array of Face objects from this Mesh that intersect with the given coordinates.\r\n     *\r\n     * The given position is translated through the matrix of this Mesh and the given Camera,\r\n     * before being compared against the vertices.\r\n     *\r\n     * If more than one Face intersects, they will all be returned in the array, but the array will\r\n     * be depth sorted first, so the first element will always be that closest to the camera.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#getFaceAt\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} x - The x position to check against.\r\n     * @param {number} y - The y position to check against.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} [camera] - The camera to pass the coordinates through. If not give, the default Scene Camera is used.\r\n     *\r\n     * @return {Phaser.Geom.Mesh.Face[]} An array of Face objects that intersect with the given point, ordered by depth.\r\n     */\r\n    getFaceAt: function (x, y, camera)\r\n    {\r\n        if (camera === undefined) { camera = this.scene.sys.cameras.main; }\r\n\r\n        var calcMatrix = GetCalcMatrix(this, camera).calc;\r\n\r\n        var faces = this.faces;\r\n        var results = [];\r\n\r\n        for (var i = 0; i < faces.length; i++)\r\n        {\r\n            var face = faces[i];\r\n\r\n            if (face.contains(x, y, calcMatrix))\r\n            {\r\n                results.push(face);\r\n            }\r\n        }\r\n\r\n        return StableSort(results, this.sortByDepth);\r\n    },\r\n\r\n    /**\r\n     * This method enables rendering of the Mesh vertices to the given Graphics instance.\r\n     *\r\n     * If you enable this feature, you **must** call `Graphics.clear()` in your Scene `update`,\r\n     * otherwise the Graphics instance you provide to debug will fill-up with draw calls,\r\n     * eventually crashing the browser. This is not done automatically to allow you to debug\r\n     * draw multiple Mesh objects to a single Graphics instance.\r\n     *\r\n     * The Mesh class has a built-in debug rendering callback `Mesh.renderDebug`, however\r\n     * you can also provide your own callback to be used instead. Do this by setting the `callback` parameter.\r\n     *\r\n     * The callback is invoked _once per render_ and sent the following parameters:\r\n     *\r\n     * `callback(src, faces)`\r\n     *\r\n     * `src` is the Mesh instance being debugged.\r\n     * `faces` is an array of the Faces that were rendered.\r\n     *\r\n     * You can get the final drawn vertex position from a Face object like this:\r\n     *\r\n     * ```javascript\r\n     * let face = faces[i];\r\n     *\r\n     * let x0 = face.vertex1.tx;\r\n     * let y0 = face.vertex1.ty;\r\n     * let x1 = face.vertex2.tx;\r\n     * let y1 = face.vertex2.ty;\r\n     * let x2 = face.vertex3.tx;\r\n     * let y2 = face.vertex3.ty;\r\n     *\r\n     * graphic.strokeTriangle(x0, y0, x1, y1, x2, y2);\r\n     * ```\r\n     *\r\n     * If using your own callback you do not have to provide a Graphics instance to this method.\r\n     *\r\n     * To disable debug rendering, to either your own callback or the built-in one, call this method\r\n     * with no arguments.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#setDebug\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} [graphic] - The Graphic instance to render to if using the built-in callback.\r\n     * @param {function} [callback] - The callback to invoke during debug render. Leave as undefined to use the built-in callback.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDebug: function (graphic, callback)\r\n    {\r\n        this.debugGraphic = graphic;\r\n\r\n        if (!graphic && !callback)\r\n        {\r\n            this.debugCallback = null;\r\n        }\r\n        else if (!callback)\r\n        {\r\n            this.debugCallback = this.renderDebug;\r\n        }\r\n        else\r\n        {\r\n            this.debugCallback = callback;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks if the transformation data in this mesh is dirty.\r\n     *\r\n     * This is used internally by the `preUpdate` step to determine if the vertices should\r\n     * be recalculated or not.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#isDirty\r\n     * @since 3.50.0\r\n     *\r\n     * @return {boolean} Returns `true` if the data of this mesh is dirty, otherwise `false`.\r\n     */\r\n    isDirty: function ()\r\n    {\r\n        var position = this.modelPosition;\r\n        var rotation = this.modelRotation;\r\n        var scale = this.modelScale;\r\n        var dirtyCache = this.dirtyCache;\r\n\r\n        var px = position.x;\r\n        var py = position.y;\r\n        var pz = position.z;\r\n\r\n        var rx = rotation.x;\r\n        var ry = rotation.y;\r\n        var rz = rotation.z;\r\n\r\n        var sx = scale.x;\r\n        var sy = scale.y;\r\n        var sz = scale.z;\r\n\r\n        var faces = this.getFaceCount();\r\n\r\n        var pxCached = dirtyCache[0];\r\n        var pyCached = dirtyCache[1];\r\n        var pzCached = dirtyCache[2];\r\n\r\n        var rxCached = dirtyCache[3];\r\n        var ryCached = dirtyCache[4];\r\n        var rzCached = dirtyCache[5];\r\n\r\n        var sxCached = dirtyCache[6];\r\n        var syCached = dirtyCache[7];\r\n        var szCached = dirtyCache[8];\r\n\r\n        var fCached = dirtyCache[9];\r\n\r\n        dirtyCache[0] = px;\r\n        dirtyCache[1] = py;\r\n        dirtyCache[2] = pz;\r\n\r\n        dirtyCache[3] = rx;\r\n        dirtyCache[4] = ry;\r\n        dirtyCache[5] = rz;\r\n\r\n        dirtyCache[6] = sx;\r\n        dirtyCache[7] = sy;\r\n        dirtyCache[8] = sz;\r\n\r\n        dirtyCache[9] = faces;\r\n\r\n        return (\r\n            pxCached !== px || pyCached !== py || pzCached !== pz ||\r\n            rxCached !== rx || ryCached !== ry || rzCached !== rz ||\r\n            sxCached !== sx || syCached !== sy || szCached !== sz ||\r\n            fCached !== faces\r\n        );\r\n    },\r\n\r\n    /**\r\n     * The Mesh update loop. The following takes place in this method:\r\n     *\r\n     * First, the `totalRendered` and `totalFrame` properties are set.\r\n     *\r\n     * If the view matrix of this Mesh isn't dirty, and the model position, rotate or scale properties are\r\n     * all clean, then the method returns at this point.\r\n     *\r\n     * Otherwise, if the viewPosition is dirty (i.e. from calling a method like `panZ`), then it will\r\n     * refresh the viewMatrix.\r\n     *\r\n     * After this, a new transformMatrix is built and it then iterates through all Faces in this\r\n     * Mesh, calling `transformCoordinatesLocal` on all of them. Internally, this updates every\r\n     * vertex, calculating its new transformed position, based on the new transform matrix.\r\n     *\r\n     * Finally, the faces are depth sorted.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#preUpdate\r\n     * @protected\r\n     * @since 3.50.0\r\n     *\r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        this.totalRendered = this.totalFrame;\r\n        this.totalFrame = 0;\r\n\r\n        var dirty = this.dirtyCache;\r\n\r\n        if (!this.ignoreDirtyCache && !dirty[10] && !this.isDirty())\r\n        {\r\n            //  If neither the view or the mesh is dirty we can bail out and save lots of math\r\n            return;\r\n        }\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n\r\n        var viewMatrix = this.viewMatrix;\r\n        var viewPosition = this.viewPosition;\r\n\r\n        if (dirty[10])\r\n        {\r\n            viewMatrix.identity();\r\n            viewMatrix.translate(viewPosition);\r\n            viewMatrix.invert();\r\n\r\n            dirty[10] = 0;\r\n        }\r\n\r\n        var transformMatrix = this.transformMatrix;\r\n\r\n        transformMatrix.setWorldMatrix(\r\n            this.modelRotation,\r\n            this.modelPosition,\r\n            this.modelScale,\r\n            this.viewMatrix,\r\n            this.projectionMatrix\r\n        );\r\n\r\n        var z = viewPosition.z;\r\n\r\n        var faces = this.faces;\r\n\r\n        for (var i = 0; i < faces.length; i++)\r\n        {\r\n            faces[i].transformCoordinatesLocal(transformMatrix, width, height, z);\r\n        }\r\n\r\n        this.depthSort();\r\n    },\r\n\r\n    /**\r\n     * The built-in Mesh debug rendering method.\r\n     *\r\n     * See `Mesh.setDebug` for more details.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#renderDebug\r\n     * @since 3.50.0\r\n     *\r\n     * @param {Phaser.GameObjects.Mesh} src - The Mesh object being rendered.\r\n     * @param {Phaser.Geom.Mesh.Face[]} faces - An array of Faces.\r\n     */\r\n    renderDebug: function (src, faces)\r\n    {\r\n        var graphic = src.debugGraphic;\r\n\r\n        for (var i = 0; i < faces.length; i++)\r\n        {\r\n            var face = faces[i];\r\n\r\n            var x0 = face.vertex1.tx;\r\n            var y0 = face.vertex1.ty;\r\n            var x1 = face.vertex2.tx;\r\n            var y1 = face.vertex2.ty;\r\n            var x2 = face.vertex3.tx;\r\n            var y2 = face.vertex3.ty;\r\n\r\n            graphic.strokeTriangle(x0, y0, x1, y1, x2, y2);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Handles the pre-destroy step for the Mesh, which removes the Animation component and typed arrays.\r\n     *\r\n     * @method Phaser.GameObjects.Mesh#preDestroy\r\n     * @private\r\n     * @since 3.50.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.clear();\r\n\r\n        this.debugCallback = null;\r\n        this.debugGraphic = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Mesh;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * This is a stub function for Mesh.Render. There is no Canvas renderer for Mesh objects.\n *\n * @method Phaser.GameObjects.Mesh#renderCanvas\n * @since 3.0.0\n * @private\n *\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\n * @param {Phaser.GameObjects.Mesh} src - The Game Object being rendered in this call.\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\n */\nvar MeshCanvasRenderer = function ()\n{\n};\n\nmodule.exports = MeshCanvasRenderer;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar BuildGameObject = require('../BuildGameObject');\nvar GameObjectCreator = require('../GameObjectCreator');\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\nvar GetValue = require('../../utils/object/GetValue');\nvar Mesh = require('./Mesh');\n\n/**\n * Creates a new Mesh Game Object and returns it.\n *\n * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectCreator#mesh\n * @since 3.0.0\n *\n * @param {object} config - The configuration object this Game Object will use to create itself.\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\n *\n * @return {Phaser.GameObjects.Mesh} The Game Object that was created.\n */\nGameObjectCreator.register('mesh', function (config, addToScene)\n{\n    if (config === undefined) { config = {}; }\n\n    var key = GetAdvancedValue(config, 'key', null);\n    var frame = GetAdvancedValue(config, 'frame', null);\n    var vertices = GetValue(config, 'vertices', []);\n    var uvs = GetValue(config, 'uvs', []);\n    var indicies = GetValue(config, 'indicies', []);\n    var containsZ = GetValue(config, 'containsZ', false);\n    var normals = GetValue(config, 'normals', []);\n    var colors = GetValue(config, 'colors', 0xffffff);\n    var alphas = GetValue(config, 'alphas', 1);\n\n    var mesh = new Mesh(this.scene, 0, 0, key, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas);\n\n    if (addToScene !== undefined)\n    {\n        config.add = addToScene;\n    }\n\n    BuildGameObject(this.scene, mesh, config);\n\n    return mesh;\n});\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Mesh = require('./Mesh');\nvar GameObjectFactory = require('../GameObjectFactory');\n\n/**\n * Creates a new Mesh Game Object and adds it to the Scene.\n *\n * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectFactory#mesh\n * @webglOnly\n * @since 3.0.0\n *\n * @param {number} [x] - The horizontal position of this Game Object in the world.\n * @param {number} [y] - The vertical position of this Game Object in the world.\n * @param {string|Phaser.Textures.Texture} [texture] - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {string|number} [frame] - An optional frame from the Texture this Game Object is rendering with.\n * @param {number[]} [vertices] - The vertices array. Either `xy` pairs, or `xyz` if the `containsZ` parameter is `true`.\n * @param {number[]} [uvs] - The UVs pairs array.\n * @param {number[]} [indicies] - Optional vertex indicies array. If you don't have one, pass `null` or an empty array.\n * @param {boolean} [containsZ=false] - Does the vertices data include a `z` component?\n * @param {number[]} [normals] - Optional vertex normals array. If you don't have one, pass `null` or an empty array.\n * @param {number|number[]} [colors=0xffffff] - An array of colors, one per vertex, or a single color value applied to all vertices.\n * @param {number|number[]} [alphas=1] - An array of alpha values, one per vertex, or a single alpha value applied to all vertices.\n *\n * @return {Phaser.GameObjects.Mesh} The Game Object that was created.\n */\nif (typeof WEBGL_RENDERER)\n{\n    GameObjectFactory.register('mesh', function (x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas)\n    {\n        return this.displayList.add(new Mesh(this.scene, x, y, texture, frame, vertices, uvs, indicies, containsZ, normals, colors, alphas));\n    });\n}\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar renderWebGL = require('../../utils/NOOP');\nvar renderCanvas = require('../../utils/NOOP');\n\nif (typeof WEBGL_RENDERER)\n{\n    renderWebGL = require('./MeshWebGLRenderer');\n}\n\nif (typeof CANVAS_RENDERER)\n{\n    renderCanvas = require('./MeshCanvasRenderer');\n}\n\nmodule.exports = {\n\n    renderWebGL: renderWebGL,\n    renderCanvas: renderCanvas\n\n};\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Mesh#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Mesh} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar MeshWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    var faces = src.faces;\r\n    var totalFaces = faces.length;\r\n\r\n    if (totalFaces === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    var textureUnit = pipeline.setGameObject(src);\r\n\r\n    var F32 = pipeline.vertexViewF32;\r\n    var U32 = pipeline.vertexViewU32;\r\n\r\n    var vertexOffset = (pipeline.vertexCount * pipeline.currentShader.vertexComponentCount) - 1;\r\n\r\n    var tintEffect = src.tintFill;\r\n\r\n    var debugFaces = [];\r\n    var debugCallback = src.debugCallback;\r\n\r\n    var a = calcMatrix.a;\r\n    var b = calcMatrix.b;\r\n    var c = calcMatrix.c;\r\n    var d = calcMatrix.d;\r\n    var e = calcMatrix.e;\r\n    var f = calcMatrix.f;\r\n\r\n    var z = src.viewPosition.z;\r\n\r\n    var hideCCW = src.hideCCW;\r\n    var roundPixels = camera.roundPixels;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    var totalFacesRendered = 0;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    for (var i = 0; i < totalFaces; i++)\r\n    {\r\n        var face = faces[i];\r\n\r\n        //  If face has alpha <= 0, or hideCCW + clockwise, or isn't in camera view, then don't draw it\r\n        if (!face.isInView(camera, hideCCW, z, alpha, a, b, c, d, e, f, roundPixels))\r\n        {\r\n            continue;\r\n        }\r\n\r\n        if (pipeline.shouldFlush(3))\r\n        {\r\n            pipeline.flush();\r\n\r\n            vertexOffset = 0;\r\n        }\r\n\r\n        vertexOffset = face.load(F32, U32, vertexOffset, textureUnit, tintEffect);\r\n\r\n        totalFacesRendered++;\r\n        pipeline.vertexCount += 3;\r\n\r\n        if (debugCallback)\r\n        {\r\n            debugFaces.push(face);\r\n        }\r\n    }\r\n\r\n    src.totalFrame += totalFacesRendered;\r\n\r\n    if (debugCallback)\r\n    {\r\n        debugCallback.call(src, src, debugFaces);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = MeshWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar FloatBetween = require('../../math/FloatBetween');\r\nvar GetEaseFunction = require('../../tweens/builders/GetEaseFunction');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Wrap = require('../../math/Wrap');\r\n\r\n/**\r\n * @classdesc\r\n * A Particle Emitter property.\r\n *\r\n * Facilitates changing Particle properties as they are emitted and throughout their lifetime.\r\n *\r\n * @class EmitterOp\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} config - Settings for the Particle Emitter that owns this property.\r\n * @param {string} key - The name of the property.\r\n * @param {number} defaultValue - The default value of the property.\r\n * @param {boolean} [emitOnly=false] - Whether the property can only be modified when a Particle is emitted.\r\n */\r\nvar EmitterOp = new Class({\r\n\r\n    initialize:\r\n\r\n    function EmitterOp (config, key, defaultValue, emitOnly)\r\n    {\r\n        if (emitOnly === undefined)\r\n        {\r\n            emitOnly = false;\r\n        }\r\n\r\n        /**\r\n         * The name of this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#propertyKey\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.propertyKey = key;\r\n\r\n        /**\r\n         * The value of this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#propertyValue\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.propertyValue = defaultValue;\r\n\r\n        /**\r\n         * The default value of this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#defaultValue\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultValue = defaultValue;\r\n\r\n        /**\r\n         * The number of steps for stepped easing between {@link Phaser.GameObjects.Particles.EmitterOp#start} and\r\n         * {@link Phaser.GameObjects.Particles.EmitterOp#end} values, per emit.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#steps\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.steps = 0;\r\n\r\n        /**\r\n         * The step counter for stepped easing, per emit.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#counter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.counter = 0;\r\n\r\n        /**\r\n         * The start value for this property to ease between.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#start\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.start = 0;\r\n\r\n        /**\r\n         * The end value for this property to ease between.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#end\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.end = 0;\r\n\r\n        /**\r\n         * The easing function to use for updating this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#ease\r\n         * @type {?function}\r\n         * @since 3.0.0\r\n         */\r\n        this.ease;\r\n\r\n        /**\r\n         * Whether this property can only be modified when a Particle is emitted.\r\n         *\r\n         * Set to `true` to allow only {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} callbacks to be set and\r\n         * affect this property.\r\n         *\r\n         * Set to `false` to allow both {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and\r\n         * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks to be set and affect this property.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#emitOnly\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.emitOnly = emitOnly;\r\n\r\n        /**\r\n         * The callback to run for Particles when they are emitted from the Particle Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#onEmit\r\n         * @type {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.onEmit = this.defaultEmit;\r\n\r\n        /**\r\n         * The callback to run for Particles when they are updated.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.EmitterOp#onUpdate\r\n         * @type {Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateCallback}\r\n         * @since 3.0.0\r\n         */\r\n        this.onUpdate = this.defaultUpdate;\r\n\r\n        this.loadConfig(config);\r\n    },\r\n\r\n    /**\r\n     * Load the property from a Particle Emitter configuration object.\r\n     *\r\n     * Optionally accepts a new property key to use, replacing the current one.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#loadConfig\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} [config] - Settings for the Particle Emitter that owns this property.\r\n     * @param {string} [newKey] - The new key to use for this property, if any.\r\n     */\r\n    loadConfig: function (config, newKey)\r\n    {\r\n        if (config === undefined)\r\n        {\r\n            config = {};\r\n        }\r\n\r\n        if (newKey)\r\n        {\r\n            this.propertyKey = newKey;\r\n        }\r\n\r\n        this.propertyValue = GetFastValue(\r\n            config,\r\n            this.propertyKey,\r\n            this.defaultValue\r\n        );\r\n\r\n        this.setMethods();\r\n\r\n        if (this.emitOnly)\r\n        {\r\n            //  Reset it back again\r\n            this.onUpdate = this.defaultUpdate;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Build a JSON representation of this Particle Emitter property.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {object} A JSON representation of this Particle Emitter property.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        return this.propertyValue;\r\n    },\r\n\r\n    /**\r\n     * Change the current value of the property and update its callback methods.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#onChange\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The value of the property.\r\n     *\r\n     * @return {this} This Emitter Op object.\r\n     */\r\n    onChange: function (value)\r\n    {\r\n        this.propertyValue = value;\r\n\r\n        return this.setMethods();\r\n    },\r\n\r\n    /**\r\n     * Update the {@link Phaser.GameObjects.Particles.EmitterOp#onEmit} and\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#onUpdate} callbacks based on the type of the current\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#propertyValue}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#setMethods\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Emitter Op object.\r\n     */\r\n    setMethods: function ()\r\n    {\r\n        var value = this.propertyValue;\r\n\r\n        var t = typeof value;\r\n\r\n        //  Reset them in case they're not changed below\r\n        this.onEmit = this.defaultEmit;\r\n        this.onUpdate = this.defaultUpdate;\r\n\r\n        if (t === 'number')\r\n        {\r\n            //  Explicit static value:\r\n            //  x: 400\r\n\r\n            this.onEmit = this.staticValueEmit;\r\n            this.onUpdate = this.staticValueUpdate; // How?\r\n        }\r\n        else if (Array.isArray(value))\r\n        {\r\n            //  Picks a random element from the array:\r\n            //  x: [ 100, 200, 300, 400 ]\r\n\r\n            this.onEmit = this.randomStaticValueEmit;\r\n        }\r\n        else if (t === 'function')\r\n        {\r\n            //  The same as setting just the onUpdate function and no onEmit (unless this op is an emitOnly one)\r\n            //  Custom callback, must return a value:\r\n\r\n            /*\r\n            x: function (particle, key, t, value)\r\n               {\r\n                   return value + 50;\r\n               }\r\n            */\r\n\r\n            if (this.emitOnly)\r\n            {\r\n                this.onEmit = value;\r\n            }\r\n            else\r\n            {\r\n                this.onUpdate = value;\r\n            }\r\n        }\r\n        else if (t === 'object' && this.hasBoth(value, 'start', 'end'))\r\n        {\r\n            this.start = value.start;\r\n            this.end = value.end;\r\n\r\n            //  x: { start: 100, end: 400, random: true } (random optional) = eases between start and end\r\n\r\n            var isRandom = this.has(value, 'random');\r\n\r\n            if (isRandom)\r\n            {\r\n                this.onEmit = this.randomRangedValueEmit;\r\n            }\r\n\r\n            if (this.has(value, 'steps'))\r\n            {\r\n                //  A stepped (per emit) range\r\n\r\n                //  x: { start: 100, end: 400, steps: 64 }\r\n\r\n                //  Increments a value stored in the emitter\r\n\r\n                this.steps = value.steps;\r\n                this.counter = this.start;\r\n\r\n                this.onEmit = this.steppedEmit;\r\n            }\r\n            else\r\n            {\r\n                //  An eased range (defaults to Linear if not specified)\r\n\r\n                //  x: { start: 100, end: 400, [ ease: 'Linear' ] }\r\n\r\n                var easeType = this.has(value, 'ease') ? value.ease : 'Linear';\r\n\r\n                this.ease = GetEaseFunction(easeType, value.easeParams);\r\n\r\n                if (!isRandom)\r\n                {\r\n                    this.onEmit = this.easedValueEmit;\r\n                }\r\n\r\n                this.onUpdate = this.easeValueUpdate;\r\n            }\r\n        }\r\n        else if (t === 'object' && this.hasBoth(value, 'min', 'max'))\r\n        {\r\n            //  { min: 100, max: 400 } = pick a random number between min and max\r\n\r\n            this.start = value.min;\r\n            this.end = value.max;\r\n            this.onEmit = this.randomRangedValueEmit;\r\n        }\r\n        else if (t === 'object' && this.has(value, 'random'))\r\n        {\r\n            //  { random: [ 100, 400 ] } = pick a random number between the two elements of the array\r\n\r\n            var rnd = value.random;\r\n\r\n            if (Array.isArray(rnd))\r\n            {\r\n                this.start = rnd[0];\r\n                this.end = rnd[1];\r\n            }\r\n\r\n            this.onEmit = this.randomRangedValueEmit;\r\n        }\r\n        else if (t === 'object' && this.hasEither(value, 'onEmit', 'onUpdate'))\r\n        {\r\n            //  Custom onEmit and onUpdate callbacks\r\n\r\n            /*\r\n            x: {\r\n                //  Called at the start of the particles life, when it is being created\r\n                onEmit: function (particle, key, t, value)\r\n                {\r\n                    return value;\r\n                },\r\n\r\n                //  Called during the particles life on each update\r\n                onUpdate: function (particle, key, t, value)\r\n                {\r\n                    return value;\r\n                }\r\n            }\r\n            */\r\n\r\n            if (this.has(value, 'onEmit'))\r\n            {\r\n                this.onEmit = value.onEmit;\r\n            }\r\n\r\n            if (this.has(value, 'onUpdate'))\r\n            {\r\n                this.onUpdate = value.onUpdate;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Check whether an object has the given property.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#has\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - The object to check.\r\n     * @param {string} key - The key of the property to look for in the object.\r\n     *\r\n     * @return {boolean} `true` if the property exists in the object, `false` otherwise.\r\n     */\r\n    has: function (object, key)\r\n    {\r\n        return object.hasOwnProperty(key);\r\n    },\r\n\r\n    /**\r\n     * Check whether an object has both of the given properties.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#hasBoth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - The object to check.\r\n     * @param {string} key1 - The key of the first property to check the object for.\r\n     * @param {string} key2 - The key of the second property to check the object for.\r\n     *\r\n     * @return {boolean} `true` if both properties exist in the object, `false` otherwise.\r\n     */\r\n    hasBoth: function (object, key1, key2)\r\n    {\r\n        return object.hasOwnProperty(key1) && object.hasOwnProperty(key2);\r\n    },\r\n\r\n    /**\r\n     * Check whether an object has at least one of the given properties.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#hasEither\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} object - The object to check.\r\n     * @param {string} key1 - The key of the first property to check the object for.\r\n     * @param {string} key2 - The key of the second property to check the object for.\r\n     *\r\n     * @return {boolean} `true` if at least one of the properties exists in the object, `false` if neither exist.\r\n     */\r\n    hasEither: function (object, key1, key2)\r\n    {\r\n        return object.hasOwnProperty(key1) || object.hasOwnProperty(key2);\r\n    },\r\n\r\n    /**\r\n     * The returned value sets what the property will be at the START of the particles life, on emit.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#defaultEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The name of the property.\r\n     * @param {number} [value] - The current value of the property.\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    defaultEmit: function (particle, key, value)\r\n    {\r\n        return value;\r\n    },\r\n\r\n    /**\r\n     * The returned value updates the property for the duration of the particles life.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#defaultUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The name of the property.\r\n     * @param {number} t - The T value (between 0 and 1)\r\n     * @param {number} value - The current value of the property.\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    defaultUpdate: function (particle, key, t, value)\r\n    {\r\n        return value;\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback that returns the current value of the property.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#staticValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The current value of the property.\r\n     */\r\n    staticValueEmit: function ()\r\n    {\r\n        return this.propertyValue;\r\n    },\r\n\r\n    /**\r\n     * An `onUpdate` callback that returns the current value of the property.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#staticValueUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The current value of the property.\r\n     */\r\n    staticValueUpdate: function ()\r\n    {\r\n        return this.propertyValue;\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback that returns a random value from the current value array.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#randomStaticValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    randomStaticValueEmit: function ()\r\n    {\r\n        var randomIndex = Math.floor(Math.random() * this.propertyValue.length);\r\n\r\n        return this.propertyValue[randomIndex];\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback that returns a value between the {@link Phaser.GameObjects.Particles.EmitterOp#start} and\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#end} range.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#randomRangedValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The key of the property.\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    randomRangedValueEmit: function (particle, key)\r\n    {\r\n        var value = FloatBetween(this.start, this.end);\r\n\r\n        if (particle && particle.data[key])\r\n        {\r\n            particle.data[key].min = value;\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback that returns a stepped value between the\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}\r\n     * range.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#steppedEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    steppedEmit: function ()\r\n    {\r\n        var current = this.counter;\r\n\r\n        var next = this.counter + (this.end - this.start) / this.steps;\r\n\r\n        this.counter = Wrap(next, this.start, this.end);\r\n\r\n        return current;\r\n    },\r\n\r\n    /**\r\n     * An `onEmit` callback for an eased property.\r\n     *\r\n     * It prepares the particle for easing by {@link Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#easedValueEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The name of the property.\r\n     *\r\n     * @return {number} {@link Phaser.GameObjects.Particles.EmitterOp#start}, as the new value of the property.\r\n     */\r\n    easedValueEmit: function (particle, key)\r\n    {\r\n        if (particle && particle.data[key])\r\n        {\r\n            var data = particle.data[key];\r\n\r\n            data.min = this.start;\r\n            data.max = this.end;\r\n        }\r\n\r\n        return this.start;\r\n    },\r\n\r\n    /**\r\n     * An `onUpdate` callback that returns an eased value between the\r\n     * {@link Phaser.GameObjects.Particles.EmitterOp#start} and {@link Phaser.GameObjects.Particles.EmitterOp#end}\r\n     * range.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.EmitterOp#easeValueUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The particle.\r\n     * @param {string} key - The name of the property.\r\n     * @param {number} t - The T value (between 0 and 1)\r\n     *\r\n     * @return {number} The new value of the property.\r\n     */\r\n    easeValueUpdate: function (particle, key, t)\r\n    {\r\n        var data = particle.data[key];\r\n\r\n        return (data.max - data.min) * this.ease(t) + data.min;\r\n    }\r\n});\r\n\r\nmodule.exports = EmitterOp;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\n\r\n/**\r\n * @classdesc\r\n * The GravityWell action applies a force on the particle to draw it towards, or repel it from, a single point.\r\n * \r\n * The force applied is inversely proportional to the square of the distance from the particle to the point, in accordance with Newton's law of gravity.\r\n * \r\n * This simulates the effect of gravity over large distances (as between planets, for example).\r\n *\r\n * @class GravityWell\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(number|Phaser.Types.GameObjects.Particles.GravityWellConfig)} [x=0] - The x coordinate of the Gravity Well, in world space.\r\n * @param {number} [y=0] - The y coordinate of the Gravity Well, in world space.\r\n * @param {number} [power=0] - The strength of the gravity force - larger numbers produce a stronger force.\r\n * @param {number} [epsilon=100] - The minimum distance for which the gravity force is calculated.\r\n * @param {number} [gravity=50] - The gravitational force of this Gravity Well.\r\n */\r\nvar GravityWell = new Class({\r\n\r\n    initialize:\r\n\r\n    function GravityWell (x, y, power, epsilon, gravity)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            var config = x;\r\n\r\n            x = GetFastValue(config, 'x', 0);\r\n            y = GetFastValue(config, 'y', 0);\r\n            power = GetFastValue(config, 'power', 0);\r\n            epsilon = GetFastValue(config, 'epsilon', 100);\r\n            gravity = GetFastValue(config, 'gravity', 50);\r\n        }\r\n        else\r\n        {\r\n            if (x === undefined) { x = 0; }\r\n            if (y === undefined) { y = 0; }\r\n            if (power === undefined) { power = 0; }\r\n            if (epsilon === undefined) { epsilon = 100; }\r\n            if (gravity === undefined) { gravity = 50; }\r\n        }\r\n\r\n        /**\r\n         * The x coordinate of the Gravity Well, in world space.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#x\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.x = x;\r\n\r\n        /**\r\n         * The y coordinate of the Gravity Well, in world space.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#y\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.y = y;\r\n\r\n        /**\r\n         * The active state of the Gravity Well. An inactive Gravity Well will not influence any particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * Internal gravity value.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#_gravity\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._gravity = gravity;\r\n\r\n        /**\r\n         * Internal power value.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#_power\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._power = 0;\r\n\r\n        /**\r\n         * Internal epsilon value.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#_epsilon\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._epsilon = 0;\r\n\r\n        /**\r\n         * The strength of the gravity force - larger numbers produce a stronger force.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#power\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.power = power;\r\n\r\n        /**\r\n         * The minimum distance for which the gravity force is calculated.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.GravityWell#epsilon\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.epsilon = epsilon;\r\n    },\r\n\r\n    /**\r\n     * Takes a Particle and updates it based on the properties of this Gravity Well.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.GravityWell#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle to update.\r\n     * @param {number} delta - The delta time in ms.\r\n     * @param {number} step - The delta value divided by 1000.\r\n     */\r\n    update: function (particle, delta)\r\n    {\r\n        var x = this.x - particle.x;\r\n        var y = this.y - particle.y;\r\n        var dSq = x * x + y * y;\r\n\r\n        if (dSq === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var d = Math.sqrt(dSq);\r\n\r\n        if (dSq < this._epsilon)\r\n        {\r\n            dSq = this._epsilon;\r\n        }\r\n\r\n        var factor = ((this._power * delta) / (dSq * d)) * 100;\r\n\r\n        particle.velocityX += x * factor;\r\n        particle.velocityY += y * factor;\r\n    },\r\n\r\n    epsilon: {\r\n\r\n        get: function ()\r\n        {\r\n            return Math.sqrt(this._epsilon);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._epsilon = value * value;\r\n        }\r\n\r\n    },\r\n\r\n    power: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._power / this._gravity;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._power = value * this._gravity;\r\n        }\r\n\r\n    },\r\n\r\n    gravity: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._gravity;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            var pwr = this.power;\r\n            this._gravity = value;\r\n            this.power = pwr;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = GravityWell;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar DegToRad = require('../../math/DegToRad');\r\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\r\n\r\n/**\r\n * @classdesc\r\n * A Particle is a simple Game Object controlled by a Particle Emitter and Manager, and rendered by the Manager.\r\n * It uses its own lightweight physics system, and can interact only with its Emitter's bounds and zones.\r\n *\r\n * @class Particle\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Emitter to which this Particle belongs.\r\n */\r\nvar Particle = new Class({\r\n\r\n    initialize:\r\n\r\n    function Particle (emitter)\r\n    {\r\n        /**\r\n         * The Emitter to which this Particle belongs.\r\n         *\r\n         * A Particle can only belong to a single Emitter and is created, updated and destroyed via it.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#emitter\r\n         * @type {Phaser.GameObjects.Particles.ParticleEmitter}\r\n         * @since 3.0.0\r\n         */\r\n        this.emitter = emitter;\r\n\r\n        /**\r\n         * The texture frame used to render this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.frame = null;\r\n\r\n        /**\r\n         * The x coordinate of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#x\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The y coordinate of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#y\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        /**\r\n         * The x velocity of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#velocityX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.velocityX = 0;\r\n\r\n        /**\r\n         * The y velocity of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#velocityY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.velocityY = 0;\r\n\r\n        /**\r\n         * The x acceleration of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#accelerationX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.accelerationX = 0;\r\n\r\n        /**\r\n         * The y acceleration of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#accelerationY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.accelerationY = 0;\r\n\r\n        /**\r\n         * The maximum horizontal velocity this Particle can travel at.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#maxVelocityX\r\n         * @type {number}\r\n         * @default 10000\r\n         * @since 3.0.0\r\n         */\r\n        this.maxVelocityX = 10000;\r\n\r\n        /**\r\n         * The maximum vertical velocity this Particle can travel at.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#maxVelocityY\r\n         * @type {number}\r\n         * @default 10000\r\n         * @since 3.0.0\r\n         */\r\n        this.maxVelocityY = 10000;\r\n\r\n        /**\r\n         * The bounciness, or restitution, of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#bounce\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.bounce = 0;\r\n\r\n        /**\r\n         * The horizontal scale of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#scaleX\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.scaleX = 1;\r\n\r\n        /**\r\n         * The vertical scale of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#scaleY\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.scaleY = 1;\r\n\r\n        /**\r\n         * The alpha value of this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#alpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.alpha = 1;\r\n\r\n        /**\r\n         * The angle of this Particle in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#angle\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.angle = 0;\r\n\r\n        /**\r\n         * The angle of this Particle in radians.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#rotation\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.rotation = 0;\r\n\r\n        /**\r\n         * The tint applied to this Particle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#tint\r\n         * @type {number}\r\n         * @webglOnly\r\n         * @since 3.0.0\r\n         */\r\n        this.tint = 0xffffff;\r\n\r\n        /**\r\n         * The lifespan of this Particle in ms.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#life\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         */\r\n        this.life = 1000;\r\n\r\n        /**\r\n         * The current life of this Particle in ms.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#lifeCurrent\r\n         * @type {number}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         */\r\n        this.lifeCurrent = 1000;\r\n\r\n        /**\r\n         * The delay applied to this Particle upon emission, in ms.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#delayCurrent\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.delayCurrent = 0;\r\n\r\n        /**\r\n         * The normalized lifespan T value, where 0 is the start and 1 is the end.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#lifeT\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.lifeT = 0;\r\n\r\n        /**\r\n         * The data used by the ease equation.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Particle#data\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = {\r\n            tint: { min: 0xffffff, max: 0xffffff, current: 0xffffff },\r\n            alpha: { min: 1, max: 1 },\r\n            rotate: { min: 0, max: 0 },\r\n            scaleX: { min: 1, max: 1 },\r\n            scaleY: { min: 1, max: 1 }\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Checks to see if this Particle is alive and updating.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#isAlive\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if this Particle is alive and updating, otherwise `false`.\r\n     */\r\n    isAlive: function ()\r\n    {\r\n        return (this.lifeCurrent > 0);\r\n    },\r\n\r\n    /**\r\n     * Resets the position of this particle back to zero.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#resetPosition\r\n     * @since 3.16.0\r\n     */\r\n    resetPosition: function ()\r\n    {\r\n        this.x = 0;\r\n        this.y = 0;\r\n    },\r\n\r\n    /**\r\n     * Starts this Particle from the given coordinates.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#fire\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The x coordinate to launch this Particle from.\r\n     * @param {number} y - The y coordinate to launch this Particle from.\r\n     */\r\n    fire: function (x, y)\r\n    {\r\n        var emitter = this.emitter;\r\n\r\n        this.frame = emitter.getFrame();\r\n\r\n        if (emitter.emitZone)\r\n        {\r\n            //  Updates particle.x and particle.y during this call\r\n            emitter.emitZone.getPoint(this);\r\n        }\r\n\r\n        if (x === undefined)\r\n        {\r\n            this.x += emitter.x.onEmit(this, 'x');\r\n        }\r\n        else\r\n        {\r\n            this.x += x;\r\n        }\r\n\r\n        if (y === undefined)\r\n        {\r\n            this.y += emitter.y.onEmit(this, 'y');\r\n        }\r\n        else\r\n        {\r\n            this.y += y;\r\n        }\r\n\r\n        this.life = emitter.lifespan.onEmit(this, 'lifespan');\r\n        this.lifeCurrent = this.life;\r\n        this.lifeT = 0;\r\n\r\n        var sx = emitter.speedX.onEmit(this, 'speedX');\r\n        var sy = (emitter.speedY) ? emitter.speedY.onEmit(this, 'speedY') : sx;\r\n\r\n        if (emitter.radial)\r\n        {\r\n            var rad = DegToRad(emitter.angle.onEmit(this, 'angle'));\r\n\r\n            this.velocityX = Math.cos(rad) * Math.abs(sx);\r\n            this.velocityY = Math.sin(rad) * Math.abs(sy);\r\n        }\r\n        else if (emitter.moveTo)\r\n        {\r\n            var mx = emitter.moveToX.onEmit(this, 'moveToX');\r\n            var my = (emitter.moveToY) ? emitter.moveToY.onEmit(this, 'moveToY') : mx;\r\n\r\n            var angle = Math.atan2(my - this.y, mx - this.x);\r\n\r\n            var speed = DistanceBetween(this.x, this.y, mx, my) / (this.life / 1000);\r\n\r\n            //  We know how many pixels we need to move, but how fast?\r\n            // var speed = this.distanceToXY(displayObject, x, y) / (maxTime / 1000);\r\n\r\n            this.velocityX = Math.cos(angle) * speed;\r\n            this.velocityY = Math.sin(angle) * speed;\r\n        }\r\n        else\r\n        {\r\n            this.velocityX = sx;\r\n            this.velocityY = sy;\r\n        }\r\n\r\n        if (emitter.acceleration)\r\n        {\r\n            this.accelerationX = emitter.accelerationX.onEmit(this, 'accelerationX');\r\n            this.accelerationY = emitter.accelerationY.onEmit(this, 'accelerationY');\r\n        }\r\n\r\n        this.maxVelocityX = emitter.maxVelocityX.onEmit(this, 'maxVelocityX');\r\n        this.maxVelocityY = emitter.maxVelocityY.onEmit(this, 'maxVelocityY');\r\n\r\n        this.delayCurrent = emitter.delay.onEmit(this, 'delay');\r\n\r\n        this.scaleX = emitter.scaleX.onEmit(this, 'scaleX');\r\n        this.scaleY = (emitter.scaleY) ? emitter.scaleY.onEmit(this, 'scaleY') : this.scaleX;\r\n\r\n        this.angle = emitter.rotate.onEmit(this, 'rotate');\r\n        this.rotation = DegToRad(this.angle);\r\n\r\n        this.bounce = emitter.bounce.onEmit(this, 'bounce');\r\n\r\n        this.alpha = emitter.alpha.onEmit(this, 'alpha');\r\n\r\n        this.tint = emitter.tint.onEmit(this, 'tint');\r\n    },\r\n\r\n    /**\r\n     * An internal method that calculates the velocity of the Particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#computeVelocity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Emitter that is updating this Particle.\r\n     * @param {number} delta - The delta time in ms.\r\n     * @param {number} step - The delta value divided by 1000.\r\n     * @param {array} processors - Particle processors (gravity wells).\r\n     */\r\n    computeVelocity: function (emitter, delta, step, processors)\r\n    {\r\n        var vx = this.velocityX;\r\n        var vy = this.velocityY;\r\n\r\n        var ax = this.accelerationX;\r\n        var ay = this.accelerationY;\r\n\r\n        var mx = this.maxVelocityX;\r\n        var my = this.maxVelocityY;\r\n\r\n        vx += (emitter.gravityX * step);\r\n        vy += (emitter.gravityY * step);\r\n\r\n        if (ax)\r\n        {\r\n            vx += (ax * step);\r\n        }\r\n\r\n        if (ay)\r\n        {\r\n            vy += (ay * step);\r\n        }\r\n\r\n        if (vx > mx)\r\n        {\r\n            vx = mx;\r\n        }\r\n        else if (vx < -mx)\r\n        {\r\n            vx = -mx;\r\n        }\r\n\r\n        if (vy > my)\r\n        {\r\n            vy = my;\r\n        }\r\n        else if (vy < -my)\r\n        {\r\n            vy = -my;\r\n        }\r\n\r\n        this.velocityX = vx;\r\n        this.velocityY = vy;\r\n\r\n        //  Apply any additional processors\r\n        for (var i = 0; i < processors.length; i++)\r\n        {\r\n            processors[i].update(this, delta, step);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if this Particle is still within the bounds defined by the given Emitter.\r\n     *\r\n     * If not, and depending on the Emitter collision flags, the Particle may either stop or rebound.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#checkBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Emitter to check the bounds against.\r\n     */\r\n    checkBounds: function (emitter)\r\n    {\r\n        var bounds = emitter.bounds;\r\n        var bounce = -this.bounce;\r\n\r\n        if (this.x < bounds.x && emitter.collideLeft)\r\n        {\r\n            this.x = bounds.x;\r\n            this.velocityX *= bounce;\r\n        }\r\n        else if (this.x > bounds.right && emitter.collideRight)\r\n        {\r\n            this.x = bounds.right;\r\n            this.velocityX *= bounce;\r\n        }\r\n\r\n        if (this.y < bounds.y && emitter.collideTop)\r\n        {\r\n            this.y = bounds.y;\r\n            this.velocityY *= bounce;\r\n        }\r\n        else if (this.y > bounds.bottom && emitter.collideBottom)\r\n        {\r\n            this.y = bounds.bottom;\r\n            this.velocityY *= bounce;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The main update method for this Particle.\r\n     *\r\n     * Updates its life values, computes the velocity and repositions the Particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Particle#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} delta - The delta time in ms.\r\n     * @param {number} step - The delta value divided by 1000.\r\n     * @param {array} processors - An optional array of update processors.\r\n     *\r\n     * @return {boolean} Returns `true` if this Particle has now expired and should be removed, otherwise `false` if still active.\r\n     */\r\n    update: function (delta, step, processors)\r\n    {\r\n        if (this.delayCurrent > 0)\r\n        {\r\n            this.delayCurrent -= delta;\r\n\r\n            return false;\r\n        }\r\n\r\n        var emitter = this.emitter;\r\n\r\n        //  How far along in life is this particle? (t = 0 to 1)\r\n        var t = 1 - (this.lifeCurrent / this.life);\r\n\r\n        this.lifeT = t;\r\n\r\n        this.computeVelocity(emitter, delta, step, processors);\r\n\r\n        this.x += this.velocityX * step;\r\n        this.y += this.velocityY * step;\r\n\r\n        if (emitter.bounds)\r\n        {\r\n            this.checkBounds(emitter);\r\n        }\r\n\r\n        if (emitter.deathZone && emitter.deathZone.willKill(this))\r\n        {\r\n            this.lifeCurrent = 0;\r\n\r\n            //  No need to go any further, particle has been killed\r\n            return true;\r\n        }\r\n\r\n        this.scaleX = emitter.scaleX.onUpdate(this, 'scaleX', t, this.scaleX);\r\n\r\n        if (emitter.scaleY)\r\n        {\r\n            this.scaleY = emitter.scaleY.onUpdate(this, 'scaleY', t, this.scaleY);\r\n        }\r\n        else\r\n        {\r\n            this.scaleY = this.scaleX;\r\n        }\r\n\r\n        this.angle = emitter.rotate.onUpdate(this, 'rotate', t, this.angle);\r\n        this.rotation = DegToRad(this.angle);\r\n\r\n        this.alpha = emitter.alpha.onUpdate(this, 'alpha', t, this.alpha);\r\n\r\n        this.tint = emitter.tint.onUpdate(this, 'tint', t, this.tint);\r\n\r\n        this.lifeCurrent -= delta;\r\n\r\n        return (this.lifeCurrent <= 0);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Particle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../../renderer/BlendModes');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar DeathZone = require('./zones/DeathZone');\r\nvar EdgeZone = require('./zones/EdgeZone');\r\nvar EmitterOp = require('./EmitterOp');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar GetRandom = require('../../utils/array/GetRandom');\r\nvar HasAny = require('../../utils/object/HasAny');\r\nvar HasValue = require('../../utils/object/HasValue');\r\nvar Particle = require('./Particle');\r\nvar RandomZone = require('./zones/RandomZone');\r\nvar Rectangle = require('../../geom/rectangle/Rectangle');\r\nvar StableSort = require('../../utils/array/StableSort');\r\nvar Vector2 = require('../../math/Vector2');\r\nvar Wrap = require('../../math/Wrap');\r\n\r\n/**\r\n * @classdesc\r\n * A particle emitter represents a single particle stream.\r\n * It controls a pool of {@link Phaser.GameObjects.Particles.Particle Particles} and is controlled by a {@link Phaser.GameObjects.Particles.ParticleEmitterManager Particle Emitter Manager}.\r\n *\r\n * @class ParticleEmitter\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} manager - The Emitter Manager this Emitter belongs to.\r\n * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} config - Settings for this emitter.\r\n */\r\nvar ParticleEmitter = new Class({\r\n\r\n    Mixins: [\r\n        Components.BlendMode,\r\n        Components.Mask,\r\n        Components.ScrollFactor,\r\n        Components.Visible\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function ParticleEmitter (manager, config)\r\n    {\r\n        /**\r\n         * The Emitter Manager this Emitter belongs to.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#manager\r\n         * @type {Phaser.GameObjects.Particles.ParticleEmitterManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = manager;\r\n\r\n        /**\r\n         * The texture assigned to particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.0.0\r\n         */\r\n        this.texture = manager.texture;\r\n\r\n        /**\r\n         * The texture frames assigned to particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#frames\r\n         * @type {Phaser.Textures.Frame[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.frames = [ manager.defaultFrame ];\r\n\r\n        /**\r\n         * The default texture frame assigned to particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#defaultFrame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultFrame = manager.defaultFrame;\r\n\r\n        /**\r\n         * Names of simple configuration properties.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#configFastMap\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.configFastMap = [\r\n            'active',\r\n            'blendMode',\r\n            'collideBottom',\r\n            'collideLeft',\r\n            'collideRight',\r\n            'collideTop',\r\n            'deathCallback',\r\n            'deathCallbackScope',\r\n            'emitCallback',\r\n            'emitCallbackScope',\r\n            'follow',\r\n            'frequency',\r\n            'gravityX',\r\n            'gravityY',\r\n            'maxParticles',\r\n            'name',\r\n            'on',\r\n            'particleBringToTop',\r\n            'particleClass',\r\n            'radial',\r\n            'timeScale',\r\n            'trackVisible',\r\n            'visible'\r\n        ];\r\n\r\n        /**\r\n         * Names of complex configuration properties.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#configOpMap\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.configOpMap = [\r\n            'accelerationX',\r\n            'accelerationY',\r\n            'angle',\r\n            'alpha',\r\n            'bounce',\r\n            'delay',\r\n            'lifespan',\r\n            'maxVelocityX',\r\n            'maxVelocityY',\r\n            'moveToX',\r\n            'moveToY',\r\n            'quantity',\r\n            'rotate',\r\n            'scaleX',\r\n            'scaleY',\r\n            'speedX',\r\n            'speedY',\r\n            'tint',\r\n            'x',\r\n            'y'\r\n        ];\r\n\r\n        /**\r\n         * The name of this Particle Emitter.\r\n         *\r\n         * Empty by default and never populated by Phaser, this is left for developers to use.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#name\r\n         * @type {string}\r\n         * @default ''\r\n         * @since 3.0.0\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * The Particle Class which will be emitted by this Emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#particleClass\r\n         * @type {Phaser.GameObjects.Particles.Particle}\r\n         * @default Phaser.GameObjects.Particles.Particle\r\n         * @since 3.0.0\r\n         */\r\n        this.particleClass = Particle;\r\n\r\n        /**\r\n         * The x-coordinate of the particle origin (where particles will be emitted).\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#x\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setPosition\r\n         */\r\n        this.x = new EmitterOp(config, 'x', 0, true);\r\n\r\n        /**\r\n         * The y-coordinate of the particle origin (where particles will be emitted).\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#y\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setPosition\r\n         */\r\n        this.y = new EmitterOp(config, 'y', 0, true);\r\n\r\n        /**\r\n         * A radial emitter will emit particles in all directions between angle min and max,\r\n         * using {@link Phaser.GameObjects.Particles.ParticleEmitter#speed} as the value. If set to false then this acts as a point Emitter.\r\n         * A point emitter will emit particles only in the direction derived from the speedX and speedY values.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#radial\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setRadial\r\n         */\r\n        this.radial = true;\r\n\r\n        /**\r\n         * Horizontal acceleration applied to emitted particles, in pixels per second squared.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#gravityX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setGravity\r\n         */\r\n        this.gravityX = 0;\r\n\r\n        /**\r\n         * Vertical acceleration applied to emitted particles, in pixels per second squared.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#gravityY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setGravity\r\n         */\r\n        this.gravityY = 0;\r\n\r\n        /**\r\n         * Whether accelerationX and accelerationY are non-zero. Set automatically during configuration.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#acceleration\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.acceleration = false;\r\n\r\n        /**\r\n         * Horizontal acceleration applied to emitted particles, in pixels per second squared.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#accelerationX\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.accelerationX = new EmitterOp(config, 'accelerationX', 0, true);\r\n\r\n        /**\r\n         * Vertical acceleration applied to emitted particles, in pixels per second squared.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#accelerationY\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.accelerationY = new EmitterOp(config, 'accelerationY', 0, true);\r\n\r\n        /**\r\n         * The maximum horizontal velocity of emitted particles, in pixels per second squared.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#maxVelocityX\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 10000\r\n         * @since 3.0.0\r\n         */\r\n        this.maxVelocityX = new EmitterOp(config, 'maxVelocityX', 10000, true);\r\n\r\n        /**\r\n         * The maximum vertical velocity of emitted particles, in pixels per second squared.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#maxVelocityY\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 10000\r\n         * @since 3.0.0\r\n         */\r\n        this.maxVelocityY = new EmitterOp(config, 'maxVelocityY', 10000, true);\r\n\r\n        /**\r\n         * The initial horizontal speed of emitted particles, in pixels per second.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#speedX\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setSpeedX\r\n         */\r\n        this.speedX = new EmitterOp(config, 'speedX', 0, true);\r\n\r\n        /**\r\n         * The initial vertical speed of emitted particles, in pixels per second.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#speedY\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setSpeedY\r\n         */\r\n        this.speedY = new EmitterOp(config, 'speedY', 0, true);\r\n\r\n        /**\r\n         * Whether moveToX and moveToY are nonzero. Set automatically during configuration.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#moveTo\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.moveTo = false;\r\n\r\n        /**\r\n         * The x-coordinate emitted particles move toward, when {@link Phaser.GameObjects.Particles.ParticleEmitter#moveTo} is true.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#moveToX\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.moveToX = new EmitterOp(config, 'moveToX', 0, true);\r\n\r\n        /**\r\n         * The y-coordinate emitted particles move toward, when {@link Phaser.GameObjects.Particles.ParticleEmitter#moveTo} is true.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#moveToY\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.moveToY = new EmitterOp(config, 'moveToY', 0, true);\r\n\r\n        /**\r\n         * Whether particles will rebound when they meet the emitter bounds.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#bounce\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.bounce = new EmitterOp(config, 'bounce', 0, true);\r\n\r\n        /**\r\n         * The horizontal scale of emitted particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#scaleX\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setScale\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setScaleX\r\n         */\r\n        this.scaleX = new EmitterOp(config, 'scaleX', 1);\r\n\r\n        /**\r\n         * The vertical scale of emitted particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#scaleY\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setScale\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setScaleY\r\n         */\r\n        this.scaleY = new EmitterOp(config, 'scaleY', 1);\r\n\r\n        /**\r\n         * Color tint applied to emitted particles. Value must not include the alpha channel.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#tint\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0xffffff\r\n         * @since 3.0.0\r\n         */\r\n        this.tint = new EmitterOp(config, 'tint', 0xffffff);\r\n\r\n        /**\r\n         * The alpha (transparency) of emitted particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#alpha\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setAlpha\r\n         */\r\n        this.alpha = new EmitterOp(config, 'alpha', 1);\r\n\r\n        /**\r\n         * The lifespan of emitted particles, in ms.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#lifespan\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 1000\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setLifespan\r\n         */\r\n        this.lifespan = new EmitterOp(config, 'lifespan', 1000, true);\r\n\r\n        /**\r\n         * The angle of the initial velocity of emitted particles, in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#angle\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default { min: 0, max: 360 }\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setAngle\r\n         */\r\n        this.angle = new EmitterOp(config, 'angle', { min: 0, max: 360 }, true);\r\n\r\n        /**\r\n         * The rotation of emitted particles, in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#rotate\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.rotate = new EmitterOp(config, 'rotate', 0);\r\n\r\n        /**\r\n         * A function to call when a particle is emitted.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#emitCallback\r\n         * @type {?Phaser.Types.GameObjects.Particles.ParticleEmitterCallback}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.emitCallback = null;\r\n\r\n        /**\r\n         * The calling context for {@link Phaser.GameObjects.Particles.ParticleEmitter#emitCallback}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#emitCallbackScope\r\n         * @type {?*}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.emitCallbackScope = null;\r\n\r\n        /**\r\n         * A function to call when a particle dies.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#deathCallback\r\n         * @type {?Phaser.Types.GameObjects.Particles.ParticleDeathCallback}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.deathCallback = null;\r\n\r\n        /**\r\n         * The calling context for {@link Phaser.GameObjects.Particles.ParticleEmitter#deathCallback}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#deathCallbackScope\r\n         * @type {?*}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.deathCallbackScope = null;\r\n\r\n        /**\r\n         * Set to hard limit the amount of particle objects this emitter is allowed to create.\r\n         * 0 means unlimited.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#maxParticles\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.maxParticles = 0;\r\n\r\n        /**\r\n         * How many particles are emitted each time particles are emitted (one explosion or one flow cycle).\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#quantity\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrequency\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setQuantity\r\n         */\r\n        this.quantity = new EmitterOp(config, 'quantity', 1, true);\r\n\r\n        /**\r\n         * How many ms to wait after emission before the particles start updating.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#delay\r\n         * @type {Phaser.GameObjects.Particles.EmitterOp}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.delay = new EmitterOp(config, 'delay', 0, true);\r\n\r\n        /**\r\n         * For a flow emitter, the time interval (>= 0) between particle flow cycles in ms.\r\n         * A value of 0 means there is one particle flow cycle for each logic update (the maximum flow frequency). This is the default setting.\r\n         * For an exploding emitter, this value will be -1.\r\n         * Calling {@link Phaser.GameObjects.Particles.ParticleEmitter#flow} also puts the emitter in flow mode (frequency >= 0).\r\n         * Calling {@link Phaser.GameObjects.Particles.ParticleEmitter#explode} also puts the emitter in explode mode (frequency = -1).\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#frequency\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrequency\r\n         */\r\n        this.frequency = 0;\r\n\r\n        /**\r\n         * Controls if the emitter is currently emitting a particle flow (when frequency >= 0).\r\n         * Already alive particles will continue to update until they expire.\r\n         * Controlled by {@link Phaser.GameObjects.Particles.ParticleEmitter#start} and {@link Phaser.GameObjects.Particles.ParticleEmitter#stop}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#on\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.on = true;\r\n\r\n        /**\r\n         * Newly emitted particles are added to the top of the particle list, i.e. rendered above those already alive.\r\n         * Set to false to send them to the back.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#particleBringToTop\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.particleBringToTop = true;\r\n\r\n        /**\r\n         * The time rate applied to active particles, affecting lifespan, movement, and tweens. Values larger than 1 are faster than normal.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.timeScale = 1;\r\n\r\n        /**\r\n         * An object describing a shape to emit particles from.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#emitZone\r\n         * @type {?Phaser.GameObjects.Particles.Zones.EdgeZone|Phaser.GameObjects.Particles.Zones.RandomZone}\r\n         * @default null\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setEmitZone\r\n         */\r\n        this.emitZone = null;\r\n\r\n        /**\r\n         * An object describing a shape that deactivates particles when they interact with it.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#deathZone\r\n         * @type {?Phaser.GameObjects.Particles.Zones.DeathZone}\r\n         * @default null\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setDeathZone\r\n         */\r\n        this.deathZone = null;\r\n\r\n        /**\r\n         * A rectangular boundary constraining particle movement.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#bounds\r\n         * @type {?Phaser.Geom.Rectangle}\r\n         * @default null\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setBounds\r\n         */\r\n        this.bounds = null;\r\n\r\n        /**\r\n         * Whether particles interact with the left edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideLeft\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.collideLeft = true;\r\n\r\n        /**\r\n         * Whether particles interact with the right edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideRight\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.collideRight = true;\r\n\r\n        /**\r\n         * Whether particles interact with the top edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideTop\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.collideTop = true;\r\n\r\n        /**\r\n         * Whether particles interact with the bottom edge of the emitter {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#collideBottom\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.collideBottom = true;\r\n\r\n        /**\r\n         * Whether this emitter updates itself and its particles.\r\n         *\r\n         * Controlled by {@link Phaser.GameObjects.Particles.ParticleEmitter#pause}\r\n         * and {@link Phaser.GameObjects.Particles.ParticleEmitter#resume}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * Set this to false to hide any active particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#visible\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setVisible\r\n         */\r\n        this.visible = true;\r\n\r\n        /**\r\n         * The blend mode of this emitter's particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#blendMode\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setBlendMode\r\n         */\r\n        this.blendMode = BlendModes.NORMAL;\r\n\r\n        /**\r\n         * A Game Object whose position is used as the particle origin.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#follow\r\n         * @type {?Phaser.GameObjects.GameObject}\r\n         * @default null\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#startFollow\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#stopFollow\r\n         */\r\n        this.follow = null;\r\n\r\n        /**\r\n         * The offset of the particle origin from the {@link Phaser.GameObjects.Particles.ParticleEmitter#follow} target.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#followOffset\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#startFollow\r\n         */\r\n        this.followOffset = new Vector2();\r\n\r\n        /**\r\n         * Whether the emitter's {@link Phaser.GameObjects.Particles.ParticleEmitter#visible} state will track\r\n         * the {@link Phaser.GameObjects.Particles.ParticleEmitter#follow} target's visibility state.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#trackVisible\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#startFollow\r\n         */\r\n        this.trackVisible = false;\r\n\r\n        /**\r\n         * The current texture frame, as an index of {@link Phaser.GameObjects.Particles.ParticleEmitter#frames}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#currentFrame\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrame\r\n         */\r\n        this.currentFrame = 0;\r\n\r\n        /**\r\n         * Whether texture {@link Phaser.GameObjects.Particles.ParticleEmitter#frames} are selected at random.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#randomFrame\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrame\r\n         */\r\n        this.randomFrame = true;\r\n\r\n        /**\r\n         * The number of consecutive particles that receive a single texture frame (per frame cycle).\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#frameQuantity\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         * @see Phaser.GameObjects.Particles.ParticleEmitter#setFrame\r\n         */\r\n        this.frameQuantity = 1;\r\n\r\n        /**\r\n         * Inactive particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#dead\r\n         * @type {Phaser.GameObjects.Particles.Particle[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.dead = [];\r\n\r\n        /**\r\n         * Active particles\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#alive\r\n         * @type {Phaser.GameObjects.Particles.Particle[]}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.alive = [];\r\n\r\n        /**\r\n         * The time until the next flow cycle.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#_counter\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._counter = 0;\r\n\r\n        /**\r\n         * Counts up to {@link Phaser.GameObjects.Particles.ParticleEmitter#frameQuantity}.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitter#_frameCounter\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._frameCounter = 0;\r\n\r\n        if (config)\r\n        {\r\n            this.fromJSON(config);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Merges configuration settings into the emitter's current settings.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#fromJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} config - Settings for this emitter.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    fromJSON: function (config)\r\n    {\r\n        if (!config)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        //  Only update properties from their current state if they exist in the given config\r\n\r\n        var i = 0;\r\n        var key = '';\r\n\r\n        for (i = 0; i < this.configFastMap.length; i++)\r\n        {\r\n            key = this.configFastMap[i];\r\n\r\n            if (HasValue(config, key))\r\n            {\r\n                this[key] = GetFastValue(config, key);\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < this.configOpMap.length; i++)\r\n        {\r\n            key = this.configOpMap[i];\r\n\r\n            if (HasValue(config, key))\r\n            {\r\n                this[key].loadConfig(config);\r\n            }\r\n        }\r\n\r\n        this.acceleration = (this.accelerationX.propertyValue !== 0 || this.accelerationY.propertyValue !== 0);\r\n\r\n        this.moveTo = (this.moveToX.propertyValue !== 0 || this.moveToY.propertyValue !== 0);\r\n\r\n        //  Special 'speed' override\r\n\r\n        if (HasValue(config, 'speed'))\r\n        {\r\n            this.speedX.loadConfig(config, 'speed');\r\n            this.speedY = null;\r\n        }\r\n\r\n        //  If you specify speedX, speedY or moveTo then it changes the emitter from radial to a point emitter\r\n        if (HasAny(config, [ 'speedX', 'speedY' ]) || this.moveTo)\r\n        {\r\n            this.radial = false;\r\n        }\r\n\r\n        //  Special 'scale' override\r\n\r\n        if (HasValue(config, 'scale'))\r\n        {\r\n            this.scaleX.loadConfig(config, 'scale');\r\n            this.scaleY = null;\r\n        }\r\n\r\n        if (HasValue(config, 'callbackScope'))\r\n        {\r\n            var callbackScope = GetFastValue(config, 'callbackScope', null);\r\n\r\n            this.emitCallbackScope = callbackScope;\r\n            this.deathCallbackScope = callbackScope;\r\n        }\r\n\r\n        if (HasValue(config, 'emitZone'))\r\n        {\r\n            this.setEmitZone(config.emitZone);\r\n        }\r\n\r\n        if (HasValue(config, 'deathZone'))\r\n        {\r\n            this.setDeathZone(config.deathZone);\r\n        }\r\n\r\n        if (HasValue(config, 'bounds'))\r\n        {\r\n            this.setBounds(config.bounds);\r\n        }\r\n\r\n        if (HasValue(config, 'followOffset'))\r\n        {\r\n            this.followOffset.setFromObject(GetFastValue(config, 'followOffset', 0));\r\n        }\r\n\r\n        if (HasValue(config, 'frame'))\r\n        {\r\n            this.setFrame(config.frame);\r\n        }\r\n\r\n        if (HasValue(config, 'reserve'))\r\n        {\r\n            this.reserve(config.reserve);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a description of this emitter suitable for JSON serialization.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} [output] - An object to copy output into.\r\n     *\r\n     * @return {object} - The output object.\r\n     */\r\n    toJSON: function (output)\r\n    {\r\n        if (output === undefined) { output = {}; }\r\n\r\n        var i = 0;\r\n        var key = '';\r\n\r\n        for (i = 0; i < this.configFastMap.length; i++)\r\n        {\r\n            key = this.configFastMap[i];\r\n\r\n            output[key] = this[key];\r\n        }\r\n\r\n        for (i = 0; i < this.configOpMap.length; i++)\r\n        {\r\n            key = this.configOpMap[i];\r\n\r\n            if (this[key])\r\n            {\r\n                output[key] = this[key].toJSON();\r\n            }\r\n        }\r\n\r\n        //  special handlers\r\n        if (!this.speedY)\r\n        {\r\n            delete output.speedX;\r\n            output.speed = this.speedX.toJSON();\r\n        }\r\n\r\n        if (!this.scaleY)\r\n        {\r\n            delete output.scaleX;\r\n            output.scale = this.scaleX.toJSON();\r\n        }\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Continuously moves the particle origin to follow a Game Object's position.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#startFollow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} target - The Game Object to follow.\r\n     * @param {number} [offsetX=0] - Horizontal offset of the particle origin from the Game Object.\r\n     * @param {number} [offsetY=0] - Vertical offset of the particle origin from the Game Object.\r\n     * @param {boolean} [trackVisible=false] - Whether the emitter's visible state will track the target's visible state.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    startFollow: function (target, offsetX, offsetY, trackVisible)\r\n    {\r\n        if (offsetX === undefined) { offsetX = 0; }\r\n        if (offsetY === undefined) { offsetY = 0; }\r\n        if (trackVisible === undefined) { trackVisible = false; }\r\n\r\n        this.follow = target;\r\n        this.followOffset.set(offsetX, offsetY);\r\n        this.trackVisible = trackVisible;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stops following a Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#stopFollow\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    stopFollow: function ()\r\n    {\r\n        this.follow = null;\r\n        this.followOffset.set(0, 0);\r\n        this.trackVisible = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Chooses a texture frame from {@link Phaser.GameObjects.Particles.ParticleEmitter#frames}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#getFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Textures.Frame} The texture frame.\r\n     */\r\n    getFrame: function ()\r\n    {\r\n        if (this.frames.length === 1)\r\n        {\r\n            return this.defaultFrame;\r\n        }\r\n        else if (this.randomFrame)\r\n        {\r\n            return GetRandom(this.frames);\r\n        }\r\n        else\r\n        {\r\n            var frame = this.frames[this.currentFrame];\r\n\r\n            this._frameCounter++;\r\n\r\n            if (this._frameCounter === this.frameQuantity)\r\n            {\r\n                this._frameCounter = 0;\r\n                this.currentFrame = Wrap(this.currentFrame + 1, 0, this._frameLength);\r\n            }\r\n\r\n            return frame;\r\n        }\r\n    },\r\n\r\n    // frame: 0\r\n    // frame: 'red'\r\n    // frame: [ 0, 1, 2, 3 ]\r\n    // frame: [ 'red', 'green', 'blue', 'pink', 'white' ]\r\n    // frame: { frames: [ 'red', 'green', 'blue', 'pink', 'white' ], [cycle: bool], [quantity: int] }\r\n\r\n    /**\r\n     * Sets a pattern for assigning texture frames to emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(array|string|number|Phaser.Types.GameObjects.Particles.ParticleEmitterFrameConfig)} frames - One or more texture frames, or a configuration object.\r\n     * @param {boolean} [pickRandom=true] - Whether frames should be assigned at random from `frames`.\r\n     * @param {number} [quantity=1] - The number of consecutive particles that will receive each frame.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setFrame: function (frames, pickRandom, quantity)\r\n    {\r\n        if (pickRandom === undefined) { pickRandom = true; }\r\n        if (quantity === undefined) { quantity = 1; }\r\n\r\n        this.randomFrame = pickRandom;\r\n        this.frameQuantity = quantity;\r\n        this.currentFrame = 0;\r\n        this._frameCounter = 0;\r\n\r\n        var t = typeof (frames);\r\n\r\n        if (Array.isArray(frames) || t === 'string' || t === 'number')\r\n        {\r\n            this.manager.setEmitterFrames(frames, this);\r\n        }\r\n        else if (t === 'object')\r\n        {\r\n            var frameConfig = frames;\r\n\r\n            frames = GetFastValue(frameConfig, 'frames', null);\r\n\r\n            if (frames)\r\n            {\r\n                this.manager.setEmitterFrames(frames, this);\r\n            }\r\n\r\n            var isCycle = GetFastValue(frameConfig, 'cycle', false);\r\n\r\n            this.randomFrame = (isCycle) ? false : true;\r\n\r\n            this.frameQuantity = GetFastValue(frameConfig, 'quantity', quantity);\r\n        }\r\n\r\n        this._frameLength = this.frames.length;\r\n\r\n        if (this._frameLength === 1)\r\n        {\r\n            this.frameQuantity = 1;\r\n            this.randomFrame = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle movement on or off.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setRadial\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [value=true] - Radial mode (true) or point mode (true).\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setRadial: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this.radial = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the position of the emitter's particle origin.\r\n     * New particles will be emitted here.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} x - The x-coordinate of the particle origin.\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} y - The y-coordinate of the particle origin.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setPosition: function (x, y)\r\n    {\r\n        this.x.onChange(x);\r\n        this.y.onChange(y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets or modifies a rectangular boundary constraining the particles.\r\n     *\r\n     * To remove the boundary, set {@link Phaser.GameObjects.Particles.ParticleEmitter#bounds} to null.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Types.GameObjects.Particles.ParticleEmitterBounds|Phaser.Types.GameObjects.Particles.ParticleEmitterBoundsAlt)} x - The x-coordinate of the left edge of the boundary, or an object representing a rectangle.\r\n     * @param {number} y - The y-coordinate of the top edge of the boundary.\r\n     * @param {number} width - The width of the boundary.\r\n     * @param {number} height - The height of the boundary.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setBounds: function (x, y, width, height)\r\n    {\r\n        if (typeof x === 'object')\r\n        {\r\n            var obj = x;\r\n\r\n            x = obj.x;\r\n            y = obj.y;\r\n            width = (HasValue(obj, 'w')) ? obj.w : obj.width;\r\n            height = (HasValue(obj, 'h')) ? obj.h : obj.height;\r\n        }\r\n\r\n        if (this.bounds)\r\n        {\r\n            this.bounds.setTo(x, y, width, height);\r\n        }\r\n        else\r\n        {\r\n            this.bounds = new Rectangle(x, y, width, height);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the initial horizontal speed of emitted particles.\r\n     * Changes the emitter to point mode.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setSpeedX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The speed, in pixels per second.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setSpeedX: function (value)\r\n    {\r\n        this.speedX.onChange(value);\r\n\r\n        //  If you specify speedX and Y then it changes the emitter from radial to a point emitter\r\n        this.radial = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the initial vertical speed of emitted particles.\r\n     * Changes the emitter to point mode.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setSpeedY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The speed, in pixels per second.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setSpeedY: function (value)\r\n    {\r\n        if (this.speedY)\r\n        {\r\n            this.speedY.onChange(value);\r\n\r\n            //  If you specify speedX and Y then it changes the emitter from radial to a point emitter\r\n            this.radial = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the initial radial speed of emitted particles.\r\n     * Changes the emitter to radial mode.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setSpeed\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The speed, in pixels per second.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setSpeed: function (value)\r\n    {\r\n        this.speedX.onChange(value);\r\n        this.speedY = null;\r\n\r\n        //  If you specify speedX and Y then it changes the emitter from radial to a point emitter\r\n        this.radial = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal scale of emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setScaleX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - The scale, relative to 1.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setScaleX: function (value)\r\n    {\r\n        this.scaleX.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical scale of emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setScaleY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - The scale, relative to 1.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setScaleY: function (value)\r\n    {\r\n        this.scaleY.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the scale of emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - The scale, relative to 1.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setScale: function (value)\r\n    {\r\n        this.scaleX.onChange(value);\r\n        this.scaleY = null;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the horizontal gravity applied to emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setGravityX\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - Acceleration due to gravity, in pixels per second squared.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setGravityX: function (value)\r\n    {\r\n        this.gravityX = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the vertical gravity applied to emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setGravityY\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - Acceleration due to gravity, in pixels per second squared.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setGravityY: function (value)\r\n    {\r\n        this.gravityY = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the gravity applied to emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setGravity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - Horizontal acceleration due to gravity, in pixels per second squared.\r\n     * @param {number} y - Vertical acceleration due to gravity, in pixels per second squared.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setGravity: function (x, y)\r\n    {\r\n        this.gravityX = x;\r\n        this.gravityY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the opacity of emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - A value between 0 (transparent) and 1 (opaque).\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setAlpha: function (value)\r\n    {\r\n        this.alpha.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the color tint of emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setTint\r\n     * @since 3.22.0\r\n     *\r\n     * @param {(Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType|Phaser.Types.GameObjects.Particles.EmitterOpOnUpdateType)} value - A value between 0 and 0xffffff.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setTint: function (value)\r\n    {\r\n        this.tint.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angle of a {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle stream.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setEmitterAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The angle of the initial velocity of emitted particles.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setEmitterAngle: function (value)\r\n    {\r\n        this.angle.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the angle of a {@link Phaser.GameObjects.Particles.ParticleEmitter#radial} particle stream.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setAngle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The angle of the initial velocity of emitted particles.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setAngle: function (value)\r\n    {\r\n        this.angle.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the lifespan of newly emitted particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setLifespan\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} value - The particle lifespan, in ms.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setLifespan: function (value)\r\n    {\r\n        this.lifespan.onChange(value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the number of particles released at each flow cycle or explosion.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setQuantity\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} quantity - The number of particles to release at each flow cycle or explosion.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setQuantity: function (quantity)\r\n    {\r\n        this.quantity.onChange(quantity);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the emitter's {@link Phaser.GameObjects.Particles.ParticleEmitter#frequency}\r\n     * and {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setFrequency\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} frequency - The time interval (>= 0) of each flow cycle, in ms; or -1 to put the emitter in explosion mode.\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} [quantity] - The number of particles to release at each flow cycle or explosion.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setFrequency: function (frequency, quantity)\r\n    {\r\n        this.frequency = frequency;\r\n\r\n        this._counter = 0;\r\n\r\n        if (quantity)\r\n        {\r\n            this.quantity.onChange(quantity);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets or removes the {@link Phaser.GameObjects.Particles.ParticleEmitter#emitZone}.\r\n     *\r\n     * An {@link Phaser.Types.GameObjects.Particles.ParticleEmitterEdgeZoneConfig EdgeZone} places particles on its edges. Its {@link Phaser.Types.GameObjects.Particles.EdgeZoneSource source} can be a Curve, Path, Circle, Ellipse, Line, Polygon, Rectangle, or Triangle; or any object with a suitable {@link Phaser.Types.GameObjects.Particles.EdgeZoneSourceCallback getPoints} method.\r\n     *\r\n     * A {@link Phaser.Types.GameObjects.Particles.ParticleEmitterRandomZoneConfig RandomZone} places randomly within its interior. Its {@link RandomZoneSource source} can be a Circle, Ellipse, Line, Polygon, Rectangle, or Triangle; or any object with a suitable {@link Phaser.Types.GameObjects.Particles.RandomZoneSourceCallback getRandomPoint} method.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setEmitZone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterEdgeZoneConfig|Phaser.Types.GameObjects.Particles.ParticleEmitterRandomZoneConfig} [zoneConfig] - An object describing the zone, or `undefined` to remove any current emit zone.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setEmitZone: function (zoneConfig)\r\n    {\r\n        if (zoneConfig === undefined)\r\n        {\r\n            this.emitZone = null;\r\n        }\r\n        else\r\n        {\r\n            //  Where source = Geom like Circle, or a Path or Curve\r\n            //  emitZone: { type: 'random', source: X }\r\n            //  emitZone: { type: 'edge', source: X, quantity: 32, [stepRate=0], [yoyo=false], [seamless=true] }\r\n\r\n            var type = GetFastValue(zoneConfig, 'type', 'random');\r\n            var source = GetFastValue(zoneConfig, 'source', null);\r\n\r\n            switch (type)\r\n            {\r\n                case 'random':\r\n\r\n                    this.emitZone = new RandomZone(source);\r\n\r\n                    break;\r\n\r\n                case 'edge':\r\n\r\n                    var quantity = GetFastValue(zoneConfig, 'quantity', 1);\r\n                    var stepRate = GetFastValue(zoneConfig, 'stepRate', 0);\r\n                    var yoyo = GetFastValue(zoneConfig, 'yoyo', false);\r\n                    var seamless = GetFastValue(zoneConfig, 'seamless', true);\r\n\r\n                    this.emitZone = new EdgeZone(source, quantity, stepRate, yoyo, seamless);\r\n\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets or removes the {@link Phaser.GameObjects.Particles.ParticleEmitter#deathZone}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#setDeathZone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterDeathZoneConfig} [zoneConfig] - An object describing the zone, or `undefined` to remove any current death zone.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    setDeathZone: function (zoneConfig)\r\n    {\r\n        if (zoneConfig === undefined)\r\n        {\r\n            this.deathZone = null;\r\n        }\r\n        else\r\n        {\r\n            //  Where source = Geom like Circle or Rect that supports a 'contains' function\r\n            //  deathZone: { type: 'onEnter', source: X }\r\n            //  deathZone: { type: 'onLeave', source: X }\r\n\r\n            var type = GetFastValue(zoneConfig, 'type', 'onEnter');\r\n            var source = GetFastValue(zoneConfig, 'source', null);\r\n\r\n            if (source && typeof source.contains === 'function')\r\n            {\r\n                var killOnEnter = (type === 'onEnter') ? true : false;\r\n\r\n                this.deathZone = new DeathZone(source, killOnEnter);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates inactive particles and adds them to this emitter's pool.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#reserve\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} particleCount - The number of particles to create.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    reserve: function (particleCount)\r\n    {\r\n        var dead = this.dead;\r\n\r\n        for (var i = 0; i < particleCount; i++)\r\n        {\r\n            dead.push(new this.particleClass(this));\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the number of active (in-use) particles in this emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#getAliveParticleCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The number of particles with `active=true`.\r\n     */\r\n    getAliveParticleCount: function ()\r\n    {\r\n        return this.alive.length;\r\n    },\r\n\r\n    /**\r\n     * Gets the number of inactive (available) particles in this emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#getDeadParticleCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The number of particles with `active=false`.\r\n     */\r\n    getDeadParticleCount: function ()\r\n    {\r\n        return this.dead.length;\r\n    },\r\n\r\n    /**\r\n     * Gets the total number of particles in this emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#getParticleCount\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The number of particles, including both alive and dead.\r\n     */\r\n    getParticleCount: function ()\r\n    {\r\n        return this.getAliveParticleCount() + this.getDeadParticleCount();\r\n    },\r\n\r\n    /**\r\n     * Whether this emitter is at its limit (if set).\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#atLimit\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Returns `true` if this Emitter is at its limit, or `false` if no limit, or below the `maxParticles` level.\r\n     */\r\n    atLimit: function ()\r\n    {\r\n        return (this.maxParticles > 0 && this.getParticleCount() === this.maxParticles);\r\n    },\r\n\r\n    /**\r\n     * Sets a function to call for each newly emitted particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#onParticleEmit\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterCallback} callback - The function.\r\n     * @param {*} [context] - The calling context.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    onParticleEmit: function (callback, context)\r\n    {\r\n        if (callback === undefined)\r\n        {\r\n            //  Clear any previously set callback\r\n            this.emitCallback = null;\r\n            this.emitCallbackScope = null;\r\n        }\r\n        else if (typeof callback === 'function')\r\n        {\r\n            this.emitCallback = callback;\r\n\r\n            if (context)\r\n            {\r\n                this.emitCallbackScope = context;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a function to call for each particle death.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#onParticleDeath\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleDeathCallback} callback - The function.\r\n     * @param {*} [context] - The function's calling context.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    onParticleDeath: function (callback, context)\r\n    {\r\n        if (callback === undefined)\r\n        {\r\n            //  Clear any previously set callback\r\n            this.deathCallback = null;\r\n            this.deathCallbackScope = null;\r\n        }\r\n        else if (typeof callback === 'function')\r\n        {\r\n            this.deathCallback = callback;\r\n\r\n            if (context)\r\n            {\r\n                this.deathCallbackScope = context;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deactivates every particle in this emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#killAll\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    killAll: function ()\r\n    {\r\n        var dead = this.dead;\r\n        var alive = this.alive;\r\n\r\n        while (alive.length > 0)\r\n        {\r\n            dead.push(alive.pop());\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calls a function for each active particle in this emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#forEachAlive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterCallback} callback - The function.\r\n     * @param {*} context - The function's calling context.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    forEachAlive: function (callback, context)\r\n    {\r\n        var alive = this.alive;\r\n        var length = alive.length;\r\n\r\n        for (var index = 0; index < length; ++index)\r\n        {\r\n            //  Sends the Particle and the Emitter\r\n            callback.call(context, alive[index], this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Calls a function for each inactive particle in this emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#forEachDead\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterCallback} callback - The function.\r\n     * @param {*} context - The function's calling context.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    forEachDead: function (callback, context)\r\n    {\r\n        var dead = this.dead;\r\n        var length = dead.length;\r\n\r\n        for (var index = 0; index < length; ++index)\r\n        {\r\n            //  Sends the Particle and the Emitter\r\n            callback.call(context, dead[index], this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#on} the emitter and resets the flow counter.\r\n     *\r\n     * If this emitter is in flow mode (frequency >= 0; the default), the particle flow will start (or restart).\r\n     *\r\n     * If this emitter is in explode mode (frequency = -1), nothing will happen.\r\n     * Use {@link Phaser.GameObjects.Particles.ParticleEmitter#explode} or {@link Phaser.GameObjects.Particles.ParticleEmitter#flow} instead.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#start\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    start: function ()\r\n    {\r\n        this.on = true;\r\n\r\n        this._counter = 0;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Turns {@link Phaser.GameObjects.Particles.ParticleEmitter#on off} the emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#stop\r\n     * @since 3.11.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    stop: function ()\r\n    {\r\n        this.on = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * {@link Phaser.GameObjects.Particles.ParticleEmitter#active Deactivates} the emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    pause: function ()\r\n    {\r\n        this.active = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * {@link Phaser.GameObjects.Particles.ParticleEmitter#active Activates} the emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    resume: function ()\r\n    {\r\n        this.active = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the emitter from its manager and the scene.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#remove\r\n     * @since 3.22.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    remove: function ()\r\n    {\r\n        this.manager.removeEmitter(this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sorts active particles with {@link Phaser.GameObjects.Particles.ParticleEmitter#depthSortCallback}.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#depthSort\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    depthSort: function ()\r\n    {\r\n        StableSort(this.alive, this.depthSortCallback);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Puts the emitter in flow mode (frequency >= 0) and starts (or restarts) a particle flow.\r\n     *\r\n     * To resume a flow at the current frequency and quantity, use {@link Phaser.GameObjects.Particles.ParticleEmitter#start} instead.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#flow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} frequency - The time interval (>= 0) of each flow cycle, in ms.\r\n     * @param {Phaser.Types.GameObjects.Particles.EmitterOpOnEmitType} [count=1] - The number of particles to emit at each flow cycle.\r\n     *\r\n     * @return {this} This Particle Emitter.\r\n     */\r\n    flow: function (frequency, count)\r\n    {\r\n        if (count === undefined) { count = 1; }\r\n\r\n        this.frequency = frequency;\r\n\r\n        this.quantity.onChange(count);\r\n\r\n        return this.start();\r\n    },\r\n\r\n    /**\r\n     * Puts the emitter in explode mode (frequency = -1), stopping any current particle flow, and emits several particles all at once.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#explode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} count - The amount of Particles to emit.\r\n     * @param {number} x - The x coordinate to emit the Particles from.\r\n     * @param {number} y - The y coordinate to emit the Particles from.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Particle} The most recently emitted Particle.\r\n     */\r\n    explode: function (count, x, y)\r\n    {\r\n        this.frequency = -1;\r\n\r\n        return this.emitParticle(count, x, y);\r\n    },\r\n\r\n    /**\r\n     * Emits particles at a given position (or the emitter's current position).\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#emitParticleAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=this.x] - The x coordinate to emit the Particles from.\r\n     * @param {number} [y=this.x] - The y coordinate to emit the Particles from.\r\n     * @param {number} [count=this.quantity] - The number of Particles to emit.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Particle} The most recently emitted Particle.\r\n     */\r\n    emitParticleAt: function (x, y, count)\r\n    {\r\n        return this.emitParticle(count, x, y);\r\n    },\r\n\r\n    /**\r\n     * Emits particles at a given position (or the emitter's current position).\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#emitParticle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [count=this.quantity] - The number of Particles to emit.\r\n     * @param {number} [x=this.x] - The x coordinate to emit the Particles from.\r\n     * @param {number} [y=this.x] - The y coordinate to emit the Particles from.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.Particle} The most recently emitted Particle.\r\n     *\r\n     * @see Phaser.GameObjects.Particles.Particle#fire\r\n     */\r\n    emitParticle: function (count, x, y)\r\n    {\r\n        if (this.atLimit())\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (count === undefined)\r\n        {\r\n            count = this.quantity.onEmit();\r\n        }\r\n\r\n        var dead = this.dead;\r\n\r\n        var followX = (this.follow) ? this.follow.x + this.followOffset.x : x;\r\n        var followY = (this.follow) ? this.follow.y + this.followOffset.y : y;\r\n\r\n        for (var i = 0; i < count; i++)\r\n        {\r\n            var particle = dead.pop();\r\n\r\n            if (!particle)\r\n            {\r\n                particle = new this.particleClass(this);\r\n            }\r\n\r\n            particle.fire(followX, followY);\r\n\r\n            if (this.particleBringToTop)\r\n            {\r\n                this.alive.push(particle);\r\n            }\r\n            else\r\n            {\r\n                this.alive.unshift(particle);\r\n            }\r\n\r\n            if (this.emitCallback)\r\n            {\r\n                this.emitCallback.call(this.emitCallbackScope, particle, this);\r\n            }\r\n\r\n            if (this.atLimit())\r\n            {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return particle;\r\n    },\r\n\r\n    /**\r\n     * Updates this emitter and its particles.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    preUpdate: function (time, delta)\r\n    {\r\n        //  Scale the delta\r\n        delta *= this.timeScale;\r\n\r\n        var step = (delta / 1000);\r\n\r\n        if (this.trackVisible)\r\n        {\r\n            this.visible = this.follow.visible;\r\n        }\r\n\r\n        //  Any particle processors?\r\n        var processors = this.manager.getProcessors();\r\n\r\n        var particles = this.alive;\r\n        var dead = this.dead;\r\n\r\n        var i = 0;\r\n        var rip = [];\r\n        var length = particles.length;\r\n\r\n        for (i = 0; i < length; i++)\r\n        {\r\n            var particle = particles[i];\r\n\r\n            //  update returns `true` if the particle is now dead (lifeCurrent <= 0)\r\n            if (particle.update(delta, step, processors))\r\n            {\r\n                rip.push({ index: i, particle: particle });\r\n            }\r\n        }\r\n\r\n        //  Move dead particles to the dead array\r\n        length = rip.length;\r\n\r\n        if (length > 0)\r\n        {\r\n            var deathCallback = this.deathCallback;\r\n            var deathCallbackScope = this.deathCallbackScope;\r\n\r\n            for (i = length - 1; i >= 0; i--)\r\n            {\r\n                var entry = rip[i];\r\n\r\n                //  Remove from particles array\r\n                particles.splice(entry.index, 1);\r\n\r\n                //  Add to dead array\r\n                dead.push(entry.particle);\r\n\r\n                //  Callback\r\n                if (deathCallback)\r\n                {\r\n                    deathCallback.call(deathCallbackScope, entry.particle);\r\n                }\r\n\r\n                entry.particle.resetPosition();\r\n            }\r\n        }\r\n\r\n        if (!this.on)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (this.frequency === 0)\r\n        {\r\n            this.emitParticle();\r\n        }\r\n        else if (this.frequency > 0)\r\n        {\r\n            this._counter -= delta;\r\n\r\n            if (this._counter <= 0)\r\n            {\r\n                this.emitParticle();\r\n\r\n                //  counter = frequency - remained from previous delta\r\n                this._counter = (this.frequency - Math.abs(this._counter));\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Calculates the difference of two particles, for sorting them by depth.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitter#depthSortCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} a - The first particle.\r\n     * @param {object} b - The second particle.\r\n     *\r\n     * @return {number} The difference of a and b's y coordinates.\r\n     */\r\n    depthSortCallback: function (a, b)\r\n    {\r\n        return a.y - b.y;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ParticleEmitter;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar GravityWell = require('./GravityWell');\r\nvar List = require('../../structs/List');\r\nvar ParticleEmitter = require('./ParticleEmitter');\r\nvar Render = require('./ParticleManagerRender');\r\n\r\n/**\r\n * @classdesc\r\n * A Particle Emitter Manager creates and controls {@link Phaser.GameObjects.Particles.ParticleEmitter Particle Emitters} and {@link Phaser.GameObjects.Particles.GravityWell Gravity Wells}.\r\n *\r\n * @class ParticleEmitterManager\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects.Particles\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Emitter Manager belongs.\r\n * @param {string} texture - The key of the Texture this Emitter Manager will use to render particles, as stored in the Texture Manager.\r\n * @param {(string|number)} [frame] - An optional frame from the Texture this Emitter Manager will use to render particles.\r\n * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig|Phaser.Types.GameObjects.Particles.ParticleEmitterConfig[]} [emitters] - Configuration settings for one or more emitters to create.\r\n */\r\nvar ParticleEmitterManager = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Depth,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    //  frame is optional and can contain the emitters array or object if skipped\r\n    function ParticleEmitterManager (scene, texture, frame, emitters)\r\n    {\r\n        GameObject.call(this, scene, 'ParticleEmitterManager');\r\n\r\n        /**\r\n         * The blend mode applied to all emitters and particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#blendMode\r\n         * @type {number}\r\n         * @default -1\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.blendMode = -1;\r\n\r\n        /**\r\n         * The time scale applied to all emitters and particles, affecting flow rate, lifespan, and movement.\r\n         * Values larger than 1 are faster than normal.\r\n         * This is multiplied with any timeScale set on each individual emitter.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.timeScale = 1;\r\n\r\n        /**\r\n         * The texture used to render this Emitter Manager's particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.texture = null;\r\n\r\n        /**\r\n         * The texture frame used to render this Emitter Manager's particles.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.frame = null;\r\n\r\n        /**\r\n         * Names of this Emitter Manager's texture frames.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#frameNames\r\n         * @type {string[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.frameNames = [];\r\n\r\n        //  frame is optional and can contain the emitters array or object if skipped\r\n        if (frame !== null && (typeof frame === 'object' || Array.isArray(frame)))\r\n        {\r\n            emitters = frame;\r\n            frame = null;\r\n        }\r\n\r\n        this.setTexture(texture, frame);\r\n\r\n        this.initPipeline();\r\n\r\n        /**\r\n         * A list of Emitters being managed by this Emitter Manager.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#emitters\r\n         * @type {Phaser.Structs.List.<Phaser.GameObjects.Particles.ParticleEmitter>}\r\n         * @since 3.0.0\r\n         */\r\n        this.emitters = new List(this);\r\n\r\n        /**\r\n         * A list of Gravity Wells being managed by this Emitter Manager.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.ParticleEmitterManager#wells\r\n         * @type {Phaser.Structs.List.<Phaser.GameObjects.Particles.GravityWell>}\r\n         * @since 3.0.0\r\n         */\r\n        this.wells = new List(this);\r\n\r\n        if (emitters)\r\n        {\r\n            //  An array of emitter configs?\r\n            if (!Array.isArray(emitters))\r\n            {\r\n                emitters = [ emitters ];\r\n            }\r\n\r\n            for (var i = 0; i < emitters.length; i++)\r\n            {\r\n                this.createEmitter(emitters[i]);\r\n            }\r\n        }\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * Sets the texture and frame this Emitter Manager will use to render with.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    setTexture: function (key, frame)\r\n    {\r\n        this.texture = this.scene.sys.textures.get(key);\r\n\r\n        return this.setFrame(frame);\r\n    },\r\n\r\n    /**\r\n     * Sets the frame this Emitter Manager will use to render with.\r\n     *\r\n     * The Frame has to belong to the current Texture being used.\r\n     *\r\n     * It can be either a string or an index.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    setFrame: function (frame)\r\n    {\r\n        this.frame = this.texture.get(frame);\r\n\r\n        var frames = this.texture.getFramesFromTextureSource(this.frame.sourceIndex);\r\n\r\n        var names = [];\r\n\r\n        frames.forEach(function (sourceFrame)\r\n        {\r\n            names.push(sourceFrame.name);\r\n        });\r\n\r\n        this.frameNames = names;\r\n\r\n        this.defaultFrame = this.frame;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Assigns texture frames to an emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setEmitterFrames\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Textures.Frame|Phaser.Textures.Frame[])} frames - The texture frames.\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The particle emitter to modify.\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    setEmitterFrames: function (frames, emitter)\r\n    {\r\n        if (!Array.isArray(frames))\r\n        {\r\n            frames = [ frames ];\r\n        }\r\n\r\n        var out = emitter.frames;\r\n\r\n        out.length = 0;\r\n\r\n        for (var i = 0; i < frames.length; i++)\r\n        {\r\n            var frame = frames[i];\r\n\r\n            if (this.frameNames.indexOf(frame) !== -1)\r\n            {\r\n                out.push(this.texture.get(frame));\r\n            }\r\n        }\r\n\r\n        if (out.length > 0)\r\n        {\r\n            emitter.defaultFrame = out[0];\r\n        }\r\n        else\r\n        {\r\n            emitter.defaultFrame = this.defaultFrame;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds an existing Particle Emitter to this Emitter Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#addEmitter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter - The Particle Emitter to add to this Emitter Manager.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} The Particle Emitter that was added to this Emitter Manager.\r\n     */\r\n    addEmitter: function (emitter)\r\n    {\r\n        return this.emitters.add(emitter);\r\n    },\r\n\r\n    /**\r\n     * Creates a new Particle Emitter object, adds it to this Emitter Manager and returns a reference to it.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#createEmitter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig} config - Configuration settings for the Particle Emitter to create.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.ParticleEmitter} The Particle Emitter that was created.\r\n     */\r\n    createEmitter: function (config)\r\n    {\r\n        return this.addEmitter(new ParticleEmitter(this, config));\r\n    },\r\n\r\n    /**\r\n     * Removes a Particle Emitter from this Emitter Manager, if the Emitter belongs to this Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#removeEmitter\r\n     * @since 3.22.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.ParticleEmitter} emitter\r\n     *\r\n     * @return {?Phaser.GameObjects.Particles.ParticleEmitter} The Particle Emitter if it was removed or null if it was not.\r\n     */\r\n    removeEmitter: function (emitter)\r\n    {\r\n        return this.emitters.remove(emitter, true);\r\n    },\r\n\r\n    /**\r\n     * Adds an existing Gravity Well object to this Emitter Manager.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#addGravityWell\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.GravityWell} well - The Gravity Well to add to this Emitter Manager.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.GravityWell} The Gravity Well that was added to this Emitter Manager.\r\n     */\r\n    addGravityWell: function (well)\r\n    {\r\n        return this.wells.add(well);\r\n    },\r\n\r\n    /**\r\n     * Creates a new Gravity Well, adds it to this Emitter Manager and returns a reference to it.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#createGravityWell\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.GravityWellConfig} config - Configuration settings for the Gravity Well to create.\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.GravityWell} The Gravity Well that was created.\r\n     */\r\n    createGravityWell: function (config)\r\n    {\r\n        return this.addGravityWell(new GravityWell(config));\r\n    },\r\n\r\n    /**\r\n     * Emits particles from each active emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#emitParticle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [count] - The number of particles to release from each emitter. The default is the emitter's own {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.\r\n     * @param {number} [x] - The x-coordinate to to emit particles from. The default is the x-coordinate of the emitter's current location.\r\n     * @param {number} [y] - The y-coordinate to to emit particles from. The default is the y-coordinate of the emitter's current location.\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    emitParticle: function (count, x, y)\r\n    {\r\n        var emitters = this.emitters.list;\r\n\r\n        for (var i = 0; i < emitters.length; i++)\r\n        {\r\n            var emitter = emitters[i];\r\n\r\n            if (emitter.active)\r\n            {\r\n                emitter.emitParticle(count, x, y);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Emits particles from each active emitter.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#emitParticleAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x] - The x-coordinate to to emit particles from. The default is the x-coordinate of the emitter's current location.\r\n     * @param {number} [y] - The y-coordinate to to emit particles from. The default is the y-coordinate of the emitter's current location.\r\n     * @param {number} [count] - The number of particles to release from each emitter. The default is the emitter's own {@link Phaser.GameObjects.Particles.ParticleEmitter#quantity}.\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    emitParticleAt: function (x, y, count)\r\n    {\r\n        return this.emitParticle(count, x, y);\r\n    },\r\n\r\n    /**\r\n     * Pauses this Emitter Manager.\r\n     *\r\n     * This has the effect of pausing all emitters, and all particles of those emitters, currently under its control.\r\n     *\r\n     * The particles will still render, but they will not have any of their logic updated.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    pause: function ()\r\n    {\r\n        this.active = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes this Emitter Manager, should it have been previously paused.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Emitter Manager.\r\n     */\r\n    resume: function ()\r\n    {\r\n        this.active = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets all active particle processors (gravity wells).\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#getProcessors\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Particles.GravityWell[]} - The active gravity wells.\r\n     */\r\n    getProcessors: function ()\r\n    {\r\n        return this.wells.getAll('active', true);\r\n    },\r\n\r\n    /**\r\n     * Updates all active emitters.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#preUpdate\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    preUpdate: function (time, delta)\r\n    {\r\n        //  Scale the delta\r\n        delta *= this.timeScale;\r\n\r\n        var emitters = this.emitters.list;\r\n\r\n        for (var i = 0; i < emitters.length; i++)\r\n        {\r\n            var emitter = emitters[i];\r\n\r\n            if (emitter.active)\r\n            {\r\n                emitter.preUpdate(time, delta);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass an EmitterManager to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setAlpha\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    setAlpha: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass an EmitterManager to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setScrollFactor\r\n     * @private\r\n     * @since 3.10.0\r\n     */\r\n    setScrollFactor: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass an EmitterManager to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.ParticleEmitterManager#setBlendMode\r\n     * @private\r\n     * @since 3.15.0\r\n     */\r\n    setBlendMode: function ()\r\n    {\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ParticleEmitterManager;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\n\r\nvar tempMatrix1 = new TransformMatrix();\r\nvar tempMatrix2 = new TransformMatrix();\r\nvar tempMatrix3 = new TransformMatrix();\r\nvar tempMatrix4 = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Particles.EmitterManager#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ParticleManagerCanvasRenderer = function (renderer, emitterManager, camera, parentMatrix)\r\n{\r\n    var emitters = emitterManager.emitters.list;\r\n    var emittersLength = emitters.length;\r\n\r\n    if (emittersLength === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var camMatrix = tempMatrix1.copyFrom(camera.matrix);\r\n    var calcMatrix = tempMatrix2;\r\n    var particleMatrix = tempMatrix3;\r\n    var managerMatrix = tempMatrix4;\r\n\r\n    if (parentMatrix)\r\n    {\r\n        managerMatrix.loadIdentity();\r\n        managerMatrix.multiply(parentMatrix);\r\n        managerMatrix.translate(emitterManager.x, emitterManager.y);\r\n        managerMatrix.rotate(emitterManager.rotation);\r\n        managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY);\r\n    }\r\n    else\r\n    {\r\n        managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);\r\n    }\r\n\r\n    var ctx = renderer.currentContext;\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    for (var e = 0; e < emittersLength; e++)\r\n    {\r\n        var emitter = emitters[e];\r\n        var particles = emitter.alive;\r\n        var particleCount = particles.length;\r\n\r\n        if (!emitter.visible || particleCount === 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        camera.addToRenderList(emitter);\r\n\r\n        var scrollFactorX = emitter.scrollFactorX;\r\n        var scrollFactorY = emitter.scrollFactorY;\r\n\r\n        ctx.save();\r\n\r\n        ctx.globalCompositeOperation = renderer.blendModes[emitter.blendMode];\r\n\r\n        for (var i = 0; i < particleCount; i++)\r\n        {\r\n            var particle = particles[i];\r\n\r\n            var alpha = particle.alpha * camera.alpha;\r\n\r\n            if (alpha <= 0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);\r\n\r\n            camMatrix.copyFrom(camera.matrix);\r\n\r\n            camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);\r\n\r\n            //  Undo the camera scroll\r\n            particleMatrix.e = particle.x;\r\n            particleMatrix.f = particle.y;\r\n\r\n            //  Multiply by the particle matrix, store result in calcMatrix\r\n            camMatrix.multiply(particleMatrix, calcMatrix);\r\n\r\n            var frame = particle.frame;\r\n            var cd = frame.canvasData;\r\n\r\n            var x = -(frame.halfWidth);\r\n            var y = -(frame.halfHeight);\r\n\r\n            ctx.globalAlpha = alpha;\r\n\r\n            ctx.save();\r\n\r\n            calcMatrix.setToContext(ctx);\r\n\r\n            if (roundPixels)\r\n            {\r\n                x = Math.round(x);\r\n                y = Math.round(y);\r\n            }\r\n\r\n            ctx.imageSmoothingEnabled = !(!renderer.antialias || frame.source.scaleMode);\r\n\r\n            ctx.drawImage(frame.source.image, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);\r\n\r\n            ctx.restore();\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = ParticleManagerCanvasRenderer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar GameObjectCreator = require('../GameObjectCreator');\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\nvar GetFastValue = require('../../utils/object/GetFastValue');\nvar ParticleEmitterManager = require('./ParticleEmitterManager');\n\n/**\n * Creates a new Particle Emitter Manager Game Object and returns it.\n *\n * Note: This method will only be available if the Particles Game Object has been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectCreator#particles\n * @since 3.0.0\n *\n * @param {object} config - The configuration object this Game Object will use to create itself.\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\n *\n * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} The Game Object that was created.\n */\nGameObjectCreator.register('particles', function (config, addToScene)\n{\n    if (config === undefined) { config = {}; }\n\n    var key = GetAdvancedValue(config, 'key', null);\n    var frame = GetAdvancedValue(config, 'frame', null);\n    var emitters = GetFastValue(config, 'emitters', null);\n\n    //  frame is optional and can contain the emitters array or object if skipped\n    var manager = new ParticleEmitterManager(this.scene, key, frame, emitters);\n\n    if (addToScene !== undefined)\n    {\n        config.add = addToScene;\n    }\n\n    var add = GetFastValue(config, 'add', false);\n\n    if (add)\n    {\n        this.displayList.add(manager);\n    }\n    else\n    {\n        this.updateList.add(manager);\n    }\n\n    return manager;\n});\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\nvar ParticleEmitterManager = require('./ParticleEmitterManager');\r\n\r\n/**\r\n * Creates a new Particle Emitter Manager Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Particles Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#particles\r\n * @since 3.0.0\r\n *\r\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|number|object)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * @param {Phaser.Types.GameObjects.Particles.ParticleEmitterConfig|Phaser.Types.GameObjects.Particles.ParticleEmitterConfig[]} [emitters] - Configuration settings for one or more emitters to create.\r\n *\r\n * @return {Phaser.GameObjects.Particles.ParticleEmitterManager} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('particles', function (key, frame, emitters)\r\n{\r\n    return this.displayList.add(new ParticleEmitterManager(this.scene, key, frame, emitters));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./ParticleManagerWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./ParticleManagerCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\nvar tempMatrix1 = new TransformMatrix();\r\nvar tempMatrix2 = new TransformMatrix();\r\nvar tempMatrix3 = new TransformMatrix();\r\nvar tempMatrix4 = new TransformMatrix();\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Particles.EmitterManager#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Particles.ParticleEmitterManager} emitterManager - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ParticleManagerWebGLRenderer = function (renderer, emitterManager, camera, parentMatrix)\r\n{\r\n    var emitters = emitterManager.emitters.list;\r\n    var emittersLength = emitters.length;\r\n\r\n    if (emittersLength === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var pipeline = renderer.pipelines.set(emitterManager.pipeline);\r\n\r\n    var camMatrix = tempMatrix1;\r\n    var calcMatrix = tempMatrix2;\r\n    var particleMatrix = tempMatrix3;\r\n    var managerMatrix = tempMatrix4;\r\n\r\n    if (parentMatrix)\r\n    {\r\n        managerMatrix.loadIdentity();\r\n        managerMatrix.multiply(parentMatrix);\r\n        managerMatrix.translate(emitterManager.x, emitterManager.y);\r\n        managerMatrix.rotate(emitterManager.rotation);\r\n        managerMatrix.scale(emitterManager.scaleX, emitterManager.scaleY);\r\n    }\r\n    else\r\n    {\r\n        managerMatrix.applyITRS(emitterManager.x, emitterManager.y, emitterManager.rotation, emitterManager.scaleX, emitterManager.scaleY);\r\n    }\r\n\r\n    var roundPixels = camera.roundPixels;\r\n    var texture = emitterManager.defaultFrame.glTexture;\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    var textureUnit = pipeline.setGameObject(emitterManager, emitterManager.defaultFrame);\r\n\r\n    renderer.pipelines.preBatch(emitterManager);\r\n\r\n    for (var e = 0; e < emittersLength; e++)\r\n    {\r\n        var emitter = emitters[e];\r\n        var particles = emitter.alive;\r\n        var particleCount = particles.length;\r\n\r\n        if (!emitter.visible || particleCount === 0)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        camera.addToRenderList(emitter);\r\n\r\n        var scrollFactorX = emitter.scrollFactorX;\r\n        var scrollFactorY = emitter.scrollFactorY;\r\n\r\n        renderer.setBlendMode(emitter.blendMode);\r\n\r\n        if (emitter.mask)\r\n        {\r\n            emitter.mask.preRenderWebGL(renderer, emitter, camera);\r\n\r\n            renderer.pipelines.set(emitterManager.pipeline);\r\n        }\r\n\r\n        var tintEffect = 0;\r\n\r\n        for (var i = 0; i < particleCount; i++)\r\n        {\r\n            var particle = particles[i];\r\n\r\n            var alpha = particle.alpha * camera.alpha;\r\n\r\n            if (alpha <= 0)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            particleMatrix.applyITRS(particle.x, particle.y, particle.rotation, particle.scaleX, particle.scaleY);\r\n\r\n            camMatrix.copyFrom(camera.matrix);\r\n\r\n            camMatrix.multiplyWithOffset(managerMatrix, -camera.scrollX * scrollFactorX, -camera.scrollY * scrollFactorY);\r\n\r\n            //  Undo the camera scroll\r\n            particleMatrix.e = particle.x;\r\n            particleMatrix.f = particle.y;\r\n\r\n            //  Multiply by the particle matrix, store result in calcMatrix\r\n            camMatrix.multiply(particleMatrix, calcMatrix);\r\n\r\n            var frame = particle.frame;\r\n\r\n            var x = -frame.halfWidth;\r\n            var y = -frame.halfHeight;\r\n            var xw = x + frame.width;\r\n            var yh = y + frame.height;\r\n\r\n            var tx0 = calcMatrix.getXRound(x, y, roundPixels);\r\n            var ty0 = calcMatrix.getYRound(x, y, roundPixels);\r\n\r\n            var tx1 = calcMatrix.getXRound(x, yh, roundPixels);\r\n            var ty1 = calcMatrix.getYRound(x, yh, roundPixels);\r\n\r\n            var tx2 = calcMatrix.getXRound(xw, yh, roundPixels);\r\n            var ty2 = calcMatrix.getYRound(xw, yh, roundPixels);\r\n\r\n            var tx3 = calcMatrix.getXRound(xw, y, roundPixels);\r\n            var ty3 = calcMatrix.getYRound(xw, y, roundPixels);\r\n\r\n            var tint = getTint(particle.tint, alpha);\r\n\r\n            pipeline.batchQuad(emitter, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, frame.u0, frame.v0, frame.u1, frame.v1, tint, tint, tint, tint, tintEffect, texture, textureUnit);\r\n        }\r\n\r\n        if (emitter.mask)\r\n        {\r\n            emitter.mask.postRenderWebGL(renderer, camera);\r\n        }\r\n    }\r\n\r\n    renderer.pipelines.postBatch(emitterManager);\r\n};\r\n\r\nmodule.exports = ParticleManagerWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.GameObjects.Particles\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    EmitterOp: require('./EmitterOp'),\r\n    GravityWell: require('./GravityWell'),\r\n    Particle: require('./Particle'),\r\n    ParticleEmitter: require('./ParticleEmitter'),\r\n    ParticleEmitterManager: require('./ParticleEmitterManager'),\r\n    Zones: require('./zones')\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A Death Zone.\r\n *\r\n * A Death Zone is a special type of zone that will kill a Particle as soon as it either enters, or leaves, the zone.\r\n *\r\n * The zone consists of a `source` which could be a Geometric shape, such as a Rectangle or Ellipse, or your own\r\n * object as long as it includes a `contains` method for which the Particles can be tested against.\r\n *\r\n * @class DeathZone\r\n * @memberof Phaser.GameObjects.Particles.Zones\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Particles.DeathZoneSource} source - An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.\r\n * @param {boolean} killOnEnter - Should the Particle be killed when it enters the zone? `true` or leaves it? `false`\r\n */\r\nvar DeathZone = new Class({\r\n\r\n    initialize:\r\n\r\n    function DeathZone (source, killOnEnter)\r\n    {\r\n        /**\r\n         * An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.\r\n         * This could be a Geometry shape, such as `Phaser.Geom.Circle`, or your own custom object.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.DeathZone#source\r\n         * @type {Phaser.Types.GameObjects.Particles.DeathZoneSource}\r\n         * @since 3.0.0\r\n         */\r\n        this.source = source;\r\n\r\n        /**\r\n         * Set to `true` if the Particle should be killed if it enters this zone.\r\n         * Set to `false` to kill the Particle if it leaves this zone.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.DeathZone#killOnEnter\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.killOnEnter = killOnEnter;\r\n    },\r\n\r\n    /**\r\n     * Checks if the given Particle will be killed or not by this zone.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.DeathZone#willKill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle to be checked against this zone.\r\n     *\r\n     * @return {boolean} Return `true` if the Particle is to be killed, otherwise return `false`.\r\n     */\r\n    willKill: function (particle)\r\n    {\r\n        var withinZone = this.source.contains(particle.x, particle.y);\r\n\r\n        return (withinZone && this.killOnEnter || !withinZone && !this.killOnEnter);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = DeathZone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\n\r\n/**\r\n * @classdesc\r\n * A zone that places particles on a shape's edges.\r\n *\r\n * @class EdgeZone\r\n * @memberof Phaser.GameObjects.Particles.Zones\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Particles.EdgeZoneSource} source - An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n * @param {number} quantity - The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.\r\n * @param {number} stepRate - The distance between each particle. When set, `quantity` is implied and should be set to 0.\r\n * @param {boolean} [yoyo=false] - Whether particles are placed from start to end and then end to start.\r\n * @param {boolean} [seamless=true] - Whether one endpoint will be removed if it's identical to the other.\r\n */\r\nvar EdgeZone = new Class({\r\n\r\n    initialize:\r\n\r\n    function EdgeZone (source, quantity, stepRate, yoyo, seamless)\r\n    {\r\n        if (yoyo === undefined) { yoyo = false; }\r\n        if (seamless === undefined) { seamless = true; }\r\n\r\n        /**\r\n         * An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#source\r\n         * @type {Phaser.Types.GameObjects.Particles.EdgeZoneSource|Phaser.Types.GameObjects.Particles.RandomZoneSource}\r\n         * @since 3.0.0\r\n         */\r\n        this.source = source;\r\n\r\n        /**\r\n         * The points placed on the source edge.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#points\r\n         * @type {Phaser.Geom.Point[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.points = [];\r\n\r\n        /**\r\n         * The number of particles to place on the source edge. Set to 0 to use `stepRate` instead.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#quantity\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.quantity = quantity;\r\n\r\n        /**\r\n         * The distance between each particle. When set, `quantity` is implied and should be set to 0.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#stepRate\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.stepRate = stepRate;\r\n\r\n        /**\r\n         * Whether particles are placed from start to end and then end to start.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#yoyo\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.yoyo = yoyo;\r\n\r\n        /**\r\n         * The counter used for iterating the EdgeZone's points.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#counter\r\n         * @type {number}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.counter = -1;\r\n\r\n        /**\r\n         * Whether one endpoint will be removed if it's identical to the other.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#seamless\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.seamless = seamless;\r\n\r\n        /**\r\n         * An internal count of the points belonging to this EdgeZone.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_length\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._length = 0;\r\n\r\n        /**\r\n         * An internal value used to keep track of the current iteration direction for the EdgeZone's points.\r\n         *\r\n         * 0 = forwards, 1 = backwards\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.EdgeZone#_direction\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._direction = 0;\r\n\r\n        this.updateSource();\r\n    },\r\n\r\n    /**\r\n     * Update the {@link Phaser.GameObjects.Particles.Zones.EdgeZone#points} from the EdgeZone's\r\n     * {@link Phaser.GameObjects.Particles.Zones.EdgeZone#source}.\r\n     *\r\n     * Also updates internal properties.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#updateSource\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Edge Zone.\r\n     */\r\n    updateSource: function ()\r\n    {\r\n        this.points = this.source.getPoints(this.quantity, this.stepRate);\r\n\r\n        //  Remove ends?\r\n        if (this.seamless)\r\n        {\r\n            var a = this.points[0];\r\n            var b = this.points[this.points.length - 1];\r\n\r\n            if (a.x === b.x && a.y === b.y)\r\n            {\r\n                this.points.pop();\r\n            }\r\n        }\r\n\r\n        var oldLength = this._length;\r\n\r\n        this._length = this.points.length;\r\n\r\n        //  Adjust counter if we now have less points than before\r\n        if (this._length < oldLength && this.counter > this._length)\r\n        {\r\n            this.counter = this._length - 1;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Change the source of the EdgeZone.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#changeSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.GameObjects.Particles.EdgeZoneSource} source - An object instance with a `getPoints(quantity, stepRate)` method returning an array of points.\r\n     *\r\n     * @return {this} This Edge Zone.\r\n     */\r\n    changeSource: function (source)\r\n    {\r\n        this.source = source;\r\n\r\n        return this.updateSource();\r\n    },\r\n\r\n    /**\r\n     * Get the next point in the Zone and set its coordinates on the given Particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.EdgeZone#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle.\r\n     */\r\n    getPoint: function (particle)\r\n    {\r\n        if (this._direction === 0)\r\n        {\r\n            this.counter++;\r\n\r\n            if (this.counter >= this._length)\r\n            {\r\n                if (this.yoyo)\r\n                {\r\n                    this._direction = 1;\r\n                    this.counter = this._length - 1;\r\n                }\r\n                else\r\n                {\r\n                    this.counter = 0;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.counter--;\r\n\r\n            if (this.counter === -1)\r\n            {\r\n                if (this.yoyo)\r\n                {\r\n                    this._direction = 0;\r\n                    this.counter = 0;\r\n                }\r\n                else\r\n                {\r\n                    this.counter = this._length - 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        var point = this.points[this.counter];\r\n\r\n        if (point)\r\n        {\r\n            particle.x = point.x;\r\n            particle.y = point.y;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = EdgeZone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Vector2 = require('../../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A zone that places particles randomly within a shapes area.\r\n *\r\n * @class RandomZone\r\n * @memberof Phaser.GameObjects.Particles.Zones\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Particles.RandomZoneSource} source - An object instance with a `getRandomPoint(point)` method.\r\n */\r\nvar RandomZone = new Class({\r\n\r\n    initialize:\r\n\r\n    function RandomZone (source)\r\n    {\r\n        /**\r\n         * An object instance with a `getRandomPoint(point)` method.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.RandomZone#source\r\n         * @type {Phaser.Types.GameObjects.Particles.RandomZoneSource}\r\n         * @since 3.0.0\r\n         */\r\n        this.source = source;\r\n\r\n        /**\r\n         * Internal calculation vector.\r\n         *\r\n         * @name Phaser.GameObjects.Particles.Zones.RandomZone#_tempVec\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tempVec = new Vector2();\r\n    },\r\n\r\n    /**\r\n     * Get the next point in the Zone and set its coordinates on the given Particle.\r\n     *\r\n     * @method Phaser.GameObjects.Particles.Zones.RandomZone#getPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.GameObjects.Particles.Particle} particle - The Particle.\r\n     */\r\n    getPoint: function (particle)\r\n    {\r\n        var vec = this._tempVec;\r\n\r\n        this.source.getRandomPoint(vec);\r\n\r\n        particle.x = vec.x;\r\n        particle.y = vec.y;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = RandomZone;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace Phaser.GameObjects.Particles.Zones\r\n */\r\n\r\nmodule.exports = {\r\n\r\n    DeathZone: require('./DeathZone'),\r\n    EdgeZone: require('./EdgeZone'),\r\n    RandomZone: require('./RandomZone')\r\n\r\n};\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar Components = require('../components');\nvar Sprite = require('../sprite/Sprite');\n\n/**\n * @classdesc\n * A PathFollower Game Object.\n *\n * A PathFollower is a Sprite Game Object with some extra helpers to allow it to follow a Path automatically.\n *\n * Anything you can do with a standard Sprite can be done with this PathFollower, such as animate it, tint it,\n * scale it and so on.\n *\n * PathFollowers are bound to a single Path at any one time and can traverse the length of the Path, from start\n * to finish, forwards or backwards, or from any given point on the Path to its end. They can optionally rotate\n * to face the direction of the path, be offset from the path coordinates or rotate independently of the Path.\n *\n * @class PathFollower\n * @extends Phaser.GameObjects.Sprite\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @extends Phaser.GameObjects.Components.PathFollower\n *\n * @param {Phaser.Scene} scene - The Scene to which this PathFollower belongs.\n * @param {Phaser.Curves.Path} path - The Path this PathFollower is following. It can only follow one Path at a time.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n */\nvar PathFollower = new Class({\n\n    Extends: Sprite,\n\n    Mixins: [\n        Components.PathFollower\n    ],\n\n    initialize:\n\n    function PathFollower (scene, path, x, y, texture, frame)\n    {\n        Sprite.call(this, scene, x, y, texture, frame);\n\n        this.path = path;\n    },\n\n    /**\n     * Internal update handler that advances this PathFollower along the path.\n     *\n     * Called automatically by the Scene step, should not typically be called directly.\n     *\n     * @method Phaser.GameObjects.PathFollower#preUpdate\n     * @protected\n     * @since 3.0.0\n     *\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\n     */\n    preUpdate: function (time, delta)\n    {\n        this.anims.update(time, delta);\n        this.pathUpdate(time);\n    }\n\n});\n\nmodule.exports = PathFollower;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar GameObjectFactory = require('../GameObjectFactory');\nvar PathFollower = require('./PathFollower');\n\n/**\n * Creates a new PathFollower Game Object and adds it to the Scene.\n *\n * Note: This method will only be available if the PathFollower Game Object has been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectFactory#follower\n * @since 3.0.0\n *\n * @param {Phaser.Curves.Path} path - The Path this PathFollower is connected to.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n *\n * @return {Phaser.GameObjects.PathFollower} The Game Object that was created.\n */\nGameObjectFactory.register('follower', function (path, x, y, key, frame)\n{\n    var sprite = new PathFollower(this.scene, path, x, y, key, frame);\n\n    this.displayList.add(sprite);\n    this.updateList.add(sprite);\n\n    return sprite;\n});\n\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar IntegerToColor = require('../../display/color/IntegerToColor');\r\nvar PIPELINES_CONST = require('../../renderer/webgl/pipelines/const');\r\nvar Render = require('./PointLightRender');\r\n\r\n/**\r\n * @classdesc\r\n * The Point Light Game Object provides a way to add a point light effect into your game,\r\n * without the expensive shader processing requirements of the traditional Light Game Object.\r\n *\r\n * The difference is that the Point Light renders using a custom shader, designed to give the\r\n * impression of a point light source, of variable radius, intensity and color, in your game.\r\n * However, unlike the Light Game Object, it does not impact any other Game Objects, or use their\r\n * normal maps for calcuations. This makes them extremely fast to render compared to Lights\r\n * and perfect for special effects, such as flickering torches or muzzle flashes.\r\n *\r\n * For maximum performance you should batch Point Light Game Objects together. This means\r\n * ensuring they follow each other consecutively on the display list. Ideally, use a Layer\r\n * Game Object and then add just Point Lights to it, so that it can batch together the rendering\r\n * of the lights. You don't _have_ to do this, and if you've only a handful of Point Lights in\r\n * your game then it's perfectly safe to mix them into the dislay list as normal. However, if\r\n * you're using a large number of them, please consider how they are mixed into the display list.\r\n *\r\n * The renderer will automatically cull Point Lights. Those with a radius that does not intersect\r\n * with the Camera will be skipped in the rendering list. This happens automatically and the\r\n * culled state is refreshed every frame, for every camera.\r\n *\r\n * The origin of a Point Light is always 0.5 and it cannot be changed.\r\n *\r\n * Point Lights are a WebGL only feature and do not have a Canvas counterpart.\r\n *\r\n * @class PointLight\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.50.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Point Light belongs. A Point Light can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Point Light in the world.\r\n * @param {number} y - The vertical position of this Point Light in the world.\r\n * @param {number} [color=0xffffff] - The color of the Point Light, given as a hex value.\r\n * @param {number} [radius=128] - The radius of the Point Light.\r\n * @param {number} [intensity=1] - The intensity, or colr blend, of the Point Light.\r\n * @param {number} [attenuation=0.1] - The attenuation  of the Point Light. This is the reduction of light from the center point.\r\n */\r\nvar PointLight = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function PointLight (scene, x, y, color, radius, intensity, attenuation)\r\n    {\r\n        if (color === undefined) { color = 0xffffff; }\r\n        if (radius === undefined) { radius = 128; }\r\n        if (intensity === undefined) { intensity = 1; }\r\n        if (attenuation === undefined) { attenuation = 0.1; }\r\n\r\n        GameObject.call(this, scene, 'PointLight');\r\n\r\n        this.initPipeline(PIPELINES_CONST.POINTLIGHT_PIPELINE);\r\n\r\n        this.setPosition(x, y);\r\n\r\n        /**\r\n         * The color of this Point Light. This property is an instance of a\r\n         * Color object, so you can use the methods within it, such as `setTo(r, g, b)`\r\n         * to change the color value.\r\n         *\r\n         * @name Phaser.GameObjects.PointLight#color\r\n         * @type {Phaser.Display.Color}\r\n         * @since 3.50.0\r\n         */\r\n        this.color = IntegerToColor(color);\r\n\r\n        /**\r\n         * The intensity of the Point Light.\r\n         *\r\n         * The colors of the light are multiplied by this value during rendering.\r\n         *\r\n         * @name Phaser.GameObjects.PointLight#intensity\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.intensity = intensity;\r\n\r\n        /**\r\n         * The attenuation of the Point Light.\r\n         *\r\n         * This value controls the force with which the light falls-off from the center of the light.\r\n         *\r\n         * Use small float-based values, i.e. 0.1.\r\n         *\r\n         * @name Phaser.GameObjects.PointLight#attenuation\r\n         * @type {number}\r\n         * @since 3.50.0\r\n         */\r\n        this.attenuation = attenuation;\r\n\r\n        //  read only:\r\n        this.width = radius * 2;\r\n        this.height = radius * 2;\r\n\r\n        this._radius = radius;\r\n    },\r\n\r\n    /**\r\n     * The radius of the Point Light.\r\n     *\r\n     * @name Phaser.GameObjects.PointLight#radius\r\n     * @type {number}\r\n     * @since 3.50.0\r\n     */\r\n    radius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._radius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._radius = value;\r\n            this.width = value * 2;\r\n            this.height = value * 2;\r\n        }\r\n\r\n    },\r\n\r\n    originX: {\r\n\r\n        get: function ()\r\n        {\r\n            return 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    originY: {\r\n\r\n        get: function ()\r\n        {\r\n            return 0.5;\r\n        }\r\n\r\n    },\r\n\r\n    displayOriginX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._radius;\r\n        }\r\n\r\n    },\r\n\r\n    displayOriginY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._radius;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = PointLight;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar PointLight = require('./PointLight');\r\n\r\n/**\r\n * Creates a new Point Light Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Point Light Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#pointlight\r\n * @since 3.50.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.PointLight} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('pointlight', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var color = GetAdvancedValue(config, 'color', 0xffffff);\r\n    var radius = GetAdvancedValue(config, 'radius', 128);\r\n    var intensity = GetAdvancedValue(config, 'intensity', 1);\r\n    var attenuation = GetAdvancedValue(config, 'attenuation', 0.1);\r\n\r\n    var layer = new PointLight(this.scene, 0, 0, color, radius, intensity, attenuation);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, layer, config);\r\n\r\n    return layer;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\nvar PointLight = require('./PointLight');\r\n\r\n/**\r\n * Creates a new Point Light Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Point Light Game Object has been built into Phaser.\r\n *\r\n * The Point Light Game Object provides a way to add a point light effect into your game,\r\n * without the expensive shader processing requirements of the traditional Light Game Object.\r\n *\r\n * The difference is that the Point Light renders using a custom shader, designed to give the\r\n * impression of a point light source, of variable radius, intensity and color, in your game.\r\n * However, unlike the Light Game Object, it does not impact any other Game Objects, or use their\r\n * normal maps for calcuations. This makes them extremely fast to render compared to Lights\r\n * and perfect for special effects, such as flickering torches or muzzle flashes.\r\n *\r\n * For maximum performance you should batch Point Light Game Objects together. This means\r\n * ensuring they follow each other consecutively on the display list. Ideally, use a Layer\r\n * Game Object and then add just Point Lights to it, so that it can batch together the rendering\r\n * of the lights. You don't _have_ to do this, and if you've only a handful of Point Lights in\r\n * your game then it's perfectly safe to mix them into the dislay list as normal. However, if\r\n * you're using a large number of them, please consider how they are mixed into the display list.\r\n *\r\n * The renderer will automatically cull Point Lights. Those with a radius that does not intersect\r\n * with the Camera will be skipped in the rendering list. This happens automatically and the\r\n * culled state is refreshed every frame, for every camera.\r\n *\r\n * The origin of a Point Light is always 0.5 and it cannot be changed.\r\n *\r\n * Point Lights are a WebGL only feature and do not have a Canvas counterpart.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#pointlight\r\n * @since 3.50.0\r\n *\r\n * @param {number} x - The horizontal position of this Point Light in the world.\r\n * @param {number} y - The vertical position of this Point Light in the world.\r\n * @param {number} [color=0xffffff] - The color of the Point Light, given as a hex value.\r\n * @param {number} [radius=128] - The radius of the Point Light.\r\n * @param {number} [intensity=1] - The intensity, or colr blend, of the Point Light.\r\n * @param {number} [attenuation=0.1] - The attenuation  of the Point Light. This is the reduction of light from the center point.\r\n *\r\n * @return {Phaser.GameObjects.PointLight} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('pointlight', function (x, y, color, radius, intensity, attenuation)\r\n{\r\n    return this.displayList.add(new PointLight(this.scene, x, y, color, radius, intensity, attenuation));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./PointLightWebGLRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.PointLight#renderWebGL\r\n * @since 3.50.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.PointLight} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar PointLightWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    var width = src.width;\r\n    var height = src.height;\r\n\r\n    var x = -src._radius;\r\n    var y = -src._radius;\r\n\r\n    var xw = x + width;\r\n    var yh = y + height;\r\n\r\n    var lightX = calcMatrix.getX(0, 0);\r\n    var lightY = calcMatrix.getY(0, 0);\r\n\r\n    var tx0 = calcMatrix.getX(x, y);\r\n    var ty0 = calcMatrix.getY(x, y);\r\n\r\n    var tx1 = calcMatrix.getX(x, yh);\r\n    var ty1 = calcMatrix.getY(x, yh);\r\n\r\n    var tx2 = calcMatrix.getX(xw, yh);\r\n    var ty2 = calcMatrix.getY(xw, yh);\r\n\r\n    var tx3 = calcMatrix.getX(xw, y);\r\n    var ty3 = calcMatrix.getY(xw, y);\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    pipeline.batchPointLight(src, camera, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, lightX, lightY);\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = PointLightWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../../renderer/BlendModes');\r\nvar Camera = require('../../cameras/2d/BaseCamera');\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar CONST = require('../../const');\r\nvar Frame = require('../../textures/Frame');\r\nvar GameObject = require('../GameObject');\r\nvar NOOP = require('../../utils/NOOP');\r\nvar PIPELINE_CONST = require('../../renderer/webgl/pipelines/const');\r\nvar Render = require('./RenderTextureRender');\r\nvar RenderTarget = require('../../renderer/webgl/RenderTarget');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\nvar UUID = require('../../utils/string/UUID');\r\n\r\n/**\r\n * @classdesc\r\n * A Render Texture.\r\n *\r\n * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and\r\n * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic\r\n * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.\r\n *\r\n * Note that under WebGL a FrameBuffer, which is what the Render Texture uses internally, cannot be anti-aliased. This means\r\n * that when drawing objects such as Shapes to a Render Texture they will appear to be drawn with no aliasing, however this\r\n * is a technical limitation of WebGL. To get around it, create your shape as a texture in an art package, then draw that\r\n * to the Render Texture.\r\n *\r\n * @class RenderTexture\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.2.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=32] - The width of the Render Texture.\r\n * @param {number} [height=32] - The height of the Render Texture.\r\n * @param {string} [key] - The texture key to make the RenderTexture from.\r\n * @param {string} [frame] - The frame to make the RenderTexture from.\r\n */\r\nvar RenderTexture = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Crop,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function RenderTexture (scene, x, y, width, height, key, frame)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = 32; }\r\n        if (height === undefined) { height = 32; }\r\n\r\n        GameObject.call(this, scene, 'RenderTexture');\r\n\r\n        /**\r\n         * A reference to either the Canvas or WebGL Renderer that the Game instance is using.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.2.0\r\n         */\r\n        this.renderer = scene.sys.renderer;\r\n\r\n        /**\r\n         * A reference to the Texture Manager.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#textureManager\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.12.0\r\n         */\r\n        this.textureManager = scene.sys.textures;\r\n\r\n        /**\r\n         * The tint of the Render Texture when rendered.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#globalTint\r\n         * @type {number}\r\n         * @default 0xffffff\r\n         * @since 3.2.0\r\n         */\r\n        this.globalTint = 0xffffff;\r\n\r\n        /**\r\n         * The alpha of the Render Texture when rendered.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#globalAlpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.2.0\r\n         */\r\n        this.globalAlpha = 1;\r\n\r\n        /**\r\n         * The HTML Canvas Element that the Render Texture is drawing to when using the Canvas Renderer.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.2.0\r\n         */\r\n        this.canvas = null;\r\n\r\n        /**\r\n         * Is this Render Texture dirty or not? If not it won't spend time clearing or filling itself.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#dirty\r\n         * @type {boolean}\r\n         * @since 3.12.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        /**\r\n         * The Texture corresponding to this Render Texture.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.12.0\r\n         */\r\n        this.texture = null;\r\n\r\n        /**\r\n         * The Frame corresponding to this Render Texture.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @since 3.12.0\r\n         */\r\n        this.frame = null;\r\n\r\n        /**\r\n         * Internal saved texture flag.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#_saved\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._saved = false;\r\n\r\n        if (key === undefined)\r\n        {\r\n            this.canvas = CanvasPool.create2D(this, width, height);\r\n\r\n            //  Create a new Texture for this RenderTexture object\r\n            this.texture = scene.sys.textures.addCanvas(UUID(), this.canvas);\r\n\r\n            //  Get the frame\r\n            this.frame = this.texture.get();\r\n        }\r\n        else\r\n        {\r\n            this.texture = scene.sys.textures.get(key);\r\n\r\n            //  Get the frame\r\n            this.frame = this.texture.get(frame);\r\n\r\n            this.canvas = this.frame.source.image;\r\n            this._saved = true;\r\n\r\n            this.dirty = true;\r\n\r\n            this.width = this.frame.cutWidth;\r\n            this.height = this.frame.cutHeight;\r\n        }\r\n\r\n        /**\r\n         * A reference to the Rendering Context belonging to the Canvas Element this Render Texture is drawing to.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.2.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * Internal erase mode flag.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#_eraseMode\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._eraseMode = false;\r\n\r\n        /**\r\n         * An internal Camera that can be used to move around the Render Texture.\r\n         * Control it just like you would any Scene Camera. The difference is that it only impacts the placement of what\r\n         * is drawn to the Render Texture. You can scroll, zoom and rotate this Camera.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#camera\r\n         * @type {Phaser.Cameras.Scene2D.BaseCamera}\r\n         * @since 3.12.0\r\n         */\r\n        this.camera = new Camera(0, 0, width, height);\r\n\r\n        /**\r\n         * The Render Target that belongs to this Render Texture.\r\n         *\r\n         * A Render Target encapsulates a framebuffer and texture for the WebGL Renderer.\r\n         *\r\n         * This property remains `null` under Canvas.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#renderTarget\r\n         * @type {Phaser.Renderer.WebGL.RenderTarget}\r\n         * @since 3.50.0\r\n         */\r\n        this.renderTarget = null;\r\n\r\n        var renderer = this.renderer;\r\n\r\n        if (!renderer)\r\n        {\r\n            this.drawGameObject = NOOP;\r\n        }\r\n        else if (renderer.type === CONST.WEBGL)\r\n        {\r\n            this.drawGameObject = this.batchGameObjectWebGL;\r\n\r\n            this.renderTarget = new RenderTarget(renderer, width, height, 1, 0, false);\r\n        }\r\n        else if (renderer.type === CONST.CANVAS)\r\n        {\r\n            this.drawGameObject = this.batchGameObjectCanvas;\r\n        }\r\n\r\n        this.camera.setScene(scene);\r\n\r\n        this.setPosition(x, y);\r\n\r\n        if (key === undefined)\r\n        {\r\n            this.setSize(width, height);\r\n        }\r\n\r\n        this.setOrigin(0, 0);\r\n\r\n        this.initPipeline(PIPELINE_CONST.SINGLE_PIPELINE);\r\n    },\r\n\r\n    /**\r\n     * Sets the size of this Game Object.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        return this.resize(width, height);\r\n    },\r\n\r\n    /**\r\n     * Resizes the Render Texture to the new dimensions given.\r\n     *\r\n     * If Render Texture was created from specific frame, only the size of the frame will be changed. The size of the source\r\n     * texture will not change.\r\n     *\r\n     * If Render Texture was not created from specific frame, the following will happen:\r\n     *\r\n     * In WebGL it will destroy and then re-create the frame buffer being used by the Render Texture.\r\n     * In Canvas it will resize the underlying canvas element.\r\n     *\r\n     * Both approaches will erase everything currently drawn to the Render Texture.\r\n     *\r\n     * If the dimensions given are the same as those already being used, calling this method will do nothing.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#resize\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} width - The new width of the Render Texture.\r\n     * @param {number} [height=width] - The new height of the Render Texture. If not specified, will be set the same as the `width`.\r\n     *\r\n     * @return {this} This Render Texture.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        if (height === undefined) { height = width; }\r\n\r\n        var frame = this.frame;\r\n\r\n        if (width !== this.width || height !== this.height)\r\n        {\r\n            if (frame.name === '__BASE')\r\n            {\r\n                //  Resize the texture\r\n\r\n                this.canvas.width = width;\r\n                this.canvas.height = height;\r\n\r\n                this.texture.width = width;\r\n                this.texture.height = height;\r\n\r\n                var renderTarget = this.renderTarget;\r\n\r\n                if (renderTarget)\r\n                {\r\n                    renderTarget.resize(width, height);\r\n\r\n                    frame.glTexture = renderTarget.texture;\r\n\r\n                    frame.source.isRenderTexture = true;\r\n                    frame.source.isGLTexture = true;\r\n                    frame.source.glTexture = renderTarget.texture;\r\n                }\r\n\r\n                this.camera.setSize(width, height);\r\n\r\n                frame.source.width = width;\r\n                frame.source.height = height;\r\n\r\n                frame.setSize(width, height);\r\n\r\n                this.width = width;\r\n                this.height = height;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  Resize the frame\r\n\r\n            var baseFrame = this.texture.getSourceImage();\r\n\r\n            if (frame.cutX + width > baseFrame.width)\r\n            {\r\n                width = baseFrame.width - frame.cutX;\r\n            }\r\n\r\n            if (frame.cutY + height > baseFrame.height)\r\n            {\r\n                height = baseFrame.height - frame.cutY;\r\n            }\r\n\r\n            frame.setSize(width, height, frame.cutX, frame.cutY);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n\r\n        var input = this.input;\r\n\r\n        if (input && !input.customHitArea)\r\n        {\r\n            input.hitArea.width = width;\r\n            input.hitArea.height = height;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the tint to use when rendering this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#setGlobalTint\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} tint - The tint value.\r\n     *\r\n     * @return {this} This Render Texture.\r\n     */\r\n    setGlobalTint: function (tint)\r\n    {\r\n        this.globalTint = tint;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the alpha to use when rendering this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#setGlobalAlpha\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} alpha - The alpha value.\r\n     *\r\n     * @return {this} This Render Texture.\r\n     */\r\n    setGlobalAlpha: function (alpha)\r\n    {\r\n        this.globalAlpha = alpha;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stores a copy of this Render Texture in the Texture Manager using the given key.\r\n     *\r\n     * After doing this, any texture based Game Object, such as a Sprite, can use the contents of this\r\n     * Render Texture by using the texture key:\r\n     *\r\n     * ```javascript\r\n     * var rt = this.add.renderTexture(0, 0, 128, 128);\r\n     *\r\n     * // Draw something to the Render Texture\r\n     *\r\n     * rt.saveTexture('doodle');\r\n     *\r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     *\r\n     * Updating the contents of this Render Texture will automatically update _any_ Game Object\r\n     * that is using it as a texture. Calling `saveTexture` again will not save another copy\r\n     * of the same texture, it will just rename the key of the existing copy.\r\n     *\r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame from a Render Texture.\r\n     *\r\n     * If you destroy this Render Texture, any Game Object using it via the Texture Manager will\r\n     * stop rendering. Ensure you remove the texture from the Texture Manager and any Game Objects\r\n     * using it first, before destroying this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#saveTexture\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was saved.\r\n     */\r\n    saveTexture: function (key)\r\n    {\r\n        this.textureManager.renameTexture(this.texture.key, key);\r\n\r\n        this._saved = true;\r\n\r\n        return this.texture;\r\n    },\r\n\r\n    /**\r\n     * Fills the Render Texture with the given color.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#fill\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} rgb - The color to fill the Render Texture with.\r\n     * @param {number} [alpha=1] - The alpha value used by the fill.\r\n     * @param {number} [x=0] - The left coordinate of the fill rectangle.\r\n     * @param {number} [y=0] - The top coordinate of the fill rectangle.\r\n     * @param {number} [width=this.frame.cutWidth] - The width of the fill rectangle.\r\n     * @param {number} [height=this.frame.cutHeight] - The height of the fill rectangle.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    fill: function (rgb, alpha, x, y, width, height)\r\n    {\r\n        var frame = this.frame;\r\n        var camera = this.camera;\r\n        var renderer = this.renderer;\r\n\r\n        if (alpha === undefined) { alpha = 1; }\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = frame.cutWidth; }\r\n        if (height === undefined) { height = frame.cutHeight; }\r\n\r\n        var r = (rgb >> 16 & 0xFF) / 255;\r\n        var g = (rgb >> 8 & 0xFF) / 255;\r\n        var b = (rgb & 0xFF) / 255;\r\n\r\n        var renderTarget = this.renderTarget;\r\n\r\n        camera.preRender();\r\n\r\n        if (renderTarget)\r\n        {\r\n            renderTarget.bind(true);\r\n\r\n            var pipeline = this.pipeline;\r\n\r\n            pipeline.manager.set(pipeline);\r\n\r\n            var tw = renderTarget.width;\r\n            var th = renderTarget.height;\r\n\r\n            var rw = renderer.width;\r\n            var rh = renderer.height;\r\n\r\n            var sx = rw / tw;\r\n            var sy = rh / th;\r\n\r\n            pipeline.drawFillRect(\r\n                x * sx, y * sy, width * sx, height * sy,\r\n                Utils.getTintFromFloats(b, g, r, 1),\r\n                alpha\r\n            );\r\n\r\n            renderTarget.unbind(true);\r\n        }\r\n        else\r\n        {\r\n            var ctx = this.context;\r\n\r\n            renderer.setContext(ctx);\r\n\r\n            ctx.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';\r\n            ctx.fillRect(x + frame.cutX, y + frame.cutY, width, height);\r\n\r\n            renderer.setContext();\r\n        }\r\n\r\n        this.dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clears the Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#clear\r\n     * @since 3.2.0\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    clear: function ()\r\n    {\r\n        if (this.dirty)\r\n        {\r\n            var renderTarget = this.renderTarget;\r\n\r\n            if (renderTarget)\r\n            {\r\n                renderTarget.clear();\r\n            }\r\n            else\r\n            {\r\n                var ctx = this.context;\r\n\r\n                ctx.save();\r\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n                ctx.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight);\r\n                ctx.restore();\r\n            }\r\n\r\n            this.dirty = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the given object, or an array of objects, to this Render Texture using a blend mode of ERASE.\r\n     * This has the effect of erasing any filled pixels in the objects from this Render Texture.\r\n     *\r\n     * It can accept any of the following:\r\n     *\r\n     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n     * * Tilemap Layers.\r\n     * * A Group. The contents of which will be iterated and drawn in turn.\r\n     * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n     * * Another Render Texture.\r\n     * * A Texture Frame instance.\r\n     * * A string. This is used to look-up a texture from the Texture Manager.\r\n     *\r\n     * Note: You cannot erase a Render Texture from itself.\r\n     *\r\n     * If passing in a Group or Container it will only draw children that return `true`\r\n     * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n     * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n     *\r\n     * If passing in an array of Game Objects it will draw them all, regardless if\r\n     * they pass a `willRender` check or not.\r\n     *\r\n     * You can pass in a string in which case it will look for a texture in the Texture\r\n     * Manager matching that string, and draw the base frame.\r\n     *\r\n     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n     * the coordinates differ based on what objects are being drawn. If the object is\r\n     * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n     * of the children. For all other types of object, the coordinates are exact.\r\n     *\r\n     * Calling this method causes the WebGL batch to flush, so it can write the texture\r\n     * data to the framebuffer being used internally. The batch is flushed at the end,\r\n     * after the entries have been iterated. So if you've a bunch of objects to draw,\r\n     * try and pass them in an array in one single call, rather than making lots of\r\n     * separate calls.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#erase\r\n     * @since 3.16.0\r\n     *\r\n     * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n     * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    erase: function (entries, x, y)\r\n    {\r\n        this._eraseMode = true;\r\n\r\n        this.draw(entries, x, y, 1, 16777215);\r\n\r\n        this._eraseMode = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the given object, or an array of objects, to this Render Texture.\r\n     *\r\n     * It can accept any of the following:\r\n     *\r\n     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n     * * Tilemap Layers.\r\n     * * A Group. The contents of which will be iterated and drawn in turn.\r\n     * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n     * * Another Render Texture.\r\n     * * A Texture Frame instance.\r\n     * * A string. This is used to look-up a texture from the Texture Manager.\r\n     *\r\n     * Note: You cannot draw a Render Texture to itself.\r\n     *\r\n     * If passing in a Group or Container it will only draw children that return `true`\r\n     * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n     * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n     *\r\n     * If passing in an array of Game Objects it will draw them all, regardless if\r\n     * they pass a `willRender` check or not.\r\n     *\r\n     * You can pass in a string in which case it will look for a texture in the Texture\r\n     * Manager matching that string, and draw the base frame. If you need to specify\r\n     * exactly which frame to draw then use the method `drawFrame` instead.\r\n     *\r\n     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n     * the coordinates differ based on what objects are being drawn. If the object is\r\n     * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n     * of the children. For all other types of object, the coordinates are exact.\r\n     *\r\n     * The `alpha` and `tint` values are only used by Texture Frames.\r\n     * Game Objects use their own alpha and tint values when being drawn.\r\n     *\r\n     * Calling this method causes the WebGL batch to flush, so it can write the texture\r\n     * data to the framebuffer being used internally. The batch is flushed at the end,\r\n     * after the entries have been iterated. So if you've a bunch of objects to draw,\r\n     * try and pass them in an array in one single call, rather than making lots of\r\n     * separate calls.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#draw\r\n     * @since 3.2.0\r\n     *\r\n     * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n     * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [alpha] -  The alpha value. Only used for Texture Frames and if not specified defaults to the `globalAlpha` property. Game Objects use their own current alpha value.\r\n     * @param {number} [tint] -  WebGL only. The tint color value. Only used for Texture Frames and if not specified defaults to the `globalTint` property. Game Objects use their own current tint value.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    draw: function (entries, x, y, alpha, tint)\r\n    {\r\n        this.beginDraw();\r\n        this.batchDraw(entries, x, y, alpha, tint);\r\n        this.endDraw();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the Texture Frame to the Render Texture at the given position.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * ```javascript\r\n     * var rt = this.add.renderTexture(0, 0, 800, 600);\r\n     * rt.drawFrame(key, frame);\r\n     * ```\r\n     *\r\n     * You can optionally provide a position, alpha and tint value to apply to the frame\r\n     * before it is drawn.\r\n     *\r\n     * Calling this method will cause a batch flush, so if you've got a stack of things to draw\r\n     * in a tight loop, try using the `draw` method instead.\r\n     *\r\n     * If you need to draw a Sprite to this Render Texture, use the `draw` method instead.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#drawFrame\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     * @param {number} [x=0] - The x position to draw the frame at.\r\n     * @param {number} [y=0] - The y position to draw the frame at.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - WebGL only. The tint color to use. If not specified it uses the `globalTint` property.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    drawFrame: function (key, frame, x, y, alpha, tint)\r\n    {\r\n        this.beginDraw();\r\n        this.batchDrawFrame(key, frame, x, y, alpha, tint);\r\n        this.endDraw();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Use this method if you need to batch draw a large number of Game Objects to\r\n     * this Render Texture in a single go, or on a frequent basis.\r\n     *\r\n     * This method starts the beginning of a batched draw.\r\n     *\r\n     * It is faster than calling `draw`, but you must be very careful to manage the\r\n     * flow of code and remember to call `endDraw()`. If you don't need to draw large\r\n     * numbers of objects it's much safer and easier to use the `draw` method instead.\r\n     *\r\n     * The flow should be:\r\n     *\r\n     * ```javascript\r\n     * // Call once:\r\n     * RenderTexture.beginDraw();\r\n     *\r\n     * // repeat n times:\r\n     * RenderTexture.batchDraw();\r\n     * // or\r\n     * RenderTexture.batchDrawFrame();\r\n     *\r\n     * // Call once:\r\n     * RenderTexture.endDraw();\r\n     * ```\r\n     *\r\n     * Do not call any methods other than `batchDraw`, `batchDrawFrame`, or `endDraw` once you\r\n     * have started a batch. Also, be very careful not to destroy this Render Texture while the\r\n     * batch is still open, or call `beginDraw` again.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#beginDraw\r\n     * @since 3.50.0\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    beginDraw: function ()\r\n    {\r\n        var camera = this.camera;\r\n        var renderer = this.renderer;\r\n        var renderTarget = this.renderTarget;\r\n\r\n        camera.preRender();\r\n\r\n        if (renderTarget)\r\n        {\r\n            renderer.beginCapture(renderTarget.width, renderTarget.height);\r\n        }\r\n        else\r\n        {\r\n            renderer.setContext(this.context);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Use this method if you have already called `beginDraw` and need to batch\r\n     * draw a large number of objects to this Render Texture.\r\n     *\r\n     * This method batches the drawing of the given objects to this Render Texture,\r\n     * without causing a bind or batch flush.\r\n     *\r\n     * It is faster than calling `draw`, but you must be very careful to manage the\r\n     * flow of code and remember to call `endDraw()`. If you don't need to draw large\r\n     * numbers of objects it's much safer and easier to use the `draw` method instead.\r\n     *\r\n     * The flow should be:\r\n     *\r\n     * ```javascript\r\n     * // Call once:\r\n     * RenderTexture.beginDraw();\r\n     *\r\n     * // repeat n times:\r\n     * RenderTexture.batchDraw();\r\n     * // or\r\n     * RenderTexture.batchDrawFrame();\r\n     *\r\n     * // Call once:\r\n     * RenderTexture.endDraw();\r\n     * ```\r\n     *\r\n     * Do not call any methods other than `batchDraw`, `batchDrawFrame`, or `endDraw` once you\r\n     * have started a batch. Also, be very careful not to destroy this Render Texture while the\r\n     * batch is still open, or call `beginDraw` again.\r\n     *\r\n     * Draws the given object, or an array of objects, to this Render Texture.\r\n     *\r\n     * It can accept any of the following:\r\n     *\r\n     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n     * * Tilemap Layers.\r\n     * * A Group. The contents of which will be iterated and drawn in turn.\r\n     * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n     * * Another Render Texture.\r\n     * * A Texture Frame instance.\r\n     * * A string. This is used to look-up a texture from the Texture Manager.\r\n     *\r\n     * Note: You cannot draw a Render Texture to itself.\r\n     *\r\n     * If passing in a Group or Container it will only draw children that return `true`\r\n     * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n     * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n     *\r\n     * If passing in an array of Game Objects it will draw them all, regardless if\r\n     * they pass a `willRender` check or not.\r\n     *\r\n     * You can pass in a string in which case it will look for a texture in the Texture\r\n     * Manager matching that string, and draw the base frame. If you need to specify\r\n     * exactly which frame to draw then use the method `drawFrame` instead.\r\n     *\r\n     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n     * the coordinates differ based on what objects are being drawn. If the object is\r\n     * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n     * of the children. For all other types of object, the coordinates are exact.\r\n     *\r\n     * The `alpha` and `tint` values are only used by Texture Frames.\r\n     * Game Objects use their own alpha and tint values when being drawn.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchDraw\r\n     * @since 3.50.0\r\n     *\r\n     * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n     * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [alpha] -  The alpha value. Only used for Texture Frames and if not specified defaults to the `globalAlpha` property. Game Objects use their own current alpha value.\r\n     * @param {number} [tint] -  WebGL only. The tint color value. Only used for Texture Frames and if not specified defaults to the `globalTint` property. Game Objects use their own current tint value.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    batchDraw: function (entries, x, y, alpha, tint)\r\n    {\r\n        if (alpha === undefined) { alpha = this.globalAlpha; }\r\n\r\n        if (tint === undefined)\r\n        {\r\n            tint = (this.globalTint >> 16) + (this.globalTint & 0xff00) + ((this.globalTint & 0xff) << 16);\r\n        }\r\n        else\r\n        {\r\n            tint = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16);\r\n        }\r\n\r\n        if (!Array.isArray(entries))\r\n        {\r\n            entries = [ entries ];\r\n        }\r\n\r\n        this.batchList(entries, x, y, alpha, tint);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Use this method if you have already called `beginDraw` and need to batch\r\n     * draw a large number of texture frames to this Render Texture.\r\n     *\r\n     * This method batches the drawing of the given frames to this Render Texture,\r\n     * without causing a bind or batch flush.\r\n     *\r\n     * It is faster than calling `drawFrame`, but you must be very careful to manage the\r\n     * flow of code and remember to call `endDraw()`. If you don't need to draw large\r\n     * numbers of frames it's much safer and easier to use the `drawFrame` method instead.\r\n     *\r\n     * The flow should be:\r\n     *\r\n     * ```javascript\r\n     * // Call once:\r\n     * RenderTexture.beginDraw();\r\n     *\r\n     * // repeat n times:\r\n     * RenderTexture.batchDraw();\r\n     * // or\r\n     * RenderTexture.batchDrawFrame();\r\n     *\r\n     * // Call once:\r\n     * RenderTexture.endDraw();\r\n     * ```\r\n     *\r\n     * Do not call any methods other than `batchDraw`, `batchDrawFrame`, or `endDraw` once you\r\n     * have started a batch. Also, be very careful not to destroy this Render Texture while the\r\n     * batch is still open, or call `beginDraw` again.\r\n     *\r\n     * Draws the Texture Frame to the Render Texture at the given position.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * ```javascript\r\n     * var rt = this.add.renderTexture(0, 0, 800, 600);\r\n     * rt.drawFrame(key, frame);\r\n     * ```\r\n     *\r\n     * You can optionally provide a position, alpha and tint value to apply to the frame\r\n     * before it is drawn.\r\n     *\r\n     * Calling this method will cause a batch flush, so if you've got a stack of things to draw\r\n     * in a tight loop, try using the `draw` method instead.\r\n     *\r\n     * If you need to draw a Sprite to this Render Texture, use the `draw` method instead.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchDrawFrame\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     * @param {number} [x=0] - The x position to draw the frame at.\r\n     * @param {number} [y=0] - The y position to draw the frame at.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - WebGL only. The tint color to use. If not specified it uses the `globalTint` property.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    batchDrawFrame: function (key, frame, x, y, alpha, tint)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (alpha === undefined) { alpha = this.globalAlpha; }\r\n\r\n        if (tint === undefined)\r\n        {\r\n            tint = (this.globalTint >> 16) + (this.globalTint & 0xff00) + ((this.globalTint & 0xff) << 16);\r\n        }\r\n        else\r\n        {\r\n            tint = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16);\r\n        }\r\n\r\n        var textureFrame = this.textureManager.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            if (this.renderTarget)\r\n            {\r\n                this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);\r\n            }\r\n            else\r\n            {\r\n                this.batchTextureFrame(textureFrame, x + this.frame.cutX, y + this.frame.cutY, alpha, tint);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Use this method to finish batch drawing to this Render Texture.\r\n     *\r\n     * Never call this method without first calling `beginDraw`.\r\n     *\r\n     * It is faster than calling `draw`, but you must be very careful to manage the\r\n     * flow of code and remember to call `endDraw()`. If you don't need to draw large\r\n     * numbers of objects it's much safer and easier to use the `draw` method instead.\r\n     *\r\n     * The flow should be:\r\n     *\r\n     * ```javascript\r\n     * // Call once:\r\n     * RenderTexture.beginDraw();\r\n     *\r\n     * // repeat n times:\r\n     * RenderTexture.batchDraw();\r\n     * // or\r\n     * RenderTexture.batchDrawFrame();\r\n     *\r\n     * // Call once:\r\n     * RenderTexture.endDraw();\r\n     * ```\r\n     *\r\n     * Do not call any methods other than `batchDraw`, `batchDrawFrame`, or `endDraw` once you\r\n     * have started a batch. Also, be very careful not to destroy this Render Texture while the\r\n     * batch is still open, or call `beginDraw` again.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#endDraw\r\n     * @since 3.50.0\r\n     *\r\n     * @param {boolean} [erase=false] - Draws all objects in this batch using a blend mode of ERASE. This has the effect of erasing any filled pixels in the objects being drawn.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    endDraw: function (erase)\r\n    {\r\n        if (erase === undefined) { erase = this._eraseMode; }\r\n\r\n        var renderer = this.renderer;\r\n\r\n        var renderTarget = this.renderTarget;\r\n\r\n        if (renderTarget)\r\n        {\r\n            var canvasTarget = renderer.endCapture();\r\n\r\n            var util = renderer.pipelines.setUtility();\r\n\r\n            util.blitFrame(canvasTarget, renderTarget, 1, false, false, erase);\r\n\r\n            renderer.resetScissor();\r\n            renderer.resetViewport();\r\n        }\r\n        else\r\n        {\r\n            renderer.setContext();\r\n        }\r\n\r\n        this.dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing of an array of children.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchList\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {array} children - The array of Game Objects to draw.\r\n     * @param {number} [x] - The x position to offset the Game Object by.\r\n     * @param {number} [y] - The y position to offset the Game Object by.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.\r\n     */\r\n    batchList: function (children, x, y, alpha, tint)\r\n    {\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            var entry = children[i];\r\n\r\n            if (!entry || entry === this)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (entry.renderWebGL || entry.renderCanvas)\r\n            {\r\n                //  Game Objects\r\n                this.drawGameObject(entry, x, y);\r\n            }\r\n            else if (entry.isParent || entry.list)\r\n            {\r\n                //  Groups / Display Lists\r\n                this.batchGroup(entry.getChildren(), x, y);\r\n            }\r\n            else if (typeof entry === 'string')\r\n            {\r\n                //  Texture key\r\n                this.batchTextureFrameKey(entry, null, x, y, alpha, tint);\r\n            }\r\n            else if (entry instanceof Frame)\r\n            {\r\n                //  Texture Frame instance\r\n                this.batchTextureFrame(entry, x, y, alpha, tint);\r\n            }\r\n            else if (Array.isArray(entry))\r\n            {\r\n                //  Another Array\r\n                this.batchList(entry, x, y, alpha, tint);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles drawing a Phaser Group contents.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchGroup\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {array} children - The array of Game Objects to draw.\r\n     * @param {number} [x=0] - The x position to offset the Game Object by.\r\n     * @param {number} [y=0] - The y position to offset the Game Object by.\r\n     */\r\n    batchGroup: function (children, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        x += this.frame.cutX;\r\n        y += this.frame.cutY;\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            var entry = children[i];\r\n\r\n            if (entry.willRender(this.camera))\r\n            {\r\n                var tx = entry.x + x;\r\n                var ty = entry.y + y;\r\n\r\n                this.drawGameObject(entry, tx, ty);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles drawing a single Phaser Game Object to this Render Texture using WebGL.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchGameObjectWebGL\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.\r\n     * @param {number} [x] - The x position to draw the Game Object at.\r\n     * @param {number} [y] - The y position to draw the Game Object at.\r\n     */\r\n    batchGameObjectWebGL: function (gameObject, x, y)\r\n    {\r\n        if (x === undefined) { x = gameObject.x; }\r\n        if (y === undefined) { y = gameObject.y; }\r\n\r\n        var prevX = gameObject.x;\r\n        var prevY = gameObject.y;\r\n\r\n        gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);\r\n\r\n        if (gameObject.renderDirect)\r\n        {\r\n            gameObject.renderDirect(this.renderer, gameObject, this.camera);\r\n        }\r\n        else\r\n        {\r\n            gameObject.renderWebGL(this.renderer, gameObject, this.camera);\r\n        }\r\n\r\n        gameObject.setPosition(prevX, prevY);\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles drawing a single Phaser Game Object to this Render Texture using Canvas.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchGameObjectCanvas\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.\r\n     * @param {number} [x] - The x position to draw the Game Object at.\r\n     * @param {number} [y] - The y position to draw the Game Object at.\r\n     */\r\n    batchGameObjectCanvas: function (gameObject, x, y)\r\n    {\r\n        if (x === undefined) { x = gameObject.x; }\r\n        if (y === undefined) { y = gameObject.y; }\r\n\r\n        var prevX = gameObject.x;\r\n        var prevY = gameObject.y;\r\n\r\n        if (this._eraseMode)\r\n        {\r\n            var blendMode = gameObject.blendMode;\r\n\r\n            gameObject.blendMode = BlendModes.ERASE;\r\n        }\r\n\r\n        gameObject.setPosition(x + this.frame.cutX, y + this.frame.cutY);\r\n\r\n        gameObject.renderCanvas(this.renderer, gameObject, this.camera, null);\r\n\r\n        gameObject.setPosition(prevX, prevY);\r\n\r\n        if (this._eraseMode)\r\n        {\r\n            gameObject.blendMode = blendMode;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing of an array of children.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchTextureFrameKey\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     * @param {number} [x=0] - The x position to offset the Game Object by.\r\n     * @param {number} [y=0] - The y position to offset the Game Object by.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.\r\n     */\r\n    batchTextureFrameKey: function (key, frame, x, y, alpha, tint)\r\n    {\r\n        var textureFrame = this.textureManager.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            this.batchTextureFrame(textureFrame, x, y, alpha, tint);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing of a Texture Frame to this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchTextureFrame\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.Textures.Frame} textureFrame - The Texture Frame to draw.\r\n     * @param {number} [x=0] - The x position to draw the Frame at.\r\n     * @param {number} [y=0] - The y position to draw the Frame at.\r\n     * @param {number} [tint] - A tint color to be applied to the frame drawn to the Render Texture.\r\n     */\r\n    batchTextureFrame: function (textureFrame, x, y, alpha, tint)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        x += this.frame.cutX;\r\n        y += this.frame.cutY;\r\n\r\n        var renderTarget = this.renderTarget;\r\n\r\n        if (renderTarget)\r\n        {\r\n            this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);\r\n        }\r\n        else\r\n        {\r\n            var ctx = this.context;\r\n            var cd = textureFrame.canvasData;\r\n            var source = textureFrame.source.image;\r\n\r\n            var matrix = this.camera.matrix;\r\n\r\n            ctx.save();\r\n\r\n            ctx.globalCompositeOperation = (this._eraseMode) ? 'destination-out' : 'source-over';\r\n\r\n            ctx.globalAlpha = alpha;\r\n\r\n            matrix.setToContext(ctx);\r\n\r\n            ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);\r\n\r\n            ctx.restore();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the given area of this Render Texture.\r\n     *\r\n     * The snapshot is taken immediately.\r\n     *\r\n     * To capture the whole Render Texture see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n     *\r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#snapshotArea\r\n     * @since 3.19.0\r\n     *\r\n     * @param {number} x - The x coordinate to grab from.\r\n     * @param {number} y - The y coordinate to grab from.\r\n     * @param {number} width - The width of the area to grab.\r\n     * @param {number} height - The height of the area to grab.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)\r\n    {\r\n        if (this.renderTarget)\r\n        {\r\n            this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, x, y, width, height, type, encoderOptions);\r\n        }\r\n        else\r\n        {\r\n            this.renderer.snapshotCanvas(this.canvas, callback, false, x, y, width, height, type, encoderOptions);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the whole of this Render Texture.\r\n     *\r\n     * The snapshot is taken immediately.\r\n     *\r\n     * To capture just a portion of the Render Texture see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n     *\r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#snapshot\r\n     * @since 3.19.0\r\n     *\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    snapshot: function (callback, type, encoderOptions)\r\n    {\r\n        if (this.renderTarget)\r\n        {\r\n            this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, false, 0, 0, this.width, this.height, type, encoderOptions);\r\n        }\r\n        else\r\n        {\r\n            this.renderer.snapshotCanvas(this.canvas, callback, false, 0, 0, this.width, this.height, type, encoderOptions);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the given pixel from this Render Texture.\r\n     *\r\n     * The snapshot is taken immediately.\r\n     *\r\n     * To capture the whole Render Texture see the `snapshot` method. To capture a specific portion, see `snapshotArea`.\r\n     *\r\n     * Unlike the other two snapshot methods, this one will send your callback a `Color` object containing the color data for\r\n     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n     * using less memory, than the other snapshot methods.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#snapshotPixel\r\n     * @since 3.19.0\r\n     *\r\n     * @param {number} x - The x coordinate of the pixel to get.\r\n     * @param {number} y - The y coordinate of the pixel to get.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    snapshotPixel: function (x, y, callback)\r\n    {\r\n        if (this.renderTarget)\r\n        {\r\n            this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, callback, true, x, y);\r\n        }\r\n        else\r\n        {\r\n            this.renderer.snapshotCanvas(this.canvas, callback, true, x, y);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (!this._saved)\r\n        {\r\n            CanvasPool.remove(this.canvas);\r\n\r\n            if (this.renderTarget)\r\n            {\r\n                this.renderTarget.destroy();\r\n            }\r\n\r\n            this.texture.destroy();\r\n            this.camera.destroy();\r\n\r\n            this.canvas = null;\r\n            this.context = null;\r\n            this.texture = null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = RenderTexture;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.RenderTexture#renderCanvas\r\n * @since 3.2.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.RenderTexture} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar RenderTextureCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = RenderTextureCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar RenderTexture = require('./RenderTexture');\r\n\r\n/**\r\n * Creates a new Render Texture Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#renderTexture\r\n * @since 3.2.0\r\n *\r\n * @param {Phaser.Types.GameObjects.RenderTexture.RenderTextureConfig} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.RenderTexture} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('renderTexture', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var x = GetAdvancedValue(config, 'x', 0);\r\n    var y = GetAdvancedValue(config, 'y', 0);\r\n    var width = GetAdvancedValue(config, 'width', 32);\r\n    var height = GetAdvancedValue(config, 'height', 32);\r\n    var key = GetAdvancedValue(config, 'key', undefined);\r\n    var frame = GetAdvancedValue(config, 'frame', undefined);\r\n\r\n    var renderTexture = new RenderTexture(this.scene, x, y, width, height, key, frame);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, renderTexture, config);\r\n\r\n    return renderTexture;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\nvar RenderTexture = require('./RenderTexture');\r\n\r\n/**\r\n * Creates a new Render Texture Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.\r\n * \r\n * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and\r\n * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic\r\n * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#renderTexture\r\n * @since 3.2.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {number} [width=32] - The width of the Render Texture.\r\n * @param {number} [height=32] - The height of the Render Texture.\r\n * @property {string} [key] - The texture key to make the RenderTexture from.\r\n * @property {string} [frame] - the frame to make the RenderTexture from.\r\n * \r\n * @return {Phaser.GameObjects.RenderTexture} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('renderTexture', function (x, y, width, height, key, frame)\r\n{\r\n    return this.displayList.add(new RenderTexture(this.scene, x, y, width, height, key, frame));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./RenderTextureWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./RenderTextureCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.RenderTexture#renderWebGL\r\n * @since 3.2.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.RenderTexture} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar RenderTextureWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var cameraAlpha = camera.alpha;\r\n\r\n    var renderTarget = src.renderTarget;\r\n    var width = renderTarget.width;\r\n    var height = renderTarget.height;\r\n\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var textureUnit = pipeline.setTexture2D(renderTarget.texture);\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    pipeline.batchTexture(\r\n        src,\r\n        renderTarget.texture,\r\n        width, height,\r\n        src.x, src.y,\r\n        width, height,\r\n        src.scaleX, src.scaleY,\r\n        src.rotation,\r\n        src.flipX, !src.flipY,\r\n        src.scrollFactorX, src.scrollFactorY,\r\n        src.displayOriginX, src.displayOriginY,\r\n        0, 0, width, height,\r\n        getTint(src.tintTopLeft, cameraAlpha * src._alphaTL),\r\n        getTint(src.tintTopRight, cameraAlpha * src._alphaTR),\r\n        getTint(src.tintBottomLeft, cameraAlpha * src._alphaBL),\r\n        getTint(src.tintBottomRight, cameraAlpha * src._alphaBR),\r\n        src.tintFill,\r\n        0, 0,\r\n        camera,\r\n        parentMatrix,\r\n        true,\r\n        textureUnit\r\n    );\r\n\r\n    renderer.resetTextures();\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = RenderTextureWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AnimationState = require('../../animations/AnimationState');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar PIPELINE_CONST = require('../../renderer/webgl/pipelines/const');\r\nvar RopeRender = require('./RopeRender');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Rope Game Object.\r\n *\r\n * The Rope object is WebGL only and does not have a Canvas counterpart.\r\n *\r\n * A Rope is a special kind of Game Object that has a texture that repeats along its entire length.\r\n * Unlike a Sprite, it isn't restricted to using just a quad and can have as many vertices as you define\r\n * when creating it. The vertices can be arranged in a horizontal or vertical strip and have their own\r\n * color and alpha values as well.\r\n *\r\n * A Ropes origin is always 0.5 x 0.5 and cannot be changed.\r\n *\r\n * @class Rope\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @webglOnly\r\n * @since 3.23.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.Texture\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {string} [texture] - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager. If not given, `__DEFAULT` is used.\r\n * @param {(string|number|null)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * @param {(number|Phaser.Types.Math.Vector2Like[])} [points=2] - An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided a simple quad is created. See `setPoints` to set this post-creation.\r\n * @param {boolean} [horizontal=true] - Should the vertices of this Rope be aligned horizontally (`true`), or vertically (`false`)?\r\n * @param {number[]} [colors] - An optional array containing the color data for this Rope. You should provide one color value per pair of vertices.\r\n * @param {number[]} [alphas] - An optional array containing the alpha data for this Rope. You should provide one alpha value per pair of vertices.\r\n */\r\nvar Rope = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.Mask,\r\n        Components.Pipeline,\r\n        Components.Size,\r\n        Components.Texture,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Components.ScrollFactor,\r\n        RopeRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Rope (scene, x, y, texture, frame, points, horizontal, colors, alphas)\r\n    {\r\n        if (texture === undefined) { texture = '__DEFAULT'; }\r\n        if (points === undefined) { points = 2; }\r\n        if (horizontal === undefined) { horizontal = true; }\r\n\r\n        GameObject.call(this, scene, 'Rope');\r\n\r\n        /**\r\n         * The Animation State of this Rope.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#anims\r\n         * @type {Phaser.Animations.AnimationState}\r\n         * @since 3.23.0\r\n         */\r\n        this.anims = new AnimationState(this);\r\n\r\n        /**\r\n         * An array containing the points data for this Rope.\r\n         *\r\n         * Each point should be given as a Vector2Like object (i.e. a Vector2, Geom.Point or object with public x/y properties).\r\n         *\r\n         * The point coordinates are given in local space, where 0 x 0 is the start of the Rope strip.\r\n         *\r\n         * You can modify the contents of this array directly in real-time to create interesting effects.\r\n         * If you do so, be sure to call `setDirty` _after_ modifying this array, so that the vertices data is\r\n         * updated before the next render. Alternatively, you can use the `setPoints` method instead.\r\n         *\r\n         * Should you need to change the _size_ of this array, then you should always use the `setPoints` method.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#points\r\n         * @type {Phaser.Types.Math.Vector2Like[]}\r\n         * @since 3.23.0\r\n         */\r\n        this.points = points;\r\n\r\n        /**\r\n         * An array containing the vertices data for this Rope.\r\n         *\r\n         * This data is calculated automatically in the `updateVertices` method, based on the points provided.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#vertices\r\n         * @type {Float32Array}\r\n         * @since 3.23.0\r\n         */\r\n        this.vertices;\r\n\r\n        /**\r\n         * An array containing the uv data for this Rope.\r\n         *\r\n         * This data is calculated automatically in the `setPoints` method, based on the points provided.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#uv\r\n         * @type {Float32Array}\r\n         * @since 3.23.0\r\n         */\r\n        this.uv;\r\n\r\n        /**\r\n         * An array containing the color data for this Rope.\r\n         *\r\n         * Colors should be given as numeric RGB values, such as 0xff0000.\r\n         * You should provide _two_ color values for every point in the Rope, one for the top and one for the bottom of each quad.\r\n         *\r\n         * You can modify the contents of this array directly in real-time, however, should you need to change the _size_\r\n         * of the array, then you should use the `setColors` method instead.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#colors\r\n         * @type {Uint32Array}\r\n         * @since 3.23.0\r\n         */\r\n        this.colors;\r\n\r\n        /**\r\n         * An array containing the alpha data for this Rope.\r\n         *\r\n         * Alphas should be given as float values, such as 0.5.\r\n         * You should provide _two_ alpha values for every point in the Rope, one for the top and one for the bottom of each quad.\r\n         *\r\n         * You can modify the contents of this array directly in real-time, however, should you need to change the _size_\r\n         * of the array, then you should use the `setAlphas` method instead.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#alphas\r\n         * @type {Float32Array}\r\n         * @since 3.23.0\r\n         */\r\n        this.alphas;\r\n\r\n        /**\r\n         * The tint fill mode.\r\n         *\r\n        * `false` = An additive tint (the default), where vertices colors are blended with the texture.\r\n        * `true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#tintFill\r\n         * @type {boolean}\r\n         * @since 3.23.0\r\n         */\r\n        this.tintFill = (texture === '__DEFAULT') ? true : false;\r\n\r\n        /**\r\n         * If the Rope is marked as `dirty` it will automatically recalculate its vertices\r\n         * the next time it renders. You can also force this by calling `updateVertices`.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#dirty\r\n         * @type {boolean}\r\n         * @since 3.23.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * Are the Rope vertices aligned horizontally, in a strip, or vertically, in a column?\r\n         *\r\n         * This property is set during instantiation and cannot be changed directly.\r\n         * See the `setVertical` and `setHorizontal` methods.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#horizontal\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.23.0\r\n         */\r\n        this.horizontal = horizontal;\r\n\r\n        /**\r\n         * The horizontally flipped state of the Game Object.\r\n         *\r\n         * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n         * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n         * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#_flipX\r\n         * @type {boolean}\r\n         * @default false\r\n         * @private\r\n         * @since 3.23.0\r\n         */\r\n        this._flipX = false;\r\n\r\n        /**\r\n         * The vertically flipped state of the Game Object.\r\n         *\r\n         * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\r\n         * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n         * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#_flipY\r\n         * @type {boolean}\r\n         * @default false\r\n         * @private\r\n         * @since 3.23.0\r\n         */\r\n        this._flipY = false;\r\n\r\n        /**\r\n         * Internal Vector2 used for vertices updates.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#_perp\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.23.0\r\n         */\r\n        this._perp = new Vector2();\r\n\r\n        /**\r\n         * You can optionally choose to render the vertices of this Rope to a Graphics instance.\r\n         *\r\n         * Achieve this by setting the `debugCallback` and the `debugGraphic` properties.\r\n         *\r\n         * You can do this in a single call via the `Rope.setDebug` method, which will use the\r\n         * built-in debug function. You can also set it to your own callback. The callback\r\n         * will be invoked _once per render_ and sent the following parameters:\r\n         *\r\n         * `debugCallback(src, meshLength, verts)`\r\n         *\r\n         * `src` is the Rope instance being debugged.\r\n         * `meshLength` is the number of mesh vertices in total.\r\n         * `verts` is an array of the translated vertex coordinates.\r\n         *\r\n         * To disable rendering, set this property back to `null`.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#debugCallback\r\n         * @type {function}\r\n         * @since 3.23.0\r\n         */\r\n        this.debugCallback = null;\r\n\r\n        /**\r\n         * The Graphics instance that the debug vertices will be drawn to, if `setDebug` has\r\n         * been called.\r\n         *\r\n         * @name Phaser.GameObjects.Rope#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.23.0\r\n         */\r\n        this.debugGraphic = null;\r\n\r\n        this.setTexture(texture, frame);\r\n        this.setPosition(x, y);\r\n        this.setSizeToFrame();\r\n        this.initPipeline(PIPELINE_CONST.ROPE_PIPELINE);\r\n\r\n        if (Array.isArray(points))\r\n        {\r\n            this.resizeArrays(points.length);\r\n        }\r\n\r\n        this.setPoints(points, colors, alphas);\r\n\r\n        this.updateVertices();\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * The Rope update loop.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#preUpdate\r\n     * @protected\r\n     * @since 3.23.0\r\n     *\r\n     * @param {number} time - The current timestamp.\r\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\r\n     */\r\n    preUpdate: function (time, delta)\r\n    {\r\n        var prevFrame = this.anims.currentFrame;\r\n\r\n        this.anims.update(time, delta);\r\n\r\n        if (this.anims.currentFrame !== prevFrame)\r\n        {\r\n            this.updateUVs();\r\n            this.updateVertices();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Start playing the given animation.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#play\r\n     * @since 3.23.0\r\n     *\r\n     * @param {string} key - The string-based key of the animation to play.\r\n     * @param {boolean} [ignoreIfPlaying=false] - If an animation is already playing then ignore this call.\r\n     * @param {number} [startFrame=0] - Optionally start the animation playing from this frame index.\r\n     *\r\n     * @return {this} This Game Object.\r\n     */\r\n    play: function (key, ignoreIfPlaying, startFrame)\r\n    {\r\n        this.anims.play(key, ignoreIfPlaying, startFrame);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Flags this Rope as being dirty. A dirty rope will recalculate all of its vertices data\r\n     * the _next_ time it renders. You should set this rope as dirty if you update the points\r\n     * array directly.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setDirty\r\n     * @since 3.23.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDirty: function ()\r\n    {\r\n        this.dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the alignment of the points in this Rope to be horizontal, in a strip format.\r\n     *\r\n     * Calling this method will reset this Rope. The current points, vertices, colors and alpha\r\n     * values will be reset to thoes values given as parameters.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setHorizontal\r\n     * @since 3.23.0\r\n     *\r\n     * @param {(number|Phaser.Types.Math.Vector2Like[])} [points] - An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided the current points length is used.\r\n     * @param {(number|number[])} [colors] - Either a single color value, or an array of values.\r\n     * @param {(number|number[])} [alphas] - Either a single alpha value, or an array of values.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setHorizontal: function (points, colors, alphas)\r\n    {\r\n        if (points === undefined) { points = this.points.length; }\r\n\r\n        if (this.horizontal)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.horizontal = true;\r\n\r\n        return this.setPoints(points, colors, alphas);\r\n    },\r\n\r\n    /**\r\n     * Sets the alignment of the points in this Rope to be vertical, in a column format.\r\n     *\r\n     * Calling this method will reset this Rope. The current points, vertices, colors and alpha\r\n     * values will be reset to thoes values given as parameters.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setVertical\r\n     * @since 3.23.0\r\n     *\r\n     * @param {(number|Phaser.Types.Math.Vector2Like[])} [points] - An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided the current points length is used.\r\n     * @param {(number|number[])} [colors] - Either a single color value, or an array of values.\r\n     * @param {(number|number[])} [alphas] - Either a single alpha value, or an array of values.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setVertical: function (points, colors, alphas)\r\n    {\r\n        if (points === undefined) { points = this.points.length; }\r\n\r\n        if (!this.horizontal)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.horizontal = false;\r\n\r\n        return this.setPoints(points, colors, alphas);\r\n    },\r\n\r\n    /**\r\n     * Sets the tint fill mode.\r\n     *\r\n     * Mode 0 (`false`) is an additive tint, the default, which blends the vertices colors with the texture.\r\n     * This mode respects the texture alpha.\r\n     *\r\n     * Mode 1 (`true`) is a fill tint. Unlike an additive tint, a fill-tint literally replaces the pixel colors\r\n     * from the texture with those in the tint. You can use this for effects such as making a player flash 'white'\r\n     * if hit by something. This mode respects the texture alpha.\r\n     *\r\n     * See the `setColors` method for details of how to color each of the vertices.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setTintFill\r\n     * @webglOnly\r\n     * @since 3.23.0\r\n     *\r\n     * @param {boolean} [value=false] - Set to `false` for an Additive tint or `true` fill tint with alpha.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setTintFill: function (value)\r\n    {\r\n        if (value === undefined) { value = false; }\r\n\r\n        this.tintFill = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the alpha values used by the Rope during rendering.\r\n     *\r\n     * You can provide the values in a number of ways:\r\n     *\r\n     * 1) One single numeric value: `setAlphas(0.5)` - This will set a single alpha for the whole Rope.\r\n     * 2) Two numeric value: `setAlphas(1, 0.5)` - This will set a 'top' and 'bottom' alpha value across the whole Rope.\r\n     * 3) An array of values: `setAlphas([ 1, 0.5, 0.2 ])`\r\n     *\r\n     * If you provide an array of values and the array has exactly the same number of values as `points` in the Rope, it\r\n     * will use each alpha value per rope segment.\r\n     *\r\n     * If the provided array has a different number of values than `points` then it will use the values in order, from\r\n     * the first Rope segment and on, until it runs out of values. This allows you to control the alpha values at all\r\n     * vertices in the Rope.\r\n     *\r\n     * Note this method is called `setAlphas` (plural) and not `setAlpha`.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setAlphas\r\n     * @since 3.23.0\r\n     *\r\n     * @param {(number|number[])} [alphas] - Either a single alpha value, or an array of values. If nothing is provided alpha is reset to 1.\r\n     * @param {number} [bottomAlpha] - An optional bottom alpha value. See the method description for details.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setAlphas: function (alphas, bottomAlpha)\r\n    {\r\n        var total = this.points.length;\r\n\r\n        if (total < 1)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var currentAlphas = this.alphas;\r\n\r\n        if (alphas === undefined)\r\n        {\r\n            alphas = [ 1 ];\r\n        }\r\n        else if (!Array.isArray(alphas) && bottomAlpha === undefined)\r\n        {\r\n            alphas = [ alphas ];\r\n        }\r\n\r\n        var i;\r\n        var index = 0;\r\n\r\n        if (bottomAlpha !== undefined)\r\n        {\r\n            //  Top / Bottom alpha pair\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                index = i * 2;\r\n\r\n                currentAlphas[index] = alphas;\r\n                currentAlphas[index + 1] = bottomAlpha;\r\n            }\r\n        }\r\n        else if (alphas.length === total)\r\n        {\r\n            //  If there are exactly the same number of alphas as points, we'll combine the alphas\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                index = i * 2;\r\n\r\n                currentAlphas[index] = alphas[i];\r\n                currentAlphas[index + 1] = alphas[i];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var prevAlpha = alphas[0];\r\n\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                index = i * 2;\r\n\r\n                if (alphas.length > index)\r\n                {\r\n                    prevAlpha = alphas[index];\r\n                }\r\n\r\n                currentAlphas[index] = prevAlpha;\r\n\r\n                if (alphas.length > index + 1)\r\n                {\r\n                    prevAlpha = alphas[index + 1];\r\n                }\r\n\r\n                currentAlphas[index + 1] = prevAlpha;\r\n            }\r\n        }\r\n\r\n        return this;\r\n\r\n    },\r\n\r\n    /**\r\n     * Set the color values used by the Rope during rendering.\r\n     *\r\n     * Colors are used to control the level of tint applied across the Rope texture.\r\n     *\r\n     * You can provide the values in a number of ways:\r\n     *\r\n     * * One single numeric value: `setColors(0xff0000)` - This will set a single color tint for the whole Rope.\r\n     * * An array of values: `setColors([ 0xff0000, 0x00ff00, 0x0000ff ])`\r\n     *\r\n     * If you provide an array of values and the array has exactly the same number of values as `points` in the Rope, it\r\n     * will use each color per rope segment.\r\n     *\r\n     * If the provided array has a different number of values than `points` then it will use the values in order, from\r\n     * the first Rope segment and on, until it runs out of values. This allows you to control the color values at all\r\n     * vertices in the Rope.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setColors\r\n     * @since 3.23.0\r\n     *\r\n     * @param {(number|number[])} [colors] - Either a single color value, or an array of values. If nothing is provided color is reset to 0xffffff.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setColors: function (colors)\r\n    {\r\n        var total = this.points.length;\r\n\r\n        if (total < 1)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var currentColors = this.colors;\r\n\r\n        if (colors === undefined)\r\n        {\r\n            colors = [ 0xffffff ];\r\n        }\r\n        else if (!Array.isArray(colors))\r\n        {\r\n            colors = [ colors ];\r\n        }\r\n\r\n        var i;\r\n        var index = 0;\r\n\r\n        if (colors.length === total)\r\n        {\r\n            //  If there are exactly the same number of colors as points, we'll combine the colors\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                index = i * 2;\r\n\r\n                currentColors[index] = colors[i];\r\n                currentColors[index + 1] = colors[i];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var prevColor = colors[0];\r\n\r\n            for (i = 0; i < total; i++)\r\n            {\r\n                index = i * 2;\r\n\r\n                if (colors.length > index)\r\n                {\r\n                    prevColor = colors[index];\r\n                }\r\n\r\n                currentColors[index] = prevColor;\r\n\r\n                if (colors.length > index + 1)\r\n                {\r\n                    prevColor = colors[index + 1];\r\n                }\r\n\r\n                currentColors[index + 1] = prevColor;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the points used by this Rope.\r\n     *\r\n     * The points should be provided as an array of Vector2, or vector2-like objects (i.e. those with public x/y properties).\r\n     *\r\n     * Each point corresponds to one segment of the Rope. The more points in the array, the more segments the rope has.\r\n     *\r\n     * Point coordinates are given in local-space, not world-space, and are directly related to the size of the texture\r\n     * this Rope object is using.\r\n     *\r\n     * For example, a Rope using a 512 px wide texture, split into 4 segments (128px each) would use the following points:\r\n     *\r\n     * ```javascript\r\n     * rope.setPoints([\r\n     *   { x: 0, y: 0 },\r\n     *   { x: 128, y: 0 },\r\n     *   { x: 256, y: 0 },\r\n     *   { x: 384, y: 0 }\r\n     * ]);\r\n     * ```\r\n     *\r\n     * Or, you can provide an integer to do the same thing:\r\n     *\r\n     * ```javascript\r\n     * rope.setPoints(4);\r\n     * ```\r\n     *\r\n     * Which will divide the Rope into 4 equally sized segments based on the frame width.\r\n     *\r\n     * Note that calling this method with a different number of points than the Rope has currently will\r\n     * _reset_ the color and alpha values, unless you provide them as arguments to this method.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setPoints\r\n     * @since 3.23.0\r\n     *\r\n     * @param {(number|Phaser.Types.Math.Vector2Like[])} [points=2] - An array containing the vertices data for this Rope, or a number that indicates how many segments to split the texture frame into. If none is provided a simple quad is created.\r\n     * @param {(number|number[])} [colors] - Either a single color value, or an array of values.\r\n     * @param {(number|number[])} [alphas] - Either a single alpha value, or an array of values.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setPoints: function (points, colors, alphas)\r\n    {\r\n        if (points === undefined) { points = 2; }\r\n\r\n        if (typeof points === 'number')\r\n        {\r\n            //  Generate an array based on the points\r\n            var segments = points;\r\n\r\n            if (segments < 2)\r\n            {\r\n                segments = 2;\r\n            }\r\n\r\n            points = [];\r\n\r\n            var s;\r\n            var frameSegment;\r\n            var offset;\r\n\r\n            if (this.horizontal)\r\n            {\r\n                offset = -(this.frame.halfWidth);\r\n                frameSegment = this.frame.width / (segments - 1);\r\n\r\n                for (s = 0; s < segments; s++)\r\n                {\r\n                    points.push({ x: offset + s * frameSegment, y: 0 });\r\n                }\r\n            }\r\n            else\r\n            {\r\n                offset = -(this.frame.halfHeight);\r\n                frameSegment = this.frame.height / (segments - 1);\r\n\r\n                for (s = 0; s < segments; s++)\r\n                {\r\n                    points.push({ x: 0, y: offset + s * frameSegment });\r\n                }\r\n            }\r\n        }\r\n\r\n        var total = points.length;\r\n        var currentTotal = this.points.length;\r\n\r\n        if (total < 1)\r\n        {\r\n            console.warn('Rope: Not enough points given');\r\n\r\n            return this;\r\n        }\r\n        else if (total === 1)\r\n        {\r\n            points.unshift({ x: 0, y: 0 });\r\n            total++;\r\n        }\r\n\r\n        if (currentTotal !== total)\r\n        {\r\n            this.resizeArrays(total);\r\n        }\r\n\r\n        this.points = points;\r\n\r\n        this.updateUVs();\r\n\r\n        if (colors !== undefined && colors !== null)\r\n        {\r\n            this.setColors(colors);\r\n        }\r\n\r\n        if (alphas !== undefined && alphas !== null)\r\n        {\r\n            this.setAlphas(alphas);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates all of the UVs based on the Rope.points and `flipX` and `flipY` settings.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#updateUVs\r\n     * @since 3.23.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateUVs: function ()\r\n    {\r\n        var currentUVs = this.uv;\r\n        var total = this.points.length;\r\n\r\n        var u0 = this.frame.u0;\r\n        var v0 = this.frame.v0;\r\n        var u1 = this.frame.u1;\r\n        var v1 = this.frame.v1;\r\n\r\n        var partH = (u1 - u0) / (total - 1);\r\n        var partV = (v1 - v0) / (total - 1);\r\n\r\n        for (var i = 0; i < total; i++)\r\n        {\r\n            var index = i * 4;\r\n\r\n            var uv0;\r\n            var uv1;\r\n            var uv2;\r\n            var uv3;\r\n\r\n            if (this.horizontal)\r\n            {\r\n                if (this._flipX)\r\n                {\r\n                    uv0 = u1 - (i * partH);\r\n                    uv2 = u1 - (i * partH);\r\n                }\r\n                else\r\n                {\r\n                    uv0 = u0 + (i * partH);\r\n                    uv2 = u0 + (i * partH);\r\n                }\r\n\r\n                if (this._flipY)\r\n                {\r\n                    uv1 = v1;\r\n                    uv3 = v0;\r\n                }\r\n                else\r\n                {\r\n                    uv1 = v0;\r\n                    uv3 = v1;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (this._flipX)\r\n                {\r\n                    uv0 = u0;\r\n                    uv2 = u1;\r\n                }\r\n                else\r\n                {\r\n                    uv0 = u1;\r\n                    uv2 = u0;\r\n                }\r\n\r\n                if (this._flipY)\r\n                {\r\n                    uv1 = v1 - (i * partV);\r\n                    uv3 = v1 - (i * partV);\r\n                }\r\n                else\r\n                {\r\n                    uv1 = v0 + (i * partV);\r\n                    uv3 = v0 + (i * partV);\r\n                }\r\n            }\r\n\r\n            currentUVs[index + 0] = uv0;\r\n            currentUVs[index + 1] = uv1;\r\n            currentUVs[index + 2] = uv2;\r\n            currentUVs[index + 3] = uv3;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resizes all of the internal arrays: `vertices`, `uv`, `colors` and `alphas` to the new\r\n     * given Rope segment total.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#resizeArrays\r\n     * @since 3.23.0\r\n     *\r\n     * @param {number} newSize - The amount of segments to split the Rope in to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    resizeArrays: function (newSize)\r\n    {\r\n        var colors = this.colors;\r\n        var alphas = this.alphas;\r\n\r\n        this.vertices = new Float32Array(newSize * 4);\r\n        this.uv = new Float32Array(newSize * 4);\r\n\r\n        colors = new Uint32Array(newSize * 2);\r\n        alphas = new Float32Array(newSize * 2);\r\n\r\n        for (var i = 0; i < newSize * 2; i++)\r\n        {\r\n            colors[i] = 0xffffff;\r\n            alphas[i] = 1;\r\n        }\r\n\r\n        this.colors = colors;\r\n        this.alphas = alphas;\r\n\r\n        //  updateVertices during next render\r\n        this.dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates the vertices based on the Rope points.\r\n     *\r\n     * This method is called automatically during rendering if `Rope.dirty` is `true`, which is set\r\n     * by the `setPoints` and `setDirty` methods. You should flag the Rope as being dirty if you modify\r\n     * the Rope points directly.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#updateVertices\r\n     * @since 3.23.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateVertices: function ()\r\n    {\r\n        var perp = this._perp;\r\n        var points = this.points;\r\n        var vertices = this.vertices;\r\n\r\n        var total = points.length;\r\n\r\n        this.dirty = false;\r\n\r\n        if (total < 1)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var nextPoint;\r\n        var lastPoint = points[0];\r\n\r\n        var frameSize = (this.horizontal) ? this.frame.halfHeight : this.frame.halfWidth;\r\n\r\n        for (var i = 0; i < total; i++)\r\n        {\r\n            var point = points[i];\r\n            var index = i * 4;\r\n\r\n            if (i < total - 1)\r\n            {\r\n                nextPoint = points[i + 1];\r\n            }\r\n            else\r\n            {\r\n                nextPoint = point;\r\n            }\r\n\r\n            perp.x = nextPoint.y - lastPoint.y;\r\n            perp.y = -(nextPoint.x - lastPoint.x);\r\n\r\n            var perpLength = perp.length();\r\n\r\n            perp.x /= perpLength;\r\n            perp.y /= perpLength;\r\n\r\n            perp.x *= frameSize;\r\n            perp.y *= frameSize;\r\n\r\n            vertices[index] = point.x + perp.x;\r\n            vertices[index + 1] = point.y + perp.y;\r\n            vertices[index + 2] = point.x - perp.x;\r\n            vertices[index + 3] = point.y - perp.y;\r\n\r\n            lastPoint = point;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method enables rendering of the Rope vertices to the given Graphics instance.\r\n     *\r\n     * If you enable this feature, you **must** call `Graphics.clear()` in your Scene `update`,\r\n     * otherwise the Graphics instance you provide to debug will fill-up with draw calls,\r\n     * eventually crashing the browser. This is not done automatically to allow you to debug\r\n     * draw multiple Rope objects to a single Graphics instance.\r\n     *\r\n     * The Rope class has a built-in debug rendering callback `Rope.renderDebugVerts`, however\r\n     * you can also provide your own callback to be used instead. Do this by setting the `callback` parameter.\r\n     *\r\n     * The callback is invoked _once per render_ and sent the following parameters:\r\n     *\r\n     * `callback(src, meshLength, verts)`\r\n     *\r\n     * `src` is the Rope instance being debugged.\r\n     * `meshLength` is the number of mesh vertices in total.\r\n     * `verts` is an array of the translated vertex coordinates.\r\n     *\r\n     * If using your own callback you do not have to provide a Graphics instance to this method.\r\n     *\r\n     * To disable debug rendering, to either your own callback or the built-in one, call this method\r\n     * with no arguments.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#setDebug\r\n     * @since 3.23.0\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} [graphic] - The Graphic instance to render to if using the built-in callback.\r\n     * @param {function} [callback] - The callback to invoke during debug render. Leave as undefined to use the built-in callback.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setDebug: function (graphic, callback)\r\n    {\r\n        this.debugGraphic = graphic;\r\n\r\n        if (!graphic && !callback)\r\n        {\r\n            this.debugCallback = null;\r\n        }\r\n        else if (!callback)\r\n        {\r\n            this.debugCallback = this.renderDebugVerts;\r\n        }\r\n        else\r\n        {\r\n            this.debugCallback = callback;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * The built-in Rope vertices debug rendering method.\r\n     *\r\n     * See `Rope.setDebug` for more details.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#renderDebugVerts\r\n     * @since 3.23.0\r\n     *\r\n     * @param {Phaser.GameObjects.Rope} src - The Rope object being rendered.\r\n     * @param {number} meshLength - The number of vertices in the mesh.\r\n     * @param {number[]} verts - An array of translated vertex coordinates.\r\n     */\r\n    renderDebugVerts: function (src, meshLength, verts)\r\n    {\r\n        var graphic = src.debugGraphic;\r\n\r\n        var px0 = verts[0];\r\n        var py0 = verts[1];\r\n        var px1 = verts[2];\r\n        var py1 = verts[3];\r\n\r\n        graphic.lineBetween(px0, py0, px1, py1);\r\n\r\n        for (var i = 4; i < meshLength; i += 4)\r\n        {\r\n            var x0 = verts[i + 0];\r\n            var y0 = verts[i + 1];\r\n            var x1 = verts[i + 2];\r\n            var y1 = verts[i + 3];\r\n\r\n            graphic.lineBetween(px0, py0, x0, y0);\r\n            graphic.lineBetween(px1, py1, x1, y1);\r\n            graphic.lineBetween(px1, py1, x0, y0);\r\n            graphic.lineBetween(x0, y0, x1, y1);\r\n\r\n            px0 = x0;\r\n            py0 = y0;\r\n            px1 = x1;\r\n            py1 = y1;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Handles the pre-destroy step for the Rope, which removes the Animation component and typed arrays.\r\n     *\r\n     * @method Phaser.GameObjects.Rope#preDestroy\r\n     * @private\r\n     * @since 3.23.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.anims.destroy();\r\n\r\n        this.anims = undefined;\r\n\r\n        this.points = null;\r\n        this.vertices = null;\r\n        this.uv = null;\r\n        this.colors = null;\r\n        this.alphas = null;\r\n\r\n        this.debugCallback = null;\r\n        this.debugGraphic = null;\r\n    },\r\n\r\n    /**\r\n     * The horizontally flipped state of the Game Object.\r\n     *\r\n     * A Game Object that is flipped horizontally will render inversed on the horizontal axis.\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     *\r\n     * @name Phaser.GameObjects.Rope#flipX\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.23.0\r\n     */\r\n    flipX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._flipX;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._flipX = value;\r\n\r\n            return this.updateUVs();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertically flipped state of the Game Object.\r\n     *\r\n     * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\r\n     * Flipping always takes place from the middle of the texture and does not impact the scale value.\r\n     * If this Game Object has a physics body, it will not change the body. This is a rendering toggle only.\r\n     *\r\n     * @name Phaser.GameObjects.Rope#flipY\r\n     * @type {boolean}\r\n     * @default false\r\n     * @since 3.23.0\r\n     */\r\n    flipY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._flipY;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._flipY = value;\r\n\r\n            return this.updateUVs();\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Rope;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * This is a stub function for Rope.Render. There is no Canvas renderer for Rope objects.\r\n *\r\n * @method Phaser.GameObjects.Rope#renderCanvas\r\n * @since 3.23.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Rope} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */\r\nvar RopeCanvasRenderer = function ()\r\n{\r\n};\r\n\r\nmodule.exports = RopeCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar Rope = require('./Rope');\r\n\r\n/**\r\n * Creates a new Rope Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Rope Game Object and WebGL support have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#rope\r\n * @since 3.23.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Rope} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('rope', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var key = GetAdvancedValue(config, 'key', null);\r\n    var frame = GetAdvancedValue(config, 'frame', null);\r\n    var horizontal = GetAdvancedValue(config, 'horizontal', true);\r\n    var points = GetValue(config, 'points', undefined);\r\n    var colors = GetValue(config, 'colors', undefined);\r\n    var alphas = GetValue(config, 'alphas', undefined);\r\n\r\n    var rope = new Rope(this.scene, 0, 0, key, frame, points, horizontal, colors, alphas);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, rope, config);\r\n\r\n    if (!config.add)\r\n    {\r\n        this.updateList.add(rope);\r\n    }\r\n\r\n    return rope;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Rope = require('./Rope');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Rope Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Rope Game Object and WebGL support have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#rope\r\n * @webglOnly\r\n * @since 3.23.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n * @param {Phaser.Types.Math.Vector2Like[]} [points] - An array containing the vertices data for this Rope. If none is provided a simple quad is created. See `setPoints` to set this post-creation.\r\n * @param {boolean} [horizontal=true] - Should the vertices of this Rope be aligned horizontally (`true`), or vertically (`false`)?\r\n * @param {number[]} [colors] - An optional array containing the color data for this Rope. You should provide one color value per pair of vertices.\r\n * @param {number[]} [alphas] - An optional array containing the alpha data for this Rope. You should provide one alpha value per pair of vertices.\r\n *\r\n * @return {Phaser.GameObjects.Rope} The Game Object that was created.\r\n */\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    GameObjectFactory.register('rope', function (x, y, texture, frame, points, horizontal, colors, alphas)\r\n    {\r\n        return this.displayList.add(new Rope(this.scene, x, y, texture, frame, points, horizontal, colors, alphas));\r\n    });\r\n}\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./RopeWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./RopeCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Rope#renderWebGL\r\n * @since 3.23.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Rope} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar RopeWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n    var vertices = src.vertices;\r\n    var uvs = src.uv;\r\n    var colors = src.colors;\r\n    var alphas = src.alphas;\r\n    var alpha = src.alpha;\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n    var roundPixels = camera.roundPixels;\r\n\r\n    var meshVerticesLength = vertices.length;\r\n    var vertexCount = Math.floor(meshVerticesLength * 0.5);\r\n\r\n    //  Because it's a triangle strip and we don't want lots of degenerate triangles joining things up\r\n    pipeline.flush();\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    var textureUnit = pipeline.setGameObject(src);\r\n\r\n    var vertexViewF32 = pipeline.vertexViewF32;\r\n    var vertexViewU32 = pipeline.vertexViewU32;\r\n\r\n    var vertexOffset = (pipeline.vertexCount * pipeline.currentShader.vertexComponentCount) - 1;\r\n\r\n    var colorIndex = 0;\r\n\r\n    var tintEffect = src.tintFill;\r\n\r\n    if (src.dirty)\r\n    {\r\n        src.updateVertices();\r\n    }\r\n\r\n    var debugCallback = src.debugCallback;\r\n    var debugVerts = [];\r\n\r\n    for (var i = 0; i < meshVerticesLength; i += 2)\r\n    {\r\n        var x = vertices[i + 0];\r\n        var y = vertices[i + 1];\r\n\r\n        var tx = x * calcMatrix.a + y * calcMatrix.c + calcMatrix.e;\r\n        var ty = x * calcMatrix.b + y * calcMatrix.d + calcMatrix.f;\r\n\r\n        if (roundPixels)\r\n        {\r\n            tx = Math.round(tx);\r\n            ty = Math.round(ty);\r\n        }\r\n\r\n        vertexViewF32[++vertexOffset] = tx;\r\n        vertexViewF32[++vertexOffset] = ty;\r\n        vertexViewF32[++vertexOffset] = uvs[i + 0];\r\n        vertexViewF32[++vertexOffset] = uvs[i + 1];\r\n        vertexViewF32[++vertexOffset] = textureUnit;\r\n        vertexViewF32[++vertexOffset] = tintEffect;\r\n        vertexViewU32[++vertexOffset] = getTint(colors[colorIndex], camera.alpha * (alphas[colorIndex] * alpha));\r\n\r\n        colorIndex++;\r\n\r\n        if (debugCallback)\r\n        {\r\n            debugVerts[i + 0] = tx;\r\n            debugVerts[i + 1] = ty;\r\n        }\r\n    }\r\n\r\n    if (debugCallback)\r\n    {\r\n        debugCallback.call(src, src, meshVerticesLength, debugVerts);\r\n    }\r\n\r\n    pipeline.vertexCount += vertexCount;\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = RopeWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Extend = require('../../utils/object/Extend');\r\nvar SetValue = require('../../utils/object/SetValue');\r\nvar ShaderRender = require('./ShaderRender');\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\n\r\n/**\r\n * @classdesc\r\n * A Shader Game Object.\r\n *\r\n * This Game Object allows you to easily add a quad with its own shader into the display list, and manipulate it\r\n * as you would any other Game Object, including scaling, rotating, positioning and adding to Containers. Shaders\r\n * can be masked with either Bitmap or Geometry masks and can also be used as a Bitmap Mask for a Camera or other\r\n * Game Object. They can also be made interactive and used for input events.\r\n *\r\n * It works by taking a reference to a `Phaser.Display.BaseShader` instance, as found in the Shader Cache. These can\r\n * be created dynamically at runtime, or loaded in via the GLSL File Loader:\r\n *\r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.glsl('fire', 'shaders/fire.glsl.js');\r\n * }\r\n *\r\n * function create ()\r\n * {\r\n *     this.add.shader('fire', 400, 300, 512, 512);\r\n * }\r\n * ```\r\n *\r\n * Please see the Phaser 3 Examples GitHub repo for examples of loading and creating shaders dynamically.\r\n *\r\n * Due to the way in which they work, you cannot directly change the alpha or blend mode of a Shader. This should\r\n * be handled via exposed uniforms in the shader code itself.\r\n *\r\n * By default a Shader will be created with a standard set of uniforms. These were added to match those\r\n * found on sites such as ShaderToy or GLSLSandbox, and provide common functionality a shader may need,\r\n * such as the timestamp, resolution or pointer position. You can replace them by specifying your own uniforms\r\n * in the Base Shader.\r\n *\r\n * These Shaders work by halting the current pipeline during rendering, creating a viewport matched to the\r\n * size of this Game Object and then renders a quad using the bound shader. At the end, the pipeline is restored.\r\n *\r\n * Because it blocks the pipeline it means it will interrupt any batching that is currently going on, so you should\r\n * use these Game Objects sparingly. If you need to have a fully batched custom shader, then please look at using\r\n * a custom pipeline instead. However, for background or special masking effects, they are extremely effective.\r\n *\r\n * @class Shader\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @webglOnly\r\n * @since 3.17.0\r\n *\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the Game Object.\r\n * @param {number} [height=128] - The height of the Game Object.\r\n * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n * @param {any} [textureData] - Additional texture data if you want to create shader with none NPOT textures.\r\n */\r\nvar Shader = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.ComputedSize,\r\n        Components.Depth,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.ScrollFactor,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        ShaderRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Shader (scene, key, x, y, width, height, textures, textureData)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = 128; }\r\n        if (height === undefined) { height = 128; }\r\n\r\n        GameObject.call(this, scene, 'Shader');\r\n\r\n        /**\r\n         * This Game Object cannot have a blend mode, so skip all checks.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#blendMode\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this.blendMode = -1;\r\n\r\n        /**\r\n         * The underlying shader object being used.\r\n         * Empty by default and set during a call to the `setShader` method.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#shader\r\n         * @type {Phaser.Display.BaseShader}\r\n         * @since 3.17.0\r\n         */\r\n        this.shader;\r\n\r\n        var renderer = scene.sys.renderer;\r\n\r\n        /**\r\n         * A reference to the current renderer.\r\n         * Shaders only work with the WebGL Renderer.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.17.0\r\n         */\r\n        this.renderer = renderer;\r\n\r\n        /**\r\n         * The WebGL context belonging to the renderer.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @since 3.17.0\r\n         */\r\n        this.gl = renderer.gl;\r\n\r\n        /**\r\n         * Raw byte buffer of vertices this Shader uses.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#vertexData\r\n         * @type {ArrayBuffer}\r\n         * @since 3.17.0\r\n         */\r\n        this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2));\r\n\r\n        /**\r\n         * The WebGL vertex buffer object this shader uses.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#vertexBuffer\r\n         * @type {WebGLBuffer}\r\n         * @since 3.17.0\r\n         */\r\n        this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW);\r\n\r\n        /**\r\n         * The WebGL shader program this shader uses.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#program\r\n         * @type {WebGLProgram}\r\n         * @since 3.17.0\r\n         */\r\n        this.program = null;\r\n\r\n        /**\r\n         * Uint8 view to the vertex raw buffer. Used for uploading vertex buffer resources to the GPU.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#bytes\r\n         * @type {Uint8Array}\r\n         * @since 3.17.0\r\n         */\r\n        this.bytes = new Uint8Array(this.vertexData);\r\n\r\n        /**\r\n         * Float32 view of the array buffer containing the shaders vertices.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#vertexViewF32\r\n         * @type {Float32Array}\r\n         * @since 3.17.0\r\n         */\r\n        this.vertexViewF32 = new Float32Array(this.vertexData);\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_tempMatrix1\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.17.0\r\n         */\r\n        this._tempMatrix1 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_tempMatrix2\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.17.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_tempMatrix3\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.17.0\r\n         */\r\n        this._tempMatrix3 = new TransformMatrix();\r\n\r\n        /**\r\n         * The view matrix the shader uses during rendering.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#viewMatrix\r\n         * @type {Float32Array}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.viewMatrix = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);\r\n\r\n        /**\r\n         * The projection matrix the shader uses during rendering.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#projectionMatrix\r\n         * @type {Float32Array}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.projectionMatrix = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);\r\n\r\n        /**\r\n         * The default uniform mappings. These can be added to (or replaced) by specifying your own uniforms when\r\n         * creating this shader game object. The uniforms are updated automatically during the render step.\r\n         *\r\n         * The defaults are:\r\n         *\r\n         * `resolution` (2f) - Set to the size of this shader.\r\n         * `time` (1f) - The elapsed game time, in seconds.\r\n         * `mouse` (2f) - If a pointer has been bound (with `setPointer`), this uniform contains its position each frame.\r\n         * `date` (4fv) - A vec4 containing the year, month, day and time in seconds.\r\n         * `sampleRate` (1f) - Sound sample rate. 44100 by default.\r\n         * `iChannel0...3` (sampler2D) - Input channels 0 to 3. `null` by default.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#uniforms\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.uniforms = {};\r\n\r\n        /**\r\n         * The pointer bound to this shader, if any.\r\n         * Set via the chainable `setPointer` method, or by modifying this property directly.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#pointer\r\n         * @type {Phaser.Input.Pointer}\r\n         * @since 3.17.0\r\n         */\r\n        this.pointer = null;\r\n\r\n        /**\r\n         * The cached width of the renderer.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_rendererWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._rendererWidth = renderer.width;\r\n\r\n        /**\r\n         * The cached height of the renderer.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_rendererHeight\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._rendererHeight = renderer.height;\r\n\r\n        /**\r\n         * Internal texture count tracker.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_textureCount\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._textureCount = 0;\r\n\r\n        /**\r\n         * A reference to the GL Frame Buffer this Shader is drawing to.\r\n         * This property is only set if you have called `Shader.setRenderToTexture`.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#framebuffer\r\n         * @type {?WebGLFramebuffer}\r\n         * @since 3.19.0\r\n         */\r\n        this.framebuffer = null;\r\n\r\n        /**\r\n         * A reference to the WebGLTexture this Shader is rendering to.\r\n         * This property is only set if you have called `Shader.setRenderToTexture`.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#glTexture\r\n         * @type {?WebGLTexture}\r\n         * @since 3.19.0\r\n         */\r\n        this.glTexture = null;\r\n\r\n        /**\r\n         * A flag that indicates if this Shader has been set to render to a texture instead of the display list.\r\n         *\r\n         * This property is `true` if you have called `Shader.setRenderToTexture`, otherwise it's `false`.\r\n         *\r\n         * A Shader that is rendering to a texture _does not_ appear on the display list.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#renderToTexture\r\n         * @type {boolean}\r\n         * @readonly\r\n         * @since 3.19.0\r\n         */\r\n        this.renderToTexture = false;\r\n\r\n        /**\r\n         * A reference to the Phaser.Textures.Texture that has been stored in the Texture Manager for this Shader.\r\n         *\r\n         * This property is only set if you have called `Shader.setRenderToTexture`, otherwise it is `null`.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.19.0\r\n         */\r\n        this.texture = null;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(width, height);\r\n        this.setOrigin(0.5, 0.5);\r\n        this.setShader(key, textures, textureData);\r\n    },\r\n\r\n    /**\r\n     * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n     * Also checks the Game Object against the given Cameras exclusion list.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#willRender\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to check against this Game Object.\r\n     *\r\n     * @return {boolean} True if the Game Object should be rendered, otherwise false.\r\n     */\r\n    willRender: function (camera)\r\n    {\r\n        if (this.renderToTexture)\r\n        {\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return !(GameObject.RENDER_MASK !== this.renderFlags || (this.cameraFilter !== 0 && (this.cameraFilter & camera.id)));\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Changes this Shader so instead of rendering to the display list it renders to a\r\n     * WebGL Framebuffer and WebGL Texture instead. This allows you to use the output\r\n     * of this shader as an input for another shader, by mapping a sampler2D uniform\r\n     * to it.\r\n     *\r\n     * After calling this method the `Shader.framebuffer` and `Shader.glTexture` properties\r\n     * are populated.\r\n     *\r\n     * Additionally, you can provide a key to this method. Doing so will create a Phaser Texture\r\n     * from this Shader and save it into the Texture Manager, allowing you to then use it for\r\n     * any texture-based Game Object, such as a Sprite or Image:\r\n     *\r\n     * ```javascript\r\n     * var shader = this.add.shader('myShader', x, y, width, height);\r\n     *\r\n     * shader.setRenderToTexture('doodle');\r\n     *\r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     *\r\n     * Note that it stores an active reference to this Shader. That means as this shader updates,\r\n     * so does the texture and any object using it to render with. Also, if you destroy this\r\n     * shader, be sure to clear any objects that may have been using it as a texture too.\r\n     *\r\n     * You can access the Phaser Texture that is created via the `Shader.texture` property.\r\n     *\r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame from a Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setRenderToTexture\r\n     * @since 3.19.0\r\n     *\r\n     * @param {string} [key] - The unique key to store the texture as within the global Texture Manager.\r\n     * @param {boolean} [flipY=false] - Does this texture need vertically flipping before rendering? This should usually be set to `true` if being fed from a buffer.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setRenderToTexture: function (key, flipY)\r\n    {\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        if (!this.renderToTexture)\r\n        {\r\n            var width = this.width;\r\n            var height = this.height;\r\n            var renderer = this.renderer;\r\n\r\n            this.glTexture = renderer.createTextureFromSource(null, width, height, 0);\r\n\r\n            this.glTexture.flipY = flipY;\r\n\r\n            this.framebuffer = renderer.createFramebuffer(width, height, this.glTexture, false);\r\n\r\n            this._rendererWidth = width;\r\n            this._rendererHeight = height;\r\n\r\n            this.renderToTexture = true;\r\n\r\n            this.projOrtho(0, this.width, this.height, 0);\r\n\r\n            if (key)\r\n            {\r\n                this.texture = this.scene.sys.textures.addGLTexture(key, this.glTexture, width, height);\r\n            }\r\n        }\r\n\r\n        //  And now render at least once, so our texture isn't blank on the first update\r\n\r\n        if (this.shader)\r\n        {\r\n            renderer.pipelines.clear();\r\n\r\n            this.load();\r\n            this.flush();\r\n\r\n            renderer.pipelines.rebind();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the fragment and, optionally, the vertex shader source code that this Shader will use.\r\n     * This will immediately delete the active shader program, if set, and then create a new one\r\n     * with the given source. Finally, the shader uniforms are initialized.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setShader\r\n     * @since 3.17.0\r\n     *\r\n     * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n     * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setShader: function (key, textures, textureData)\r\n    {\r\n        if (textures === undefined) { textures = []; }\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            var cache = this.scene.sys.cache.shader;\r\n\r\n            if (!cache.has(key))\r\n            {\r\n                console.warn('Shader missing: ' + key);\r\n                return this;\r\n            }\r\n\r\n            this.shader = cache.get(key);\r\n        }\r\n        else\r\n        {\r\n            this.shader = key;\r\n        }\r\n\r\n        var gl = this.gl;\r\n        var renderer = this.renderer;\r\n\r\n        if (this.program)\r\n        {\r\n            gl.deleteProgram(this.program);\r\n        }\r\n\r\n        var program = renderer.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);\r\n\r\n        //  The default uniforms available within the vertex shader\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uViewMatrix'), false, this.viewMatrix);\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjectionMatrix'), false, this.projectionMatrix);\r\n        gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), this.width, this.height);\r\n\r\n        this.program = program;\r\n\r\n        var d = new Date();\r\n\r\n        //  The default uniforms available within the fragment shader\r\n        var defaultUniforms = {\r\n            resolution: { type: '2f', value: { x: this.width, y: this.height } },\r\n            time: { type: '1f', value: 0 },\r\n            mouse: { type: '2f', value: { x: this.width / 2, y: this.height / 2 } },\r\n            date: { type: '4fv', value: [ d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds() ] },\r\n            sampleRate: { type: '1f', value: 44100.0 },\r\n            iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: true } },\r\n            iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: true } },\r\n            iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: true } },\r\n            iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: true } }\r\n        };\r\n\r\n        if (this.shader.uniforms)\r\n        {\r\n            this.uniforms = Extend(true, {}, this.shader.uniforms, defaultUniforms);\r\n        }\r\n        else\r\n        {\r\n            this.uniforms = defaultUniforms;\r\n        }\r\n\r\n        for (var i = 0; i < 4; i++)\r\n        {\r\n            if (textures[i])\r\n            {\r\n                this.setSampler2D('iChannel' + i, textures[i], i, textureData);\r\n            }\r\n        }\r\n\r\n        this.initUniforms();\r\n\r\n        this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds a Phaser Pointer object to this Shader.\r\n     *\r\n     * The screen position of the pointer will be set in to the shaders `mouse` uniform\r\n     * automatically every frame. Call this method with no arguments to unbind the pointer.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setPointer\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} [pointer] - The Pointer to bind to this shader.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setPointer: function (pointer)\r\n    {\r\n        this.pointer = pointer;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets this shader to use an orthographic projection matrix.\r\n     * This matrix is stored locally in the `projectionMatrix` property,\r\n     * as well as being bound to the `uProjectionMatrix` uniform.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#projOrtho\r\n     * @since 3.17.0\r\n     *\r\n     * @param {number} left - The left value.\r\n     * @param {number} right - The right value.\r\n     * @param {number} bottom - The bottom value.\r\n     * @param {number} top - The top value.\r\n     */\r\n    projOrtho: function (left, right, bottom, top)\r\n    {\r\n        var near = -1000;\r\n        var far = 1000;\r\n\r\n        var leftRight = 1 / (left - right);\r\n        var bottomTop = 1 / (bottom - top);\r\n        var nearFar = 1 / (near - far);\r\n\r\n        var pm = this.projectionMatrix;\r\n\r\n        pm[0] = -2 * leftRight;\r\n        pm[5] = -2 * bottomTop;\r\n        pm[10] = 2 * nearFar;\r\n        pm[12] = (left + right) * leftRight;\r\n        pm[13] = (top + bottom) * bottomTop;\r\n        pm[14] = (far + near) * nearFar;\r\n\r\n        var program = this.program;\r\n\r\n        var gl = this.gl;\r\n        var renderer = this.renderer;\r\n\r\n        renderer.setProgram(program);\r\n\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjectionMatrix'), false, this.projectionMatrix);\r\n\r\n        this._rendererWidth = right;\r\n        this._rendererHeight = bottom;\r\n    },\r\n\r\n    // Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/\r\n    // http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\r\n\r\n    /**\r\n     * Initializes all of the uniforms this shader uses.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#initUniforms\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    initUniforms: function ()\r\n    {\r\n        var gl = this.gl;\r\n        var map = this.renderer.glFuncMap;\r\n        var program = this.program;\r\n\r\n        this._textureCount = 0;\r\n\r\n        for (var key in this.uniforms)\r\n        {\r\n            var uniform = this.uniforms[key];\r\n\r\n            var type = uniform.type;\r\n            var data = map[type];\r\n\r\n            uniform.uniformLocation = gl.getUniformLocation(program, key);\r\n\r\n            if (type !== 'sampler2D')\r\n            {\r\n                uniform.glMatrix = data.matrix;\r\n                uniform.glValueLength = data.length;\r\n                uniform.glFunc = data.func;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets a sampler2D uniform on this shader where the source texture is a WebGLTexture.\r\n     *\r\n     * This allows you to feed the output from one Shader into another:\r\n     *\r\n     * ```javascript\r\n     * let shader1 = this.add.shader(baseShader1, 0, 0, 512, 512).setRenderToTexture();\r\n     * let shader2 = this.add.shader(baseShader2, 0, 0, 512, 512).setRenderToTexture('output');\r\n     *\r\n     * shader1.setSampler2DBuffer('iChannel0', shader2.glTexture, 512, 512);\r\n     * shader2.setSampler2DBuffer('iChannel0', shader1.glTexture, 512, 512);\r\n     * ```\r\n     *\r\n     * In the above code, the result of baseShader1 is fed into Shader2 as the `iChannel0` sampler2D uniform.\r\n     * The result of baseShader2 is then fed back into shader1 again, creating a feedback loop.\r\n     *\r\n     * If you wish to use an image from the Texture Manager as a sampler2D input for this shader,\r\n     * see the `Shader.setSampler2D` method.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setSampler2DBuffer\r\n     * @since 3.19.0\r\n     *\r\n     * @param {string} uniformKey - The key of the sampler2D uniform to be updated, i.e. `iChannel0`.\r\n     * @param {WebGLTexture} texture - A WebGLTexture reference.\r\n     * @param {number} width - The width of the texture.\r\n     * @param {number} height - The height of the texture.\r\n     * @param {number} [textureIndex=0] - The texture index.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setSampler2DBuffer: function (uniformKey, texture, width, height, textureIndex, textureData)\r\n    {\r\n        if (textureIndex === undefined) { textureIndex = 0; }\r\n        if (textureData === undefined) { textureData = {}; }\r\n\r\n        var uniform = this.uniforms[uniformKey];\r\n\r\n        uniform.value = texture;\r\n\r\n        textureData.width = width;\r\n        textureData.height = height;\r\n\r\n        uniform.textureData = textureData;\r\n\r\n        this._textureCount = textureIndex;\r\n\r\n        this.initSampler2D(uniform);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a sampler2D uniform on this shader.\r\n     *\r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     *\r\n     * If you wish to use another Shader as a sampler2D input for this shader, see the `Shader.setSampler2DBuffer` method.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setSampler2D\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} uniformKey - The key of the sampler2D uniform to be updated, i.e. `iChannel0`.\r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {number} [textureIndex=0] - The texture index.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setSampler2D: function (uniformKey, textureKey, textureIndex, textureData)\r\n    {\r\n        if (textureIndex === undefined) { textureIndex = 0; }\r\n\r\n        var textureManager = this.scene.sys.textures;\r\n\r\n        if (textureManager.exists(textureKey))\r\n        {\r\n            var frame = textureManager.getFrame(textureKey);\r\n\r\n            if (frame.glTexture && frame.glTexture.isRenderTexture)\r\n            {\r\n                return this.setSampler2DBuffer(uniformKey, frame.glTexture, frame.width, frame.height, textureIndex, textureData);\r\n            }\r\n\r\n            var uniform = this.uniforms[uniformKey];\r\n            var source = frame.source;\r\n\r\n            uniform.textureKey = textureKey;\r\n            uniform.source = source.image;\r\n            uniform.value = frame.glTexture;\r\n\r\n            if (source.isGLTexture)\r\n            {\r\n                if (!textureData)\r\n                {\r\n                    textureData = {};\r\n                }\r\n\r\n                textureData.width = source.width;\r\n                textureData.height = source.height;\r\n            }\r\n\r\n            if (textureData)\r\n            {\r\n                uniform.textureData = textureData;\r\n            }\r\n\r\n            this._textureCount = textureIndex;\r\n\r\n            this.initSampler2D(uniform);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a property of a uniform already present on this shader.\r\n     *\r\n     * To modify the value of a uniform such as a 1f or 1i use the `value` property directly:\r\n     *\r\n     * ```javascript\r\n     * shader.setUniform('size.value', 16);\r\n     * ```\r\n     *\r\n     * You can use dot notation to access deeper values, for example:\r\n     *\r\n     * ```javascript\r\n     * shader.setUniform('resolution.value.x', 512);\r\n     * ```\r\n     *\r\n     * The change to the uniform will take effect the next time the shader is rendered.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setUniform\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} key - The key of the uniform to modify. Use dots for deep properties, i.e. `resolution.value.x`.\r\n     * @param {any} value - The value to set into the uniform.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setUniform: function (key, value)\r\n    {\r\n        SetValue(this.uniforms, key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the uniform object for the given key, or `null` if the uniform couldn't be found.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#getUniform\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} key - The key of the uniform to return the value for.\r\n     *\r\n     * @return {any} A reference to the uniform object. This is not a copy, so modifying it will update the original object also.\r\n     */\r\n    getUniform: function (key)\r\n    {\r\n        return GetFastValue(this.uniforms, key, null);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel0` sampler2D uniform.\r\n     *\r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setChannel0\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel0: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel0', textureKey, 0, textureData);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel1` sampler2D uniform.\r\n     *\r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setChannel1\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel1: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel1', textureKey, 1, textureData);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel2` sampler2D uniform.\r\n     *\r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setChannel2\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel2: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel2', textureKey, 2, textureData);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel3` sampler2D uniform.\r\n     *\r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setChannel3\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     *\r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel3: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel3', textureKey, 3, textureData);\r\n    },\r\n\r\n    /**\r\n     * Internal method that takes a sampler2D uniform and prepares it for use by setting the\r\n     * gl texture parameters.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#initSampler2D\r\n     * @private\r\n     * @since 3.17.0\r\n     *\r\n     * @param {any} uniform - The sampler2D uniform to process.\r\n     */\r\n    initSampler2D: function (uniform)\r\n    {\r\n        if (!uniform.value)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var gl = this.gl;\r\n\r\n        gl.activeTexture(gl.TEXTURE0 + this._textureCount);\r\n        gl.bindTexture(gl.TEXTURE_2D, uniform.value);\r\n\r\n        //  Extended texture data\r\n\r\n        var data = uniform.textureData;\r\n\r\n        if (data && !uniform.value.isRenderTexture)\r\n        {\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\r\n\r\n            //  mag / minFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST\r\n            //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT\r\n            //  format can be: gl.LUMINANCE or gl.RGBA\r\n\r\n            var magFilter = gl[GetFastValue(data, 'magFilter', 'linear').toUpperCase()];\r\n            var minFilter = gl[GetFastValue(data, 'minFilter', 'linear').toUpperCase()];\r\n            var wrapS = gl[GetFastValue(data, 'wrapS', 'repeat').toUpperCase()];\r\n            var wrapT = gl[GetFastValue(data, 'wrapT', 'repeat').toUpperCase()];\r\n            var format = gl[GetFastValue(data, 'format', 'rgba').toUpperCase()];\r\n\r\n            if (data.repeat)\r\n            {\r\n                wrapS = gl.REPEAT;\r\n                wrapT = gl.REPEAT;\r\n            }\r\n\r\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);\r\n\r\n            if (data.width)\r\n            {\r\n                var width = GetFastValue(data, 'width', 512);\r\n                var height = GetFastValue(data, 'height', 2);\r\n                var border = GetFastValue(data, 'border', 0);\r\n\r\n                //  texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels)\r\n                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);\r\n            }\r\n            else\r\n            {\r\n                //  texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels)\r\n                gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.source);\r\n            }\r\n\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\r\n        }\r\n\r\n        this.renderer.setProgram(this.program);\r\n\r\n        gl.uniform1i(uniform.uniformLocation, this._textureCount);\r\n\r\n        this._textureCount++;\r\n    },\r\n\r\n    /**\r\n     * Synchronizes all of the uniforms this shader uses.\r\n     * Each uniforms gl function is called in turn.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#syncUniforms\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    syncUniforms: function ()\r\n    {\r\n        var gl = this.gl;\r\n\r\n        var uniforms = this.uniforms;\r\n        var uniform;\r\n        var length;\r\n        var glFunc;\r\n        var location;\r\n        var value;\r\n        var textureCount = 0;\r\n\r\n        for (var key in uniforms)\r\n        {\r\n            uniform = uniforms[key];\r\n\r\n            glFunc = uniform.glFunc;\r\n            length = uniform.glValueLength;\r\n            location = uniform.uniformLocation;\r\n            value = uniform.value;\r\n\r\n            if (value === null)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (length === 1)\r\n            {\r\n                if (uniform.glMatrix)\r\n                {\r\n                    glFunc.call(gl, location, uniform.transpose, value);\r\n                }\r\n                else\r\n                {\r\n                    glFunc.call(gl, location, value);\r\n                }\r\n            }\r\n            else if (length === 2)\r\n            {\r\n                glFunc.call(gl, location, value.x, value.y);\r\n            }\r\n            else if (length === 3)\r\n            {\r\n                glFunc.call(gl, location, value.x, value.y, value.z);\r\n            }\r\n            else if (length === 4)\r\n            {\r\n                glFunc.call(gl, location, value.x, value.y, value.z, value.w);\r\n            }\r\n            else if (uniform.type === 'sampler2D')\r\n            {\r\n                gl.activeTexture(gl.TEXTURE0 + textureCount);\r\n\r\n                gl.bindTexture(gl.TEXTURE_2D, value);\r\n\r\n                gl.uniform1i(location, textureCount);\r\n\r\n                textureCount++;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically during render.\r\n     *\r\n     * This method performs matrix ITRS and then stores the resulting value in the `uViewMatrix` uniform.\r\n     * It then sets up the vertex buffer and shader, updates and syncs the uniforms ready\r\n     * for flush to be called.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#load\r\n     * @since 3.17.0\r\n     *\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [matrix2D] - The transform matrix to use during rendering.\r\n     */\r\n    load: function (matrix2D)\r\n    {\r\n        //  ITRS\r\n\r\n        var gl = this.gl;\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var renderer = this.renderer;\r\n        var program = this.program;\r\n        var vm = this.viewMatrix;\r\n\r\n        if (!this.renderToTexture)\r\n        {\r\n            var x = -this._displayOriginX;\r\n            var y = -this._displayOriginY;\r\n\r\n            vm[0] = matrix2D[0];\r\n            vm[1] = matrix2D[1];\r\n            vm[4] = matrix2D[2];\r\n            vm[5] = matrix2D[3];\r\n            vm[8] = matrix2D[4];\r\n            vm[9] = matrix2D[5];\r\n            vm[12] = vm[0] * x + vm[4] * y;\r\n            vm[13] = vm[1] * x + vm[5] * y;\r\n        }\r\n\r\n        //  Update vertex shader uniforms\r\n\r\n        gl.useProgram(program);\r\n\r\n        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uViewMatrix'), false, vm);\r\n        gl.uniform2f(gl.getUniformLocation(program, 'uResolution'), this.width, this.height);\r\n\r\n        //  Update fragment shader uniforms\r\n\r\n        var uniforms = this.uniforms;\r\n        var res = uniforms.resolution;\r\n\r\n        res.value.x = width;\r\n        res.value.y = height;\r\n\r\n        uniforms.time.value = renderer.game.loop.getDuration();\r\n\r\n        var pointer = this.pointer;\r\n\r\n        if (pointer)\r\n        {\r\n            var mouse = uniforms.mouse;\r\n\r\n            var px = pointer.x / width;\r\n            var py = 1 - pointer.y / height;\r\n\r\n            mouse.value.x = px.toFixed(2);\r\n            mouse.value.y = py.toFixed(2);\r\n        }\r\n\r\n        this.syncUniforms();\r\n    },\r\n\r\n    /**\r\n     * Called automatically during render.\r\n     *\r\n     * Sets the active shader, loads the vertex buffer and then draws.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#flush\r\n     * @since 3.17.0\r\n     */\r\n    flush: function ()\r\n    {\r\n        //  Bind\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var program = this.program;\r\n\r\n        var gl = this.gl;\r\n        var vertexBuffer = this.vertexBuffer;\r\n        var renderer = this.renderer;\r\n        var vertexSize = Float32Array.BYTES_PER_ELEMENT * 2;\r\n\r\n        if (this.renderToTexture)\r\n        {\r\n            renderer.setFramebuffer(this.framebuffer);\r\n\r\n            gl.clearColor(0, 0, 0, 0);\r\n\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n\r\n        var location = gl.getAttribLocation(program, 'inPosition');\r\n\r\n        if (location !== -1)\r\n        {\r\n            gl.enableVertexAttribArray(location);\r\n\r\n            gl.vertexAttribPointer(location, 2, gl.FLOAT, false, vertexSize, 0);\r\n        }\r\n\r\n        //  Draw\r\n\r\n        var vf = this.vertexViewF32;\r\n\r\n        vf[3] = height;\r\n        vf[4] = width;\r\n        vf[5] = height;\r\n        vf[8] = width;\r\n        vf[9] = height;\r\n        vf[10] = width;\r\n\r\n        //  Flush\r\n\r\n        var vertexCount = 6;\r\n\r\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));\r\n\r\n        gl.drawArrays(gl.TRIANGLES, 0, vertexCount);\r\n\r\n        if (this.renderToTexture)\r\n        {\r\n            renderer.setFramebuffer(null, false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass a Shader to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setAlpha\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    setAlpha: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass a Shader to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setBlendMode\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    setBlendMode: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#preDestroy\r\n     * @protected\r\n     * @since 3.17.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        var gl = this.gl;\r\n\r\n        gl.deleteProgram(this.program);\r\n        gl.deleteBuffer(this.vertexBuffer);\r\n\r\n        if (this.renderToTexture)\r\n        {\r\n            this.renderer.deleteFramebuffer(this.framebuffer);\r\n\r\n            this.texture.destroy();\r\n\r\n            this.framebuffer = null;\r\n            this.glTexture = null;\r\n            this.texture = null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Shader;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * This is a stub function for Shader.Render. There is no Canvas renderer for Shader objects.\r\n *\r\n * @method Phaser.GameObjects.Shader#renderCanvas\r\n * @since 3.17.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Shader} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n */\r\nvar ShaderCanvasRenderer = function ()\r\n{\r\n};\r\n\r\nmodule.exports = ShaderCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar Shader = require('./Shader');\r\n\r\n/**\r\n * Creates a new Shader Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Shader Game Object and WebGL support have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#shader\r\n * @since 3.17.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Shader} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('shader', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var key = GetAdvancedValue(config, 'key', null);\r\n    var x = GetAdvancedValue(config, 'x', 0);\r\n    var y = GetAdvancedValue(config, 'y', 0);\r\n    var width = GetAdvancedValue(config, 'width', 128);\r\n    var height = GetAdvancedValue(config, 'height', 128);\r\n\r\n    var shader = new Shader(this.scene, key, x, y, width, height);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, shader, config);\r\n\r\n    return shader;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Shader = require('./Shader');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Shader Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Shader Game Object and WebGL support have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#shader\r\n * @webglOnly\r\n * @since 3.17.0\r\n *\r\n * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the Game Object.\r\n * @param {number} [height=128] - The height of the Game Object.\r\n * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n * @param {object} [textureData] - Optional additional texture data.\r\n *\r\n * @return {Phaser.GameObjects.Shader} The Game Object that was created.\r\n */\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    GameObjectFactory.register('shader', function (key, x, y, width, height, textures, textureData)\r\n    {\r\n        return this.displayList.add(new Shader(this.scene, key, x, y, width, height, textures, textureData));\r\n    });\r\n}\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./ShaderWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./ShaderCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../GetCalcMatrix');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Shader#renderWebGL\r\n * @since 3.17.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Shader} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ShaderWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (!src.shader)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.pipelines.clear();\r\n\r\n    if (src.renderToTexture)\r\n    {\r\n        src.load();\r\n        src.flush();\r\n    }\r\n    else\r\n    {\r\n        var calcMatrix = GetCalcMatrix(src, camera, parentMatrix).calc;\r\n\r\n        //  Renderer size changed?\r\n        if (renderer.width !== src._rendererWidth || renderer.height !== src._rendererHeight)\r\n        {\r\n            src.projOrtho(0, renderer.width, renderer.height, 0);\r\n        }\r\n\r\n        src.load(calcMatrix.matrix);\r\n        src.flush();\r\n    }\r\n\r\n    renderer.pipelines.rebind();\r\n};\r\n\r\nmodule.exports = ShaderWebGLRenderer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Utils = require('../../renderer/webgl/Utils');\n\n/**\n * Renders a filled path for the given Shape.\n *\n * @method Phaser.GameObjects.Shape#FillPathWebGL\n * @since 3.13.0\n * @private\n *\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The WebGL Pipeline used to render this Shape.\n * @param {Phaser.GameObjects.Components.TransformMatrix} calcMatrix - The transform matrix used to get the position values.\n * @param {Phaser.GameObjects.Shape} src - The Game Object shape being rendered in this call.\n * @param {number} alpha - The base alpha value.\n * @param {number} dx - The source displayOriginX.\n * @param {number} dy - The source displayOriginY.\n */\nvar FillPathWebGL = function (pipeline, calcMatrix, src, alpha, dx, dy)\n{\n    var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);\n\n    var path = src.pathData;\n    var pathIndexes = src.pathIndexes;\n\n    for (var i = 0; i < pathIndexes.length; i += 3)\n    {\n        var p0 = pathIndexes[i] * 2;\n        var p1 = pathIndexes[i + 1] * 2;\n        var p2 = pathIndexes[i + 2] * 2;\n\n        var x0 = path[p0 + 0] - dx;\n        var y0 = path[p0 + 1] - dy;\n        var x1 = path[p1 + 0] - dx;\n        var y1 = path[p1 + 1] - dy;\n        var x2 = path[p2 + 0] - dx;\n        var y2 = path[p2 + 1] - dy;\n\n        var tx0 = calcMatrix.getX(x0, y0);\n        var ty0 = calcMatrix.getY(x0, y0);\n\n        var tx1 = calcMatrix.getX(x1, y1);\n        var ty1 = calcMatrix.getY(x1, y1);\n\n        var tx2 = calcMatrix.getX(x2, y2);\n        var ty2 = calcMatrix.getY(x2, y2);\n\n        pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);\n    }\n};\n\nmodule.exports = FillPathWebGL;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sets the fillStyle on the target context based on the given Shape.\r\n *\r\n * @method Phaser.GameObjects.Shape#FillStyleCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {CanvasRenderingContext2D} ctx - The context to set the fill style on.\r\n * @param {Phaser.GameObjects.Shape} src - The Game Object to set the fill style from.\r\n * @param {number} [altColor] - An alternative color to render with.\r\n * @param {number} [altAlpha] - An alternative alpha to render with.\r\n */\r\nvar FillStyleCanvas = function (ctx, src, altColor, altAlpha)\r\n{\r\n    var fillColor = (altColor) ? altColor : src.fillColor;\r\n    var fillAlpha = (altAlpha) ? altAlpha : src.fillAlpha;\r\n\r\n    var red = ((fillColor & 0xFF0000) >>> 16);\r\n    var green = ((fillColor & 0xFF00) >>> 8);\r\n    var blue = (fillColor & 0xFF);\r\n\r\n    ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';\r\n};\r\n\r\nmodule.exports = FillStyleCanvas;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Sets the strokeStyle and lineWidth on the target context based on the given Shape.\r\n *\r\n * @method Phaser.GameObjects.Shape#LineStyleCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {CanvasRenderingContext2D} ctx - The context to set the stroke style on.\r\n * @param {Phaser.GameObjects.Shape} src - The Game Object to set the stroke style from.\r\n * @param {number} [altColor] - An alternative color to render with.\r\n * @param {number} [altAlpha] - An alternative alpha to render with.\r\n */\r\nvar LineStyleCanvas = function (ctx, src, altColor, altAlpha)\r\n{\r\n    var strokeColor = (altColor) ? altColor : src.strokeColor;\r\n    var strokeAlpha = (altAlpha) ? altAlpha : src.strokeAlpha;\r\n\r\n    var red = ((strokeColor & 0xFF0000) >>> 16);\r\n    var green = ((strokeColor & 0xFF00) >>> 8);\r\n    var blue = (strokeColor & 0xFF);\r\n\r\n    ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + strokeAlpha + ')';\r\n    ctx.lineWidth = src.lineWidth;\r\n};\r\n\r\nmodule.exports = LineStyleCanvas;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar Line = require('../../geom/line/Line');\r\n\r\n/**\r\n * @classdesc\r\n * The Shape Game Object is a base class for the various different shapes, such as the Arc, Star or Polygon.\r\n * You cannot add a Shape directly to your Scene, it is meant as a base for your own custom Shape classes.\r\n *\r\n * @class Shape\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @extends Phaser.GameObjects.Components.AlphaSingle\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {string} [type] - The internal type of the Shape.\r\n * @param {any} [data] - The data of the source shape geometry, if any.\r\n */\r\nvar Shape = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.AlphaSingle,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Transform,\r\n        Components.Visible\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Shape (scene, type, data)\r\n    {\r\n        if (type === undefined) { type = 'Shape'; }\r\n\r\n        GameObject.call(this, scene, type);\r\n\r\n        /**\r\n         * The source Shape data. Typically a geometry object.\r\n         * You should not manipulate this directly.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#geom\r\n         * @type {any}\r\n         * @readonly\r\n         * @since 3.13.0\r\n         */\r\n        this.geom = data;\r\n\r\n        /**\r\n         * Holds the polygon path data for filled rendering.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#pathData\r\n         * @type {number[]}\r\n         * @readonly\r\n         * @since 3.13.0\r\n         */\r\n        this.pathData = [];\r\n\r\n        /**\r\n         * Holds the earcut polygon path index data for filled rendering.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#pathIndexes\r\n         * @type {number[]}\r\n         * @readonly\r\n         * @since 3.13.0\r\n         */\r\n        this.pathIndexes = [];\r\n\r\n        /**\r\n         * The fill color used by this Shape.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#fillColor\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillColor = 0xffffff;\r\n\r\n        /**\r\n         * The fill alpha value used by this Shape.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#fillAlpha\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillAlpha = 1;\r\n\r\n        /**\r\n         * The stroke color used by this Shape.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#strokeColor\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.strokeColor = 0xffffff;\r\n\r\n        /**\r\n         * The stroke alpha value used by this Shape.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#strokeAlpha\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.strokeAlpha = 1;\r\n\r\n        /**\r\n         * The stroke line width used by this Shape.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#lineWidth\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.lineWidth = 1;\r\n\r\n        /**\r\n         * Controls if this Shape is filled or not.\r\n         * Note that some Shapes do not support being filled (such as Line shapes)\r\n         *\r\n         * @name Phaser.GameObjects.Shape#isFilled\r\n         * @type {boolean}\r\n         * @since 3.13.0\r\n         */\r\n        this.isFilled = false;\r\n\r\n        /**\r\n         * Controls if this Shape is stroked or not.\r\n         * Note that some Shapes do not support being stroked (such as Iso Box shapes)\r\n         *\r\n         * @name Phaser.GameObjects.Shape#isStroked\r\n         * @type {boolean}\r\n         * @since 3.13.0\r\n         */\r\n        this.isStroked = false;\r\n\r\n        /**\r\n         * Controls if this Shape path is closed during rendering when stroked.\r\n         * Note that some Shapes are always closed when stroked (such as Ellipse shapes)\r\n         *\r\n         * @name Phaser.GameObjects.Shape#closePath\r\n         * @type {boolean}\r\n         * @since 3.13.0\r\n         */\r\n        this.closePath = true;\r\n\r\n        /**\r\n         * Private internal value.\r\n         * A Line used when parsing internal path data to avoid constant object re-creation.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#_tempLine\r\n         * @type {Phaser.Geom.Line}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._tempLine = new Line();\r\n\r\n        /**\r\n         * The native (un-scaled) width of this Game Object.\r\n         *\r\n         * Changing this value will not change the size that the Game Object is rendered in-game.\r\n         * For that you need to either set the scale of the Game Object (`setScale`) or use\r\n         * the `displayWidth` property.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#width\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.width = 0;\r\n\r\n        /**\r\n         * The native (un-scaled) height of this Game Object.\r\n         *\r\n         * Changing this value will not change the size that the Game Object is rendered in-game.\r\n         * For that you need to either set the scale of the Game Object (`setScale`) or use\r\n         * the `displayHeight` property.\r\n         *\r\n         * @name Phaser.GameObjects.Shape#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = 0;\r\n\r\n        this.initPipeline();\r\n    },\r\n\r\n    /**\r\n     * Sets the fill color and alpha for this Shape.\r\n     *\r\n     * If you wish for the Shape to not be filled then call this method with no arguments, or just set `isFilled` to `false`.\r\n     *\r\n     * Note that some Shapes do not support fill colors, such as the Line shape.\r\n     *\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Shape#setFillStyle\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} [color] - The color used to fill this shape. If not provided the Shape will not be filled.\r\n     * @param {number} [alpha=1] - The alpha value used when filling this shape, if a fill color is given.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFillStyle: function (color, alpha)\r\n    {\r\n        if (alpha === undefined) { alpha = 1; }\r\n\r\n        if (color === undefined)\r\n        {\r\n            this.isFilled = false;\r\n        }\r\n        else\r\n        {\r\n            this.fillColor = color;\r\n            this.fillAlpha = alpha;\r\n            this.isFilled = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the stroke color and alpha for this Shape.\r\n     *\r\n     * If you wish for the Shape to not be stroked then call this method with no arguments, or just set `isStroked` to `false`.\r\n     *\r\n     * Note that some Shapes do not support being stroked, such as the Iso Box shape.\r\n     *\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Shape#setStrokeStyle\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} [lineWidth] - The width of line to stroke with. If not provided or undefined the Shape will not be stroked.\r\n     * @param {number} [color] - The color used to stroke this shape. If not provided the Shape will not be stroked.\r\n     * @param {number} [alpha=1] - The alpha value used when stroking this shape, if a stroke color is given.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setStrokeStyle: function (lineWidth, color, alpha)\r\n    {\r\n        if (alpha === undefined) { alpha = 1; }\r\n\r\n        if (lineWidth === undefined)\r\n        {\r\n            this.isStroked = false;\r\n        }\r\n        else\r\n        {\r\n            this.lineWidth = lineWidth;\r\n            this.strokeColor = color;\r\n            this.strokeAlpha = alpha;\r\n            this.isStroked = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets if this Shape path is closed during rendering when stroked.\r\n     * Note that some Shapes are always closed when stroked (such as Ellipse shapes)\r\n     *\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Shape#setClosePath\r\n     * @since 3.13.0\r\n     *\r\n     * @param {boolean} value - Set to `true` if the Shape should be closed when stroked, otherwise `false`.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setClosePath: function (value)\r\n    {\r\n        this.closePath = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the internal size of this Game Object, as used for frame or physics body creation.\r\n     *\r\n     * This will not change the size that the Game Object is rendered in-game.\r\n     * For that you need to either set the scale of the Game Object (`setScale`) or call the\r\n     * `setDisplaySize` method, which is the same thing as changing the scale but allows you\r\n     * to do so by giving pixel values.\r\n     *\r\n     * If you have enabled this Game Object for input, changing the size will _not_ change the\r\n     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.\r\n     *\r\n     * @method Phaser.GameObjects.Shape#setSize\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the display size of this Shape.\r\n     *\r\n     * Calling this will adjust the scale.\r\n     *\r\n     * @method Phaser.GameObjects.Shape#setDisplaySize\r\n     * @since 3.53.0\r\n     *\r\n     * @param {number} width - The display width of this Shape.\r\n     * @param {number} height - The display height of this Shape.\r\n     *\r\n     * @return {this} This Shape instance.\r\n     */\r\n    setDisplaySize: function (width, height)\r\n    {\r\n        this.displayWidth = width;\r\n        this.displayHeight = height;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Shape#preDestroy\r\n     * @protected\r\n     * @since 3.13.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.geom = null;\r\n        this._tempLine = null;\r\n        this.pathData = [];\r\n        this.pathIndexes = [];\r\n    },\r\n\r\n    /**\r\n     * The displayed width of this Game Object.\r\n     *\r\n     * This value takes into account the scale factor.\r\n     *\r\n     * Setting this value will adjust the Game Object's scale property.\r\n     *\r\n     * @name Phaser.GameObjects.Shape#displayWidth\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\r\n    displayWidth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.scaleX * this.width;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleX = value / this.width;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The displayed height of this Game Object.\r\n     *\r\n     * This value takes into account the scale factor.\r\n     *\r\n     * Setting this value will adjust the Game Object's scale property.\r\n     *\r\n     * @name Phaser.GameObjects.Shape#displayHeight\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\r\n    displayHeight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.scaleY * this.height;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.scaleY = value / this.height;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Shape;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders a stroke outline around the given Shape.\r\n *\r\n * @method Phaser.GameObjects.Shape#StrokePathWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The WebGL Pipeline used to render this Shape.\r\n * @param {Phaser.GameObjects.Shape} src - The Game Object shape being rendered in this call.\r\n * @param {number} alpha - The base alpha value.\r\n * @param {number} dx - The source displayOriginX.\r\n * @param {number} dy - The source displayOriginY.\r\n */\r\nvar StrokePathWebGL = function (pipeline, src, alpha, dx, dy)\r\n{\r\n    var strokeTint = pipeline.strokeTint;\r\n    var strokeTintColor = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);\r\n\r\n    strokeTint.TL = strokeTintColor;\r\n    strokeTint.TR = strokeTintColor;\r\n    strokeTint.BL = strokeTintColor;\r\n    strokeTint.BR = strokeTintColor;\r\n\r\n    var path = src.pathData;\r\n    var pathLength = path.length - 1;\r\n    var lineWidth = src.lineWidth;\r\n    var halfLineWidth = lineWidth / 2;\r\n\r\n    var px1 = path[0] - dx;\r\n    var py1 = path[1] - dy;\r\n\r\n    if (!src.closePath)\r\n    {\r\n        pathLength -= 2;\r\n    }\r\n\r\n    for (var i = 2; i < pathLength; i += 2)\r\n    {\r\n        var px2 = path[i] - dx;\r\n        var py2 = path[i + 1] - dy;\r\n\r\n        pipeline.batchLine(\r\n            px1,\r\n            py1,\r\n            px2,\r\n            py2,\r\n            halfLineWidth,\r\n            halfLineWidth,\r\n            lineWidth,\r\n            i - 2,\r\n            (src.closePath) ? (i === pathLength - 1) : false\r\n        );\r\n\r\n        px1 = px2;\r\n        py1 = py2;\r\n    }\r\n};\r\n\r\nmodule.exports = StrokePathWebGL;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar ArcRender = require('./ArcRender');\r\nvar Class = require('../../../utils/Class');\r\nvar DegToRad = require('../../../math/DegToRad');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar GeomCircle = require('../../../geom/circle/Circle');\r\nvar MATH_CONST = require('../../../math/const');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The Arc Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * When it renders it displays an arc shape. You can control the start and end angles of the arc,\r\n * as well as if the angles are winding clockwise or anti-clockwise. With the default settings\r\n * it renders as a complete circle. By changing the angles you can create other arc shapes,\r\n * such as half-circles.\r\n * \r\n * Arcs also have an `iterations` property and corresponding `setIterations` method. This allows\r\n * you to control how smooth the shape renders in WebGL, by controlling the number of iterations\r\n * that take place during construction.\r\n *\r\n * @class Arc\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [radius=128] - The radius of the arc.\r\n * @param {number} [startAngle=0] - The start angle of the arc, in degrees.\r\n * @param {number} [endAngle=360] - The end angle of the arc, in degrees.\r\n * @param {boolean} [anticlockwise=false] - The winding order of the start and end angles.\r\n * @param {number} [fillColor] - The color the arc will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the arc will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Arc = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        ArcRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Arc (scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (radius === undefined) { radius = 128; }\r\n        if (startAngle === undefined) { startAngle = 0; }\r\n        if (endAngle === undefined) { endAngle = 360; }\r\n        if (anticlockwise === undefined) { anticlockwise = false; }\r\n\r\n        Shape.call(this, scene, 'Arc', new GeomCircle(0, 0, radius));\r\n\r\n        /**\r\n         * Private internal value. Holds the start angle in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Arc#_startAngle\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._startAngle = startAngle;\r\n\r\n        /**\r\n         * Private internal value. Holds the end angle in degrees.\r\n         *\r\n         * @name Phaser.GameObjects.Arc#_endAngle\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._endAngle = endAngle;\r\n\r\n        /**\r\n         * Private internal value. Holds the winding order of the start and end angles.\r\n         *\r\n         * @name Phaser.GameObjects.Arc#_anticlockwise\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._anticlockwise = anticlockwise;\r\n\r\n        /**\r\n         * Private internal value. Holds the number of iterations used when drawing the arc.\r\n         *\r\n         * @name Phaser.GameObjects.Arc#_iterations\r\n         * @type {number}\r\n         * @default 0.01\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._iterations = 0.01;\r\n\r\n        this.setPosition(x, y);\r\n\r\n        var diameter = this.geom.radius * 2;\r\n        this.setSize(diameter, diameter);\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * The number of iterations used when drawing the arc.\r\n     * Increase this value for smoother arcs, at the cost of more polygons being rendered.\r\n     * Modify this value by small amounts, such as 0.01.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#iterations\r\n     * @type {number}\r\n     * @default 0.01\r\n     * @since 3.13.0\r\n     */\r\n    iterations: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._iterations;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._iterations = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The radius of the arc.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#radius\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\r\n    radius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.geom.radius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.geom.radius = value;\r\n\r\n            var diameter = value * 2;\r\n            this.setSize(diameter, diameter);\r\n            this.updateDisplayOrigin();\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The start angle of the arc, in degrees.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#startAngle\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\r\n    startAngle: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._startAngle;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._startAngle = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The end angle of the arc, in degrees.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#endAngle\r\n     * @type {number}\r\n     * @since 3.13.0\r\n     */\r\n    endAngle: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._endAngle;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._endAngle = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The winding order of the start and end angles.\r\n     *\r\n     * @name Phaser.GameObjects.Arc#anticlockwise\r\n     * @type {boolean}\r\n     * @since 3.13.0\r\n     */\r\n    anticlockwise: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._anticlockwise;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._anticlockwise = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the radius of the arc.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#setRadius\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the radius to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setRadius: function (value)\r\n    {\r\n        this.radius = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the number of iterations used when drawing the arc.\r\n     * Increase this value for smoother arcs, at the cost of more polygons being rendered.\r\n     * Modify this value by small amounts, such as 0.01.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#setIterations\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the iterations to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setIterations: function (value)\r\n    {\r\n        if (value === undefined) { value = 0.01; }\r\n\r\n        this.iterations = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the starting angle of the arc, in degrees.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#setStartAngle\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the starting angle to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setStartAngle: function (angle, anticlockwise)\r\n    {\r\n        this._startAngle = angle;\r\n\r\n        if (anticlockwise !== undefined)\r\n        {\r\n            this._anticlockwise = anticlockwise;\r\n        }\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the ending angle of the arc, in degrees.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#setEndAngle\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the ending angle to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setEndAngle: function (angle, anticlockwise)\r\n    {\r\n        this._endAngle = angle;\r\n\r\n        if (anticlockwise !== undefined)\r\n        {\r\n            this._anticlockwise = anticlockwise;\r\n        }\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Arc#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var step = this._iterations;\r\n        var iteration = step;\r\n\r\n        var radius = this.geom.radius;\r\n        var startAngle = DegToRad(this._startAngle);\r\n        var endAngle = DegToRad(this._endAngle);\r\n        var anticlockwise = this._anticlockwise;\r\n\r\n        var x = radius;\r\n        var y = radius;\r\n\r\n        endAngle -= startAngle;\r\n\r\n        if (anticlockwise)\r\n        {\r\n            if (endAngle < -MATH_CONST.PI2)\r\n            {\r\n                endAngle = -MATH_CONST.PI2;\r\n            }\r\n            else if (endAngle > 0)\r\n            {\r\n                endAngle = -MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;\r\n            }\r\n        }\r\n        else if (endAngle > MATH_CONST.PI2)\r\n        {\r\n            endAngle = MATH_CONST.PI2;\r\n        }\r\n        else if (endAngle < 0)\r\n        {\r\n            endAngle = MATH_CONST.PI2 + endAngle % MATH_CONST.PI2;\r\n        }\r\n\r\n        var path = [ x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius ];\r\n\r\n        var ta;\r\n\r\n        while (iteration < 1)\r\n        {\r\n            ta = endAngle * iteration + startAngle;\r\n\r\n            path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);\r\n\r\n            iteration += step;\r\n        }\r\n\r\n        ta = endAngle + startAngle;\r\n\r\n        path.push(x + Math.cos(ta) * radius, y + Math.sin(ta) * radius);\r\n\r\n        path.push(x + Math.cos(startAngle) * radius, y + Math.sin(startAngle) * radius);\r\n\r\n        this.pathIndexes = Earcut(path);\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Arc;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar DegToRad = require('../../../math/DegToRad');\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Arc#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Arc} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ArcCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var radius = src.radius;\r\n\r\n        ctx.beginPath();\r\n\r\n        ctx.arc(\r\n            (radius) - src.originX * (radius * 2),\r\n            (radius) - src.originY * (radius * 2),\r\n            radius,\r\n            DegToRad(src._startAngle),\r\n            DegToRad(src._endAngle),\r\n            src.anticlockwise\r\n        );\r\n\r\n        if (src.closePath)\r\n        {\r\n            ctx.closePath();\r\n        }\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = ArcCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Arc = require('./Arc');\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Arc Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Arc Game Object has been built into Phaser.\r\n * \r\n * The Arc Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * When it renders it displays an arc shape. You can control the start and end angles of the arc,\r\n * as well as if the angles are winding clockwise or anti-clockwise. With the default settings\r\n * it renders as a complete circle. By changing the angles you can create other arc shapes,\r\n * such as half-circles.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#arc\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [radius=128] - The radius of the arc.\r\n * @param {number} [startAngle=0] - The start angle of the arc, in degrees.\r\n * @param {number} [endAngle=360] - The end angle of the arc, in degrees.\r\n * @param {boolean} [anticlockwise=false] - The winding order of the start and end angles.\r\n * @param {number} [fillColor] - The color the arc will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the arc will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Arc} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('arc', function (x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Arc(this.scene, x, y, radius, startAngle, endAngle, anticlockwise, fillColor, fillAlpha));\r\n});\r\n\r\n/**\r\n * Creates a new Circle Shape Game Object and adds it to the Scene.\r\n * \r\n * A Circle is an Arc with no defined start and end angle, making it render as a complete circle.\r\n *\r\n * Note: This method will only be available if the Arc Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#circle\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [radius=128] - The radius of the circle.\r\n * @param {number} [fillColor] - The color the circle will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the circle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Arc} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('circle', function (x, y, radius, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Arc(this.scene, x, y, radius, 0, 360, false, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./ArcWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./ArcCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar FillPathWebGL = require('../FillPathWebGL');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Arc#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Arc} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar ArcWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = ArcWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar CurveRender = require('./CurveRender');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar Rectangle = require('../../../geom/rectangle/Rectangle');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The Curve Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * To render a Curve Shape you must first create a `Phaser.Curves.Curve` object, then pass it to\r\n * the Curve Shape in the constructor.\r\n * \r\n * The Curve shape also has a `smoothness` property and corresponding `setSmoothness` method.\r\n * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations\r\n * that take place during construction. Increase and decrease the default value for smoother, or more\r\n * jagged, shapes.\r\n *\r\n * @class Curve\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {Phaser.Curves.Curve} [curve] - The Curve object to use to create the Shape.\r\n * @param {number} [fillColor] - The color the curve will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the curve will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Curve = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        CurveRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Curve (scene, x, y, curve, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        Shape.call(this, scene, 'Curve', curve);\r\n\r\n        /**\r\n         * Private internal value.\r\n         * The number of points used to draw the curve. Higher values create smoother renders at the cost of more triangles being drawn.\r\n         *\r\n         * @name Phaser.GameObjects.Curve#_smoothness\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._smoothness = 32;\r\n\r\n        /**\r\n         * Private internal value.\r\n         * The Curve bounds rectangle.\r\n         *\r\n         * @name Phaser.GameObjects.Curve#_curveBounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._curveBounds = new Rectangle();\r\n\r\n        this.closePath = false;\r\n\r\n        this.setPosition(x, y);\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * The smoothness of the curve. The number of points used when rendering it.\r\n     * Increase this value for smoother curves, at the cost of more polygons being rendered.\r\n     *\r\n     * @name Phaser.GameObjects.Curve#smoothness\r\n     * @type {number}\r\n     * @default 32\r\n     * @since 3.13.0\r\n     */\r\n    smoothness: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._smoothness;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._smoothness = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the smoothness of the curve. The number of points used when rendering it.\r\n     * Increase this value for smoother curves, at the cost of more polygons being rendered.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Curve#setSmoothness\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the smoothness to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSmoothness: function (value)\r\n    {\r\n        this._smoothness = value;\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Curve#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var bounds = this._curveBounds;\r\n        var smoothness = this._smoothness;\r\n\r\n        //  Update the bounds in case the underlying data has changed\r\n        this.geom.getBounds(bounds, smoothness);\r\n\r\n        this.setSize(bounds.width, bounds.height);\r\n        this.updateDisplayOrigin();\r\n\r\n        var path = [];\r\n        var points = this.geom.getPoints(smoothness);\r\n\r\n        for (var i = 0; i < points.length; i++)\r\n        {\r\n            path.push(points[i].x, points[i].y);\r\n        }\r\n\r\n        path.push(points[0].x, points[0].y);\r\n\r\n        this.pathIndexes = Earcut(path);\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Curve;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Curve#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Curve} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar CurveCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX + src._curveBounds.x;\r\n        var dy = src._displayOriginY + src._curveBounds.y;\r\n\r\n        var path = src.pathData;\r\n        var pathLength = path.length - 1;\r\n\r\n        var px1 = path[0] - dx;\r\n        var py1 = path[1] - dy;\r\n\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(px1, py1);\r\n\r\n        if (!src.closePath)\r\n        {\r\n            pathLength -= 2;\r\n        }\r\n\r\n        for (var i = 2; i < pathLength; i += 2)\r\n        {\r\n            var px2 = path[i] - dx;\r\n            var py2 = path[i + 1] - dy;\r\n\r\n            ctx.lineTo(px2, py2);\r\n        }\r\n\r\n        if (src.closePath)\r\n        {\r\n            ctx.closePath();\r\n        }\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = CurveCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar Curve = require('./Curve');\r\n\r\n/**\r\n * Creates a new Curve Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Curve Game Object has been built into Phaser.\r\n * \r\n * The Curve Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * To render a Curve Shape you must first create a `Phaser.Curves.Curve` object, then pass it to\r\n * the Curve Shape in the constructor.\r\n * \r\n * The Curve shape also has a `smoothness` property and corresponding `setSmoothness` method.\r\n * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations\r\n * that take place during construction. Increase and decrease the default value for smoother, or more\r\n * jagged, shapes.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#curve\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {Phaser.Curves.Curve} [curve] - The Curve object to use to create the Shape.\r\n * @param {number} [fillColor] - The color the curve will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the curve will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Curve} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('curve', function (x, y, curve, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Curve(this.scene, x, y, curve, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./CurveWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./CurveCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillPathWebGL = require('../FillPathWebGL');\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Curve#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Curve} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar CurveWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX + src._curveBounds.x;\r\n    var dy = src._displayOriginY + src._curveBounds.y;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = CurveWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar EllipseRender = require('./EllipseRender');\r\nvar GeomEllipse = require('../../../geom/ellipse/Ellipse');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The Ellipse Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * When it renders it displays an ellipse shape. You can control the width and height of the ellipse.\r\n * If the width and height match it will render as a circle. If the width is less than the height,\r\n * it will look more like an egg shape.\r\n * \r\n * The Ellipse shape also has a `smoothness` property and corresponding `setSmoothness` method.\r\n * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations\r\n * that take place during construction. Increase and decrease the default value for smoother, or more\r\n * jagged, shapes.\r\n *\r\n * @class Ellipse\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the ellipse. An ellipse with equal width and height renders as a circle.\r\n * @param {number} [height=128] - The height of the ellipse. An ellipse with equal width and height renders as a circle.\r\n * @param {number} [fillColor] - The color the ellipse will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the ellipse will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Ellipse = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        EllipseRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Ellipse (scene, x, y, width, height, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = 128; }\r\n        if (height === undefined) { height = 128; }\r\n\r\n        Shape.call(this, scene, 'Ellipse', new GeomEllipse(width / 2, height / 2, width, height));\r\n\r\n        /**\r\n         * Private internal value.\r\n         * The number of points used to draw the curve. Higher values create smoother renders at the cost of more triangles being drawn.\r\n         *\r\n         * @name Phaser.GameObjects.Ellipse#_smoothness\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._smoothness = 64;\r\n\r\n        this.setPosition(x, y);\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * The smoothness of the ellipse. The number of points used when rendering it.\r\n     * Increase this value for a smoother ellipse, at the cost of more polygons being rendered.\r\n     *\r\n     * @name Phaser.GameObjects.Ellipse#smoothness\r\n     * @type {number}\r\n     * @default 64\r\n     * @since 3.13.0\r\n     */\r\n    smoothness: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._smoothness;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._smoothness = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Sets the size of the ellipse by changing the underlying geometry data, rather than scaling the object.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Ellipse#setSize\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} width - The width of the ellipse.\r\n     * @param {number} height - The height of the ellipse.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.geom.setPosition(width / 2, height / 2);\r\n        this.geom.setSize(width, height);\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the smoothness of the ellipse. The number of points used when rendering it.\r\n     * Increase this value for a smoother ellipse, at the cost of more polygons being rendered.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Ellipse#setSmoothness\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the smoothness to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSmoothness: function (value)\r\n    {\r\n        this._smoothness = value;\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Ellipse#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var path = [];\r\n        var points = this.geom.getPoints(this._smoothness);\r\n\r\n        for (var i = 0; i < points.length; i++)\r\n        {\r\n            path.push(points[i].x, points[i].y);\r\n        }\r\n\r\n        path.push(points[0].x, points[0].y);\r\n\r\n        this.pathIndexes = Earcut(path);\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Ellipse;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Ellipse#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Ellipse} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar EllipseCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX;\r\n        var dy = src._displayOriginY;\r\n\r\n        var path = src.pathData;\r\n        var pathLength = path.length - 1;\r\n\r\n        var px1 = path[0] - dx;\r\n        var py1 = path[1] - dy;\r\n\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(px1, py1);\r\n\r\n        if (!src.closePath)\r\n        {\r\n            pathLength -= 2;\r\n        }\r\n\r\n        for (var i = 2; i < pathLength; i += 2)\r\n        {\r\n            var px2 = path[i] - dx;\r\n            var py2 = path[i + 1] - dy;\r\n\r\n            ctx.lineTo(px2, py2);\r\n        }\r\n\r\n        ctx.closePath();\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = EllipseCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Ellipse = require('./Ellipse');\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Ellipse Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Ellipse Game Object has been built into Phaser.\r\n * \r\n * The Ellipse Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * When it renders it displays an ellipse shape. You can control the width and height of the ellipse.\r\n * If the width and height match it will render as a circle. If the width is less than the height,\r\n * it will look more like an egg shape.\r\n * \r\n * The Ellipse shape also has a `smoothness` property and corresponding `setSmoothness` method.\r\n * This allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations\r\n * that take place during construction. Increase and decrease the default value for smoother, or more\r\n * jagged, shapes.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#ellipse\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the ellipse. An ellipse with equal width and height renders as a circle.\r\n * @param {number} [height=128] - The height of the ellipse. An ellipse with equal width and height renders as a circle.\r\n * @param {number} [fillColor] - The color the ellipse will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the ellipse will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Ellipse} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('ellipse', function (x, y, width, height, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Ellipse(this.scene, x, y, width, height, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./EllipseWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./EllipseCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillPathWebGL = require('../FillPathWebGL');\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Ellipse#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Ellipse} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar EllipseWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = EllipseWebGLRenderer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../../utils/Class');\nvar Shape = require('../Shape');\nvar GridRender = require('./GridRender');\n\n/**\n * @classdesc\n * The Grid Shape is a Game Object that can be added to a Scene, Group or Container. You can\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\n *\n * This shape supports only fill colors and cannot be stroked.\n *\n * A Grid Shape allows you to display a grid in your game, where you can control the size of the\n * grid as well as the width and height of the grid cells. You can set a fill color for each grid\n * cell as well as an alternate fill color. When the alternate fill color is set then the grid\n * cells will alternate the fill colors as they render, creating a chess-board effect. You can\n * also optionally have an outline fill color. If set, this draws lines between the grid cells\n * in the given color. If you specify an outline color with an alpha of zero, then it will draw\n * the cells spaced out, but without the lines between them.\n *\n * @class Grid\n * @extends Phaser.GameObjects.Shape\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.13.0\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\n * @param {number} [width=128] - The width of the grid.\n * @param {number} [height=128] - The height of the grid.\n * @param {number} [cellWidth=32] - The width of one cell in the grid.\n * @param {number} [cellHeight=32] - The height of one cell in the grid.\n * @param {number} [fillColor] - The color the grid cells will be filled with, i.e. 0xff0000 for red.\n * @param {number} [fillAlpha] - The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\n * @param {number} [outlineFillColor] - The color of the lines between the grid cells. See the `setOutline` method.\n * @param {number} [outlineFillAlpha] - The alpha of the lines between the grid cells.\n */\nvar Grid = new Class({\n\n    Extends: Shape,\n\n    Mixins: [\n        GridRender\n    ],\n\n    initialize:\n\n    function Grid (scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha)\n    {\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = 0; }\n        if (width === undefined) { width = 128; }\n        if (height === undefined) { height = 128; }\n        if (cellWidth === undefined) { cellWidth = 32; }\n        if (cellHeight === undefined) { cellHeight = 32; }\n\n        Shape.call(this, scene, 'Grid', null);\n\n        /**\n         * The width of each grid cell.\n         * Must be a positive value.\n         *\n         * @name Phaser.GameObjects.Grid#cellWidth\n         * @type {number}\n         * @since 3.13.0\n         */\n        this.cellWidth = cellWidth;\n\n        /**\n         * The height of each grid cell.\n         * Must be a positive value.\n         *\n         * @name Phaser.GameObjects.Grid#cellHeight\n         * @type {number}\n         * @since 3.13.0\n         */\n        this.cellHeight = cellHeight;\n\n        /**\n         * Will the grid render its cells in the `fillColor`?\n         *\n         * @name Phaser.GameObjects.Grid#showCells\n         * @type {boolean}\n         * @since 3.13.0\n         */\n        this.showCells = true;\n\n        /**\n         * The color of the lines between each grid cell.\n         *\n         * @name Phaser.GameObjects.Grid#outlineFillColor\n         * @type {number}\n         * @since 3.13.0\n         */\n        this.outlineFillColor = 0;\n\n        /**\n         * The alpha value for the color of the lines between each grid cell.\n         *\n         * @name Phaser.GameObjects.Grid#outlineFillAlpha\n         * @type {number}\n         * @since 3.13.0\n         */\n        this.outlineFillAlpha = 0;\n\n        /**\n         * Will the grid display the lines between each cell when it renders?\n         *\n         * @name Phaser.GameObjects.Grid#showOutline\n         * @type {boolean}\n         * @since 3.13.0\n         */\n        this.showOutline = true;\n\n        /**\n         * Will the grid render the alternating cells in the `altFillColor`?\n         *\n         * @name Phaser.GameObjects.Grid#showAltCells\n         * @type {boolean}\n         * @since 3.13.0\n         */\n        this.showAltCells = false;\n\n        /**\n         * The color the alternating grid cells will be filled with, i.e. 0xff0000 for red.\n         *\n         * @name Phaser.GameObjects.Grid#altFillColor\n         * @type {number}\n         * @since 3.13.0\n         */\n        this.altFillColor;\n\n        /**\n         * The alpha the alternating grid cells will be filled with.\n         * You can also set the alpha of the overall Shape using its `alpha` property.\n         *\n         * @name Phaser.GameObjects.Grid#altFillAlpha\n         * @type {number}\n         * @since 3.13.0\n         */\n        this.altFillAlpha;\n\n        this.setPosition(x, y);\n        this.setSize(width, height);\n\n        this.setFillStyle(fillColor, fillAlpha);\n\n        if (outlineFillColor !== undefined)\n        {\n            this.setOutlineStyle(outlineFillColor, outlineFillAlpha);\n        }\n\n        this.updateDisplayOrigin();\n    },\n\n    /**\n     * Sets the fill color and alpha level the grid cells will use when rendering.\n     *\n     * If this method is called with no values then the grid cells will not be rendered,\n     * however the grid lines and alternating cells may still be.\n     *\n     * Also see the `setOutlineStyle` and `setAltFillStyle` methods.\n     *\n     * This call can be chained.\n     *\n     * @method Phaser.GameObjects.Grid#setFillStyle\n     * @since 3.13.0\n     *\n     * @param {number} [fillColor] - The color the grid cells will be filled with, i.e. 0xff0000 for red.\n     * @param {number} [fillAlpha=1] - The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setFillStyle: function (fillColor, fillAlpha)\n    {\n        if (fillAlpha === undefined) { fillAlpha = 1; }\n\n        if (fillColor === undefined)\n        {\n            this.showCells = false;\n        }\n        else\n        {\n            this.fillColor = fillColor;\n            this.fillAlpha = fillAlpha;\n            this.showCells = true;\n        }\n\n        return this;\n    },\n\n    /**\n     * Sets the fill color and alpha level that the alternating grid cells will use.\n     *\n     * If this method is called with no values then alternating grid cells will not be rendered in a different color.\n     *\n     * Also see the `setOutlineStyle` and `setFillStyle` methods.\n     *\n     * This call can be chained.\n     *\n     * @method Phaser.GameObjects.Grid#setAltFillStyle\n     * @since 3.13.0\n     *\n     * @param {number} [fillColor] - The color the alternating grid cells will be filled with, i.e. 0xff0000 for red.\n     * @param {number} [fillAlpha=1] - The alpha the alternating grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setAltFillStyle: function (fillColor, fillAlpha)\n    {\n        if (fillAlpha === undefined) { fillAlpha = 1; }\n\n        if (fillColor === undefined)\n        {\n            this.showAltCells = false;\n        }\n        else\n        {\n            this.altFillColor = fillColor;\n            this.altFillAlpha = fillAlpha;\n            this.showAltCells = true;\n        }\n\n        return this;\n    },\n\n    /**\n     * Sets the fill color and alpha level that the lines between each grid cell will use.\n     *\n     * If this method is called with no values then the grid lines will not be rendered at all, however\n     * the cells themselves may still be if they have colors set.\n     *\n     * Also see the `setFillStyle` and `setAltFillStyle` methods.\n     *\n     * This call can be chained.\n     *\n     * @method Phaser.GameObjects.Grid#setOutlineStyle\n     * @since 3.13.0\n     *\n     * @param {number} [fillColor] - The color the lines between the grid cells will be filled with, i.e. 0xff0000 for red.\n     * @param {number} [fillAlpha=1] - The alpha the lines between the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setOutlineStyle: function (fillColor, fillAlpha)\n    {\n        if (fillAlpha === undefined) { fillAlpha = 1; }\n\n        if (fillColor === undefined)\n        {\n            this.showOutline = false;\n        }\n        else\n        {\n            this.outlineFillColor = fillColor;\n            this.outlineFillAlpha = fillAlpha;\n            this.showOutline = true;\n        }\n\n        return this;\n    }\n\n});\n\nmodule.exports = Grid;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Grid#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Grid} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar GridCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = -src._displayOriginX;\r\n        var dy = -src._displayOriginY;\r\n\r\n        var alpha = camera.alpha * src.alpha;\r\n\r\n        //  Work out the grid size\r\n\r\n        var width = src.width;\r\n        var height = src.height;\r\n\r\n        var cellWidth = src.cellWidth;\r\n        var cellHeight = src.cellHeight;\r\n\r\n        var gridWidth = Math.ceil(width / cellWidth);\r\n        var gridHeight = Math.ceil(height / cellHeight);\r\n\r\n        var cellWidthA = cellWidth;\r\n        var cellHeightA = cellHeight;\r\n\r\n        var cellWidthB = cellWidth - ((gridWidth * cellWidth) - width);\r\n        var cellHeightB = cellHeight - ((gridHeight * cellHeight) - height);\r\n\r\n        var showCells = src.showCells;\r\n        var showAltCells = src.showAltCells;\r\n        var showOutline = src.showOutline;\r\n\r\n        var x = 0;\r\n        var y = 0;\r\n        var r = 0;\r\n        var cw = 0;\r\n        var ch = 0;\r\n\r\n        if (showOutline)\r\n        {\r\n            //  To make room for the grid lines (in case alpha < 1)\r\n            cellWidthA--;\r\n            cellHeightA--;\r\n\r\n            if (cellWidthB === cellWidth)\r\n            {\r\n                cellWidthB--;\r\n            }\r\n\r\n            if (cellHeightB === cellHeight)\r\n            {\r\n                cellHeightB--;\r\n            }\r\n        }\r\n\r\n        if (showCells && src.fillAlpha > 0)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            for (y = 0; y < gridHeight; y++)\r\n            {\r\n                if (showAltCells)\r\n                {\r\n                    r = y % 2;\r\n                }\r\n\r\n                for (x = 0; x < gridWidth; x++)\r\n                {\r\n                    if (showAltCells && r)\r\n                    {\r\n                        r = 0;\r\n                        continue;\r\n                    }\r\n\r\n                    r++;\r\n\r\n                    cw = (x < gridWidth - 1) ? cellWidthA : cellWidthB;\r\n                    ch = (y < gridHeight - 1) ? cellHeightA : cellHeightB;\r\n\r\n                    ctx.fillRect(\r\n                        dx + x * cellWidth,\r\n                        dy + y * cellHeight,\r\n                        cw,\r\n                        ch\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        if (showAltCells && src.altFillAlpha > 0)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.altFillColor, src.altFillAlpha * alpha);\r\n\r\n            for (y = 0; y < gridHeight; y++)\r\n            {\r\n                if (showAltCells)\r\n                {\r\n                    r = y % 2;\r\n                }\r\n\r\n                for (x = 0; x < gridWidth; x++)\r\n                {\r\n                    if (showAltCells && !r)\r\n                    {\r\n                        r = 1;\r\n                        continue;\r\n                    }\r\n\r\n                    r = 0;\r\n\r\n                    cw = (x < gridWidth - 1) ? cellWidthA : cellWidthB;\r\n                    ch = (y < gridHeight - 1) ? cellHeightA : cellHeightB;\r\n\r\n                    ctx.fillRect(\r\n                        dx + x * cellWidth,\r\n                        dy + y * cellHeight,\r\n                        cw,\r\n                        ch\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        if (showOutline && src.outlineFillAlpha > 0)\r\n        {\r\n            LineStyleCanvas(ctx, src, src.outlineFillColor, src.outlineFillAlpha * alpha);\r\n\r\n            for (x = 1; x < gridWidth; x++)\r\n            {\r\n                var x1 = x * cellWidth;\r\n\r\n                ctx.beginPath();\r\n\r\n                ctx.moveTo(x1 + dx, dy);\r\n                ctx.lineTo(x1 + dx, height + dy);\r\n\r\n                ctx.stroke();\r\n            }\r\n\r\n            for (y = 1; y < gridHeight; y++)\r\n            {\r\n                var y1 = y * cellHeight;\r\n\r\n                ctx.beginPath();\r\n\r\n                ctx.moveTo(dx, y1 + dy);\r\n                ctx.lineTo(dx + width, y1 + dy);\r\n\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = GridCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar Grid = require('./Grid');\r\n\r\n/**\r\n * Creates a new Grid Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Grid Game Object has been built into Phaser.\r\n * \r\n * The Grid Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports only fill colors and cannot be stroked.\r\n * \r\n * A Grid Shape allows you to display a grid in your game, where you can control the size of the\r\n * grid as well as the width and height of the grid cells. You can set a fill color for each grid\r\n * cell as well as an alternate fill color. When the alternate fill color is set then the grid\r\n * cells will alternate the fill colors as they render, creating a chess-board effect. You can\r\n * also optionally have an outline fill color. If set, this draws lines between the grid cells\r\n * in the given color. If you specify an outline color with an alpha of zero, then it will draw\r\n * the cells spaced out, but without the lines between them.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#grid\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the grid.\r\n * @param {number} [height=128] - The height of the grid.\r\n * @param {number} [cellWidth=32] - The width of one cell in the grid.\r\n * @param {number} [cellHeight=32] - The height of one cell in the grid.\r\n * @param {number} [fillColor] - The color the grid cells will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the grid cells will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n * @param {number} [outlineFillColor] - The color of the lines between the grid cells.\r\n * @param {number} [outlineFillAlpha] - The alpha of the lines between the grid cells.\r\n *\r\n * @return {Phaser.GameObjects.Grid} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('grid', function (x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha)\r\n{\r\n    return this.displayList.add(new Grid(this.scene, x, y, width, height, cellWidth, cellHeight, fillColor, fillAlpha, outlineFillColor, outlineFillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./GridWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./GridCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Grid#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Grid} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar GridWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    calcMatrix.translate(-src._displayOriginX, -src._displayOriginY);\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    //  Work out the grid size\r\n\r\n    var width = src.width;\r\n    var height = src.height;\r\n\r\n    var cellWidth = src.cellWidth;\r\n    var cellHeight = src.cellHeight;\r\n\r\n    var gridWidth = Math.ceil(width / cellWidth);\r\n    var gridHeight = Math.ceil(height / cellHeight);\r\n\r\n    var cellWidthA = cellWidth;\r\n    var cellHeightA = cellHeight;\r\n\r\n    var cellWidthB = cellWidth - ((gridWidth * cellWidth) - width);\r\n    var cellHeightB = cellHeight - ((gridHeight * cellHeight) - height);\r\n\r\n    var fillTint;\r\n    var fillTintColor;\r\n\r\n    var showCells = src.showCells;\r\n    var showAltCells = src.showAltCells;\r\n    var showOutline = src.showOutline;\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n    var r = 0;\r\n    var cw = 0;\r\n    var ch = 0;\r\n\r\n    if (showOutline)\r\n    {\r\n        //  To make room for the grid lines (in case alpha < 1)\r\n        cellWidthA--;\r\n        cellHeightA--;\r\n\r\n        if (cellWidthB === cellWidth)\r\n        {\r\n            cellWidthB--;\r\n        }\r\n\r\n        if (cellHeightB === cellHeight)\r\n        {\r\n            cellHeightB--;\r\n        }\r\n    }\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (showCells && src.fillAlpha > 0)\r\n    {\r\n        fillTint = pipeline.fillTint;\r\n        fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);\r\n\r\n        fillTint.TL = fillTintColor;\r\n        fillTint.TR = fillTintColor;\r\n        fillTint.BL = fillTintColor;\r\n        fillTint.BR = fillTintColor;\r\n\r\n        for (y = 0; y < gridHeight; y++)\r\n        {\r\n            if (showAltCells)\r\n            {\r\n                r = y % 2;\r\n            }\r\n\r\n            for (x = 0; x < gridWidth; x++)\r\n            {\r\n                if (showAltCells && r)\r\n                {\r\n                    r = 0;\r\n                    continue;\r\n                }\r\n\r\n                r++;\r\n\r\n                cw = (x < gridWidth - 1) ? cellWidthA : cellWidthB;\r\n                ch = (y < gridHeight - 1) ? cellHeightA : cellHeightB;\r\n\r\n                pipeline.batchFillRect(\r\n                    x * cellWidth,\r\n                    y * cellHeight,\r\n                    cw,\r\n                    ch\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    if (showAltCells && src.altFillAlpha > 0)\r\n    {\r\n        fillTint = pipeline.fillTint;\r\n        fillTintColor = Utils.getTintAppendFloatAlpha(src.altFillColor, src.altFillAlpha * alpha);\r\n\r\n        fillTint.TL = fillTintColor;\r\n        fillTint.TR = fillTintColor;\r\n        fillTint.BL = fillTintColor;\r\n        fillTint.BR = fillTintColor;\r\n\r\n        for (y = 0; y < gridHeight; y++)\r\n        {\r\n            if (showAltCells)\r\n            {\r\n                r = y % 2;\r\n            }\r\n\r\n            for (x = 0; x < gridWidth; x++)\r\n            {\r\n                if (showAltCells && !r)\r\n                {\r\n                    r = 1;\r\n                    continue;\r\n                }\r\n\r\n                r = 0;\r\n\r\n                cw = (x < gridWidth - 1) ? cellWidthA : cellWidthB;\r\n                ch = (y < gridHeight - 1) ? cellHeightA : cellHeightB;\r\n\r\n                pipeline.batchFillRect(\r\n                    x * cellWidth,\r\n                    y * cellHeight,\r\n                    cw,\r\n                    ch\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    if (showOutline && src.outlineFillAlpha > 0)\r\n    {\r\n        var strokeTint = pipeline.strokeTint;\r\n        var color = Utils.getTintAppendFloatAlpha(src.outlineFillColor, src.outlineFillAlpha * alpha);\r\n\r\n        strokeTint.TL = color;\r\n        strokeTint.TR = color;\r\n        strokeTint.BL = color;\r\n        strokeTint.BR = color;\r\n\r\n        for (x = 1; x < gridWidth; x++)\r\n        {\r\n            var x1 = x * cellWidth;\r\n\r\n            pipeline.batchLine(x1, 0, x1, height, 1, 1, 1, 0, false);\r\n        }\r\n\r\n        for (y = 1; y < gridHeight; y++)\r\n        {\r\n            var y1 = y * cellHeight;\r\n\r\n            pipeline.batchLine(0, y1, width, y1, 1, 1, 1, 0, false);\r\n        }\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = GridWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar IsoBoxRender = require('./IsoBoxRender');\r\nvar Class = require('../../../utils/Class');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The IsoBox Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports only fill colors and cannot be stroked.\r\n * \r\n * An IsoBox is an 'isometric' rectangle. Each face of it has a different fill color. You can set\r\n * the color of the top, left and right faces of the rectangle respectively. You can also choose\r\n * which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.\r\n * \r\n * You cannot view an IsoBox from under-neath, however you can change the 'angle' by setting\r\n * the `projection` property.\r\n *\r\n * @class IsoBox\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [size=48] - The width of the iso box in pixels. The left and right faces will be exactly half this value.\r\n * @param {number} [height=32] - The height of the iso box. The left and right faces will be this tall. The overall height of the isobox will be this value plus half the `size` value.\r\n * @param {number} [fillTop=0xeeeeee] - The fill color of the top face of the iso box.\r\n * @param {number} [fillLeft=0x999999] - The fill color of the left face of the iso box.\r\n * @param {number} [fillRight=0xcccccc] - The fill color of the right face of the iso box.\r\n */\r\nvar IsoBox = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        IsoBoxRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function IsoBox (scene, x, y, size, height, fillTop, fillLeft, fillRight)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (size === undefined) { size = 48; }\r\n        if (height === undefined) { height = 32; }\r\n        if (fillTop === undefined) { fillTop = 0xeeeeee; }\r\n        if (fillLeft === undefined) { fillLeft = 0x999999; }\r\n        if (fillRight === undefined) { fillRight = 0xcccccc; }\r\n\r\n        Shape.call(this, scene, 'IsoBox', null);\r\n\r\n        /**\r\n         * The projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#projection\r\n         * @type {number}\r\n         * @default 4\r\n         * @since 3.13.0\r\n         */\r\n        this.projection = 4;\r\n\r\n        /**\r\n         * The color used to fill in the top of the iso box.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#fillTop\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillTop = fillTop;\r\n\r\n        /**\r\n         * The color used to fill in the left-facing side of the iso box.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#fillLeft\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillLeft = fillLeft;\r\n\r\n        /**\r\n         * The color used to fill in the right-facing side of the iso box.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#fillRight\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillRight = fillRight;\r\n\r\n        /**\r\n         * Controls if the top-face of the iso box be rendered.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#showTop\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.13.0\r\n         */\r\n        this.showTop = true;\r\n\r\n        /**\r\n         * Controls if the left-face of the iso box be rendered.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#showLeft\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.13.0\r\n         */\r\n        this.showLeft = true;\r\n\r\n        /**\r\n         * Controls if the right-face of the iso box be rendered.\r\n         *\r\n         * @name Phaser.GameObjects.IsoBox#showRight\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.13.0\r\n         */\r\n        this.showRight = true;\r\n\r\n        this.isFilled = true;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(size, height);\r\n\r\n        this.updateDisplayOrigin();\r\n    },\r\n\r\n    /**\r\n     * Sets the projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoBox#setProjection\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the projection to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setProjection: function (value)\r\n    {\r\n        this.projection = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets which faces of the iso box will be rendered.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoBox#setFaces\r\n     * @since 3.13.0\r\n     * \r\n     * @param {boolean} [showTop=true] - Show the top-face of the iso box.\r\n     * @param {boolean} [showLeft=true] - Show the left-face of the iso box.\r\n     * @param {boolean} [showRight=true] - Show the right-face of the iso box.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFaces: function (showTop, showLeft, showRight)\r\n    {\r\n        if (showTop === undefined) { showTop = true; }\r\n        if (showLeft === undefined) { showLeft = true; }\r\n        if (showRight === undefined) { showRight = true; }\r\n\r\n        this.showTop = showTop;\r\n        this.showLeft = showLeft;\r\n        this.showRight = showRight;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the fill colors for each face of the iso box.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoBox#setFillStyle\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} [fillTop] - The color used to fill the top of the iso box.\r\n     * @param {number} [fillLeft] - The color used to fill in the left-facing side of the iso box.\r\n     * @param {number} [fillRight] - The color used to fill in the right-facing side of the iso box.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFillStyle: function (fillTop, fillLeft, fillRight)\r\n    {\r\n        this.fillTop = fillTop;\r\n        this.fillLeft = fillLeft;\r\n        this.fillRight = fillRight;\r\n\r\n        this.isFilled = true;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = IsoBox;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.IsoBox#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.IsoBox} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar IsoBoxCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled)\r\n    {\r\n        var size = src.width;\r\n        var height = src.height;\r\n\r\n        var sizeA = size / 2;\r\n        var sizeB = size / src.projection;\r\n\r\n        //  Top Face\r\n\r\n        if (src.showTop)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.fillTop);\r\n\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(-sizeA, -height);\r\n            ctx.lineTo(0, -sizeB - height);\r\n            ctx.lineTo(sizeA, -height);\r\n            ctx.lineTo(sizeA, -1);\r\n            ctx.lineTo(0, sizeB - 1);\r\n            ctx.lineTo(-sizeA, -1);\r\n            ctx.lineTo(-sizeA, -height);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        //  Left Face\r\n\r\n        if (src.showLeft)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.fillLeft);\r\n\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(-sizeA, 0);\r\n            ctx.lineTo(0, sizeB);\r\n            ctx.lineTo(0, sizeB - height);\r\n            ctx.lineTo(-sizeA, -height);\r\n            ctx.lineTo(-sizeA, 0);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        //  Right Face\r\n\r\n        if (src.showRight)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.fillRight);\r\n\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(sizeA, 0);\r\n            ctx.lineTo(0, sizeB);\r\n            ctx.lineTo(0, sizeB - height);\r\n            ctx.lineTo(sizeA, -height);\r\n            ctx.lineTo(sizeA, 0);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = IsoBoxCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar IsoBox = require('./IsoBox');\r\n\r\n/**\r\n * Creates a new IsoBox Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the IsoBox Game Object has been built into Phaser.\r\n * \r\n * The IsoBox Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports only fill colors and cannot be stroked.\r\n * \r\n * An IsoBox is an 'isometric' rectangle. Each face of it has a different fill color. You can set\r\n * the color of the top, left and right faces of the rectangle respectively. You can also choose\r\n * which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.\r\n * \r\n * You cannot view an IsoBox from under-neath, however you can change the 'angle' by setting\r\n * the `projection` property.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#isobox\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [size=48] - The width of the iso box in pixels. The left and right faces will be exactly half this value.\r\n * @param {number} [height=32] - The height of the iso box. The left and right faces will be this tall. The overall height of the isobox will be this value plus half the `size` value.\r\n * @param {number} [fillTop=0xeeeeee] - The fill color of the top face of the iso box.\r\n * @param {number} [fillLeft=0x999999] - The fill color of the left face of the iso box.\r\n * @param {number} [fillRight=0xcccccc] - The fill color of the right face of the iso box.\r\n *\r\n * @return {Phaser.GameObjects.IsoBox} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('isobox', function (x, y, size, height, fillTop, fillLeft, fillRight)\r\n{\r\n    return this.displayList.add(new IsoBox(this.scene, x, y, size, height, fillTop, fillLeft, fillRight));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./IsoBoxWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./IsoBoxCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.IsoBox#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.IsoBox} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar IsoBoxWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var size = src.width;\r\n    var height = src.height;\r\n\r\n    var sizeA = size / 2;\r\n    var sizeB = size / src.projection;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (!src.isFilled)\r\n    {\r\n        return;\r\n    }\r\n\r\n    var tint;\r\n\r\n    var x0;\r\n    var y0;\r\n\r\n    var x1;\r\n    var y1;\r\n\r\n    var x2;\r\n    var y2;\r\n\r\n    var x3;\r\n    var y3;\r\n\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    //  Top Face\r\n\r\n    if (src.showTop)\r\n    {\r\n        tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);\r\n\r\n        x0 = calcMatrix.getX(-sizeA, -height);\r\n        y0 = calcMatrix.getY(-sizeA, -height);\r\n\r\n        x1 = calcMatrix.getX(0, -sizeB - height);\r\n        y1 = calcMatrix.getY(0, -sizeB - height);\r\n\r\n        x2 = calcMatrix.getX(sizeA, -height);\r\n        y2 = calcMatrix.getY(sizeA, -height);\r\n\r\n        x3 = calcMatrix.getX(0, sizeB - height);\r\n        y3 = calcMatrix.getY(0, sizeB - height);\r\n\r\n        pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);\r\n    }\r\n\r\n    //  Left Face\r\n\r\n    if (src.showLeft)\r\n    {\r\n        tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);\r\n\r\n        x0 = calcMatrix.getX(-sizeA, 0);\r\n        y0 = calcMatrix.getY(-sizeA, 0);\r\n\r\n        x1 = calcMatrix.getX(0, sizeB);\r\n        y1 = calcMatrix.getY(0, sizeB);\r\n\r\n        x2 = calcMatrix.getX(0, sizeB - height);\r\n        y2 = calcMatrix.getY(0, sizeB - height);\r\n\r\n        x3 = calcMatrix.getX(-sizeA, -height);\r\n        y3 = calcMatrix.getY(-sizeA, -height);\r\n\r\n        pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);\r\n    }\r\n\r\n    //  Right Face\r\n\r\n    if (src.showRight)\r\n    {\r\n        tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);\r\n\r\n        x0 = calcMatrix.getX(sizeA, 0);\r\n        y0 = calcMatrix.getY(sizeA, 0);\r\n\r\n        x1 = calcMatrix.getX(0, sizeB);\r\n        y1 = calcMatrix.getY(0, sizeB);\r\n\r\n        x2 = calcMatrix.getX(0, sizeB - height);\r\n        y2 = calcMatrix.getY(0, sizeB - height);\r\n\r\n        x3 = calcMatrix.getX(sizeA, -height);\r\n        y3 = calcMatrix.getY(sizeA, -height);\r\n\r\n        pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = IsoBoxWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar IsoTriangleRender = require('./IsoTriangleRender');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The IsoTriangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports only fill colors and cannot be stroked.\r\n * \r\n * An IsoTriangle is an 'isometric' triangle. Think of it like a pyramid. Each face has a different\r\n * fill color. You can set the color of the top, left and right faces of the triangle respectively\r\n * You can also choose which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.\r\n * \r\n * You cannot view an IsoTriangle from under-neath, however you can change the 'angle' by setting\r\n * the `projection` property. The `reversed` property controls if the IsoTriangle is rendered upside\r\n * down or not.\r\n *\r\n * @class IsoTriangle\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [size=48] - The width of the iso triangle in pixels. The left and right faces will be exactly half this value.\r\n * @param {number} [height=32] - The height of the iso triangle. The left and right faces will be this tall. The overall height of the iso triangle will be this value plus half the `size` value.\r\n * @param {boolean} [reversed=false] - Is the iso triangle upside down?\r\n * @param {number} [fillTop=0xeeeeee] - The fill color of the top face of the iso triangle.\r\n * @param {number} [fillLeft=0x999999] - The fill color of the left face of the iso triangle.\r\n * @param {number} [fillRight=0xcccccc] - The fill color of the right face of the iso triangle.\r\n */\r\nvar IsoTriangle = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        IsoTriangleRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function IsoTriangle (scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (size === undefined) { size = 48; }\r\n        if (height === undefined) { height = 32; }\r\n        if (reversed === undefined) { reversed = false; }\r\n        if (fillTop === undefined) { fillTop = 0xeeeeee; }\r\n        if (fillLeft === undefined) { fillLeft = 0x999999; }\r\n        if (fillRight === undefined) { fillRight = 0xcccccc; }\r\n\r\n        Shape.call(this, scene, 'IsoTriangle', null);\r\n\r\n        /**\r\n         * The projection level of the iso box. Change this to change the 'angle' at which you are looking at the box.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#projection\r\n         * @type {number}\r\n         * @default 4\r\n         * @since 3.13.0\r\n         */\r\n        this.projection = 4;\r\n\r\n        /**\r\n         * The color used to fill in the top of the iso triangle. This is only used if the triangle is reversed.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#fillTop\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillTop = fillTop;\r\n\r\n        /**\r\n         * The color used to fill in the left-facing side of the iso triangle.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#fillLeft\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillLeft = fillLeft;\r\n\r\n        /**\r\n         * The color used to fill in the right-facing side of the iso triangle.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#fillRight\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.fillRight = fillRight;\r\n\r\n        /**\r\n         * Controls if the top-face of the iso triangle be rendered.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#showTop\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.13.0\r\n         */\r\n        this.showTop = true;\r\n\r\n        /**\r\n         * Controls if the left-face of the iso triangle be rendered.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#showLeft\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.13.0\r\n         */\r\n        this.showLeft = true;\r\n\r\n        /**\r\n         * Controls if the right-face of the iso triangle be rendered.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#showRight\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.13.0\r\n         */\r\n        this.showRight = true;\r\n\r\n        /**\r\n         * Sets if the iso triangle will be rendered upside down or not.\r\n         *\r\n         * @name Phaser.GameObjects.IsoTriangle#isReversed\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.13.0\r\n         */\r\n        this.isReversed = reversed;\r\n\r\n        this.isFilled = true;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(size, height);\r\n\r\n        this.updateDisplayOrigin();\r\n    },\r\n\r\n    /**\r\n     * Sets the projection level of the iso triangle. Change this to change the 'angle' at which you are looking at the pyramid.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoTriangle#setProjection\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The value to set the projection to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setProjection: function (value)\r\n    {\r\n        this.projection = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets if the iso triangle will be rendered upside down or not.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoTriangle#setReversed\r\n     * @since 3.13.0\r\n     * \r\n     * @param {boolean} reversed - Sets if the iso triangle will be rendered upside down or not.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setReversed: function (reversed)\r\n    {\r\n        this.isReversed = reversed;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets which faces of the iso triangle will be rendered.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoTriangle#setFaces\r\n     * @since 3.13.0\r\n     * \r\n     * @param {boolean} [showTop=true] - Show the top-face of the iso triangle (only if `reversed` is true)\r\n     * @param {boolean} [showLeft=true] - Show the left-face of the iso triangle.\r\n     * @param {boolean} [showRight=true] - Show the right-face of the iso triangle.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFaces: function (showTop, showLeft, showRight)\r\n    {\r\n        if (showTop === undefined) { showTop = true; }\r\n        if (showLeft === undefined) { showLeft = true; }\r\n        if (showRight === undefined) { showRight = true; }\r\n\r\n        this.showTop = showTop;\r\n        this.showLeft = showLeft;\r\n        this.showRight = showRight;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the fill colors for each face of the iso triangle.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.IsoTriangle#setFillStyle\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} [fillTop] - The color used to fill the top of the iso triangle.\r\n     * @param {number} [fillLeft] - The color used to fill in the left-facing side of the iso triangle.\r\n     * @param {number} [fillRight] - The color used to fill in the right-facing side of the iso triangle.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFillStyle: function (fillTop, fillLeft, fillRight)\r\n    {\r\n        this.fillTop = fillTop;\r\n        this.fillLeft = fillLeft;\r\n        this.fillRight = fillRight;\r\n\r\n        this.isFilled = true;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = IsoTriangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.IsoTriangle#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.IsoTriangle} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar IsoTriangleCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix) && src.isFilled)\r\n    {\r\n        var size = src.width;\r\n        var height = src.height;\r\n\r\n        var sizeA = size / 2;\r\n        var sizeB = size / src.projection;\r\n\r\n        var reversed = src.isReversed;\r\n\r\n        //  Top Face\r\n\r\n        if (src.showTop && reversed)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.fillTop);\r\n\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(-sizeA, -height);\r\n            ctx.lineTo(0, -sizeB - height);\r\n            ctx.lineTo(sizeA, -height);\r\n            ctx.lineTo(0, sizeB - height);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        //  Left Face\r\n\r\n        if (src.showLeft)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.fillLeft);\r\n\r\n            ctx.beginPath();\r\n\r\n            if (reversed)\r\n            {\r\n                ctx.moveTo(-sizeA, -height);\r\n                ctx.lineTo(0, sizeB);\r\n                ctx.lineTo(0, sizeB - height);\r\n            }\r\n            else\r\n            {\r\n                ctx.moveTo(-sizeA, 0);\r\n                ctx.lineTo(0, sizeB);\r\n                ctx.lineTo(0, sizeB - height);\r\n            }\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        //  Right Face\r\n\r\n        if (src.showRight)\r\n        {\r\n            FillStyleCanvas(ctx, src, src.fillRight);\r\n\r\n            ctx.beginPath();\r\n\r\n            if (reversed)\r\n            {\r\n                ctx.moveTo(sizeA, -height);\r\n                ctx.lineTo(0, sizeB);\r\n                ctx.lineTo(0, sizeB - height);\r\n            }\r\n            else\r\n            {\r\n                ctx.moveTo(sizeA, 0);\r\n                ctx.lineTo(0, sizeB);\r\n                ctx.lineTo(0, sizeB - height);\r\n            }\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = IsoTriangleCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar IsoTriangle = require('./IsoTriangle');\r\n\r\n/**\r\n * Creates a new IsoTriangle Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the IsoTriangle Game Object has been built into Phaser.\r\n * \r\n * The IsoTriangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports only fill colors and cannot be stroked.\r\n * \r\n * An IsoTriangle is an 'isometric' triangle. Think of it like a pyramid. Each face has a different\r\n * fill color. You can set the color of the top, left and right faces of the triangle respectively\r\n * You can also choose which of the faces are rendered via the `showTop`, `showLeft` and `showRight` properties.\r\n * \r\n * You cannot view an IsoTriangle from under-neath, however you can change the 'angle' by setting\r\n * the `projection` property. The `reversed` property controls if the IsoTriangle is rendered upside\r\n * down or not.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#isotriangle\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [size=48] - The width of the iso triangle in pixels. The left and right faces will be exactly half this value.\r\n * @param {number} [height=32] - The height of the iso triangle. The left and right faces will be this tall. The overall height of the iso triangle will be this value plus half the `size` value.\r\n * @param {boolean} [reversed=false] - Is the iso triangle upside down?\r\n * @param {number} [fillTop=0xeeeeee] - The fill color of the top face of the iso triangle.\r\n * @param {number} [fillLeft=0x999999] - The fill color of the left face of the iso triangle.\r\n * @param {number} [fillRight=0xcccccc] - The fill color of the right face of the iso triangle.\r\n *\r\n * @return {Phaser.GameObjects.IsoTriangle} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('isotriangle', function (x, y, size, height, reversed, fillTop, fillLeft, fillRight)\r\n{\r\n    return this.displayList.add(new IsoTriangle(this.scene, x, y, size, height, reversed, fillTop, fillLeft, fillRight));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./IsoTriangleWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./IsoTriangleCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.IsoTriangle#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.IsoTriangle} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar IsoTriangleWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var size = src.width;\r\n    var height = src.height;\r\n\r\n    var sizeA = size / 2;\r\n    var sizeB = size / src.projection;\r\n\r\n    var reversed = src.isReversed;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    if (!src.isFilled)\r\n    {\r\n        return;\r\n    }\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    var tint;\r\n\r\n    var x0;\r\n    var y0;\r\n\r\n    var x1;\r\n    var y1;\r\n\r\n    var x2;\r\n    var y2;\r\n\r\n    //  Top Face\r\n\r\n    if (src.showTop && reversed)\r\n    {\r\n        tint = Utils.getTintAppendFloatAlpha(src.fillTop, alpha);\r\n\r\n        x0 = calcMatrix.getX(-sizeA, -height);\r\n        y0 = calcMatrix.getY(-sizeA, -height);\r\n\r\n        x1 = calcMatrix.getX(0, -sizeB - height);\r\n        y1 = calcMatrix.getY(0, -sizeB - height);\r\n\r\n        x2 = calcMatrix.getX(sizeA, -height);\r\n        y2 = calcMatrix.getY(sizeA, -height);\r\n\r\n        var x3 = calcMatrix.getX(0, sizeB - height);\r\n        var y3 = calcMatrix.getY(0, sizeB - height);\r\n\r\n        pipeline.batchQuad(src, x0, y0, x1, y1, x2, y2, x3, y3, 0, 0, 1, 1, tint, tint, tint, tint, 2);\r\n    }\r\n\r\n    //  Left Face\r\n\r\n    if (src.showLeft)\r\n    {\r\n        tint = Utils.getTintAppendFloatAlpha(src.fillLeft, alpha);\r\n\r\n        if (reversed)\r\n        {\r\n            x0 = calcMatrix.getX(-sizeA, -height);\r\n            y0 = calcMatrix.getY(-sizeA, -height);\r\n\r\n            x1 = calcMatrix.getX(0, sizeB);\r\n            y1 = calcMatrix.getY(0, sizeB);\r\n\r\n            x2 = calcMatrix.getX(0, sizeB - height);\r\n            y2 = calcMatrix.getY(0, sizeB - height);\r\n        }\r\n        else\r\n        {\r\n            x0 = calcMatrix.getX(-sizeA, 0);\r\n            y0 = calcMatrix.getY(-sizeA, 0);\r\n\r\n            x1 = calcMatrix.getX(0, sizeB);\r\n            y1 = calcMatrix.getY(0, sizeB);\r\n\r\n            x2 = calcMatrix.getX(0, sizeB - height);\r\n            y2 = calcMatrix.getY(0, sizeB - height);\r\n        }\r\n\r\n        pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);\r\n    }\r\n\r\n    //  Right Face\r\n\r\n    if (src.showRight)\r\n    {\r\n        tint = Utils.getTintAppendFloatAlpha(src.fillRight, alpha);\r\n\r\n        if (reversed)\r\n        {\r\n            x0 = calcMatrix.getX(sizeA, -height);\r\n            y0 = calcMatrix.getY(sizeA, -height);\r\n\r\n            x1 = calcMatrix.getX(0, sizeB);\r\n            y1 = calcMatrix.getY(0, sizeB);\r\n\r\n            x2 = calcMatrix.getX(0, sizeB - height);\r\n            y2 = calcMatrix.getY(0, sizeB - height);\r\n        }\r\n        else\r\n        {\r\n            x0 = calcMatrix.getX(sizeA, 0);\r\n            y0 = calcMatrix.getY(sizeA, 0);\r\n\r\n            x1 = calcMatrix.getX(0, sizeB);\r\n            y1 = calcMatrix.getY(0, sizeB);\r\n\r\n            x2 = calcMatrix.getX(0, sizeB - height);\r\n            y2 = calcMatrix.getY(0, sizeB - height);\r\n        }\r\n\r\n        pipeline.batchTri(src, x0, y0, x1, y1, x2, y2, 0, 0, 1, 1, tint, tint, tint, 2);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = IsoTriangleWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Shape = require('../Shape');\r\nvar GeomLine = require('../../../geom/line/Line');\r\nvar LineRender = require('./LineRender');\r\n\r\n/**\r\n * @classdesc\r\n * The Line Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n *\r\n * This shape supports only stroke colors and cannot be filled.\r\n *\r\n * A Line Shape allows you to draw a line between two points in your game. You can control the\r\n * stroke color and thickness of the line. In WebGL only you can also specify a different\r\n * thickness for the start and end of the line, allowing you to render lines that taper-off.\r\n *\r\n * If you need to draw multiple lines in a sequence you may wish to use the Polygon Shape instead.\r\n *\r\n * Be aware that as with all Game Objects the default origin is 0.5. If you need to draw a Line\r\n * between two points and want the x1/y1 values to match the x/y values, then set the origin to 0.\r\n *\r\n * @class Line\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [x1=0] - The horizontal position of the start of the line.\r\n * @param {number} [y1=0] - The vertical position of the start of the line.\r\n * @param {number} [x2=128] - The horizontal position of the end of the line.\r\n * @param {number} [y2=0] - The vertical position of the end of the line.\r\n * @param {number} [strokeColor] - The color the line will be drawn in, i.e. 0xff0000 for red.\r\n * @param {number} [strokeAlpha] - The alpha the line will be drawn in. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Line = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        LineRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Line (scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (x1 === undefined) { x1 = 0; }\r\n        if (y1 === undefined) { y1 = 0; }\r\n        if (x2 === undefined) { x2 = 128; }\r\n        if (y2 === undefined) { y2 = 0; }\r\n\r\n        Shape.call(this, scene, 'Line', new GeomLine(x1, y1, x2, y2));\r\n\r\n        var width = Math.max(1, this.geom.right - this.geom.left);\r\n        var height = Math.max(1, this.geom.bottom - this.geom.top);\r\n\r\n        /**\r\n         * The width (or thickness) of the line.\r\n         * See the setLineWidth method for extra details on changing this on WebGL.\r\n         *\r\n         * @name Phaser.GameObjects.Line#lineWidth\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.lineWidth = 1;\r\n\r\n        /**\r\n         * Private internal value. Holds the start width of the line.\r\n         *\r\n         * @name Phaser.GameObjects.Line#_startWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._startWidth = 1;\r\n\r\n        /**\r\n         * Private internal value. Holds the end width of the line.\r\n         *\r\n         * @name Phaser.GameObjects.Line#_endWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._endWidth = 1;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(width, height);\r\n\r\n        if (strokeColor !== undefined)\r\n        {\r\n            this.setStrokeStyle(1, strokeColor, strokeAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n    },\r\n\r\n    /**\r\n     * Sets the width of the line.\r\n     *\r\n     * When using the WebGL renderer you can have different start and end widths.\r\n     * When using the Canvas renderer only the `startWidth` value is used. The `endWidth` is ignored.\r\n     *\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Line#setLineWidth\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} startWidth - The start width of the line.\r\n     * @param {number} [endWidth] - The end width of the line. Only used in WebGL.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setLineWidth: function (startWidth, endWidth)\r\n    {\r\n        if (endWidth === undefined) { endWidth = startWidth; }\r\n\r\n        this._startWidth = startWidth;\r\n        this._endWidth = endWidth;\r\n\r\n        this.lineWidth = startWidth;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the start and end coordinates of this Line.\r\n     *\r\n     * @method Phaser.GameObjects.Line#setTo\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} [x1=0] - The horizontal position of the start of the line.\r\n     * @param {number} [y1=0] - The vertical position of the start of the line.\r\n     * @param {number} [x2=0] - The horizontal position of the end of the line.\r\n     * @param {number} [y2=0] - The vertical position of the end of the line.\r\n     *\r\n     * @return {this} This Line object.\r\n     */\r\n    setTo: function (x1, y1, x2, y2)\r\n    {\r\n        this.geom.setTo(x1, y1, x2, y2);\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Line;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Line#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Line} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar LineCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX;\r\n        var dy = src._displayOriginY;\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(src.geom.x1 - dx, src.geom.y1 - dy);\r\n            ctx.lineTo(src.geom.x2 - dx, src.geom.y2 - dy);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = LineCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar Line = require('./Line');\r\n\r\n/**\r\n * Creates a new Line Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Line Game Object has been built into Phaser.\r\n * \r\n * The Line Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports only stroke colors and cannot be filled.\r\n * \r\n * A Line Shape allows you to draw a line between two points in your game. You can control the\r\n * stroke color and thickness of the line. In WebGL only you can also specify a different\r\n * thickness for the start and end of the line, allowing you to render lines that taper-off.\r\n * \r\n * If you need to draw multiple lines in a sequence you may wish to use the Polygon Shape instead.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#line\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [x1=0] - The horizontal position of the start of the line.\r\n * @param {number} [y1=0] - The vertical position of the start of the line.\r\n * @param {number} [x2=128] - The horizontal position of the end of the line.\r\n * @param {number} [y2=0] - The vertical position of the end of the line.\r\n * @param {number} [strokeColor] - The color the line will be drawn in, i.e. 0xff0000 for red.\r\n * @param {number} [strokeAlpha] - The alpha the line will be drawn in. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Line} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('line', function (x, y, x1, y1, x2, y2, strokeColor, strokeAlpha)\r\n{\r\n    return this.displayList.add(new Line(this.scene, x, y, x1, y1, x2, y2, strokeColor, strokeAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./LineWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./LineCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Line#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Line} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar LineWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isStroked)\r\n    {\r\n        var strokeTint = pipeline.strokeTint;\r\n        var color = Utils.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);\r\n\r\n        strokeTint.TL = color;\r\n        strokeTint.TR = color;\r\n        strokeTint.BL = color;\r\n        strokeTint.BR = color;\r\n\r\n        var startWidth = src._startWidth;\r\n        var endWidth = src._endWidth;\r\n\r\n        pipeline.batchLine(\r\n            src.geom.x1 - dx,\r\n            src.geom.y1 - dy,\r\n            src.geom.x2 - dx,\r\n            src.geom.y2 - dy,\r\n            startWidth,\r\n            endWidth,\r\n            1,\r\n            0,\r\n            false,\r\n            result.sprite,\r\n            result.camera\r\n        );\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = LineWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar PolygonRender = require('./PolygonRender');\r\nvar Class = require('../../../utils/Class');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar GetAABB = require('../../../geom/polygon/GetAABB');\r\nvar GeomPolygon = require('../../../geom/polygon/Polygon');\r\nvar Shape = require('../Shape');\r\nvar Smooth = require('../../../geom/polygon/Smooth');\r\n\r\n/**\r\n * @classdesc\r\n * The Polygon Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * The Polygon Shape is created by providing a list of points, which are then used to create an\r\n * internal Polygon geometry object. The points can be set from a variety of formats:\r\n *\r\n * - A string containing paired values separated by a single space: `'40 0 40 20 100 20 100 80 40 80 40 100 0 50'`\r\n * - An array of Point or Vector2 objects: `[new Phaser.Math.Vector2(x1, y1), ...]`\r\n * - An array of objects with public x/y properties: `[obj1, obj2, ...]`\r\n * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\r\n * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`\r\n * \r\n * By default the `x` and `y` coordinates of this Shape refer to the center of it. However, depending\r\n * on the coordinates of the points provided, the final shape may be rendered offset from its origin.\r\n *\r\n * @class Polygon\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {any} [points] - The points that make up the polygon.\r\n * @param {number} [fillColor] - The color the polygon will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the polygon will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Polygon = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        PolygonRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Polygon (scene, x, y, points, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        Shape.call(this, scene, 'Polygon', new GeomPolygon(points));\r\n\r\n        var bounds = GetAABB(this.geom);\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(bounds.width, bounds.height);\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Smooths the polygon over the number of iterations specified.\r\n     * The base polygon data will be updated and replaced with the smoothed values.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Polygon#smooth\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} [iterations=1] - The number of times to apply the polygon smoothing.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    smooth: function (iterations)\r\n    {\r\n        if (iterations === undefined) { iterations = 1; }\r\n\r\n        for (var i = 0; i < iterations; i++)\r\n        {\r\n            Smooth(this.geom);\r\n        }\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Polygon#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var path = [];\r\n        var points = this.geom.points;\r\n\r\n        for (var i = 0; i < points.length; i++)\r\n        {\r\n            path.push(points[i].x, points[i].y);\r\n        }\r\n\r\n        path.push(points[0].x, points[0].y);\r\n\r\n        this.pathIndexes = Earcut(path);\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Polygon;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Polygon#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Polygon} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar PolygonCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX;\r\n        var dy = src._displayOriginY;\r\n\r\n        var path = src.pathData;\r\n        var pathLength = path.length - 1;\r\n\r\n        var px1 = path[0] - dx;\r\n        var py1 = path[1] - dy;\r\n\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(px1, py1);\r\n\r\n        if (!src.closePath)\r\n        {\r\n            pathLength -= 2;\r\n        }\r\n\r\n        for (var i = 2; i < pathLength; i += 2)\r\n        {\r\n            var px2 = path[i] - dx;\r\n            var py2 = path[i + 1] - dy;\r\n\r\n            ctx.lineTo(px2, py2);\r\n        }\r\n\r\n        ctx.closePath();\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = PolygonCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar Polygon = require('./Polygon');\r\n\r\n/**\r\n * Creates a new Polygon Shape Game Object and adds it to the Scene.\r\n * \r\n * Note: This method will only be available if the Polygon Game Object has been built into Phaser.\r\n * \r\n * The Polygon Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * The Polygon Shape is created by providing a list of points, which are then used to create an\r\n * internal Polygon geometry object. The points can be set from a variety of formats:\r\n *\r\n * - An array of Point or Vector2 objects: `[new Phaser.Math.Vector2(x1, y1), ...]`\r\n * - An array of objects with public x/y properties: `[obj1, obj2, ...]`\r\n * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`\r\n * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`\r\n * \r\n * By default the `x` and `y` coordinates of this Shape refer to the center of it. However, depending\r\n * on the coordinates of the points provided, the final shape may be rendered offset from its origin.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#polygon\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {any} [points] - The points that make up the polygon.\r\n * @param {number} [fillColor] - The color the polygon will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the polygon will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Polygon} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('polygon', function (x, y, points, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Polygon(this.scene, x, y, points, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./PolygonWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./PolygonCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillPathWebGL = require('../FillPathWebGL');\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Polygon#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Polygon} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar PolygonWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = PolygonWebGLRenderer;\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../../utils/Class');\nvar GeomRectangle = require('../../../geom/rectangle/Rectangle');\nvar Shape = require('../Shape');\nvar RectangleRender = require('./RectangleRender');\n\n/**\n * @classdesc\n * The Rectangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\n *\n * This shape supports both fill and stroke colors.\n *\n * You can change the size of the rectangle by changing the `width` and `height` properties.\n *\n * @class Rectangle\n * @extends Phaser.GameObjects.Shape\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.13.0\n *\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {number} [width=128] - The width of the rectangle.\n * @param {number} [height=128] - The height of the rectangle.\n * @param {number} [fillColor] - The color the rectangle will be filled with, i.e. 0xff0000 for red.\n * @param {number} [fillAlpha] - The alpha the rectangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\n */\nvar Rectangle = new Class({\n\n    Extends: Shape,\n\n    Mixins: [\n        RectangleRender\n    ],\n\n    initialize:\n\n    function Rectangle (scene, x, y, width, height, fillColor, fillAlpha)\n    {\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = 0; }\n        if (width === undefined) { width = 128; }\n        if (height === undefined) { height = 128; }\n\n        Shape.call(this, scene, 'Rectangle', new GeomRectangle(0, 0, width, height));\n\n        this.setPosition(x, y);\n        this.setSize(width, height);\n\n        if (fillColor !== undefined)\n        {\n            this.setFillStyle(fillColor, fillAlpha);\n        }\n\n        this.updateDisplayOrigin();\n        this.updateData();\n    },\n\n    /**\n     * Sets the internal size of this Game Object, as used for frame or physics body creation.\n     *\n     * This will not change the size that the Game Object is rendered in-game.\n     * For that you need to either set the scale of the Game Object (`setScale`) or call the\n     * `setDisplaySize` method, which is the same thing as changing the scale but allows you\n     * to do so by giving pixel values.\n     *\n     * If you have enabled this Game Object for input, changing the size will _not_ change the\n     * size of the hit area. To do this you should adjust the `input.hitArea` object directly.\n     *\n     * @method Phaser.GameObjects.Rectangle#setSize\n     * @since 3.13.0\n     *\n     * @param {number} width - The width of this Game Object.\n     * @param {number} height - The height of this Game Object.\n     *\n     * @return {this} This Game Object instance.\n     */\n    setSize: function (width, height)\n    {\n        this.width = width;\n        this.height = height;\n\n        this.geom.setSize(width, height);\n\n        this.updateData();\n\n        return this;\n    },\n\n    /**\n     * Internal method that updates the data and path values.\n     *\n     * @method Phaser.GameObjects.Rectangle#updateData\n     * @private\n     * @since 3.13.0\n     *\n     * @return {this} This Game Object instance.\n     */\n    updateData: function ()\n    {\n        var path = [];\n        var rect = this.geom;\n        var line = this._tempLine;\n\n        rect.getLineA(line);\n\n        path.push(line.x1, line.y1, line.x2, line.y2);\n\n        rect.getLineB(line);\n\n        path.push(line.x2, line.y2);\n\n        rect.getLineC(line);\n\n        path.push(line.x2, line.y2);\n\n        rect.getLineD(line);\n\n        path.push(line.x2, line.y2);\n\n        this.pathData = path;\n\n        return this;\n    }\n\n});\n\nmodule.exports = Rectangle;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Rectangle#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Rectangle} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar RectangleCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX;\r\n        var dy = src._displayOriginY;\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fillRect(\r\n                -dx,\r\n                -dy,\r\n                src.width,\r\n                src.height\r\n            );\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.beginPath();\r\n\r\n            ctx.rect(\r\n                -dx,\r\n                -dy,\r\n                src.width,\r\n                src.height\r\n            );\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = RectangleCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar Rectangle = require('./Rectangle');\r\n\r\n/**\r\n * Creates a new Rectangle Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Rectangle Game Object has been built into Phaser.\r\n * \r\n * The Rectangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * You can change the size of the rectangle by changing the `width` and `height` properties.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#rectangle\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the rectangle.\r\n * @param {number} [height=128] - The height of the rectangle.\r\n * @param {number} [fillColor] - The color the rectangle will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the rectangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Rectangle} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('rectangle', function (x, y, width, height, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Rectangle(this.scene, x, y, width, height, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./RectangleWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./RectangleCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Rectangle#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Rectangle} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar RectangleWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        var fillTint = pipeline.fillTint;\r\n        var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);\r\n\r\n        fillTint.TL = fillTintColor;\r\n        fillTint.TR = fillTintColor;\r\n        fillTint.BL = fillTintColor;\r\n        fillTint.BR = fillTintColor;\r\n\r\n        pipeline.batchFillRect(\r\n            -dx,\r\n            -dy,\r\n            src.width,\r\n            src.height\r\n        );\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = RectangleWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar StarRender = require('./StarRender');\r\nvar Class = require('../../../utils/Class');\r\nvar Earcut = require('../../../geom/polygon/Earcut');\r\nvar Shape = require('../Shape');\r\n\r\n/**\r\n * @classdesc\r\n * The Star Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * As the name implies, the Star shape will display a star in your game. You can control several\r\n * aspects of it including the number of points that constitute the star. The default is 5. If\r\n * you change it to 4 it will render as a diamond. If you increase them, you'll get a more spiky\r\n * star shape.\r\n * \r\n * You can also control the inner and outer radius, which is how 'long' each point of the star is.\r\n * Modify these values to create more interesting shapes.\r\n *\r\n * @class Star\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [points=5] - The number of points on the star.\r\n * @param {number} [innerRadius=32] - The inner radius of the star.\r\n * @param {number} [outerRadius=64] - The outer radius of the star.\r\n * @param {number} [fillColor] - The color the star will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the star will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Star = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        StarRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Star (scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (points === undefined) { points = 5; }\r\n        if (innerRadius === undefined) { innerRadius = 32; }\r\n        if (outerRadius === undefined) { outerRadius = 64; }\r\n\r\n        Shape.call(this, scene, 'Star', null);\r\n\r\n        /**\r\n         * Private internal value.\r\n         * The number of points in the star.\r\n         *\r\n         * @name Phaser.GameObjects.Star#_points\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._points = points;\r\n\r\n        /**\r\n         * Private internal value.\r\n         * The inner radius of the star.\r\n         *\r\n         * @name Phaser.GameObjects.Star#_innerRadius\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._innerRadius = innerRadius;\r\n\r\n        /**\r\n         * Private internal value.\r\n         * The outer radius of the star.\r\n         *\r\n         * @name Phaser.GameObjects.Star#_outerRadius\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.13.0\r\n         */\r\n        this._outerRadius = outerRadius;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(outerRadius * 2, outerRadius * 2);\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the number of points that make up the Star shape.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Star#setPoints\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The amount of points the Star will have.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setPoints: function (value)\r\n    {\r\n        this._points = value;\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the inner radius of the Star shape.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Star#setInnerRadius\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The amount to set the inner radius to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setInnerRadius: function (value)\r\n    {\r\n        this._innerRadius = value;\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the outer radius of the Star shape.\r\n     * This call can be chained.\r\n     *\r\n     * @method Phaser.GameObjects.Star#setOuterRadius\r\n     * @since 3.13.0\r\n     * \r\n     * @param {number} value - The amount to set the outer radius to.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setOuterRadius: function (value)\r\n    {\r\n        this._outerRadius = value;\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * The number of points that make up the Star shape.\r\n     *\r\n     * @name Phaser.GameObjects.Star#points\r\n     * @type {number}\r\n     * @default 5\r\n     * @since 3.13.0\r\n     */\r\n    points: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._points;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._points = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The inner radius of the Star shape.\r\n     *\r\n     * @name Phaser.GameObjects.Star#innerRadius\r\n     * @type {number}\r\n     * @default 32\r\n     * @since 3.13.0\r\n     */\r\n    innerRadius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._innerRadius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._innerRadius = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The outer radius of the Star shape.\r\n     *\r\n     * @name Phaser.GameObjects.Star#outerRadius\r\n     * @type {number}\r\n     * @default 64\r\n     * @since 3.13.0\r\n     */\r\n    outerRadius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._outerRadius;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._outerRadius = value;\r\n\r\n            this.updateData();\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Star#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var path = [];\r\n\r\n        var points = this._points;\r\n        var innerRadius = this._innerRadius;\r\n        var outerRadius = this._outerRadius;\r\n\r\n        var rot = Math.PI / 2 * 3;\r\n        var step = Math.PI / points;\r\n\r\n        //  So origin 0.5 = the center of the star\r\n        var x = outerRadius;\r\n        var y = outerRadius;\r\n    \r\n        path.push(x, y + -outerRadius);\r\n\r\n        for (var i = 0; i < points; i++)\r\n        {\r\n            path.push(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);\r\n\r\n            rot += step;\r\n\r\n            path.push(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);\r\n    \r\n            rot += step;\r\n        }\r\n\r\n        path.push(x, y + -outerRadius);\r\n\r\n        this.pathIndexes = Earcut(path);\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Star;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Star#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Star} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar StarCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX;\r\n        var dy = src._displayOriginY;\r\n\r\n        var path = src.pathData;\r\n        var pathLength = path.length - 1;\r\n\r\n        var px1 = path[0] - dx;\r\n        var py1 = path[1] - dy;\r\n\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(px1, py1);\r\n\r\n        if (!src.closePath)\r\n        {\r\n            pathLength -= 2;\r\n        }\r\n\r\n        for (var i = 2; i < pathLength; i += 2)\r\n        {\r\n            var px2 = path[i] - dx;\r\n            var py2 = path[i + 1] - dy;\r\n\r\n            ctx.lineTo(px2, py2);\r\n        }\r\n\r\n        ctx.closePath();\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = StarCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Star = require('./Star');\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Star Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Star Game Object has been built into Phaser.\r\n * \r\n * The Star Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * As the name implies, the Star shape will display a star in your game. You can control several\r\n * aspects of it including the number of points that constitute the star. The default is 5. If\r\n * you change it to 4 it will render as a diamond. If you increase them, you'll get a more spiky\r\n * star shape.\r\n * \r\n * You can also control the inner and outer radius, which is how 'long' each point of the star is.\r\n * Modify these values to create more interesting shapes.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#star\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [points=5] - The number of points on the star.\r\n * @param {number} [innerRadius=32] - The inner radius of the star.\r\n * @param {number} [outerRadius=64] - The outer radius of the star.\r\n * @param {number} [fillColor] - The color the star will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the star will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Star} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('star', function (x, y, points, innerRadius, outerRadius, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Star(this.scene, x, y, points, innerRadius, outerRadius, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./StarWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./StarCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillPathWebGL = require('../FillPathWebGL');\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Star#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Star} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar StarWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = StarWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../../utils/Class');\r\nvar Shape = require('../Shape');\r\nvar GeomTriangle = require('../../../geom/triangle/Triangle');\r\nvar TriangleRender = require('./TriangleRender');\r\n\r\n/**\r\n * @classdesc\r\n * The Triangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * The Triangle consists of 3 lines, joining up to form a triangular shape. You can control the\r\n * position of each point of these lines. The triangle is always closed and cannot have an open\r\n * face. If you require that, consider using a Polygon instead.\r\n *\r\n * @class Triangle\r\n * @extends Phaser.GameObjects.Shape\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.13.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [x1=0] - The horizontal position of the first point in the triangle.\r\n * @param {number} [y1=128] - The vertical position of the first point in the triangle.\r\n * @param {number} [x2=64] - The horizontal position of the second point in the triangle.\r\n * @param {number} [y2=0] - The vertical position of the second point in the triangle.\r\n * @param {number} [x3=128] - The horizontal position of the third point in the triangle.\r\n * @param {number} [y3=128] - The vertical position of the third point in the triangle.\r\n * @param {number} [fillColor] - The color the triangle will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the triangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n */\r\nvar Triangle = new Class({\r\n\r\n    Extends: Shape,\r\n\r\n    Mixins: [\r\n        TriangleRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Triangle (scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (x1 === undefined) { x1 = 0; }\r\n        if (y1 === undefined) { y1 = 128; }\r\n        if (x2 === undefined) { x2 = 64; }\r\n        if (y2 === undefined) { y2 = 0; }\r\n        if (x3 === undefined) { x3 = 128; }\r\n        if (y3 === undefined) { y3 = 128; }\r\n\r\n        Shape.call(this, scene, 'Triangle', new GeomTriangle(x1, y1, x2, y2, x3, y3));\r\n\r\n        var width = this.geom.right - this.geom.left;\r\n        var height = this.geom.bottom - this.geom.top;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(width, height);\r\n\r\n        if (fillColor !== undefined)\r\n        {\r\n            this.setFillStyle(fillColor, fillAlpha);\r\n        }\r\n\r\n        this.updateDisplayOrigin();\r\n        this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Sets the data for the lines that make up this Triangle shape.\r\n     *\r\n     * @method Phaser.GameObjects.Triangle#setTo\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} [x1=0] - The horizontal position of the first point in the triangle.\r\n     * @param {number} [y1=0] - The vertical position of the first point in the triangle.\r\n     * @param {number} [x2=0] - The horizontal position of the second point in the triangle.\r\n     * @param {number} [y2=0] - The vertical position of the second point in the triangle.\r\n     * @param {number} [x3=0] - The horizontal position of the third point in the triangle.\r\n     * @param {number} [y3=0] - The vertical position of the third point in the triangle.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setTo: function (x1, y1, x2, y2, x3, y3)\r\n    {\r\n        this.geom.setTo(x1, y1, x2, y2, x3, y3);\r\n\r\n        return this.updateData();\r\n    },\r\n\r\n    /**\r\n     * Internal method that updates the data and path values.\r\n     *\r\n     * @method Phaser.GameObjects.Triangle#updateData\r\n     * @private\r\n     * @since 3.13.0\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    updateData: function ()\r\n    {\r\n        var path = [];\r\n        var tri = this.geom;\r\n        var line = this._tempLine;\r\n\r\n        tri.getLineA(line);\r\n\r\n        path.push(line.x1, line.y1, line.x2, line.y2);\r\n\r\n        tri.getLineB(line);\r\n\r\n        path.push(line.x2, line.y2);\r\n\r\n        tri.getLineC(line);\r\n\r\n        path.push(line.x2, line.y2);\r\n\r\n        this.pathData = path;\r\n\r\n        return this;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Triangle;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar FillStyleCanvas = require('../FillStyleCanvas');\r\nvar LineStyleCanvas = require('../LineStyleCanvas');\r\nvar SetTransform = require('../../../renderer/canvas/utils/SetTransform');\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Triangle#renderCanvas\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Triangle} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TriangleCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var ctx = renderer.currentContext;\r\n\r\n    if (SetTransform(renderer, ctx, src, camera, parentMatrix))\r\n    {\r\n        var dx = src._displayOriginX;\r\n        var dy = src._displayOriginY;\r\n\r\n        var x1 = src.geom.x1 - dx;\r\n        var y1 = src.geom.y1 - dy;\r\n        var x2 = src.geom.x2 - dx;\r\n        var y2 = src.geom.y2 - dy;\r\n        var x3 = src.geom.x3 - dx;\r\n        var y3 = src.geom.y3 - dy;\r\n\r\n        ctx.beginPath();\r\n\r\n        ctx.moveTo(x1, y1);\r\n        ctx.lineTo(x2, y2);\r\n        ctx.lineTo(x3, y3);\r\n\r\n        ctx.closePath();\r\n\r\n        if (src.isFilled)\r\n        {\r\n            FillStyleCanvas(ctx, src);\r\n\r\n            ctx.fill();\r\n        }\r\n\r\n        if (src.isStroked)\r\n        {\r\n            LineStyleCanvas(ctx, src);\r\n\r\n            ctx.stroke();\r\n        }\r\n\r\n        //  Restore the context saved in SetTransform\r\n        ctx.restore();\r\n    }\r\n};\r\n\r\nmodule.exports = TriangleCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../../GameObjectFactory');\r\nvar Triangle = require('./Triangle');\r\n\r\n/**\r\n * Creates a new Triangle Shape Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Triangle Game Object has been built into Phaser.\r\n * \r\n * The Triangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\r\n * treat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\r\n * it for input or physics. It provides a quick and easy way for you to render this shape in your\r\n * game without using a texture, while still taking advantage of being fully batched in WebGL.\r\n * \r\n * This shape supports both fill and stroke colors.\r\n * \r\n * The Triangle consists of 3 lines, joining up to form a triangular shape. You can control the\r\n * position of each point of these lines. The triangle is always closed and cannot have an open\r\n * face. If you require that, consider using a Polygon instead.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#triangle\r\n * @since 3.13.0\r\n *\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [x1=0] - The horizontal position of the first point in the triangle.\r\n * @param {number} [y1=128] - The vertical position of the first point in the triangle.\r\n * @param {number} [x2=64] - The horizontal position of the second point in the triangle.\r\n * @param {number} [y2=0] - The vertical position of the second point in the triangle.\r\n * @param {number} [x3=128] - The horizontal position of the third point in the triangle.\r\n * @param {number} [y3=128] - The vertical position of the third point in the triangle.\r\n * @param {number} [fillColor] - The color the triangle will be filled with, i.e. 0xff0000 for red.\r\n * @param {number} [fillAlpha] - The alpha the triangle will be filled with. You can also set the alpha of the overall Shape using its `alpha` property.\r\n *\r\n * @return {Phaser.GameObjects.Triangle} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('triangle', function (x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha)\r\n{\r\n    return this.displayList.add(new Triangle(this.scene, x, y, x1, y1, x2, y2, x3, y3, fillColor, fillAlpha));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../../utils/NOOP');\r\nvar renderCanvas = require('../../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./TriangleWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./TriangleCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GetCalcMatrix = require('../../GetCalcMatrix');\r\nvar StrokePathWebGL = require('../StrokePathWebGL');\r\nvar Utils = require('../../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Triangle#renderWebGL\r\n * @since 3.13.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Triangle} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TriangleWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    camera.addToRenderList(src);\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline);\r\n\r\n    var result = GetCalcMatrix(src, camera, parentMatrix);\r\n\r\n    pipeline.calcMatrix.copyFrom(result.calc);\r\n\r\n    var dx = src._displayOriginX;\r\n    var dy = src._displayOriginY;\r\n    var alpha = camera.alpha * src.alpha;\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    if (src.isFilled)\r\n    {\r\n        var fillTint = pipeline.fillTint;\r\n        var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);\r\n\r\n        fillTint.TL = fillTintColor;\r\n        fillTint.TR = fillTintColor;\r\n        fillTint.BL = fillTintColor;\r\n        fillTint.BR = fillTintColor;\r\n\r\n        var x1 = src.geom.x1 - dx;\r\n        var y1 = src.geom.y1 - dy;\r\n        var x2 = src.geom.x2 - dx;\r\n        var y2 = src.geom.y2 - dy;\r\n        var x3 = src.geom.x3 - dx;\r\n        var y3 = src.geom.y3 - dy;\r\n\r\n        pipeline.batchFillTriangle(\r\n            x1,\r\n            y1,\r\n            x2,\r\n            y2,\r\n            x3,\r\n            y3,\r\n            result.sprite,\r\n            result.camera\r\n        );\r\n    }\r\n\r\n    if (src.isStroked)\r\n    {\r\n        StrokePathWebGL(pipeline, src, alpha, dx, dy);\r\n    }\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = TriangleWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar BuildGameObjectAnimation = require('../BuildGameObjectAnimation');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar Sprite = require('./Sprite');\r\n\r\n/**\r\n * Creates a new Sprite Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Sprite Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#sprite\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Sprite.SpriteConfig} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Sprite} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('sprite', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var key = GetAdvancedValue(config, 'key', null);\r\n    var frame = GetAdvancedValue(config, 'frame', null);\r\n\r\n    var sprite = new Sprite(this.scene, 0, 0, key, frame);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, sprite, config);\r\n\r\n    //  Sprite specific config options:\r\n\r\n    BuildGameObjectAnimation(sprite, config);\r\n\r\n    return sprite;\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\nvar Sprite = require('./Sprite');\r\n\r\n/**\r\n * Creates a new Sprite Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Sprite Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#sprite\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\r\n *\r\n * @return {Phaser.GameObjects.Sprite} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('sprite', function (x, y, key, frame)\r\n{\r\n    var sprite = new Sprite(this.scene, x, y, key, frame);\r\n\r\n    this.displayList.add(sprite);\r\n\r\n    return sprite;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Returns an object containing dimensions of the Text object.\r\n *\r\n * @function Phaser.GameObjects.GetTextSize\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.Text} text - The Text object to calculate the size from.\r\n * @param {Phaser.Types.GameObjects.Text.TextMetrics} size - The Text metrics to use when calculating the size.\r\n * @param {string[]} lines - The lines of text to calculate the size from.\r\n *\r\n * @return {Phaser.Types.GameObjects.Text.GetTextSizeObject} An object containing dimensions of the Text object.\r\n */\r\nvar GetTextSize = function (text, size, lines)\r\n{\r\n    var canvas = text.canvas;\r\n    var context = text.context;\r\n    var style = text.style;\r\n\r\n    var lineWidths = [];\r\n    var maxLineWidth = 0;\r\n    var drawnLines = lines.length;\r\n\r\n    if (style.maxLines > 0 && style.maxLines < lines.length)\r\n    {\r\n        drawnLines = style.maxLines;\r\n    }\r\n\r\n    style.syncFont(canvas, context);\r\n\r\n    //  Text Width\r\n\r\n    for (var i = 0; i < drawnLines; i++)\r\n    {\r\n        var lineWidth = style.strokeThickness;\r\n\r\n        lineWidth += context.measureText(lines[i]).width;\r\n\r\n        // Adjust for wrapped text\r\n        if (style.wordWrap)\r\n        {\r\n            lineWidth -= context.measureText(' ').width;\r\n        }\r\n\r\n        lineWidths[i] = Math.ceil(lineWidth);\r\n        maxLineWidth = Math.max(maxLineWidth, lineWidths[i]);\r\n    }\r\n\r\n    //  Text Height\r\n\r\n    var lineHeight = size.fontSize + style.strokeThickness;\r\n    var height = lineHeight * drawnLines;\r\n    var lineSpacing = text.lineSpacing;\r\n\r\n    //  Adjust for line spacing\r\n    if (drawnLines > 1)\r\n    {\r\n        height += lineSpacing * (drawnLines - 1);\r\n    }\r\n\r\n    return {\r\n        width: maxLineWidth,\r\n        height: height,\r\n        lines: drawnLines,\r\n        lineWidths: lineWidths,\r\n        lineSpacing: lineSpacing,\r\n        lineHeight: lineHeight\r\n    };\r\n};\r\n\r\nmodule.exports = GetTextSize;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\n\r\n/**\r\n * Calculates the ascent, descent and fontSize of a given font style.\r\n *\r\n * @function Phaser.GameObjects.MeasureText\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.GameObjects.TextStyle} textStyle - The TextStyle object to measure.\r\n *\r\n * @return {Phaser.Types.GameObjects.Text.TextMetrics} An object containing the ascent, descent and fontSize of the TextStyle.\r\n */\r\nvar MeasureText = function (textStyle)\r\n{\r\n    var canvas = CanvasPool.create(this);\r\n    var context = canvas.getContext('2d');\r\n\r\n    textStyle.syncFont(canvas, context);\r\n\r\n    var metrics = context.measureText(textStyle.testString);\r\n\r\n    if ('actualBoundingBoxAscent' in metrics)\r\n    {\r\n        var ascent = metrics.actualBoundingBoxAscent;\r\n        var descent = metrics.actualBoundingBoxDescent;\r\n\r\n        CanvasPool.remove(canvas);\r\n\r\n        return {\r\n            ascent: ascent,\r\n            descent: descent,\r\n            fontSize: ascent + descent\r\n        };\r\n    }\r\n\r\n    var width = Math.ceil(metrics.width * textStyle.baselineX);\r\n    var baseline = width;\r\n    var height = 2 * baseline;\r\n\r\n    baseline = baseline * textStyle.baselineY | 0;\r\n\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    context.fillStyle = '#f00';\r\n    context.fillRect(0, 0, width, height);\r\n\r\n    context.font = textStyle._font;\r\n\r\n    context.textBaseline = 'alphabetic';\r\n    context.fillStyle = '#000';\r\n    context.fillText(textStyle.testString, 0, baseline);\r\n\r\n    var output = {\r\n        ascent: 0,\r\n        descent: 0,\r\n        fontSize: 0\r\n    };\r\n\r\n    var imagedata = context.getImageData(0, 0, width, height);\r\n    if (!imagedata)\r\n    {\r\n        output.ascent = baseline;\r\n        output.descent = baseline + 6;\r\n        output.fontSize = output.ascent + output.descent;\r\n\r\n        CanvasPool.remove(canvas);\r\n\r\n        return output;\r\n    }\r\n\r\n    var pixels = imagedata.data;\r\n    var numPixels = pixels.length;\r\n    var line = width * 4;\r\n    var i;\r\n    var j;\r\n    var idx = 0;\r\n    var stop = false;\r\n\r\n    // ascent. scan from top to bottom until we find a non red pixel\r\n    for (i = 0; i < baseline; i++)\r\n    {\r\n        for (j = 0; j < line; j += 4)\r\n        {\r\n            if (pixels[idx + j] !== 255)\r\n            {\r\n                stop = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!stop)\r\n        {\r\n            idx += line;\r\n        }\r\n        else\r\n        {\r\n            break;\r\n        }\r\n    }\r\n\r\n    output.ascent = baseline - i;\r\n\r\n    idx = numPixels - line;\r\n    stop = false;\r\n\r\n    // descent. scan from bottom to top until we find a non red pixel\r\n    for (i = height; i > baseline; i--)\r\n    {\r\n        for (j = 0; j < line; j += 4)\r\n        {\r\n            if (pixels[idx + j] !== 255)\r\n            {\r\n                stop = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!stop)\r\n        {\r\n            idx -= line;\r\n        }\r\n        else\r\n        {\r\n            break;\r\n        }\r\n    }\r\n\r\n    output.descent = (i - baseline);\r\n    output.fontSize = output.ascent + output.descent;\r\n\r\n    CanvasPool.remove(canvas);\r\n\r\n    return output;\r\n};\r\n\r\nmodule.exports = MeasureText;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar AddToDOM = require('../../dom/AddToDOM');\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameEvents = require('../../core/events');\r\nvar GameObject = require('../GameObject');\r\nvar GetTextSize = require('./GetTextSize');\r\nvar GetValue = require('../../utils/object/GetValue');\r\nvar RemoveFromDOM = require('../../dom/RemoveFromDOM');\r\nvar TextRender = require('./TextRender');\r\nvar TextStyle = require('./TextStyle');\r\n\r\n/**\r\n * @classdesc\r\n * A Text Game Object.\r\n *\r\n * Text objects work by creating their own internal hidden Canvas and then renders text to it using\r\n * the standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered\r\n * to your game during the render pass.\r\n *\r\n * Because it uses the Canvas API you can take advantage of all the features this offers, such as\r\n * applying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts\r\n * loaded externally, such as Google or TypeKit Web fonts.\r\n *\r\n * **Important:** The font name must be quoted if it contains certain combinations of digits or\r\n * special characters, either when creating the Text object, or when setting the font via `setFont`\r\n * or `setFontFamily`, e.g.:\r\n *\r\n * ```javascript\r\n * this.add.text(0, 0, 'Hello World', { fontFamily: 'Georgia, \"Goudy Bookletter 1911\", Times, serif' });\r\n * ```\r\n *\r\n * ```javascript\r\n * this.add.text(0, 0, 'Hello World', { font: '\"Press Start 2P\"' });\r\n * ```\r\n *\r\n * You can only display fonts that are currently loaded and available to the browser: therefore fonts must\r\n * be pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,\r\n * or have the fonts ready available in the CSS on the page in which your Phaser game resides.\r\n *\r\n * See {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts\r\n * across mobile browsers.\r\n *\r\n * A note on performance: Every time the contents of a Text object changes, i.e. changing the text being\r\n * displayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the\r\n * new texture to the GPU. This can be an expensive operation if used often, or with large quantities of\r\n * Text objects in your game. If you run into performance issues you would be better off using Bitmap Text\r\n * instead, as it benefits from batching and avoids expensive Canvas API calls.\r\n *\r\n * @class Text\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|string[])} text - The text this Text object will display.\r\n * @param {Phaser.Types.GameObjects.Text.TextStyle} style - The text style configuration object.\r\n *\r\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Valid_family_names\r\n */\r\nvar Text = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Crop,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        TextRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Text (scene, x, y, text, style)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        GameObject.call(this, scene, 'Text');\r\n\r\n        /**\r\n         * The renderer in use by this Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.12.0\r\n         */\r\n        this.renderer = scene.sys.renderer;\r\n\r\n        this.setPosition(x, y);\r\n        this.setOrigin(0, 0);\r\n        this.initPipeline();\r\n\r\n        /**\r\n         * The canvas element that the text is rendered to.\r\n         *\r\n         * @name Phaser.GameObjects.Text#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.canvas = CanvasPool.create(this);\r\n\r\n        /**\r\n         * The context of the canvas element that the text is rendered to.\r\n         *\r\n         * @name Phaser.GameObjects.Text#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * The Text Style object.\r\n         *\r\n         * Manages the style of this Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#style\r\n         * @type {Phaser.GameObjects.TextStyle}\r\n         * @since 3.0.0\r\n         */\r\n        this.style = new TextStyle(this, style);\r\n\r\n        /**\r\n         * Whether to automatically round line positions.\r\n         *\r\n         * @name Phaser.GameObjects.Text#autoRound\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.autoRound = true;\r\n\r\n        /**\r\n         * The Regular Expression that is used to split the text up into lines, in\r\n         * multi-line text. By default this is `/(?:\\r\\n|\\r|\\n)/`.\r\n         * You can change this RegExp to be anything else that you may need.\r\n         *\r\n         * @name Phaser.GameObjects.Text#splitRegExp\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.splitRegExp = /(?:\\r\\n|\\r|\\n)/;\r\n\r\n        /**\r\n         * The text to display.\r\n         *\r\n         * @name Phaser.GameObjects.Text#_text\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._text = undefined;\r\n\r\n        /**\r\n         * Specify a padding value which is added to the line width and height when calculating the Text size.\r\n         * Allows you to add extra spacing if the browser is unable to accurately determine the true font dimensions.\r\n         *\r\n         * @name Phaser.GameObjects.Text#padding\r\n         * @type {Phaser.Types.GameObjects.Text.TextPadding}\r\n         * @since 3.0.0\r\n         */\r\n        this.padding = { left: 0, right: 0, top: 0, bottom: 0 };\r\n\r\n        /**\r\n         * The width of this Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#width\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.width = 1;\r\n\r\n        /**\r\n         * The height of this Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#height\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.height = 1;\r\n\r\n        /**\r\n         * The line spacing value.\r\n         * This value is added to the font height to calculate the overall line height.\r\n         * Only has an effect if this Text object contains multiple lines of text.\r\n         *\r\n         * If you update this property directly, instead of using the `setLineSpacing` method, then\r\n         * be sure to call `updateText` after, or you won't see the change reflected in the Text object.\r\n         *\r\n         * @name Phaser.GameObjects.Text#lineSpacing\r\n         * @type {number}\r\n         * @since 3.13.0\r\n         */\r\n        this.lineSpacing = 0;\r\n\r\n        /**\r\n         * Whether the text or its settings have changed and need updating.\r\n         *\r\n         * @name Phaser.GameObjects.Text#dirty\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        //  If resolution wasn't set, force it to 1\r\n        if (this.style.resolution === 0)\r\n        {\r\n            this.style.resolution = 1;\r\n        }\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.Text#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        //  Create a Texture for this Text object\r\n        this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);\r\n\r\n        //  Get the frame\r\n        this.frame = this.texture.get();\r\n\r\n        //  Set the resolution\r\n        this.frame.source.resolution = this.style.resolution;\r\n\r\n        if (this.renderer && this.renderer.gl)\r\n        {\r\n            //  Clear the default 1x1 glTexture, as we override it later\r\n            this.renderer.deleteTexture(this.frame.source.glTexture);\r\n\r\n            this.frame.source.glTexture = null;\r\n        }\r\n\r\n        this.initRTL();\r\n\r\n        this.setText(text);\r\n\r\n        if (style && style.padding)\r\n        {\r\n            this.setPadding(style.padding);\r\n        }\r\n\r\n        if (style && style.lineSpacing)\r\n        {\r\n            this.setLineSpacing(style.lineSpacing);\r\n        }\r\n\r\n        scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function ()\r\n        {\r\n            this.dirty = true;\r\n        }, this);\r\n    },\r\n\r\n    /**\r\n     * Initialize right to left text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#initRTL\r\n     * @since 3.0.0\r\n     */\r\n    initRTL: function ()\r\n    {\r\n        if (!this.style.rtl)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Here is where the crazy starts.\r\n        //\r\n        //  Due to browser implementation issues, you cannot fillText BiDi text to a canvas\r\n        //  that is not part of the DOM. It just completely ignores the direction property.\r\n\r\n        this.canvas.dir = 'rtl';\r\n\r\n        //  Experimental atm, but one day ...\r\n        this.context.direction = 'rtl';\r\n\r\n        //  Add it to the DOM, but hidden within the parent canvas.\r\n        this.canvas.style.display = 'none';\r\n\r\n        AddToDOM(this.canvas, this.scene.sys.canvas);\r\n\r\n        //  And finally we set the x origin\r\n        this.originX = 1;\r\n    },\r\n\r\n    /**\r\n     * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n     * bounds.\r\n     *\r\n     * @method Phaser.GameObjects.Text#runWordWrap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text to perform word wrap detection against.\r\n     *\r\n     * @return {string} The text after wrapping has been applied.\r\n     */\r\n    runWordWrap: function (text)\r\n    {\r\n        var style = this.style;\r\n\r\n        if (style.wordWrapCallback)\r\n        {\r\n            var wrappedLines = style.wordWrapCallback.call(style.wordWrapCallbackScope, text, this);\r\n\r\n            if (Array.isArray(wrappedLines))\r\n            {\r\n                wrappedLines = wrappedLines.join('\\n');\r\n            }\r\n\r\n            return wrappedLines;\r\n        }\r\n        else if (style.wordWrapWidth)\r\n        {\r\n            if (style.wordWrapUseAdvanced)\r\n            {\r\n                return this.advancedWordWrap(text, this.context, this.style.wordWrapWidth);\r\n            }\r\n            else\r\n            {\r\n                return this.basicWordWrap(text, this.context, this.style.wordWrapWidth);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            return text;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Advanced wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n     * bounds. Consecutive spaces will be collapsed and replaced with a single space. Lines will be\r\n     * trimmed of white space before processing. Throws an error if wordWrapWidth is less than a\r\n     * single character.\r\n     *\r\n     * @method Phaser.GameObjects.Text#advancedWordWrap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text to perform word wrap detection against.\r\n     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\r\n     * @param {number} wordWrapWidth - The word wrap width.\r\n     *\r\n     * @return {string} The wrapped text.\r\n     */\r\n    advancedWordWrap: function (text, context, wordWrapWidth)\r\n    {\r\n        var output = '';\r\n\r\n        // Condense consecutive spaces and split into lines\r\n        var lines = text\r\n            .replace(/ +/gi, ' ')\r\n            .split(this.splitRegExp);\r\n\r\n        var linesCount = lines.length;\r\n\r\n        for (var i = 0; i < linesCount; i++)\r\n        {\r\n            var line = lines[i];\r\n            var out = '';\r\n\r\n            // Trim whitespace\r\n            line = line.replace(/^ *|\\s*$/gi, '');\r\n\r\n            // If entire line is less than wordWrapWidth append the entire line and exit early\r\n            var lineWidth = context.measureText(line).width;\r\n\r\n            if (lineWidth < wordWrapWidth)\r\n            {\r\n                output += line + '\\n';\r\n                continue;\r\n            }\r\n\r\n            // Otherwise, calculate new lines\r\n            var currentLineWidth = wordWrapWidth;\r\n\r\n            // Split into words\r\n            var words = line.split(' ');\r\n\r\n            for (var j = 0; j < words.length; j++)\r\n            {\r\n                var word = words[j];\r\n                var wordWithSpace = word + ' ';\r\n                var wordWidth = context.measureText(wordWithSpace).width;\r\n\r\n                if (wordWidth > currentLineWidth)\r\n                {\r\n                    // Break word\r\n                    if (j === 0)\r\n                    {\r\n                        // Shave off letters from word until it's small enough\r\n                        var newWord = wordWithSpace;\r\n\r\n                        while (newWord.length)\r\n                        {\r\n                            newWord = newWord.slice(0, -1);\r\n                            wordWidth = context.measureText(newWord).width;\r\n\r\n                            if (wordWidth <= currentLineWidth)\r\n                            {\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        // If wordWrapWidth is too small for even a single letter, shame user\r\n                        // failure with a fatal error\r\n                        if (!newWord.length)\r\n                        {\r\n                            throw new Error('This text\\'s wordWrapWidth setting is less than a single character!');\r\n                        }\r\n\r\n                        // Replace current word in array with remainder\r\n                        var secondPart = word.substr(newWord.length);\r\n\r\n                        words[j] = secondPart;\r\n\r\n                        // Append first piece to output\r\n                        out += newWord;\r\n                    }\r\n\r\n                    // If existing word length is 0, don't include it\r\n                    var offset = (words[j].length) ? j : j + 1;\r\n\r\n                    // Collapse rest of sentence and remove any trailing white space\r\n                    var remainder = words.slice(offset).join(' ')\r\n                        .replace(/[ \\n]*$/gi, '');\r\n\r\n                    // Prepend remainder to next line\r\n                    lines[i + 1] = remainder + ' ' + (lines[i + 1] || '');\r\n                    linesCount = lines.length;\r\n\r\n                    break; // Processing on this line\r\n\r\n                    // Append word with space to output\r\n                }\r\n                else\r\n                {\r\n                    out += wordWithSpace;\r\n                    currentLineWidth -= wordWidth;\r\n                }\r\n            }\r\n\r\n            // Append processed line to output\r\n            output += out.replace(/[ \\n]*$/gi, '') + '\\n';\r\n        }\r\n\r\n        // Trim the end of the string\r\n        output = output.replace(/[\\s|\\n]*$/gi, '');\r\n\r\n        return output;\r\n    },\r\n\r\n    /**\r\n     * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal\r\n     * bounds. Spaces are not collapsed and whitespace is not trimmed.\r\n     *\r\n     * @method Phaser.GameObjects.Text#basicWordWrap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text to perform word wrap detection against.\r\n     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\r\n     * @param {number} wordWrapWidth - The word wrap width.\r\n     *\r\n     * @return {string} The wrapped text.\r\n     */\r\n    basicWordWrap: function (text, context, wordWrapWidth)\r\n    {\r\n        var result = '';\r\n        var lines = text.split(this.splitRegExp);\r\n        var lastLineIndex = lines.length - 1;\r\n        var whiteSpaceWidth = context.measureText(' ').width;\r\n\r\n        for (var i = 0; i <= lastLineIndex; i++)\r\n        {\r\n            var spaceLeft = wordWrapWidth;\r\n            var words = lines[i].split(' ');\r\n            var lastWordIndex = words.length - 1;\r\n\r\n            for (var j = 0; j <= lastWordIndex; j++)\r\n            {\r\n                var word = words[j];\r\n                var wordWidth = context.measureText(word).width;\r\n                var wordWidthWithSpace = wordWidth;\r\n\r\n                if (j < lastWordIndex)\r\n                {\r\n                    wordWidthWithSpace += whiteSpaceWidth;\r\n                }\r\n\r\n                if (wordWidthWithSpace > spaceLeft)\r\n                {\r\n                    // Skip printing the newline if it's the first word of the line that is greater\r\n                    // than the word wrap width.\r\n                    if (j > 0)\r\n                    {\r\n                        result += '\\n';\r\n                        spaceLeft = wordWrapWidth;\r\n                    }\r\n                }\r\n\r\n                result += word;\r\n\r\n                if (j < lastWordIndex)\r\n                {\r\n                    result += ' ';\r\n                    spaceLeft -= wordWidthWithSpace;\r\n                }\r\n                else\r\n                {\r\n                    spaceLeft -= wordWidth;\r\n                }\r\n            }\r\n\r\n            if (i < lastLineIndex)\r\n            {\r\n                result += '\\n';\r\n            }\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * Runs the given text through this Text objects word wrapping and returns the results as an\r\n     * array, where each element of the array corresponds to a wrapped line of text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#getWrappedText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} text - The text for which the wrapping will be calculated. If unspecified, the Text objects current text will be used.\r\n     *\r\n     * @return {string[]} An array of strings with the pieces of wrapped text.\r\n     */\r\n    getWrappedText: function (text)\r\n    {\r\n        if (text === undefined) { text = this._text; }\r\n\r\n        this.style.syncFont(this.canvas, this.context);\r\n\r\n        var wrappedLines = this.runWordWrap(text);\r\n\r\n        return wrappedLines.split(this.splitRegExp);\r\n    },\r\n\r\n    /**\r\n     * Set the text to display.\r\n     *\r\n     * An array of strings will be joined with `\\n` line breaks.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setText\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|string[])} value - The string, or array of strings, to be set as the content of this Text object.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setText: function (value)\r\n    {\r\n        if (!value && value !== 0)\r\n        {\r\n            value = '';\r\n        }\r\n\r\n        if (Array.isArray(value))\r\n        {\r\n            value = value.join('\\n');\r\n        }\r\n\r\n        if (value !== this._text)\r\n        {\r\n            this._text = value.toString();\r\n\r\n            this.updateText();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the text style.\r\n     *\r\n     * @example\r\n     * text.setStyle({\r\n     *     fontSize: '64px',\r\n     *     fontFamily: 'Arial',\r\n     *     color: '#ffffff',\r\n     *     align: 'center',\r\n     *     backgroundColor: '#ff00ff'\r\n     * });\r\n     *\r\n     * @method Phaser.GameObjects.Text#setStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} style - The style settings to set.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setStyle: function (style)\r\n    {\r\n        return this.style.setStyle(style);\r\n    },\r\n\r\n    /**\r\n     * Set the font.\r\n     *\r\n     * If a string is given, the font family is set.\r\n     *\r\n     * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`\r\n     * properties of that object are set.\r\n     *\r\n     * **Important:** The font name must be quoted if it contains certain combinations of digits or\r\n     * special characters:\r\n     *\r\n     * ```javascript\r\n     * Text.setFont('\"Press Start 2P\"');\r\n     * ```\r\n     *\r\n     * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n     * quoted properly, too:\r\n     *\r\n     * ```javascript\r\n     * Text.setFont('Georgia, \"Goudy Bookletter 1911\", Times, serif');\r\n     * ```\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFont\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} font - The font family or font settings to set.\r\n     *\r\n     * @return {this} This Text object.\r\n     *\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Valid_family_names\r\n     */\r\n    setFont: function (font)\r\n    {\r\n        return this.style.setFont(font);\r\n    },\r\n\r\n    /**\r\n     * Set the font family.\r\n     *\r\n     * **Important:** The font name must be quoted if it contains certain combinations of digits or\r\n     * special characters:\r\n     *\r\n     * ```javascript\r\n     * Text.setFont('\"Press Start 2P\"');\r\n     * ```\r\n     *\r\n     * Equally, if you wish to provide a list of fallback fonts, then you should ensure they are all\r\n     * quoted properly, too:\r\n     *\r\n     * ```javascript\r\n     * Text.setFont('Georgia, \"Goudy Bookletter 1911\", Times, serif');\r\n     * ```\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFontFamily\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} family - The font family.\r\n     *\r\n     * @return {this} This Text object.\r\n     *\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font-family#Valid_family_names\r\n     */\r\n    setFontFamily: function (family)\r\n    {\r\n        return this.style.setFontFamily(family);\r\n    },\r\n\r\n    /**\r\n     * Set the font size.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFontSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} size - The font size.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setFontSize: function (size)\r\n    {\r\n        return this.style.setFontSize(size);\r\n    },\r\n\r\n    /**\r\n     * Set the font style.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFontStyle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} style - The font style.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setFontStyle: function (style)\r\n    {\r\n        return this.style.setFontStyle(style);\r\n    },\r\n\r\n    /**\r\n     * Set a fixed width and height for the text.\r\n     *\r\n     * Pass in `0` for either of these parameters to disable fixed width or height respectively.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFixedSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The fixed width to set. `0` disables fixed width.\r\n     * @param {number} height - The fixed height to set. `0` disables fixed height.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setFixedSize: function (width, height)\r\n    {\r\n        return this.style.setFixedSize(width, height);\r\n    },\r\n\r\n    /**\r\n     * Set the background color.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setBackgroundColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - The background color.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setBackgroundColor: function (color)\r\n    {\r\n        return this.style.setBackgroundColor(color);\r\n    },\r\n\r\n    /**\r\n     * Set the fill style to be used by the Text object.\r\n     *\r\n     * This can be any valid CanvasRenderingContext2D fillStyle value, such as\r\n     * a color (in hex, rgb, rgba, hsl or named values), a gradient or a pattern.\r\n     *\r\n     * See the [MDN fillStyle docs](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle) for more details.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setFill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|any)} color - The text fill style. Can be any valid CanvasRenderingContext `fillStyle` value.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setFill: function (fillStyle)\r\n    {\r\n        return this.style.setFill(fillStyle);\r\n    },\r\n\r\n    /**\r\n     * Set the text fill color.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - The text fill color.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setColor: function (color)\r\n    {\r\n        return this.style.setColor(color);\r\n    },\r\n\r\n    /**\r\n     * Set the stroke settings.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setStroke\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - The stroke color.\r\n     * @param {number} thickness - The stroke thickness.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setStroke: function (color, thickness)\r\n    {\r\n        return this.style.setStroke(color, thickness);\r\n    },\r\n\r\n    /**\r\n     * Set the shadow settings.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadow\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal shadow offset.\r\n     * @param {number} [y=0] - The vertical shadow offset.\r\n     * @param {string} [color='#000'] - The shadow color.\r\n     * @param {number} [blur=0] - The shadow blur radius.\r\n     * @param {boolean} [shadowStroke=false] - Whether to stroke the shadow.\r\n     * @param {boolean} [shadowFill=true] - Whether to fill the shadow.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)\r\n    {\r\n        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);\r\n    },\r\n\r\n    /**\r\n     * Set the shadow offset.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - The horizontal shadow offset.\r\n     * @param {number} y - The vertical shadow offset.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setShadowOffset: function (x, y)\r\n    {\r\n        return this.style.setShadowOffset(x, y);\r\n    },\r\n\r\n    /**\r\n     * Set the shadow color.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowColor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} color - The shadow color.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setShadowColor: function (color)\r\n    {\r\n        return this.style.setShadowColor(color);\r\n    },\r\n\r\n    /**\r\n     * Set the shadow blur radius.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowBlur\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} blur - The shadow blur radius.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setShadowBlur: function (blur)\r\n    {\r\n        return this.style.setShadowBlur(blur);\r\n    },\r\n\r\n    /**\r\n     * Enable or disable shadow stroke.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowStroke\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} enabled - Whether shadow stroke is enabled or not.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setShadowStroke: function (enabled)\r\n    {\r\n        return this.style.setShadowStroke(enabled);\r\n    },\r\n\r\n    /**\r\n     * Enable or disable shadow fill.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setShadowFill\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} enabled - Whether shadow fill is enabled or not.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setShadowFill: function (enabled)\r\n    {\r\n        return this.style.setShadowFill(enabled);\r\n    },\r\n\r\n    /**\r\n     * Set the width (in pixels) to use for wrapping lines. Pass in null to remove wrapping by width.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setWordWrapWidth\r\n     * @since 3.0.0\r\n     *\r\n     * @param {?number} width - The maximum width of a line in pixels. Set to null to remove wrapping.\r\n     * @param {boolean} [useAdvancedWrap=false] - Whether or not to use the advanced wrapping\r\n     * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,\r\n     * spaces and whitespace are left as is.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setWordWrapWidth: function (width, useAdvancedWrap)\r\n    {\r\n        return this.style.setWordWrapWidth(width, useAdvancedWrap);\r\n    },\r\n\r\n    /**\r\n     * Set a custom callback for wrapping lines. Pass in null to remove wrapping by callback.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setWordWrapCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {TextStyleWordWrapCallback} callback - A custom function that will be responsible for wrapping the\r\n     * text. It will receive two arguments: text (the string to wrap), textObject (this Text\r\n     * instance). It should return the wrapped lines either as an array of lines or as a string with\r\n     * newline characters in place to indicate where breaks should happen.\r\n     * @param {object} [scope=null] - The scope that will be applied when the callback is invoked.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setWordWrapCallback: function (callback, scope)\r\n    {\r\n        return this.style.setWordWrapCallback(callback, scope);\r\n    },\r\n\r\n    /**\r\n     * Set the alignment of the text in this Text object.\r\n     *\r\n     * The argument can be one of: `left`, `right`, `center` or `justify`.\r\n     *\r\n     * Alignment only works if the Text object has more than one line of text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setAlign\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} [align='left'] - The text alignment for multi-line text.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setAlign: function (align)\r\n    {\r\n        return this.style.setAlign(align);\r\n    },\r\n\r\n    /**\r\n     * Set the resolution used by this Text object.\r\n     *\r\n     * By default it will be set to match the resolution set in the Game Config,\r\n     * but you can override it via this method, or by specifying it in the Text style configuration object.\r\n     *\r\n     * It allows for much clearer text on High DPI devices, at the cost of memory because it uses larger\r\n     * internal Canvas textures for the Text.\r\n     *\r\n     * Therefore, please use with caution, as the more high res Text you have, the more memory it uses.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setResolution\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} value - The resolution for this Text object to use.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setResolution: function (value)\r\n    {\r\n        return this.style.setResolution(value);\r\n    },\r\n\r\n    /**\r\n     * Sets the line spacing value.\r\n     *\r\n     * This value is _added_ to the height of the font when calculating the overall line height.\r\n     * This only has an effect if this Text object consists of multiple lines of text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setLineSpacing\r\n     * @since 3.13.0\r\n     *\r\n     * @param {number} value - The amount to add to the font height to achieve the overall line height.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setLineSpacing: function (value)\r\n    {\r\n        this.lineSpacing = value;\r\n\r\n        return this.updateText();\r\n    },\r\n\r\n    /**\r\n     * Set the text padding.\r\n     *\r\n     * 'left' can be an object.\r\n     *\r\n     * If only 'left' and 'top' are given they are treated as 'x' and 'y'.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setPadding\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(number|Phaser.Types.GameObjects.Text.TextPadding)} left - The left padding value, or a padding config object.\r\n     * @param {number} [top] - The top padding value.\r\n     * @param {number} [right] - The right padding value.\r\n     * @param {number} [bottom] - The bottom padding value.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setPadding: function (left, top, right, bottom)\r\n    {\r\n        if (typeof left === 'object')\r\n        {\r\n            var config = left;\r\n\r\n            //  If they specify x and/or y this applies to all\r\n            var x = GetValue(config, 'x', null);\r\n\r\n            if (x !== null)\r\n            {\r\n                left = x;\r\n                right = x;\r\n            }\r\n            else\r\n            {\r\n                left = GetValue(config, 'left', 0);\r\n                right = GetValue(config, 'right', left);\r\n            }\r\n\r\n            var y = GetValue(config, 'y', null);\r\n\r\n            if (y !== null)\r\n            {\r\n                top = y;\r\n                bottom = y;\r\n            }\r\n            else\r\n            {\r\n                top = GetValue(config, 'top', 0);\r\n                bottom = GetValue(config, 'bottom', top);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (left === undefined) { left = 0; }\r\n            if (top === undefined) { top = left; }\r\n            if (right === undefined) { right = left; }\r\n            if (bottom === undefined) { bottom = top; }\r\n        }\r\n\r\n        this.padding.left = left;\r\n        this.padding.top = top;\r\n        this.padding.right = right;\r\n        this.padding.bottom = bottom;\r\n\r\n        return this.updateText();\r\n    },\r\n\r\n    /**\r\n     * Set the maximum number of lines to draw.\r\n     *\r\n     * @method Phaser.GameObjects.Text#setMaxLines\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [max=0] - The maximum number of lines to draw.\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    setMaxLines: function (max)\r\n    {\r\n        return this.style.setMaxLines(max);\r\n    },\r\n\r\n    /**\r\n     * Update the displayed text.\r\n     *\r\n     * @method Phaser.GameObjects.Text#updateText\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Text object.\r\n     */\r\n    updateText: function ()\r\n    {\r\n        var canvas = this.canvas;\r\n        var context = this.context;\r\n        var style = this.style;\r\n        var resolution = style.resolution;\r\n        var size = style.metrics;\r\n\r\n        style.syncFont(canvas, context);\r\n\r\n        var outputText = this._text;\r\n\r\n        if (style.wordWrapWidth || style.wordWrapCallback)\r\n        {\r\n            outputText = this.runWordWrap(this._text);\r\n        }\r\n\r\n        //  Split text into lines\r\n        var lines = outputText.split(this.splitRegExp);\r\n\r\n        var textSize = GetTextSize(this, size, lines);\r\n\r\n        var padding = this.padding;\r\n\r\n        var textWidth;\r\n\r\n        if (style.fixedWidth === 0)\r\n        {\r\n            this.width = textSize.width + padding.left + padding.right;\r\n\r\n            textWidth = textSize.width;\r\n        }\r\n        else\r\n        {\r\n            this.width = style.fixedWidth;\r\n\r\n            textWidth = this.width - padding.left - padding.right;\r\n\r\n            if (textWidth < textSize.width)\r\n            {\r\n                textWidth = textSize.width;\r\n            }\r\n        }\r\n\r\n        if (style.fixedHeight === 0)\r\n        {\r\n            this.height = textSize.height + padding.top + padding.bottom;\r\n        }\r\n        else\r\n        {\r\n            this.height = style.fixedHeight;\r\n        }\r\n\r\n        var w = this.width;\r\n        var h = this.height;\r\n\r\n        this.updateDisplayOrigin();\r\n\r\n        w *= resolution;\r\n        h *= resolution;\r\n\r\n        w = Math.max(w, 1);\r\n        h = Math.max(h, 1);\r\n\r\n        if (canvas.width !== w || canvas.height !== h)\r\n        {\r\n            canvas.width = w;\r\n            canvas.height = h;\r\n\r\n            this.frame.setSize(w, h);\r\n\r\n            //  Because resizing the canvas resets the context\r\n            style.syncFont(canvas, context);\r\n        }\r\n        else\r\n        {\r\n            context.clearRect(0, 0, w, h);\r\n        }\r\n\r\n        context.save();\r\n\r\n        context.scale(resolution, resolution);\r\n\r\n        if (style.backgroundColor)\r\n        {\r\n            context.fillStyle = style.backgroundColor;\r\n            context.fillRect(0, 0, w, h);\r\n        }\r\n\r\n        style.syncStyle(canvas, context);\r\n\r\n        context.textBaseline = 'alphabetic';\r\n\r\n        //  Apply padding\r\n        context.translate(padding.left, padding.top);\r\n\r\n        var linePositionX;\r\n        var linePositionY;\r\n\r\n        //  Draw text line by line\r\n        for (var i = 0; i < textSize.lines; i++)\r\n        {\r\n            linePositionX = style.strokeThickness / 2;\r\n            linePositionY = (style.strokeThickness / 2 + i * textSize.lineHeight) + size.ascent;\r\n\r\n            if (i > 0)\r\n            {\r\n                linePositionY += (textSize.lineSpacing * i);\r\n            }\r\n\r\n            if (style.rtl)\r\n            {\r\n                linePositionX = w - linePositionX;\r\n            }\r\n            else if (style.align === 'right')\r\n            {\r\n                linePositionX += textWidth - textSize.lineWidths[i];\r\n            }\r\n            else if (style.align === 'center')\r\n            {\r\n                linePositionX += (textWidth - textSize.lineWidths[i]) / 2;\r\n            }\r\n            else if (style.align === 'justify')\r\n            {\r\n                //  To justify text line its width must be no less than 85% of defined width\r\n                var minimumLengthToApplyJustification = 0.85;\r\n\r\n                if (textSize.lineWidths[i] / textSize.width >= minimumLengthToApplyJustification)\r\n                {\r\n                    var extraSpace = textSize.width - textSize.lineWidths[i];\r\n                    var spaceSize = context.measureText(' ').width;\r\n                    var trimmedLine = lines[i].trim();\r\n                    var array = trimmedLine.split(' ');\r\n\r\n                    extraSpace += (lines[i].length - trimmedLine.length) * spaceSize;\r\n\r\n                    var extraSpaceCharacters = Math.floor(extraSpace / spaceSize);\r\n                    var idx = 0;\r\n\r\n                    while (extraSpaceCharacters > 0)\r\n                    {\r\n                        array[idx] += ' ';\r\n                        idx = (idx + 1) % (array.length - 1 || 1);\r\n                        --extraSpaceCharacters;\r\n                    }\r\n\r\n                    lines[i] = array.join(' ');\r\n                }\r\n            }\r\n\r\n            if (this.autoRound)\r\n            {\r\n                linePositionX = Math.round(linePositionX);\r\n                linePositionY = Math.round(linePositionY);\r\n            }\r\n\r\n            if (style.strokeThickness)\r\n            {\r\n                this.style.syncShadow(context, style.shadowStroke);\r\n\r\n                context.strokeText(lines[i], linePositionX, linePositionY);\r\n            }\r\n\r\n            if (style.color)\r\n            {\r\n                this.style.syncShadow(context, style.shadowFill);\r\n\r\n                context.fillText(lines[i], linePositionX, linePositionY);\r\n            }\r\n        }\r\n\r\n        context.restore();\r\n\r\n        if (this.renderer && this.renderer.gl)\r\n        {\r\n            this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);\r\n\r\n            this.frame.glTexture = this.frame.source.glTexture;\r\n        }\r\n\r\n        this.dirty = true;\r\n\r\n        var input = this.input;\r\n\r\n        if (input && !input.customHitArea)\r\n        {\r\n            input.hitArea.width = this.width;\r\n            input.hitArea.height = this.height;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Get the current text metrics.\r\n     *\r\n     * @method Phaser.GameObjects.Text#getTextMetrics\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.Text.TextMetrics} The text metrics.\r\n     */\r\n    getTextMetrics: function ()\r\n    {\r\n        return this.style.getTextMetrics();\r\n    },\r\n\r\n    /**\r\n     * The text string being rendered by this Text Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#text\r\n     * @type {string}\r\n     * @since 3.0.0\r\n     */\r\n    text: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._text;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.setText(value);\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Build a JSON representation of the Text object.\r\n     *\r\n     * @method Phaser.GameObjects.Text#toJSON\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Types.GameObjects.JSONGameObject} A JSON representation of the Text object.\r\n     */\r\n    toJSON: function ()\r\n    {\r\n        var out = Components.ToJSON(this);\r\n\r\n        //  Extra Text data is added here\r\n\r\n        var data = {\r\n            autoRound: this.autoRound,\r\n            text: this._text,\r\n            style: this.style.toJSON(),\r\n            padding: {\r\n                left: this.padding.left,\r\n                right: this.padding.right,\r\n                top: this.padding.top,\r\n                bottom: this.padding.bottom\r\n            }\r\n        };\r\n\r\n        out.data = data;\r\n\r\n        return out;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Text#preDestroy\r\n     * @protected\r\n     * @since 3.0.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (this.style.rtl)\r\n        {\r\n            RemoveFromDOM(this.canvas);\r\n        }\r\n\r\n        CanvasPool.remove(this.canvas);\r\n\r\n        this.texture.destroy();\r\n    }\r\n\r\n    /**\r\n     * The horizontal origin of this Game Object.\r\n     * The origin maps the relationship between the size and position of the Game Object.\r\n     * The default value is 0.5, meaning all Game Objects are positioned based on their center.\r\n     * Setting the value to 0 means the position now relates to the left of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#originX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n\r\n    /**\r\n     * The vertical origin of this Game Object.\r\n     * The origin maps the relationship between the size and position of the Game Object.\r\n     * The default value is 0.5, meaning all Game Objects are positioned based on their center.\r\n     * Setting the value to 0 means the position now relates to the top of the Game Object.\r\n     *\r\n     * @name Phaser.GameObjects.Text#originY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n\r\n});\r\n\r\nmodule.exports = Text;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Text#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TextCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (src.width === 0 || src.height === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = TextCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar Text = require('./Text');\r\n\r\n/**\r\n * Creates a new Text Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#text\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.Text.TextConfig} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Text} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('text', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    // style Object = {\r\n    //     font: [ 'font', '16px Courier' ],\r\n    //     backgroundColor: [ 'backgroundColor', null ],\r\n    //     fill: [ 'fill', '#fff' ],\r\n    //     stroke: [ 'stroke', '#fff' ],\r\n    //     strokeThickness: [ 'strokeThickness', 0 ],\r\n    //     shadowOffsetX: [ 'shadow.offsetX', 0 ],\r\n    //     shadowOffsetY: [ 'shadow.offsetY', 0 ],\r\n    //     shadowColor: [ 'shadow.color', '#000' ],\r\n    //     shadowBlur: [ 'shadow.blur', 0 ],\r\n    //     shadowStroke: [ 'shadow.stroke', false ],\r\n    //     shadowFill: [ 'shadow.fill', false ],\r\n    //     align: [ 'align', 'left' ],\r\n    //     maxLines: [ 'maxLines', 0 ],\r\n    //     fixedWidth: [ 'fixedWidth', false ],\r\n    //     fixedHeight: [ 'fixedHeight', false ],\r\n    //     rtl: [ 'rtl', false ]\r\n    // }\r\n\r\n    var content = GetAdvancedValue(config, 'text', '');\r\n    var style = GetAdvancedValue(config, 'style', null);\r\n\r\n    //  Padding\r\n    //      { padding: 2 }\r\n    //      { padding: { x: , y: }}\r\n    //      { padding: { left: , top: }}\r\n    //      { padding: { left: , right: , top: , bottom: }}\r\n\r\n    var padding = GetAdvancedValue(config, 'padding', null);\r\n\r\n    if (padding !== null)\r\n    {\r\n        style.padding = padding;\r\n    }\r\n\r\n    var text = new Text(this.scene, 0, 0, content, style);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, text, config);\r\n\r\n    //  Text specific config options:\r\n\r\n    text.autoRound = GetAdvancedValue(config, 'autoRound', true);\r\n    text.resolution = GetAdvancedValue(config, 'resolution', 1);\r\n\r\n    return text;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Text = require('./Text');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Text Game Object and adds it to the Scene.\r\n *\r\n * A Text Game Object.\r\n *\r\n * Text objects work by creating their own internal hidden Canvas and then renders text to it using\r\n * the standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered\r\n * to your game during the render pass.\r\n *\r\n * Because it uses the Canvas API you can take advantage of all the features this offers, such as\r\n * applying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts\r\n * loaded externally, such as Google or TypeKit Web fonts.\r\n *\r\n * You can only display fonts that are currently loaded and available to the browser: therefore fonts must\r\n * be pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,\r\n * or have the fonts ready available in the CSS on the page in which your Phaser game resides.\r\n *\r\n * See {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts\r\n * across mobile browsers.\r\n *\r\n * A note on performance: Every time the contents of a Text object changes, i.e. changing the text being\r\n * displayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the\r\n * new texture to the GPU. This can be an expensive operation if used often, or with large quantities of\r\n * Text objects in your game. If you run into performance issues you would be better off using Bitmap Text\r\n * instead, as it benefits from batching and avoids expensive Canvas API calls.\r\n *\r\n * Note: This method will only be available if the Text Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#text\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {(string|string[])} text - The text this Text object will display.\r\n * @param {Phaser.Types.GameObjects.Text.TextStyle} [style] - The Text style configuration object.\r\n *\r\n * @return {Phaser.GameObjects.Text} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('text', function (x, y, text, style)\r\n{\r\n    return this.displayList.add(new Text(this.scene, x, y, text, style));\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./TextWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./TextCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\nvar GetValue = require('../../utils/object/GetValue');\nvar MeasureText = require('./MeasureText');\n\n//  Key: [ Object Key, Default Value ]\n\nvar propertyMap = {\n    fontFamily: [ 'fontFamily', 'Courier' ],\n    fontSize: [ 'fontSize', '16px' ],\n    fontStyle: [ 'fontStyle', '' ],\n    backgroundColor: [ 'backgroundColor', null ],\n    color: [ 'color', '#fff' ],\n    stroke: [ 'stroke', '#fff' ],\n    strokeThickness: [ 'strokeThickness', 0 ],\n    shadowOffsetX: [ 'shadow.offsetX', 0 ],\n    shadowOffsetY: [ 'shadow.offsetY', 0 ],\n    shadowColor: [ 'shadow.color', '#000' ],\n    shadowBlur: [ 'shadow.blur', 0 ],\n    shadowStroke: [ 'shadow.stroke', false ],\n    shadowFill: [ 'shadow.fill', false ],\n    align: [ 'align', 'left' ],\n    maxLines: [ 'maxLines', 0 ],\n    fixedWidth: [ 'fixedWidth', 0 ],\n    fixedHeight: [ 'fixedHeight', 0 ],\n    resolution: [ 'resolution', 0 ],\n    rtl: [ 'rtl', false ],\n    testString: [ 'testString', '|Mqgy' ],\n    baselineX: [ 'baselineX', 1.2 ],\n    baselineY: [ 'baselineY', 1.4 ],\n    wordWrapWidth: [ 'wordWrap.width', null ],\n    wordWrapCallback: [ 'wordWrap.callback', null ],\n    wordWrapCallbackScope: [ 'wordWrap.callbackScope', null ],\n    wordWrapUseAdvanced: [ 'wordWrap.useAdvancedWrap', false ]\n};\n\n/**\n * @classdesc\n * A TextStyle class manages all of the style settings for a Text object.\n *\n * Text Game Objects create a TextStyle instance automatically, which is\n * accessed via the `Text.style` property. You do not normally need to\n * instantiate one yourself.\n *\n * @class TextStyle\n * @memberof Phaser.GameObjects\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.GameObjects.Text} text - The Text object that this TextStyle is styling.\n * @param {Phaser.Types.GameObjects.Text.TextStyle} style - The style settings to set.\n */\nvar TextStyle = new Class({\n\n    initialize:\n\n    function TextStyle (text, style)\n    {\n        /**\n         * The Text object that this TextStyle is styling.\n         *\n         * @name Phaser.GameObjects.TextStyle#parent\n         * @type {Phaser.GameObjects.Text}\n         * @since 3.0.0\n         */\n        this.parent = text;\n\n        /**\n         * The font family.\n         *\n         * @name Phaser.GameObjects.TextStyle#fontFamily\n         * @type {string}\n         * @default 'Courier'\n         * @since 3.0.0\n         */\n        this.fontFamily;\n\n        /**\n         * The font size.\n         *\n         * @name Phaser.GameObjects.TextStyle#fontSize\n         * @type {string}\n         * @default '16px'\n         * @since 3.0.0\n         */\n        this.fontSize;\n\n        /**\n         * The font style.\n         *\n         * @name Phaser.GameObjects.TextStyle#fontStyle\n         * @type {string}\n         * @since 3.0.0\n         */\n        this.fontStyle;\n\n        /**\n         * The background color.\n         *\n         * @name Phaser.GameObjects.TextStyle#backgroundColor\n         * @type {string}\n         * @since 3.0.0\n         */\n        this.backgroundColor;\n\n        /**\n         * The text fill color.\n         *\n         * @name Phaser.GameObjects.TextStyle#color\n         * @type {string}\n         * @default '#fff'\n         * @since 3.0.0\n         */\n        this.color;\n\n        /**\n         * The text stroke color.\n         *\n         * @name Phaser.GameObjects.TextStyle#stroke\n         * @type {string}\n         * @default '#fff'\n         * @since 3.0.0\n         */\n        this.stroke;\n\n        /**\n         * The text stroke thickness.\n         *\n         * @name Phaser.GameObjects.TextStyle#strokeThickness\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.strokeThickness;\n\n        /**\n         * The horizontal shadow offset.\n         *\n         * @name Phaser.GameObjects.TextStyle#shadowOffsetX\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.shadowOffsetX;\n\n        /**\n         * The vertical shadow offset.\n         *\n         * @name Phaser.GameObjects.TextStyle#shadowOffsetY\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.shadowOffsetY;\n\n        /**\n         * The shadow color.\n         *\n         * @name Phaser.GameObjects.TextStyle#shadowColor\n         * @type {string}\n         * @default '#000'\n         * @since 3.0.0\n         */\n        this.shadowColor;\n\n        /**\n         * The shadow blur radius.\n         *\n         * @name Phaser.GameObjects.TextStyle#shadowBlur\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.shadowBlur;\n\n        /**\n         * Whether shadow stroke is enabled or not.\n         *\n         * @name Phaser.GameObjects.TextStyle#shadowStroke\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.shadowStroke;\n\n        /**\n         * Whether shadow fill is enabled or not.\n         *\n         * @name Phaser.GameObjects.TextStyle#shadowFill\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.shadowFill;\n\n        /**\n         * The text alignment.\n         *\n         * @name Phaser.GameObjects.TextStyle#align\n         * @type {string}\n         * @default 'left'\n         * @since 3.0.0\n         */\n        this.align;\n\n        /**\n         * The maximum number of lines to draw.\n         *\n         * @name Phaser.GameObjects.TextStyle#maxLines\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.maxLines;\n\n        /**\n         * The fixed width of the text.\n         *\n         * `0` means no fixed with.\n         *\n         * @name Phaser.GameObjects.TextStyle#fixedWidth\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.fixedWidth;\n\n        /**\n         * The fixed height of the text.\n         *\n         * `0` means no fixed height.\n         *\n         * @name Phaser.GameObjects.TextStyle#fixedHeight\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.fixedHeight;\n\n        /**\n         * The resolution the text is rendered to its internal canvas at.\n         * The default is 0, which means it will use the resolution set in the Game Config.\n         *\n         * @name Phaser.GameObjects.TextStyle#resolution\n         * @type {number}\n         * @default 0\n         * @since 3.12.0\n         */\n        this.resolution;\n\n        /**\n         * Whether the text should render right to left.\n         *\n         * @name Phaser.GameObjects.TextStyle#rtl\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.rtl;\n\n        /**\n         * The test string to use when measuring the font.\n         *\n         * @name Phaser.GameObjects.TextStyle#testString\n         * @type {string}\n         * @default '|Mqgy'\n         * @since 3.0.0\n         */\n        this.testString;\n\n        /**\n         * The amount of horizontal padding added to the width of the text when calculating the font metrics.\n         *\n         * @name Phaser.GameObjects.TextStyle#baselineX\n         * @type {number}\n         * @default 1.2\n         * @since 3.3.0\n         */\n        this.baselineX;\n\n        /**\n         * The amount of vertical padding added to the height of the text when calculating the font metrics.\n         *\n         * @name Phaser.GameObjects.TextStyle#baselineY\n         * @type {number}\n         * @default 1.4\n         * @since 3.3.0\n         */\n        this.baselineY;\n\n        /**\n         * The maximum width of a line of text in pixels. Null means no line wrapping. Setting this\n         * property directly will not re-run the word wrapping algorithm. To change the width and\n         * re-wrap, use {@link Phaser.GameObjects.TextStyle#setWordWrapWidth}.\n         *\n         * @name Phaser.GameObjects.TextStyle#wordWrapWidth\n         * @type {number | null}\n         * @default null\n         * @since 3.24.0\n         */\n        this.wordWrapWidth;\n\n        /**\n         * A custom function that will be responsible for wrapping the text. It will receive two\n         * arguments: text (the string to wrap), textObject (this Text instance). It should return\n         * the wrapped lines either as an array of lines or as a string with newline characters in\n         * place to indicate where breaks should happen. Setting this directly will not re-run the\n         * word wrapping algorithm. To change the callback and re-wrap, use\n         * {@link Phaser.GameObjects.TextStyle#setWordWrapCallback}.\n         *\n         * @name Phaser.GameObjects.TextStyle#wordWrapCallback\n         * @type {TextStyleWordWrapCallback | null}\n         * @default null\n         * @since 3.24.0\n         */\n        this.wordWrapCallback;\n\n        /**\n         * The scope that will be applied when the wordWrapCallback is invoked. Setting this directly will not re-run the\n         * word wrapping algorithm. To change the callback and re-wrap, use\n         * {@link Phaser.GameObjects.TextStyle#setWordWrapCallback}.\n         *\n         * @name Phaser.GameObjects.TextStyle#wordWrapCallbackScope\n         * @type {object | null}\n         * @default null\n         * @since 3.24.0\n         */\n        this.wordWrapCallbackScope;\n\n        /**\n         * Whether or not to use the advanced wrapping algorithm. If true, spaces are collapsed and\n         * whitespace is trimmed from lines. If false, spaces and whitespace are left as is. Setting\n         * this property directly will not re-run the word wrapping algorithm. To change the\n         * advanced setting and re-wrap, use {@link Phaser.GameObjects.TextStyle#setWordWrapWidth}.\n         *\n         * @name Phaser.GameObjects.TextStyle#wordWrapUseAdvanced\n         * @type {boolean}\n         * @default false\n         * @since 3.24.0\n         */\n        this.wordWrapUseAdvanced;\n\n        /**\n         * The font style, size and family.\n         *\n         * @name Phaser.GameObjects.TextStyle#_font\n         * @type {string}\n         * @private\n         * @since 3.0.0\n         */\n        this._font;\n\n        //  Set to defaults + user style\n        this.setStyle(style, false, true);\n\n        var metrics = GetValue(style, 'metrics', false);\n\n        //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning\n        //  Doing this is reset if you then change the font of this TextStyle after creation\n        if (metrics)\n        {\n            this.metrics = {\n                ascent: GetValue(metrics, 'ascent', 0),\n                descent: GetValue(metrics, 'descent', 0),\n                fontSize: GetValue(metrics, 'fontSize', 0)\n            };\n        }\n        else\n        {\n            this.metrics = MeasureText(this);\n        }\n    },\n\n    /**\n     * Set the text style.\n     *\n     * @example\n     * text.setStyle({\n     *     fontSize: '64px',\n     *     fontFamily: 'Arial',\n     *     color: '#ffffff',\n     *     align: 'center',\n     *     backgroundColor: '#ff00ff'\n     * });\n     *\n     * @method Phaser.GameObjects.TextStyle#setStyle\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.GameObjects.Text.TextStyle} style - The style settings to set.\n     * @param {boolean} [updateText=true] - Whether to update the text immediately.\n     * @param {boolean} [setDefaults=false] - Use the default values is not set, or the local values.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setStyle: function (style, updateText, setDefaults)\n    {\n        if (updateText === undefined) { updateText = true; }\n        if (setDefaults === undefined) { setDefaults = false; }\n\n        //  Avoid type mutation\n        // eslint-disable-next-line no-prototype-builtins\n        if (style && style.hasOwnProperty('fontSize') && typeof style.fontSize === 'number')\n        {\n            style.fontSize = style.fontSize.toString() + 'px';\n        }\n\n        for (var key in propertyMap)\n        {\n            var value = (setDefaults) ? propertyMap[key][1] : this[key];\n\n            if (key === 'wordWrapCallback' || key === 'wordWrapCallbackScope')\n            {\n                // Callback & scope should be set without processing the values\n                this[key] = GetValue(style, propertyMap[key][0], value);\n            }\n            else\n            {\n                this[key] = GetAdvancedValue(style, propertyMap[key][0], value);\n            }\n        }\n\n        //  Allow for 'font' override\n        var font = GetValue(style, 'font', null);\n\n        if (font !== null)\n        {\n            this.setFont(font, false);\n        }\n\n        this._font = [ this.fontStyle, this.fontSize, this.fontFamily ].join(' ').trim();\n\n        //  Allow for 'fill' to be used in place of 'color'\n        var fill = GetValue(style, 'fill', null);\n\n        if (fill !== null)\n        {\n            this.color = fill;\n        }\n\n        if (updateText)\n        {\n            return this.update(true);\n        }\n        else\n        {\n            return this.parent;\n        }\n    },\n\n    /**\n     * Synchronize the font settings to the given Canvas Rendering Context.\n     *\n     * @method Phaser.GameObjects.TextStyle#syncFont\n     * @since 3.0.0\n     *\n     * @param {HTMLCanvasElement} canvas - The Canvas Element.\n     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\n     */\n    syncFont: function (canvas, context)\n    {\n        context.font = this._font;\n    },\n\n    /**\n     * Synchronize the text style settings to the given Canvas Rendering Context.\n     *\n     * @method Phaser.GameObjects.TextStyle#syncStyle\n     * @since 3.0.0\n     *\n     * @param {HTMLCanvasElement} canvas - The Canvas Element.\n     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\n     */\n    syncStyle: function (canvas, context)\n    {\n        context.textBaseline = 'alphabetic';\n\n        context.fillStyle = this.color;\n        context.strokeStyle = this.stroke;\n\n        context.lineWidth = this.strokeThickness;\n        context.lineCap = 'round';\n        context.lineJoin = 'round';\n    },\n\n    /**\n     * Synchronize the shadow settings to the given Canvas Rendering Context.\n     *\n     * @method Phaser.GameObjects.TextStyle#syncShadow\n     * @since 3.0.0\n     *\n     * @param {CanvasRenderingContext2D} context - The Canvas Rendering Context.\n     * @param {boolean} enabled - Whether shadows are enabled or not.\n     */\n    syncShadow: function (context, enabled)\n    {\n        if (enabled)\n        {\n            context.shadowOffsetX = this.shadowOffsetX;\n            context.shadowOffsetY = this.shadowOffsetY;\n            context.shadowColor = this.shadowColor;\n            context.shadowBlur = this.shadowBlur;\n        }\n        else\n        {\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n            context.shadowColor = 0;\n            context.shadowBlur = 0;\n        }\n    },\n\n    /**\n     * Update the style settings for the parent Text object.\n     *\n     * @method Phaser.GameObjects.TextStyle#update\n     * @since 3.0.0\n     *\n     * @param {boolean} recalculateMetrics - Whether to recalculate font and text metrics.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    update: function (recalculateMetrics)\n    {\n        if (recalculateMetrics)\n        {\n            this._font = [ this.fontStyle, this.fontSize, this.fontFamily ].join(' ').trim();\n\n            this.metrics = MeasureText(this);\n        }\n\n        return this.parent.updateText();\n    },\n\n    /**\n     * Set the font.\n     *\n     * If a string is given, the font family is set.\n     *\n     * If an object is given, the `fontFamily`, `fontSize` and `fontStyle`\n     * properties of that object are set.\n     *\n     * @method Phaser.GameObjects.TextStyle#setFont\n     * @since 3.0.0\n     *\n     * @param {(string|object)} font - The font family or font settings to set.\n     * @param {boolean} [updateText=true] - Whether to update the text immediately.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setFont: function (font, updateText)\n    {\n        if (updateText === undefined) { updateText = true; }\n\n        var fontFamily = font;\n        var fontSize = '';\n        var fontStyle = '';\n\n        if (typeof font !== 'string')\n        {\n            fontFamily = GetValue(font, 'fontFamily', 'Courier');\n            fontSize = GetValue(font, 'fontSize', '16px');\n            fontStyle = GetValue(font, 'fontStyle', '');\n        }\n        else\n        {\n            var fontSplit = font.split(' ');\n\n            var i = 0;\n\n            fontStyle = (fontSplit.length > 2) ? fontSplit[i++] : '';\n            fontSize = fontSplit[i++] || '16px';\n            fontFamily = fontSplit[i++] || 'Courier';\n        }\n\n        if (fontFamily !== this.fontFamily || fontSize !== this.fontSize || fontStyle !== this.fontStyle)\n        {\n            this.fontFamily = fontFamily;\n            this.fontSize = fontSize;\n            this.fontStyle = fontStyle;\n\n            if (updateText)\n            {\n                this.update(true);\n            }\n        }\n\n        return this.parent;\n    },\n\n    /**\n     * Set the font family.\n     *\n     * @method Phaser.GameObjects.TextStyle#setFontFamily\n     * @since 3.0.0\n     *\n     * @param {string} family - The font family.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setFontFamily: function (family)\n    {\n        if (this.fontFamily !== family)\n        {\n            this.fontFamily = family;\n\n            this.update(true);\n        }\n\n        return this.parent;\n    },\n\n    /**\n     * Set the font style.\n     *\n     * @method Phaser.GameObjects.TextStyle#setFontStyle\n     * @since 3.0.0\n     *\n     * @param {string} style - The font style.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setFontStyle: function (style)\n    {\n        if (this.fontStyle !== style)\n        {\n            this.fontStyle = style;\n\n            this.update(true);\n        }\n\n        return this.parent;\n    },\n\n    /**\n     * Set the font size.\n     *\n     * @method Phaser.GameObjects.TextStyle#setFontSize\n     * @since 3.0.0\n     *\n     * @param {(number|string)} size - The font size.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setFontSize: function (size)\n    {\n        if (typeof size === 'number')\n        {\n            size = size.toString() + 'px';\n        }\n\n        if (this.fontSize !== size)\n        {\n            this.fontSize = size;\n\n            this.update(true);\n        }\n\n        return this.parent;\n    },\n\n    /**\n     * Set the test string to use when measuring the font.\n     *\n     * @method Phaser.GameObjects.TextStyle#setTestString\n     * @since 3.0.0\n     *\n     * @param {string} string - The test string to use when measuring the font.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setTestString: function (string)\n    {\n        this.testString = string;\n\n        return this.update(true);\n    },\n\n    /**\n     * Set a fixed width and height for the text.\n     *\n     * Pass in `0` for either of these parameters to disable fixed width or height respectively.\n     *\n     * @method Phaser.GameObjects.TextStyle#setFixedSize\n     * @since 3.0.0\n     *\n     * @param {number} width - The fixed width to set.\n     * @param {number} height - The fixed height to set.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setFixedSize: function (width, height)\n    {\n        this.fixedWidth = width;\n        this.fixedHeight = height;\n\n        if (width)\n        {\n            this.parent.width = width;\n        }\n\n        if (height)\n        {\n            this.parent.height = height;\n        }\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the background color.\n     *\n     * @method Phaser.GameObjects.TextStyle#setBackgroundColor\n     * @since 3.0.0\n     *\n     * @param {string} color - The background color.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setBackgroundColor: function (color)\n    {\n        this.backgroundColor = color;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the text fill color.\n     *\n     * @method Phaser.GameObjects.TextStyle#setFill\n     * @since 3.0.0\n     *\n     * @param {string} color - The text fill color.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setFill: function (color)\n    {\n        this.color = color;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the text fill color.\n     *\n     * @method Phaser.GameObjects.TextStyle#setColor\n     * @since 3.0.0\n     *\n     * @param {string} color - The text fill color.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setColor: function (color)\n    {\n        this.color = color;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the resolution used by the Text object.\n     *\n     * By default it will be set to match the resolution set in the Game Config,\n     * but you can override it via this method. It allows for much clearer text on High DPI devices,\n     * at the cost of memory because it uses larger internal Canvas textures for the Text.\n     *\n     * Please use with caution, as the more high res Text you have, the more memory it uses up.\n     *\n     * @method Phaser.GameObjects.TextStyle#setResolution\n     * @since 3.12.0\n     *\n     * @param {number} value - The resolution for this Text object to use.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setResolution: function (value)\n    {\n        this.resolution = value;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the stroke settings.\n     *\n     * @method Phaser.GameObjects.TextStyle#setStroke\n     * @since 3.0.0\n     *\n     * @param {string} color - The stroke color.\n     * @param {number} thickness - The stroke thickness.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setStroke: function (color, thickness)\n    {\n        if (thickness === undefined) { thickness = this.strokeThickness; }\n\n        if (color === undefined && this.strokeThickness !== 0)\n        {\n            //  Reset the stroke to zero (disabling it)\n            this.strokeThickness = 0;\n\n            this.update(true);\n        }\n        else if (this.stroke !== color || this.strokeThickness !== thickness)\n        {\n            this.stroke = color;\n            this.strokeThickness = thickness;\n\n            this.update(true);\n        }\n\n        return this.parent;\n    },\n\n    /**\n     * Set the shadow settings.\n     *\n     * Calling this method always re-measures the parent Text object,\n     * so only call it when you actually change the shadow settings.\n     *\n     * @method Phaser.GameObjects.TextStyle#setShadow\n     * @since 3.0.0\n     *\n     * @param {number} [x=0] - The horizontal shadow offset.\n     * @param {number} [y=0] - The vertical shadow offset.\n     * @param {string} [color='#000'] - The shadow color.\n     * @param {number} [blur=0] - The shadow blur radius.\n     * @param {boolean} [shadowStroke=false] - Whether to stroke the shadow.\n     * @param {boolean} [shadowFill=true] - Whether to fill the shadow.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setShadow: function (x, y, color, blur, shadowStroke, shadowFill)\n    {\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = 0; }\n        if (color === undefined) { color = '#000'; }\n        if (blur === undefined) { blur = 0; }\n        if (shadowStroke === undefined) { shadowStroke = false; }\n        if (shadowFill === undefined) { shadowFill = true; }\n\n        this.shadowOffsetX = x;\n        this.shadowOffsetY = y;\n        this.shadowColor = color;\n        this.shadowBlur = blur;\n        this.shadowStroke = shadowStroke;\n        this.shadowFill = shadowFill;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the shadow offset.\n     *\n     * @method Phaser.GameObjects.TextStyle#setShadowOffset\n     * @since 3.0.0\n     *\n     * @param {number} [x=0] - The horizontal shadow offset.\n     * @param {number} [y=0] - The vertical shadow offset.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setShadowOffset: function (x, y)\n    {\n        if (x === undefined) { x = 0; }\n        if (y === undefined) { y = x; }\n\n        this.shadowOffsetX = x;\n        this.shadowOffsetY = y;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the shadow color.\n     *\n     * @method Phaser.GameObjects.TextStyle#setShadowColor\n     * @since 3.0.0\n     *\n     * @param {string} [color='#000'] - The shadow color.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setShadowColor: function (color)\n    {\n        if (color === undefined) { color = '#000'; }\n\n        this.shadowColor = color;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the shadow blur radius.\n     *\n     * @method Phaser.GameObjects.TextStyle#setShadowBlur\n     * @since 3.0.0\n     *\n     * @param {number} [blur=0] - The shadow blur radius.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setShadowBlur: function (blur)\n    {\n        if (blur === undefined) { blur = 0; }\n\n        this.shadowBlur = blur;\n\n        return this.update(false);\n    },\n\n    /**\n     * Enable or disable shadow stroke.\n     *\n     * @method Phaser.GameObjects.TextStyle#setShadowStroke\n     * @since 3.0.0\n     *\n     * @param {boolean} enabled - Whether shadow stroke is enabled or not.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setShadowStroke: function (enabled)\n    {\n        this.shadowStroke = enabled;\n\n        return this.update(false);\n    },\n\n    /**\n     * Enable or disable shadow fill.\n     *\n     * @method Phaser.GameObjects.TextStyle#setShadowFill\n     * @since 3.0.0\n     *\n     * @param {boolean} enabled - Whether shadow fill is enabled or not.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setShadowFill: function (enabled)\n    {\n        this.shadowFill = enabled;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the width (in pixels) to use for wrapping lines.\n     *\n     * Pass in null to remove wrapping by width.\n     *\n     * @method Phaser.GameObjects.TextStyle#setWordWrapWidth\n     * @since 3.0.0\n     *\n     * @param {number} width - The maximum width of a line in pixels. Set to null to remove wrapping.\n     * @param {boolean} [useAdvancedWrap=false] - Whether or not to use the advanced wrapping\n     * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,\n     * spaces and whitespace are left as is.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setWordWrapWidth: function (width, useAdvancedWrap)\n    {\n        if (useAdvancedWrap === undefined) { useAdvancedWrap = false; }\n\n        this.wordWrapWidth = width;\n        this.wordWrapUseAdvanced = useAdvancedWrap;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set a custom callback for wrapping lines.\n     *\n     * Pass in null to remove wrapping by callback.\n     *\n     * @method Phaser.GameObjects.TextStyle#setWordWrapCallback\n     * @since 3.0.0\n     *\n     * @param {TextStyleWordWrapCallback} callback - A custom function that will be responsible for wrapping the\n     * text. It will receive two arguments: text (the string to wrap), textObject (this Text\n     * instance). It should return the wrapped lines either as an array of lines or as a string with\n     * newline characters in place to indicate where breaks should happen.\n     * @param {object} [scope=null] - The scope that will be applied when the callback is invoked.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setWordWrapCallback: function (callback, scope)\n    {\n        if (scope === undefined) { scope = null; }\n\n        this.wordWrapCallback = callback;\n        this.wordWrapCallbackScope = scope;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the alignment of the text in this Text object.\n     *\n     * The argument can be one of: `left`, `right`, `center` or `justify`.\n     *\n     * Alignment only works if the Text object has more than one line of text.\n     *\n     * @method Phaser.GameObjects.TextStyle#setAlign\n     * @since 3.0.0\n     *\n     * @param {string} [align='left'] - The text alignment for multi-line text.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setAlign: function (align)\n    {\n        if (align === undefined) { align = 'left'; }\n\n        this.align = align;\n\n        return this.update(false);\n    },\n\n    /**\n     * Set the maximum number of lines to draw.\n     *\n     * @method Phaser.GameObjects.TextStyle#setMaxLines\n     * @since 3.0.0\n     *\n     * @param {number} [max=0] - The maximum number of lines to draw.\n     *\n     * @return {Phaser.GameObjects.Text} The parent Text object.\n     */\n    setMaxLines: function (max)\n    {\n        if (max === undefined) { max = 0; }\n\n        this.maxLines = max;\n\n        return this.update(false);\n    },\n\n    /**\n     * Get the current text metrics.\n     *\n     * @method Phaser.GameObjects.TextStyle#getTextMetrics\n     * @since 3.0.0\n     *\n     * @return {Phaser.Types.GameObjects.Text.TextMetrics} The text metrics.\n     */\n    getTextMetrics: function ()\n    {\n        var metrics = this.metrics;\n\n        return {\n            ascent: metrics.ascent,\n            descent: metrics.descent,\n            fontSize: metrics.fontSize\n        };\n    },\n\n    /**\n     * Build a JSON representation of this Text Style.\n     *\n     * @method Phaser.GameObjects.TextStyle#toJSON\n     * @since 3.0.0\n     *\n     * @return {object} A JSON representation of this Text Style.\n     */\n    toJSON: function ()\n    {\n        var output = {};\n\n        for (var key in propertyMap)\n        {\n            output[key] = this[key];\n        }\n\n        output.metrics = this.getTextMetrics();\n\n        return output;\n    },\n\n    /**\n     * Destroy this Text Style.\n     *\n     * @method Phaser.GameObjects.TextStyle#destroy\n     * @since 3.0.0\n     */\n    destroy: function ()\n    {\n        this.parent = undefined;\n    }\n\n});\n\nmodule.exports = TextStyle;\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Text#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TextWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (src.width === 0 || src.height === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    var frame = src.frame;\r\n    var width = frame.width;\r\n    var height = frame.height;\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var textureUnit = pipeline.setTexture2D(frame.glTexture, src);\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    pipeline.batchTexture(\r\n        src,\r\n        frame.glTexture,\r\n        width, height,\r\n        src.x, src.y,\r\n        width / src.style.resolution, height / src.style.resolution,\r\n        src.scaleX, src.scaleY,\r\n        src.rotation,\r\n        src.flipX, src.flipY,\r\n        src.scrollFactorX, src.scrollFactorY,\r\n        src.displayOriginX, src.displayOriginY,\r\n        0, 0, width, height,\r\n        getTint(src.tintTopLeft, camera.alpha * src._alphaTL),\r\n        getTint(src.tintTopRight, camera.alpha * src._alphaTR),\r\n        getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),\r\n        getTint(src.tintBottomRight, camera.alpha * src._alphaBR),\r\n        src.tintFill,\r\n        0, 0,\r\n        camera,\r\n        parentMatrix,\r\n        false,\r\n        textureUnit\r\n    );\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = TextWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameEvents = require('../../core/events');\r\nvar GameObject = require('../GameObject');\r\nvar GetPowerOfTwo = require('../../math/pow2/GetPowerOfTwo');\r\nvar Smoothing = require('../../display/canvas/Smoothing');\r\nvar TileSpriteRender = require('./TileSpriteRender');\r\nvar Vector2 = require('../../math/Vector2');\r\n\r\n//  bitmask flag for GameObject.renderMask\r\nvar _FLAG = 8; // 1000\r\n\r\n/**\r\n * @classdesc\r\n * A TileSprite is a Sprite that has a repeating texture.\r\n *\r\n * The texture can be scrolled and scaled independently of the TileSprite itself. Textures will automatically wrap and\r\n * are designed so that you can create game backdrops using seamless textures as a source.\r\n *\r\n * You shouldn't ever create a TileSprite any larger than your actual canvas size. If you want to create a large repeating background\r\n * that scrolls across the whole map of your game, then you create a TileSprite that fits the canvas size and then use the `tilePosition`\r\n * property to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will\r\n * consume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to\r\n * adjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.\r\n *\r\n * An important note about Tile Sprites and NPOT textures: Internally, TileSprite textures use GL_REPEAT to provide\r\n * seamless repeating of the textures. This, combined with the way in which the textures are handled in WebGL, means\r\n * they need to be POT (power-of-two) sizes in order to wrap. If you provide a NPOT (non power-of-two) texture to a\r\n * TileSprite it will generate a POT sized canvas and draw your texture to it, scaled up to the POT size. It's then\r\n * scaled back down again during rendering to the original dimensions. While this works, in that it allows you to use\r\n * any size texture for a Tile Sprite, it does mean that NPOT textures are going to appear anti-aliased when rendered,\r\n * due to the interpolation that took place when it was resized into a POT texture. This is especially visible in\r\n * pixel art graphics. If you notice it and it becomes an issue, the only way to avoid it is to ensure that you\r\n * provide POT textures for Tile Sprites.\r\n *\r\n * @class TileSprite\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Crop\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {number} width - The width of the Game Object. If zero it will use the size of the texture frame.\r\n * @param {number} height - The height of the Game Object. If zero it will use the size of the texture frame.\r\n * @param {string} textureKey - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\r\n * @param {(string|number)} [frameKey] - An optional frame from the Texture this Game Object is rendering with.\r\n */\r\nvar TileSprite = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Crop,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        TileSpriteRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function TileSprite (scene, x, y, width, height, textureKey, frameKey)\r\n    {\r\n        var renderer = scene.sys.renderer;\r\n\r\n        GameObject.call(this, scene, 'TileSprite');\r\n\r\n        var displayTexture = scene.sys.textures.get(textureKey);\r\n        var displayFrame = displayTexture.get(frameKey);\r\n\r\n        if (!width || !height)\r\n        {\r\n            width = displayFrame.width;\r\n            height = displayFrame.height;\r\n        }\r\n        else\r\n        {\r\n            width = Math.floor(width);\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        /**\r\n         * Internal tile position vector.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#_tilePosition\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tilePosition = new Vector2();\r\n\r\n        /**\r\n         * Internal tile scale vector.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#_tileScale\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._tileScale = new Vector2(1, 1);\r\n\r\n        /**\r\n         * Whether the Tile Sprite has changed in some way, requiring an re-render of its tile texture.\r\n         *\r\n         * Such changes include the texture frame and scroll position of the Tile Sprite.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#dirty\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * The renderer in use by this Tile Sprite.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.0.0\r\n         */\r\n        this.renderer = renderer;\r\n\r\n        /**\r\n         * The Canvas element that the TileSprite renders its fill pattern in to.\r\n         * Only used in Canvas mode.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#canvas\r\n         * @type {?HTMLCanvasElement}\r\n         * @since 3.12.0\r\n         */\r\n        this.canvas = CanvasPool.create(this, width, height);\r\n\r\n        /**\r\n         * The Context of the Canvas element that the TileSprite renders its fill pattern in to.\r\n         * Only used in Canvas mode.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.12.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * The Texture the TileSprite is using as its fill pattern.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#displayTexture\r\n         * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this.displayTexture = displayTexture;\r\n\r\n        /**\r\n         * The Frame the TileSprite is using as its fill pattern.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#displayFrame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this.displayFrame = displayFrame;\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        /**\r\n         * The Texture this Game Object is using to render with.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#texture\r\n         * @type {Phaser.Textures.Texture|Phaser.Textures.CanvasTexture}\r\n         * @since 3.0.0\r\n         */\r\n        this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);\r\n\r\n        /**\r\n         * The Texture Frame this Game Object is using to render with.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @since 3.0.0\r\n         */\r\n        this.frame = this.texture.get();\r\n\r\n        /**\r\n         * The next power of two value from the width of the Fill Pattern frame.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#potWidth\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.potWidth = GetPowerOfTwo(displayFrame.width);\r\n\r\n        /**\r\n         * The next power of two value from the height of the Fill Pattern frame.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#potHeight\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.potHeight = GetPowerOfTwo(displayFrame.height);\r\n\r\n        /**\r\n         * The Canvas that the TileSprites texture is rendered to.\r\n         * This is used to create a WebGL texture from.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#fillCanvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.12.0\r\n         */\r\n        this.fillCanvas = CanvasPool.create2D(this, this.potWidth, this.potHeight);\r\n\r\n        /**\r\n         * The Canvas Context used to render the TileSprites texture.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#fillContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.12.0\r\n         */\r\n        this.fillContext = this.fillCanvas.getContext('2d');\r\n\r\n        /**\r\n         * The texture that the Tile Sprite is rendered to, which is then rendered to a Scene.\r\n         * In WebGL this is a WebGLTexture. In Canvas it's a Canvas Fill Pattern.\r\n         *\r\n         * @name Phaser.GameObjects.TileSprite#fillPattern\r\n         * @type {?(WebGLTexture|CanvasPattern)}\r\n         * @since 3.12.0\r\n         */\r\n        this.fillPattern = null;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(width, height);\r\n        this.setFrame(frameKey);\r\n        this.setOriginFromFrame();\r\n        this.initPipeline();\r\n\r\n        scene.sys.game.events.on(GameEvents.CONTEXT_RESTORED, function (renderer)\r\n        {\r\n            if (!renderer)\r\n            {\r\n                return;\r\n            }\r\n            \r\n            var gl = renderer.gl;\r\n\r\n            this.dirty = true;\r\n            this.fillPattern = null;\r\n            this.fillPattern = renderer.createTexture2D(0, gl.LINEAR, gl.LINEAR, gl.REPEAT, gl.REPEAT, gl.RGBA, this.fillCanvas, this.potWidth, this.potHeight);\r\n\r\n        }, this);\r\n    },\r\n\r\n    /**\r\n     * Sets the texture and frame this Game Object will use to render with.\r\n     *\r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|number)} [frame] - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setTexture: function (key, frame)\r\n    {\r\n        this.displayTexture = this.scene.sys.textures.get(key);\r\n\r\n        return this.setFrame(frame);\r\n    },\r\n\r\n    /**\r\n     * Sets the frame this Game Object will use to render with.\r\n     *\r\n     * The Frame has to belong to the current Texture being used.\r\n     *\r\n     * It can be either a string or an index.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setFrame\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|number)} frame - The name or index of the frame within the Texture.\r\n     *\r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setFrame: function (frame)\r\n    {\r\n        var newFrame = this.displayTexture.get(frame);\r\n\r\n        this.potWidth = GetPowerOfTwo(newFrame.width);\r\n        this.potHeight = GetPowerOfTwo(newFrame.height);\r\n\r\n        //  So updateCanvas is triggered\r\n        this.canvas.width = 0;\r\n\r\n        if (!newFrame.cutWidth || !newFrame.cutHeight)\r\n        {\r\n            this.renderFlags &= ~_FLAG;\r\n        }\r\n        else\r\n        {\r\n            this.renderFlags |= _FLAG;\r\n        }\r\n\r\n        this.displayFrame = newFrame;\r\n\r\n        this.dirty = true;\r\n\r\n        this.updateTileTexture();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setTilePosition\r\n     * @since 3.3.0\r\n     *\r\n     * @param {number} [x] - The x position of this sprite's tiling texture.\r\n     * @param {number} [y] - The y position of this sprite's tiling texture.\r\n     *\r\n     * @return {this} This Tile Sprite instance.\r\n     */\r\n    setTilePosition: function (x, y)\r\n    {\r\n        if (x !== undefined)\r\n        {\r\n            this.tilePositionX = x;\r\n        }\r\n\r\n        if (y !== undefined)\r\n        {\r\n            this.tilePositionY = y;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets {@link Phaser.GameObjects.TileSprite#tileScaleX} and {@link Phaser.GameObjects.TileSprite#tileScaleY}.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#setTileScale\r\n     * @since 3.12.0\r\n     *\r\n     * @param {number} [x] - The horizontal scale of the tiling texture. If not given it will use the current `tileScaleX` value.\r\n     * @param {number} [y=x] - The vertical scale of the tiling texture. If not given it will use the `x` value.\r\n     *\r\n     * @return {this} This Tile Sprite instance.\r\n     */\r\n    setTileScale: function (x, y)\r\n    {\r\n        if (x === undefined) { x = this.tileScaleX; }\r\n        if (y === undefined) { y = x; }\r\n\r\n        this.tileScaleX = x;\r\n        this.tileScaleY = y;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Render the tile texture if it is dirty, or if the frame has changed.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#updateTileTexture\r\n     * @private\r\n     * @since 3.0.0\r\n     */\r\n    updateTileTexture: function ()\r\n    {\r\n        if (!this.dirty || !this.renderer)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Draw the displayTexture to our fillCanvas\r\n\r\n        var frame = this.displayFrame;\r\n\r\n        if (frame.source.isRenderTexture || frame.source.isGLTexture)\r\n        {\r\n            console.warn('TileSprites can only use Image or Canvas based textures');\r\n\r\n            this.dirty = false;\r\n\r\n            return;\r\n        }\r\n\r\n        var ctx = this.fillContext;\r\n        var canvas = this.fillCanvas;\r\n\r\n        var fw = this.potWidth;\r\n        var fh = this.potHeight;\r\n\r\n        if (!this.renderer || !this.renderer.gl)\r\n        {\r\n            fw = frame.cutWidth;\r\n            fh = frame.cutHeight;\r\n        }\r\n\r\n        ctx.clearRect(0, 0, fw, fh);\r\n\r\n        canvas.width = fw;\r\n        canvas.height = fh;\r\n\r\n        ctx.drawImage(\r\n            frame.source.image,\r\n            frame.cutX, frame.cutY,\r\n            frame.cutWidth, frame.cutHeight,\r\n            0, 0,\r\n            fw, fh\r\n        );\r\n\r\n        if (this.renderer && this.renderer.gl)\r\n        {\r\n            this.fillPattern = this.renderer.canvasToTexture(canvas, this.fillPattern);\r\n        }\r\n        else\r\n        {\r\n            this.fillPattern = ctx.createPattern(canvas, 'repeat');\r\n        }\r\n\r\n        this.updateCanvas();\r\n\r\n        this.dirty = false;\r\n    },\r\n\r\n    /**\r\n     * Draw the fill pattern to the internal canvas.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#updateCanvas\r\n     * @private\r\n     * @since 3.12.0\r\n     */\r\n    updateCanvas: function ()\r\n    {\r\n        var canvas = this.canvas;\r\n\r\n        if (canvas.width !== this.width || canvas.height !== this.height)\r\n        {\r\n            canvas.width = this.width;\r\n            canvas.height = this.height;\r\n\r\n            this.frame.setSize(this.width, this.height);\r\n            this.updateDisplayOrigin();\r\n\r\n            this.dirty = true;\r\n        }\r\n\r\n        if (!this.dirty || this.renderer && this.renderer.gl)\r\n        {\r\n            this.dirty = false;\r\n            return;\r\n        }\r\n\r\n        var ctx = this.context;\r\n\r\n        if (!this.scene.sys.game.config.antialias)\r\n        {\r\n            Smoothing.disable(ctx);\r\n        }\r\n\r\n        var scaleX = this._tileScale.x;\r\n        var scaleY = this._tileScale.y;\r\n\r\n        var positionX = this._tilePosition.x;\r\n        var positionY = this._tilePosition.y;\r\n\r\n        ctx.clearRect(0, 0, this.width, this.height);\r\n\r\n        ctx.save();\r\n\r\n        ctx.scale(scaleX, scaleY);\r\n\r\n        ctx.translate(-positionX, -positionY);\r\n\r\n        ctx.fillStyle = this.fillPattern;\r\n\r\n        ctx.fillRect(positionX, positionY, this.width / scaleX, this.height / scaleY);\r\n\r\n        ctx.restore();\r\n\r\n        this.dirty = false;\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.TileSprite#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (this.renderer && this.renderer.gl)\r\n        {\r\n            this.renderer.deleteTexture(this.fillPattern);\r\n        }\r\n\r\n        CanvasPool.remove(this.canvas);\r\n        CanvasPool.remove(this.fillCanvas);\r\n\r\n        this.fillPattern = null;\r\n        this.fillContext = null;\r\n        this.fillCanvas = null;\r\n\r\n        this.displayTexture = null;\r\n        this.displayFrame = null;\r\n\r\n        this.texture.destroy();\r\n\r\n        this.renderer = null;\r\n    },\r\n\r\n    /**\r\n     * The horizontal scroll position of the Tile Sprite.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#tilePositionX\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    tilePositionX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._tilePosition.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tilePosition.x = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scroll position of the Tile Sprite.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#tilePositionY\r\n     * @type {number}\r\n     * @default 0\r\n     * @since 3.0.0\r\n     */\r\n    tilePositionY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._tilePosition.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tilePosition.y = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The horizontal scale of the Tile Sprite texture.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#tileScaleX\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.11.0\r\n     */\r\n    tileScaleX: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._tileScale.x;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tileScale.x = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The vertical scale of the Tile Sprite texture.\r\n     *\r\n     * @name Phaser.GameObjects.TileSprite#tileScaleY\r\n     * @type {number}\r\n     * @default 1\r\n     * @since 3.11.0\r\n     */\r\n    tileScaleY: {\r\n\r\n        get: function ()\r\n        {\r\n            return this._tileScale.y;\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this._tileScale.y = value;\r\n            this.dirty = true;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = TileSprite;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.TileSprite#renderCanvas\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.TileSprite} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TileSpriteCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    src.updateCanvas();\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n};\r\n\r\nmodule.exports = TileSpriteCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar TileSprite = require('./TileSprite');\r\n\r\n/**\r\n * Creates a new TileSprite Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#tileSprite\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Types.GameObjects.TileSprite.TileSpriteConfig} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.TileSprite} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('tileSprite', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var x = GetAdvancedValue(config, 'x', 0);\r\n    var y = GetAdvancedValue(config, 'y', 0);\r\n    var width = GetAdvancedValue(config, 'width', 512);\r\n    var height = GetAdvancedValue(config, 'height', 512);\r\n    var key = GetAdvancedValue(config, 'key', '');\r\n    var frame = GetAdvancedValue(config, 'frame', '');\r\n\r\n    var tile = new TileSprite(this.scene, x, y, width, height, key, frame);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, tile, config);\r\n\r\n    return tile;\r\n});\r\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar TileSprite = require('./TileSprite');\nvar GameObjectFactory = require('../GameObjectFactory');\n\n/**\n * Creates a new TileSprite Game Object and adds it to the Scene.\n *\n * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.\n *\n * @method Phaser.GameObjects.GameObjectFactory#tileSprite\n * @since 3.0.0\n *\n * @param {number} x - The horizontal position of this Game Object in the world.\n * @param {number} y - The vertical position of this Game Object in the world.\n * @param {number} width - The width of the Game Object. If zero it will use the size of the texture frame.\n * @param {number} height - The height of the Game Object. If zero it will use the size of the texture frame.\n * @param {(string|Phaser.Textures.Texture)} texture - The key, or instance of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n * @param {(string|number)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n *\n * @return {Phaser.GameObjects.TileSprite} The Game Object that was created.\n */\nGameObjectFactory.register('tileSprite', function (x, y, width, height, key, frame)\n{\n    return this.displayList.add(new TileSprite(this.scene, x, y, width, height, key, frame));\n});\n\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\n//\n//  There are several properties available to use:\n//\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\n//  this.displayList - a reference to the Display List the Scene owns\n//  this.updateList - a reference to the Update List the Scene owns\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./TileSpriteWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./TileSpriteCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Utils = require('../../renderer/webgl/Utils');\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.TileSprite#renderWebGL\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.TileSprite} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar TileSpriteWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    src.updateCanvas();\r\n\r\n    var width = src.width;\r\n    var height = src.height;\r\n\r\n    if (width === 0 || height === 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    camera.addToRenderList(src);\r\n\r\n    renderer.pipelines.preBatch(src);\r\n\r\n    var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n    var pipeline = renderer.pipelines.set(src.pipeline, src);\r\n\r\n    var textureUnit = pipeline.setTexture2D(src.fillPattern, src);\r\n\r\n    pipeline.batchTexture(\r\n        src,\r\n        src.fillPattern,\r\n        src.displayFrame.width * src.tileScaleX, src.displayFrame.height * src.tileScaleY,\r\n        src.x, src.y,\r\n        width, height,\r\n        src.scaleX, src.scaleY,\r\n        src.rotation,\r\n        src.flipX, src.flipY,\r\n        src.scrollFactorX, src.scrollFactorY,\r\n        src.originX * width, src.originY * height,\r\n        0, 0, width, height,\r\n        getTint(src.tintTopLeft, camera.alpha * src._alphaTL),\r\n        getTint(src.tintTopRight, camera.alpha * src._alphaTR),\r\n        getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),\r\n        getTint(src.tintBottomRight, camera.alpha * src._alphaBR),\r\n        src.tintFill,\r\n        (src.tilePositionX % src.displayFrame.width) / src.displayFrame.width,\r\n        (src.tilePositionY % src.displayFrame.height) / src.displayFrame.height,\r\n        camera,\r\n        parentMatrix,\r\n        false,\r\n        textureUnit\r\n    );\r\n\r\n    renderer.pipelines.postBatch(src);\r\n};\r\n\r\nmodule.exports = TileSpriteWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Clamp = require('../../math/Clamp');\r\nvar Components = require('../components');\r\nvar Events = require('../events');\r\nvar GameEvents = require('../../core/events/');\r\nvar InputEvents = require('../../input/events/');\r\nvar GameObject = require('../GameObject');\r\nvar SoundEvents = require('../../sound/events/');\r\nvar UUID = require('../../utils/string/UUID');\r\nvar VideoRender = require('./VideoRender');\r\nvar MATH_CONST = require('../../math/const');\r\n\r\n/**\r\n * @classdesc\r\n * A Video Game Object.\r\n *\r\n * This Game Object is capable of handling playback of a previously loaded video from the Phaser Video Cache,\r\n * or playing a video based on a given URL. Videos can be either local, or streamed.\r\n *\r\n * ```javascript\r\n * preload () {\r\n *   this.load.video('pixar', 'nemo.mp4');\r\n * }\r\n *\r\n * create () {\r\n *   this.add.video(400, 300, 'pixar');\r\n * }\r\n * ```\r\n *\r\n * To all intents and purposes, a video is a standard Game Object, just like a Sprite. And as such, you can do\r\n * all the usual things to it, such as scaling, rotating, cropping, tinting, making interactive, giving a\r\n * physics body, etc.\r\n *\r\n * Transparent videos are also possible via the WebM file format. Providing the video file has was encoded with\r\n * an alpha channel, and providing the browser supports WebM playback (not all of them do), then it will render\r\n * in-game with full transparency.\r\n *\r\n * ### Autoplaying Videos\r\n *\r\n * Videos can only autoplay if the browser has been unlocked with an interaction, or satisfies the MEI settings.\r\n * The policies that control autoplaying are vast and vary between browser.\r\n * You can, and should, read more about it here: https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\r\n *\r\n * If your video doesn't contain any audio, then set the `noAudio` parameter to `true` when the video is _loaded_,\r\n * and it will often allow the video to play immediately:\r\n *\r\n * ```javascript\r\n * preload () {\r\n *   this.load.video('pixar', 'nemo.mp4', 'loadeddata', false, true);\r\n * }\r\n * ```\r\n *\r\n * The 5th parameter in the load call tells Phaser that the video doesn't contain any audio tracks. Video without\r\n * audio can autoplay without requiring a user interaction. Video with audio cannot do this unless it satisfies\r\n * the browsers MEI settings. See the MDN Autoplay Guide for further details.\r\n *\r\n * Note that due to a bug in IE11 you cannot play a video texture to a Sprite in WebGL. For IE11 force Canvas mode.\r\n *\r\n * More details about video playback and the supported media formats can be found on MDN:\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement\r\n * https://developer.mozilla.org/en-US/docs/Web/Media/Formats\r\n *\r\n * @class Video\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.20.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Size\r\n * @extends Phaser.GameObjects.Components.TextureCrop\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} [key] - Optional key of the Video this Game Object will play, as stored in the Video Cache.\r\n */\r\nvar Video = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Size,\r\n        Components.TextureCrop,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        VideoRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Video (scene, x, y, key)\r\n    {\r\n        GameObject.call(this, scene, 'Video');\r\n\r\n        /**\r\n         * A reference to the HTML Video Element this Video Game Object is playing.\r\n         * Will be `null` until a video is loaded for playback.\r\n         *\r\n         * @name Phaser.GameObjects.Video#video\r\n         * @type {?HTMLVideoElement}\r\n         * @since 3.20.0\r\n         */\r\n        this.video = null;\r\n\r\n        /**\r\n         * The Phaser Texture this Game Object is using to render the video to.\r\n         * Will be `null` until a video is loaded for playback.\r\n         *\r\n         * @name Phaser.GameObjects.Video#videoTexture\r\n         * @type {?Phaser.Textures.Texture}\r\n         * @since 3.20.0\r\n         */\r\n        this.videoTexture = null;\r\n\r\n        /**\r\n         * A reference to the TextureSource belong to the `videoTexture` Texture object.\r\n         * Will be `null` until a video is loaded for playback.\r\n         *\r\n         * @name Phaser.GameObjects.Video#videoTextureSource\r\n         * @type {?Phaser.Textures.TextureSource}\r\n         * @since 3.20.0\r\n         */\r\n        this.videoTextureSource = null;\r\n\r\n        /**\r\n         * A Phaser CanvasTexture instance that holds the most recent snapshot taken from the video.\r\n         * This will only be set if `snapshot` or `snapshotArea` have been called, and will be `null` until that point.\r\n         *\r\n         * @name Phaser.GameObjects.Video#snapshotTexture\r\n         * @type {?Phaser.Textures.CanvasTexture}\r\n         * @since 3.20.0\r\n         */\r\n        this.snapshotTexture = null;\r\n\r\n        /**\r\n         * If you have saved this video to a texture via the `saveTexture` method, this controls if the video\r\n         * is rendered with `flipY` in WebGL or not. You often need to set this if you wish to use the video texture\r\n         * as the input source for a shader. If you find your video is appearing upside down within a shader or\r\n         * custom pipeline, flip this property.\r\n         *\r\n         * @name Phaser.GameObjects.Video#flipY\r\n         * @type {boolean}\r\n         * @since 3.20.0\r\n         */\r\n        this.flipY = false;\r\n\r\n        /**\r\n         * The key used by the texture as stored in the Texture Manager.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_key\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._key = UUID();\r\n\r\n        /**\r\n         * An internal flag holding the current state of the video lock, should document interaction be required\r\n         * before playback can begin.\r\n         *\r\n         * @name Phaser.GameObjects.Video#touchLocked\r\n         * @type {boolean}\r\n         * @since 3.20.0\r\n         */\r\n        this.touchLocked = true;\r\n\r\n        /**\r\n         * Should the video auto play when document interaction is required and happens?\r\n         *\r\n         * @name Phaser.GameObjects.Video#playWhenUnlocked\r\n         * @type {boolean}\r\n         * @since 3.20.0\r\n         */\r\n        this.playWhenUnlocked = false;\r\n\r\n        /**\r\n         * When starting playback of a video Phaser will monitor its `readyState` using a `setTimeout` call.\r\n         * The `setTimeout` happens once every `Video.retryInterval` ms. It will carry on monitoring the video\r\n         * state in this manner until the `retryLimit` is reached and then abort.\r\n         *\r\n         * @name Phaser.GameObjects.Video#retryLimit\r\n         * @type {number}\r\n         * @since 3.20.0\r\n         */\r\n        this.retryLimit = 20;\r\n\r\n        /**\r\n         * The current retry attempt.\r\n         *\r\n         * @name Phaser.GameObjects.Video#retry\r\n         * @type {number}\r\n         * @since 3.20.0\r\n         */\r\n        this.retry = 0;\r\n\r\n        /**\r\n         * The number of ms between each retry while monitoring the ready state of a downloading video.\r\n         *\r\n         * @name Phaser.GameObjects.Video#retryInterval\r\n         * @type {number}\r\n         * @since 3.20.0\r\n         */\r\n        this.retryInterval = 500;\r\n\r\n        /**\r\n         * The setTimeout callback ID.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_retryID\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._retryID = null;\r\n\r\n        /**\r\n         * The video was muted due to a system event, such as the game losing focus.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_systemMuted\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._systemMuted = false;\r\n\r\n        /**\r\n         * The video was muted due to game code, not a system event.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_codeMuted\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._codeMuted = false;\r\n\r\n        /**\r\n         * The video was paused due to a system event, such as the game losing focus.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_systemPaused\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._systemPaused = false;\r\n\r\n        /**\r\n         * The video was paused due to game code, not a system event.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_codePaused\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._codePaused = false;\r\n\r\n        /**\r\n         * The locally bound event callback handlers.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_callbacks\r\n         * @type {any}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._callbacks = {\r\n            play: this.playHandler.bind(this),\r\n            error: this.loadErrorHandler.bind(this),\r\n            end: this.completeHandler.bind(this),\r\n            time: this.timeUpdateHandler.bind(this),\r\n            seeking: this.seekingHandler.bind(this),\r\n            seeked: this.seekedHandler.bind(this)\r\n        };\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        /**\r\n         * An object containing in and out markers for sequence playback.\r\n         *\r\n         * @name Phaser.GameObjects.Video#markers\r\n         * @type {any}\r\n         * @since 3.20.0\r\n         */\r\n        this.markers = {};\r\n\r\n        /**\r\n         * The in marker.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_markerIn\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._markerIn = -1;\r\n\r\n        /**\r\n         * The out marker.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_markerOut\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._markerOut = MATH_CONST.MAX_SAFE_INTEGER;\r\n\r\n        /**\r\n         * The last time the TextureSource was updated.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_lastUpdate\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._lastUpdate = 0;\r\n\r\n        /**\r\n         * The key of the video being played from the Video cache, if any.\r\n         *\r\n         * @name Phaser.GameObjects.Video#_cacheKey\r\n         * @type {string}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._cacheKey = '';\r\n\r\n        /**\r\n         * Is the video currently seeking?\r\n         *\r\n         * @name Phaser.GameObjects.Video#_isSeeking\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.20.0\r\n         */\r\n        this._isSeeking = false;\r\n\r\n        /**\r\n         * Should the Video element that this Video is using, be removed from the DOM\r\n         * when this Video is destroyed?\r\n         *\r\n         * @name Phaser.GameObjects.Video#removeVideoElementOnDestroy\r\n         * @type {boolean}\r\n         * @since 3.21.0\r\n         */\r\n        this.removeVideoElementOnDestroy = false;\r\n\r\n        this.setPosition(x, y);\r\n        this.initPipeline();\r\n\r\n        if (key)\r\n        {\r\n            this.changeSource(key, false);\r\n        }\r\n\r\n        var game = scene.sys.game.events;\r\n\r\n        game.on(GameEvents.PAUSE, this.globalPause, this);\r\n        game.on(GameEvents.RESUME, this.globalResume, this);\r\n\r\n        var sound = scene.sys.sound;\r\n\r\n        if (sound)\r\n        {\r\n            sound.on(SoundEvents.GLOBAL_MUTE, this.globalMute, this);\r\n        }\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    addedToScene: function ()\r\n    {\r\n        this.scene.sys.updateList.add(this);\r\n    },\r\n\r\n    //  Overrides Game Object method\r\n    removedFromScene: function ()\r\n    {\r\n        this.scene.sys.updateList.remove(this);\r\n    },\r\n\r\n    /**\r\n     * Starts this video playing.\r\n     *\r\n     * If the video is already playing, or has been queued to play with `changeSource` then this method just returns.\r\n     *\r\n     * Videos can only autoplay if the browser has been unlocked. This happens if you have interacted with the browser, i.e.\r\n     * by clicking on it or pressing a key, or due to server settings. The policies that control autoplaying are vast and\r\n     * vary between browser. You can read more here: https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\r\n     *\r\n     * If your video doesn't contain any audio, then set the `noAudio` parameter to `true` when the video is loaded,\r\n     * and it will often allow the video to play immediately:\r\n     *\r\n     * ```javascript\r\n     * preload () {\r\n     *   this.load.video('pixar', 'nemo.mp4', 'loadeddata', false, true);\r\n     * }\r\n     * ```\r\n     *\r\n     * The 5th parameter in the load call tells Phaser that the video doesn't contain any audio tracks. Video without\r\n     * audio can autoplay without requiring a user interaction. Video with audio cannot do this unless it satisfies\r\n     * the browsers MEI settings. See the MDN Autoplay Guide for details.\r\n     *\r\n     * If you need audio in your videos, then you'll have to consider the fact that the video cannot start playing until the\r\n     * user has interacted with the browser, into your game flow.\r\n     *\r\n     * @method Phaser.GameObjects.Video#play\r\n     * @since 3.20.0\r\n     *\r\n     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n     * @param {number} [markerIn] - Optional in marker time, in seconds, for playback of a sequence of the video.\r\n     * @param {number} [markerOut] - Optional out marker time, in seconds, for playback of a sequence of the video.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    play: function (loop, markerIn, markerOut)\r\n    {\r\n        if ((this.touchLocked && this.playWhenUnlocked) || this.isPlaying())\r\n        {\r\n            return this;\r\n        }\r\n\r\n        var video = this.video;\r\n\r\n        if (!video)\r\n        {\r\n            console.warn('Video not loaded');\r\n\r\n            return this;\r\n        }\r\n\r\n        if (loop === undefined) { loop = video.loop; }\r\n\r\n        var sound = this.scene.sys.sound;\r\n\r\n        if (sound && sound.mute)\r\n        {\r\n            //  Mute will be set based on the global mute state of the Sound Manager (if there is one)\r\n            this.setMute(true);\r\n        }\r\n\r\n        if (!isNaN(markerIn))\r\n        {\r\n            this._markerIn = markerIn;\r\n        }\r\n\r\n        if (!isNaN(markerOut) && markerOut > markerIn)\r\n        {\r\n            this._markerOut = markerOut;\r\n        }\r\n\r\n        video.loop = loop;\r\n\r\n        var callbacks = this._callbacks;\r\n\r\n        var playPromise = video.play();\r\n\r\n        if (playPromise !== undefined)\r\n        {\r\n            playPromise.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this));\r\n        }\r\n        else\r\n        {\r\n            //  Old-school browsers with no Promises\r\n            video.addEventListener('playing', callbacks.play, true);\r\n\r\n            //  If video hasn't downloaded properly yet ...\r\n            if (video.readyState < 2)\r\n            {\r\n                this.retry = this.retryLimit;\r\n\r\n                this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\r\n            }\r\n        }\r\n\r\n        //  Set these _after_ calling `play` or they don't fire (useful, thanks browsers)\r\n        video.addEventListener('ended', callbacks.end, true);\r\n        video.addEventListener('timeupdate', callbacks.time, true);\r\n        video.addEventListener('seeking', callbacks.seeking, true);\r\n        video.addEventListener('seeked', callbacks.seeked, true);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This method allows you to change the source of the current video element. It works by first stopping the\r\n     * current video, if playing. Then deleting the video texture, if one has been created. Finally, it makes a\r\n     * new video texture and starts playback of the new source through the existing video element.\r\n     *\r\n     * The reason you may wish to do this is because videos that require interaction to unlock, remain in an unlocked\r\n     * state, even if you change the source of the video. By changing the source to a new video you avoid having to\r\n     * go through the unlock process again.\r\n     *\r\n     * @method Phaser.GameObjects.Video#changeSource\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - The key of the Video this Game Object will swap to playing, as stored in the Video Cache.\r\n     * @param {boolean} [autoplay=true] - Should the video start playing immediately, once the swap is complete?\r\n     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n     * @param {number} [markerIn] - Optional in marker time, in seconds, for playback of a sequence of the video.\r\n     * @param {number} [markerOut] - Optional out marker time, in seconds, for playback of a sequence of the video.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    changeSource: function (key, autoplay, loop, markerIn, markerOut)\r\n    {\r\n        if (autoplay === undefined) { autoplay = true; }\r\n\r\n        var currentVideo = this.video;\r\n\r\n        if (currentVideo)\r\n        {\r\n            this.stop();\r\n        }\r\n\r\n        var newVideo = this.scene.sys.cache.video.get(key);\r\n\r\n        if (newVideo)\r\n        {\r\n            this.video = newVideo;\r\n\r\n            this._cacheKey = key;\r\n\r\n            this._codePaused = newVideo.paused;\r\n            this._codeMuted = newVideo.muted;\r\n\r\n            if (this.videoTexture)\r\n            {\r\n                this.scene.sys.textures.remove(this._key);\r\n\r\n                this.videoTexture = this.scene.sys.textures.create(this._key, newVideo, newVideo.videoWidth, newVideo.videoHeight);\r\n                this.videoTextureSource = this.videoTexture.source[0];\r\n                this.videoTexture.add('__BASE', 0, 0, 0, newVideo.videoWidth, newVideo.videoHeight);\r\n\r\n                this.setTexture(this.videoTexture);\r\n                this.setSizeToFrame();\r\n                this.updateDisplayOrigin();\r\n\r\n                this.emit(Events.VIDEO_CREATED, this, newVideo.videoWidth, newVideo.videoHeight);\r\n            }\r\n            else\r\n            {\r\n                this.updateTexture();\r\n            }\r\n\r\n            newVideo.currentTime = 0;\r\n\r\n            this._lastUpdate = 0;\r\n\r\n            if (autoplay)\r\n            {\r\n                this.play(loop, markerIn, markerOut);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.video = null;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a sequence marker to this video.\r\n     *\r\n     * Markers allow you to split a video up into sequences, delineated by a start and end time, given in seconds.\r\n     *\r\n     * You can then play back specific markers via the `playMarker` method.\r\n     *\r\n     * Note that marker timing is _not_ frame-perfect. You should construct your videos in such a way that you allow for\r\n     * plenty of extra padding before and after each sequence to allow for discrepancies in browser seek and currentTime accuracy.\r\n     *\r\n     * See https://github.com/w3c/media-and-entertainment/issues/4 for more details about this issue.\r\n     *\r\n     * @method Phaser.GameObjects.Video#addMarker\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - A unique name to give this marker.\r\n     * @param {number} markerIn - The time, in seconds, representing the start of this marker.\r\n     * @param {number} markerOut - The time, in seconds, representing the end of this marker.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    addMarker: function (key, markerIn, markerOut)\r\n    {\r\n        if (!isNaN(markerIn) && markerIn >= 0 && !isNaN(markerOut))\r\n        {\r\n            this.markers[key] = [ markerIn, markerOut ];\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Plays a pre-defined sequence in this video.\r\n     *\r\n     * Markers allow you to split a video up into sequences, delineated by a start and end time, given in seconds and\r\n     * specified via the `addMarker` method.\r\n     *\r\n     * Note that marker timing is _not_ frame-perfect. You should construct your videos in such a way that you allow for\r\n     * plenty of extra padding before and after each sequence to allow for discrepancies in browser seek and currentTime accuracy.\r\n     *\r\n     * See https://github.com/w3c/media-and-entertainment/issues/4 for more details about this issue.\r\n     *\r\n     * @method Phaser.GameObjects.Video#playMarker\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - The name of the marker sequence to play.\r\n     * @param {boolean} [loop=false] - Should the video loop automatically when it reaches the end? Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    playMarker: function (key, loop)\r\n    {\r\n        var marker = this.markers[key];\r\n\r\n        if (marker)\r\n        {\r\n            this.play(loop, marker[0], marker[1]);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a previously set marker from this video.\r\n     *\r\n     * If the marker is currently playing it will _not_ stop playback.\r\n     *\r\n     * @method Phaser.GameObjects.Video#removeMarker\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - The name of the marker to remove.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    removeMarker: function (key)\r\n    {\r\n        delete this.markers[key];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the current frame of the video and renders it to a CanvasTexture object,\r\n     * which is then returned. You can optionally resize the grab by passing a width and height.\r\n     *\r\n     * This method returns a reference to the `Video.snapshotTexture` object. Calling this method\r\n     * multiple times will overwrite the previous snapshot with the most recent one.\r\n     *\r\n     * @method Phaser.GameObjects.Video#snapshot\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} [width] - The width of the resulting CanvasTexture.\r\n     * @param {number} [height] - The height of the resulting CanvasTexture.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture}\r\n     */\r\n    snapshot: function (width, height)\r\n    {\r\n        if (width === undefined) { width = this.width; }\r\n        if (height === undefined) { height = this.height; }\r\n\r\n        return this.snapshotArea(0, 0, this.width, this.height, width, height);\r\n    },\r\n\r\n    /**\r\n     * Takes a snapshot of the specified area of the current frame of the video and renders it to a CanvasTexture object,\r\n     * which is then returned. You can optionally resize the grab by passing a different `destWidth` and `destHeight`.\r\n     *\r\n     * This method returns a reference to the `Video.snapshotTexture` object. Calling this method\r\n     * multiple times will overwrite the previous snapshot with the most recent one.\r\n     *\r\n     * @method Phaser.GameObjects.Video#snapshotArea\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} [x=0] - The horizontal location of the top-left of the area to grab from.\r\n     * @param {number} [y=0] - The vertical location of the top-left of the area to grab from.\r\n     * @param {number} [srcWidth] - The width of area to grab from the video. If not given it will grab the full video dimensions.\r\n     * @param {number} [srcHeight] - The height of area to grab from the video. If not given it will grab the full video dimensions.\r\n     * @param {number} [destWidth] - The destination width of the grab, allowing you to resize it.\r\n     * @param {number} [destHeight] - The destination height of the grab, allowing you to resize it.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture}\r\n     */\r\n    snapshotArea: function (x, y, srcWidth, srcHeight, destWidth, destHeight)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (srcWidth === undefined) { srcWidth = this.width; }\r\n        if (srcHeight === undefined) { srcHeight = this.height; }\r\n        if (destWidth === undefined) { destWidth = srcWidth; }\r\n        if (destHeight === undefined) { destHeight = srcHeight; }\r\n\r\n        var video = this.video;\r\n        var snap = this.snapshotTexture;\r\n\r\n        if (!snap)\r\n        {\r\n            snap = this.scene.sys.textures.createCanvas(UUID(), destWidth, destHeight);\r\n\r\n            this.snapshotTexture = snap;\r\n\r\n            if (video)\r\n            {\r\n                snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            snap.setSize(destWidth, destHeight);\r\n\r\n            if (video)\r\n            {\r\n                snap.context.drawImage(video, x, y, srcWidth, srcHeight, 0, 0, destWidth, destHeight);\r\n            }\r\n        }\r\n\r\n        return snap.update();\r\n    },\r\n\r\n    /**\r\n     * Stores a copy of this Videos `snapshotTexture` in the Texture Manager using the given key.\r\n     *\r\n     * This texture is created when the `snapshot` or `snapshotArea` methods are called.\r\n     *\r\n     * After doing this, any texture based Game Object, such as a Sprite, can use the contents of the\r\n     * snapshot by using the texture key:\r\n     *\r\n     * ```javascript\r\n     * var vid = this.add.video(0, 0, 'intro');\r\n     *\r\n     * vid.snapshot();\r\n     *\r\n     * vid.saveSnapshotTexture('doodle');\r\n     *\r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     *\r\n     * Updating the contents of the `snapshotTexture`, for example by calling `snapshot` again,\r\n     * will automatically update _any_ Game Object that is using it as a texture.\r\n     * Calling `saveSnapshotTexture` again will not save another copy of the same texture,\r\n     * it will just rename the existing one.\r\n     *\r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame.\r\n     *\r\n     * @method Phaser.GameObjects.Video#saveSnapshotTexture\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n     *\r\n     * @return {Phaser.Textures.CanvasTexture} The Texture that was saved.\r\n     */\r\n    saveSnapshotTexture: function (key)\r\n    {\r\n        if (this.snapshotTexture)\r\n        {\r\n            this.scene.sys.textures.renameTexture(this.snapshotTexture.key, key);\r\n        }\r\n        else\r\n        {\r\n            this.snapshotTexture = this.scene.sys.textures.createCanvas(key, this.width, this.height);\r\n        }\r\n\r\n        return this.snapshotTexture;\r\n    },\r\n\r\n    /**\r\n     * Loads a Video from the given URL, ready for playback with the `Video.play` method.\r\n     *\r\n     * You can control at what point the browser determines the video as being ready for playback via\r\n     * the `loadEvent` parameter. See https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement\r\n     * for more details.\r\n     *\r\n     * @method Phaser.GameObjects.Video#loadURL\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} url - The URL of the video to load or be streamed.\r\n     * @param {string} [loadEvent='loadeddata'] - The load event to listen for. Either `loadeddata`, `canplay` or `canplaythrough`.\r\n     * @param {boolean} [noAudio=false] - Does the video have an audio track? If not you can enable auto-playing on it.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    loadURL: function (url, loadEvent, noAudio)\r\n    {\r\n        if (loadEvent === undefined) { loadEvent = 'loadeddata'; }\r\n        if (noAudio === undefined) { noAudio = false; }\r\n\r\n        if (this.video)\r\n        {\r\n            this.stop();\r\n        }\r\n\r\n        if (this.videoTexture)\r\n        {\r\n            this.scene.sys.textures.remove(this._key);\r\n        }\r\n\r\n        var video = document.createElement('video');\r\n\r\n        video.controls = false;\r\n\r\n        if (noAudio)\r\n        {\r\n            video.muted = true;\r\n            video.defaultMuted = true;\r\n\r\n            video.setAttribute('autoplay', 'autoplay');\r\n        }\r\n\r\n        video.setAttribute('playsinline', 'playsinline');\r\n        video.setAttribute('preload', 'auto');\r\n\r\n        video.addEventListener('error', this._callbacks.error, true);\r\n\r\n        video.src = url;\r\n\r\n        video.load();\r\n\r\n        this.video = video;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Loads a Video from the given MediaStream object, ready for playback with the `Video.play` method.\r\n     *\r\n     * You can control at what point the browser determines the video as being ready for playback via\r\n     * the `loadEvent` parameter. See https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement\r\n     * for more details.\r\n     *\r\n     * @method Phaser.GameObjects.Video#loadMediaStream\r\n     * @since 3.50.0\r\n     *\r\n     * @param {string} stream - The MediaStream object.\r\n     * @param {string} [loadEvent='loadeddata'] - The load event to listen for. Either `loadeddata`, `canplay` or `canplaythrough`.\r\n     * @param {boolean} [noAudio=false] - Does the video have an audio track? If not you can enable auto-playing on it.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    loadMediaStream: function (stream, loadEvent, noAudio)\r\n    {\r\n        if (loadEvent === undefined) { loadEvent = 'loadeddata'; }\r\n        if (noAudio === undefined) { noAudio = false; }\r\n\r\n        if (this.video)\r\n        {\r\n            this.stop();\r\n        }\r\n\r\n        if (this.videoTexture)\r\n        {\r\n            this.scene.sys.textures.remove(this._key);\r\n        }\r\n\r\n        var video = document.createElement('video');\r\n\r\n        video.controls = false;\r\n\r\n        if (noAudio)\r\n        {\r\n            video.muted = true;\r\n            video.defaultMuted = true;\r\n\r\n            video.setAttribute('autoplay', 'autoplay');\r\n        }\r\n\r\n        video.setAttribute('playsinline', 'playsinline');\r\n        video.setAttribute('preload', 'auto');\r\n\r\n        video.addEventListener('error', this._callbacks.error, true);\r\n\r\n        try\r\n        {\r\n            video.srcObject = stream;\r\n        }\r\n        catch (error)\r\n        {\r\n            video.src = window.URL.createObjectURL(stream);\r\n        }\r\n\r\n        video.load();\r\n\r\n        this.video = video;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * This internal method is called automatically if the playback Promise resolves successfully.\r\n     *\r\n     * @method Phaser.GameObjects.Video#playPromiseSuccessHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_PLAY\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    playPromiseSuccessHandler: function ()\r\n    {\r\n        this._codePaused = false;\r\n        this.touchLocked = false;\r\n\r\n        this.emit(Events.VIDEO_PLAY, this);\r\n\r\n        if (this._markerIn > -1)\r\n        {\r\n            this.video.currentTime = this._markerIn;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * This internal method is called automatically if the playback Promise fails to resolve.\r\n     *\r\n     * @method Phaser.GameObjects.Video#playPromiseErrorHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_ERROR\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {any} error - The Promise resolution error.\r\n     */\r\n    playPromiseErrorHandler: function (error)\r\n    {\r\n        this.scene.sys.input.once(InputEvents.POINTER_DOWN, this.unlockHandler, this);\r\n\r\n        this.touchLocked = true;\r\n        this.playWhenUnlocked = true;\r\n\r\n        this.emit(Events.VIDEO_ERROR, this, error);\r\n    },\r\n\r\n    /**\r\n     * Called when the video emits a `playing` event during load.\r\n     *\r\n     * This is only listened for if the browser doesn't support Promises.\r\n     *\r\n     * @method Phaser.GameObjects.Video#playHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_PLAY\r\n     * @since 3.20.0\r\n     */\r\n    playHandler: function ()\r\n    {\r\n        this._codePaused = false;\r\n        this.touchLocked = false;\r\n\r\n        this.emit(Events.VIDEO_PLAY, this);\r\n\r\n        this.video.removeEventListener('playing', this._callbacks.play, true);\r\n    },\r\n\r\n    /**\r\n     * This internal method is called automatically if the video fails to load.\r\n     *\r\n     * @method Phaser.GameObjects.Video#loadErrorHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_ERROR\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {Event} event - The error Event.\r\n     */\r\n    loadErrorHandler: function (event)\r\n    {\r\n        this.stop();\r\n\r\n        this.emit(Events.VIDEO_ERROR, this, event);\r\n    },\r\n\r\n    /**\r\n     * This internal method is called if the video couldn't be played because it was interaction locked\r\n     * by the browser, but an input event has since been received.\r\n     *\r\n     * @method Phaser.GameObjects.Video#unlockHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_UNLOCKED\r\n     * @fires Phaser.GameObjects.Events#VIDEO_PLAY\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {any} error - The Promise resolution error.\r\n     */\r\n    unlockHandler: function ()\r\n    {\r\n        this.touchLocked = false;\r\n        this.playWhenUnlocked = false;\r\n\r\n        this.emit(Events.VIDEO_UNLOCKED, this);\r\n\r\n        if (this._markerIn > -1)\r\n        {\r\n            this.video.currentTime = this._markerIn;\r\n        }\r\n\r\n        this.video.play();\r\n\r\n        this.emit(Events.VIDEO_PLAY, this);\r\n    },\r\n\r\n    /**\r\n     * Called when the video completes playback, i.e. reaches an `ended` state.\r\n     *\r\n     * This will never happen if the video is coming from a live stream, where the duration is `Infinity`.\r\n     *\r\n     * @method Phaser.GameObjects.Video#completeHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_COMPLETE\r\n     * @since 3.20.0\r\n     */\r\n    completeHandler: function ()\r\n    {\r\n        this.emit(Events.VIDEO_COMPLETE, this);\r\n    },\r\n\r\n    /**\r\n     * Called when the video emits a `timeUpdate` event during playback.\r\n     *\r\n     * This event is too slow and irregular to be used for actual video timing or texture updating,\r\n     * but we can use it to determine if a video has looped.\r\n     *\r\n     * @method Phaser.GameObjects.Video#timeUpdateHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_LOOP\r\n     * @since 3.20.0\r\n     */\r\n    timeUpdateHandler: function ()\r\n    {\r\n        if (this.video && this.video.currentTime < this._lastUpdate)\r\n        {\r\n            this.emit(Events.VIDEO_LOOP, this);\r\n\r\n            this._lastUpdate = 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The internal update step.\r\n     *\r\n     * @method Phaser.GameObjects.Video#preUpdate\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    preUpdate: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            var currentTime = video.currentTime;\r\n\r\n            //  Don't render a new frame unless the video has actually changed time\r\n            if (currentTime !== this._lastUpdate)\r\n            {\r\n                this._lastUpdate = currentTime;\r\n\r\n                this.updateTexture();\r\n\r\n                if (currentTime >= this._markerOut)\r\n                {\r\n                    if (video.loop)\r\n                    {\r\n                        video.currentTime = this._markerIn;\r\n\r\n                        this.updateTexture();\r\n\r\n                        this._lastUpdate = currentTime;\r\n\r\n                        this.emit(Events.VIDEO_LOOP, this);\r\n                    }\r\n                    else\r\n                    {\r\n                        this.emit(Events.VIDEO_COMPLETE, this);\r\n\r\n                        this.stop();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal callback that monitors the download progress of a video after changing its source.\r\n     *\r\n     * @method Phaser.GameObjects.Video#checkVideoProgress\r\n     * @fires Phaser.GameObjects.Events#VIDEO_TIMEOUT\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    checkVideoProgress: function ()\r\n    {\r\n        if (this.video.readyState >= 2)\r\n        {\r\n            //  We've got enough data to update the texture for playback\r\n            this.updateTexture();\r\n        }\r\n        else\r\n        {\r\n            this.retry--;\r\n\r\n            if (this.retry > 0)\r\n            {\r\n                this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval);\r\n            }\r\n            else\r\n            {\r\n                this.emit(Events.VIDEO_TIMEOUT, this);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that is called when enough video data has been received in order to create a texture\r\n     * from it. The texture is assigned to the `Video.videoTexture` property and given a base frame that\r\n     * encompases the whole video size.\r\n     *\r\n     * @method Phaser.GameObjects.Video#updateTexture\r\n     * @since 3.20.0\r\n     */\r\n    updateTexture: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        var width = video.videoWidth;\r\n        var height = video.videoHeight;\r\n\r\n        if (!this.videoTexture)\r\n        {\r\n            this.videoTexture = this.scene.sys.textures.create(this._key, video, width, height);\r\n            this.videoTextureSource = this.videoTexture.source[0];\r\n            this.videoTexture.add('__BASE', 0, 0, 0, width, height);\r\n\r\n            this.setTexture(this.videoTexture);\r\n            this.setSizeToFrame();\r\n            this.updateDisplayOrigin();\r\n\r\n            this.emit(Events.VIDEO_CREATED, this, width, height);\r\n        }\r\n        else\r\n        {\r\n            var textureSource = this.videoTextureSource;\r\n\r\n            if (textureSource.source !== video)\r\n            {\r\n                textureSource.source = video;\r\n                textureSource.width = width;\r\n                textureSource.height = height;\r\n            }\r\n\r\n            textureSource.update();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns the key of the currently played video, as stored in the Video Cache.\r\n     * If the video did not come from the cache this will return an empty string.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getVideoKey\r\n     * @since 3.20.0\r\n     *\r\n     * @return {string} The key of the video being played from the Video Cache, if any.\r\n     */\r\n    getVideoKey: function ()\r\n    {\r\n        return this._cacheKey;\r\n    },\r\n\r\n    /**\r\n     * Seeks to a given point in the video. The value is given as a float between 0 and 1,\r\n     * where 0 represents the start of the video and 1 represents the end.\r\n     *\r\n     * Seeking only works if the video has a duration, so will not work for live streams.\r\n     *\r\n     * When seeking begins, this video will emit a `seeking` event. When the video completes\r\n     * seeking (i.e. reaches its designated timestamp) it will emit a `seeked` event.\r\n     *\r\n     * If you wish to seek based on time instead, use the `Video.setCurrentTime` method.\r\n     *\r\n     * @method Phaser.GameObjects.Video#seekTo\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} value - The point in the video to seek to. A value between 0 and 1.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    seekTo: function (value)\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            var duration = video.duration;\r\n\r\n            if (duration !== Infinity && !isNaN(duration))\r\n            {\r\n                var seekTime = duration * value;\r\n\r\n                this.setCurrentTime(seekTime);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * A double-precision floating-point value indicating the current playback time in seconds.\r\n     * If the media has not started to play and has not been seeked, this value is the media's initial playback time.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getCurrentTime\r\n     * @since 3.20.0\r\n     *\r\n     * @return {number} A double-precision floating-point value indicating the current playback time in seconds.\r\n     */\r\n    getCurrentTime: function ()\r\n    {\r\n        return (this.video) ? this.video.currentTime : 0;\r\n    },\r\n\r\n    /**\r\n     * Seeks to a given playback time in the video. The value is given in _seconds_ or as a string.\r\n     *\r\n     * Seeking only works if the video has a duration, so will not work for live streams.\r\n     *\r\n     * When seeking begins, this video will emit a `seeking` event. When the video completes\r\n     * seeking (i.e. reaches its designated timestamp) it will emit a `seeked` event.\r\n     *\r\n     * You can provide a string prefixed with either a `+` or a `-`, such as `+2.5` or `-2.5`.\r\n     * In this case it will seek to +/- the value given, relative to the _current time_.\r\n     *\r\n     * If you wish to seek based on a duration percentage instead, use the `Video.seekTo` method.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setCurrentTime\r\n     * @since 3.20.0\r\n     *\r\n     * @param {(string|number)} value - The playback time to seek to in seconds. Can be expressed as a string, such as `+2` to seek 2 seconds ahead from the current time.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setCurrentTime: function (value)\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            if (typeof value === 'string')\r\n            {\r\n                var op = value[0];\r\n                var num = parseFloat(value.substr(1));\r\n\r\n                if (op === '+')\r\n                {\r\n                    value = video.currentTime + num;\r\n                }\r\n                else if (op === '-')\r\n                {\r\n                    value = video.currentTime - num;\r\n                }\r\n            }\r\n\r\n            video.currentTime = value;\r\n\r\n            this._lastUpdate = value;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean indicating if this Video is currently seeking, or not.\r\n     *\r\n     * @method Phaser.GameObjects.Video#isSeeking\r\n     * @since 3.20.0\r\n     *\r\n     * @return {boolean} A boolean indicating if this Video is currently seeking, or not.\r\n     */\r\n    isSeeking: function ()\r\n    {\r\n        return this._isSeeking;\r\n    },\r\n\r\n    /**\r\n     * Internal seeking handler.\r\n     *\r\n     * @method Phaser.GameObjects.Video#seekingHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_SEEKING\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    seekingHandler: function ()\r\n    {\r\n        this._isSeeking = true;\r\n\r\n        this.emit(Events.VIDEO_SEEKING, this);\r\n    },\r\n\r\n    /**\r\n     * Internal seeked handler.\r\n     *\r\n     * @method Phaser.GameObjects.Video#seekedHandler\r\n     * @fires Phaser.GameObjects.Events#VIDEO_SEEKED\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    seekedHandler: function ()\r\n    {\r\n        this._isSeeking = false;\r\n\r\n        this.emit(Events.VIDEO_SEEKED, this);\r\n\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            this.updateTexture();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns the current progress of the video. Progress is defined as a value between 0 (the start)\r\n     * and 1 (the end).\r\n     *\r\n     * Progress can only be returned if the video has a duration, otherwise it will always return zero.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getProgress\r\n     * @since 3.20.0\r\n     *\r\n     * @return {number} The current progress of playback. If the video has no duration, will always return zero.\r\n     */\r\n    getProgress: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            var now = video.currentTime;\r\n            var duration = video.duration;\r\n\r\n            if (duration !== Infinity && !isNaN(duration))\r\n            {\r\n                return now / duration;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * A double-precision floating-point value which indicates the duration (total length) of the media in seconds,\r\n     * on the media's timeline. If no media is present on the element, or the media is not valid, the returned value is NaN.\r\n     *\r\n     * If the media has no known end (such as for live streams of unknown duration, web radio, media incoming from WebRTC,\r\n     * and so forth), this value is +Infinity.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getDuration\r\n     * @since 3.20.0\r\n     *\r\n     * @return {number} A double-precision floating-point value indicating the duration of the media in seconds.\r\n     */\r\n    getDuration: function ()\r\n    {\r\n        return (this.video) ? this.video.duration : 0;\r\n    },\r\n\r\n    /**\r\n     * Sets the muted state of the currently playing video, if one is loaded.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setMute\r\n     * @since 3.20.0\r\n     *\r\n     * @param {boolean} [value=true] - The mute value. `true` if the video should be muted, otherwise `false`.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setMute: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        this._codeMuted = value;\r\n\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            video.muted = (this._systemMuted) ? true : value;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean indicating if this Video is currently muted.\r\n     *\r\n     * @method Phaser.GameObjects.Video#isMuted\r\n     * @since 3.20.0\r\n     *\r\n     * @return {boolean} A boolean indicating if this Video is currently muted, or not.\r\n     */\r\n    isMuted: function ()\r\n    {\r\n        return this._codeMuted;\r\n    },\r\n\r\n    /**\r\n     * Internal global mute handler. Will mute the video, if playing, if the global sound system mutes.\r\n     *\r\n     * @method Phaser.GameObjects.Video#globalMute\r\n     * @private\r\n     * @since 3.20.0\r\n     *\r\n     * @param {(Phaser.Sound.WebAudioSoundManager|Phaser.Sound.HTML5AudioSoundManager)} soundManager - A reference to the Sound Manager that emitted the event.\r\n     * @param {boolean} mute - The mute value. `true` if the Sound Manager is now muted, otherwise `false`.\r\n     */\r\n    globalMute: function (soundManager, value)\r\n    {\r\n        this._systemMuted = value;\r\n\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            video.muted = (this._codeMuted) ? true : value;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal global pause handler. Will pause the video if the Game itself pauses.\r\n     *\r\n     * @method Phaser.GameObjects.Video#globalPause\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    globalPause: function ()\r\n    {\r\n        this._systemPaused = true;\r\n\r\n        if (this.video)\r\n        {\r\n            this.video.pause();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal global resume handler. Will resume a paused video if the Game itself resumes.\r\n     *\r\n     * @method Phaser.GameObjects.Video#globalResume\r\n     * @private\r\n     * @since 3.20.0\r\n     */\r\n    globalResume: function ()\r\n    {\r\n        this._systemPaused = false;\r\n\r\n        if (this.video && !this._codePaused)\r\n        {\r\n            this.video.play();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the paused state of the currently loaded video.\r\n     *\r\n     * If the video is playing, calling this method with `true` will pause playback.\r\n     * If the video is paused, calling this method with `false` will resume playback.\r\n     *\r\n     * If no video is loaded, this method does nothing.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setPaused\r\n     * @since 3.20.0\r\n     *\r\n     * @param {boolean} [value=true] - The paused value. `true` if the video should be paused, `false` to resume it.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setPaused: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        var video = this.video;\r\n\r\n        this._codePaused = value;\r\n\r\n        if (video)\r\n        {\r\n            if (value)\r\n            {\r\n                if (!video.paused)\r\n                {\r\n                    video.pause();\r\n                }\r\n            }\r\n            else if (!value)\r\n            {\r\n                if (video.paused && !this._systemPaused)\r\n                {\r\n                    video.play();\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n     *\r\n     * @method Phaser.GameObjects.Video#getVolume\r\n     * @since 3.20.0\r\n     *\r\n     * @return {number} A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n     */\r\n    getVolume: function ()\r\n    {\r\n        return (this.video) ? this.video.volume : 1;\r\n    },\r\n\r\n    /**\r\n     * Sets the volume of the currently playing video.\r\n     *\r\n     * The value given is a double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n     *\r\n     * @method Phaser.GameObjects.Video#setVolume\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} [value=1] - A double indicating the audio volume, from 0.0 (silent) to 1.0 (loudest).\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setVolume: function (value)\r\n    {\r\n        if (value === undefined) { value = 1; }\r\n\r\n        if (this.video)\r\n        {\r\n            this.video.volume = Clamp(value, 0, 1);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a double that indicates the rate at which the media is being played back.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getPlaybackRate\r\n     * @since 3.20.0\r\n     *\r\n     * @return {number} A double that indicates the rate at which the media is being played back.\r\n     */\r\n    getPlaybackRate: function ()\r\n    {\r\n        return (this.video) ? this.video.playbackRate : 1;\r\n    },\r\n\r\n    /**\r\n     * Sets the playback rate of the current video.\r\n     *\r\n     * The value given is a double that indicates the rate at which the media is being played back.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setPlaybackRate\r\n     * @since 3.20.0\r\n     *\r\n     * @param {number} [rate] - A double that indicates the rate at which the media is being played back.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setPlaybackRate: function (rate)\r\n    {\r\n        if (this.video)\r\n        {\r\n            this.video.playbackRate = rate;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean which indicates whether the media element should start over when it reaches the end.\r\n     *\r\n     * @method Phaser.GameObjects.Video#getLoop\r\n     * @since 3.20.0\r\n     *\r\n     * @return {boolean} A boolean which indicates whether the media element will start over when it reaches the end.\r\n     */\r\n    getLoop: function ()\r\n    {\r\n        return (this.video) ? this.video.loop : false;\r\n    },\r\n\r\n    /**\r\n     * Sets the loop state of the current video.\r\n     *\r\n     * The value given is a boolean which indicates whether the media element will start over when it reaches the end.\r\n     *\r\n     * Not all videos can loop, for example live streams.\r\n     *\r\n     * Please note that not all browsers support _seamless_ video looping for all encoding formats.\r\n     *\r\n     * @method Phaser.GameObjects.Video#setLoop\r\n     * @since 3.20.0\r\n     *\r\n     * @param {boolean} [value=true] - A boolean which indicates whether the media element will start over when it reaches the end.\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    setLoop: function (value)\r\n    {\r\n        if (value === undefined) { value = true; }\r\n\r\n        if (this.video)\r\n        {\r\n            this.video.loop = value;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean which indicates whether the video is currently playing.\r\n     *\r\n     * @method Phaser.GameObjects.Video#isPlaying\r\n     * @since 3.20.0\r\n     *\r\n     * @return {boolean} A boolean which indicates whether the video is playing, or not.\r\n     */\r\n    isPlaying: function ()\r\n    {\r\n        return (this.video) ? !(this.video.paused || this.video.ended) : false;\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean which indicates whether the video is currently paused.\r\n     *\r\n     * @method Phaser.GameObjects.Video#isPaused\r\n     * @since 3.20.0\r\n     *\r\n     * @return {boolean} A boolean which indicates whether the video is paused, or not.\r\n     */\r\n    isPaused: function ()\r\n    {\r\n        return ((this.video && this.video.paused) || this._codePaused || this._systemPaused);\r\n    },\r\n\r\n    /**\r\n     * Stores this Video in the Texture Manager using the given key as a dynamic texture,\r\n     * which any texture-based Game Object, such as a Sprite, can use as its texture:\r\n     *\r\n     * ```javascript\r\n     * var vid = this.add.video(0, 0, 'intro');\r\n     *\r\n     * vid.play();\r\n     *\r\n     * vid.saveTexture('doodle');\r\n     *\r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     *\r\n     * The saved texture is automatically updated as the video plays. If you pause this video,\r\n     * or change its source, then the saved texture updates instantly.\r\n     *\r\n     * Calling `saveTexture` again will not save another copy of the same texture, it will just rename the existing one.\r\n     *\r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame.\r\n     *\r\n     * If you intend to save the texture so you can use it as the input for a Shader, you may need to set the\r\n     * `flipY` parameter to `true` if you find the video renders upside down in your shader.\r\n     *\r\n     * @method Phaser.GameObjects.Video#saveTexture\r\n     * @since 3.20.0\r\n     *\r\n     * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n     * @param {boolean} [flipY=false] - Should the WebGL Texture set `UNPACK_MULTIPLY_FLIP_Y` during upload?\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was saved.\r\n     */\r\n    saveTexture: function (key, flipY)\r\n    {\r\n        if (flipY === undefined) { flipY = false; }\r\n\r\n        if (this.videoTexture)\r\n        {\r\n            this.scene.sys.textures.renameTexture(this._key, key);\r\n        }\r\n\r\n        this._key = key;\r\n\r\n        this.flipY = flipY;\r\n\r\n        if (this.videoTextureSource)\r\n        {\r\n            this.videoTextureSource.setFlipY(flipY);\r\n        }\r\n\r\n        return this.videoTexture;\r\n    },\r\n\r\n    /**\r\n     * Stops the video playing and clears all internal event listeners.\r\n     *\r\n     * If you only wish to pause playback of the video, and resume it a later time, use the `Video.pause` method instead.\r\n     *\r\n     * If the video hasn't finished downloading, calling this method will not abort the download. To do that you need to\r\n     * call `destroy` instead.\r\n     *\r\n     * @method Phaser.GameObjects.Video#stop\r\n     * @fires Phaser.GameObjects.Events#VIDEO_STOP\r\n     * @since 3.20.0\r\n     *\r\n     * @return {this} This Video Game Object for method chaining.\r\n     */\r\n    stop: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        if (video)\r\n        {\r\n            var callbacks = this._callbacks;\r\n\r\n            for (var callback in callbacks)\r\n            {\r\n                video.removeEventListener(callback, callbacks[callback], true);\r\n            }\r\n\r\n            video.pause();\r\n        }\r\n\r\n        if (this._retryID)\r\n        {\r\n            window.clearTimeout(this._retryID);\r\n        }\r\n\r\n        this.emit(Events.VIDEO_STOP, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the Video element from the DOM by calling parentNode.removeChild on itself.\r\n     *\r\n     * Also removes the autoplay and src attributes and nulls the Video reference.\r\n     *\r\n     * You should not call this method if you were playing a video from the Video Cache that\r\n     * you wish to play again in your game, or if another Video object is also using the same\r\n     * video.\r\n     *\r\n     * If you loaded an external video via `Video.loadURL` then you should call this function\r\n     * to clear up once you are done with the instance.\r\n     *\r\n     * @method Phaser.GameObjects.Video#removeVideoElement\r\n     * @since 3.20.0\r\n     */\r\n    removeVideoElement: function ()\r\n    {\r\n        var video = this.video;\r\n\r\n        if (!video)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (video.parentNode)\r\n        {\r\n            video.parentNode.removeChild(video);\r\n        }\r\n\r\n        while (video.hasChildNodes())\r\n        {\r\n            video.removeChild(video.firstChild);\r\n        }\r\n\r\n        video.removeAttribute('autoplay');\r\n        video.removeAttribute('src');\r\n\r\n        this.video = null;\r\n    },\r\n\r\n    /**\r\n     * Handles the pre-destroy step for the Video object.\r\n     *\r\n     * This calls `Video.stop` and optionally `Video.removeVideoElement`.\r\n     *\r\n     * If any Sprites are using this Video as their texture it is up to you to manage those.\r\n     *\r\n     * @method Phaser.GameObjects.Video#preDestroy\r\n     * @private\r\n     * @since 3.21.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        this.stop();\r\n\r\n        if (this.removeVideoElementOnDestroy)\r\n        {\r\n            this.removeVideoElement();\r\n        }\r\n\r\n        var game = this.scene.sys.game.events;\r\n\r\n        game.off(GameEvents.PAUSE, this.globalPause, this);\r\n        game.off(GameEvents.RESUME, this.globalResume, this);\r\n\r\n        var sound = this.scene.sys.sound;\r\n\r\n        if (sound)\r\n        {\r\n            sound.off(SoundEvents.GLOBAL_MUTE, this.globalMute, this);\r\n        }\r\n\r\n        if (this._retryID)\r\n        {\r\n            window.clearTimeout(this._retryID);\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Video;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the Canvas Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Video#renderCanvas\r\n * @since 3.20.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.\r\n * @param {Phaser.GameObjects.Video} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar VideoCanvasRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (src.videoTexture)\r\n    {\r\n        camera.addToRenderList(src);\r\n\r\n        renderer.batchSprite(src, src.frame, camera, parentMatrix);\r\n    }\r\n};\r\n\r\nmodule.exports = VideoCanvasRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BuildGameObject = require('../BuildGameObject');\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar Video = require('./Video');\r\n\r\n/**\r\n * Creates a new Video Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Video Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#video\r\n * @since 3.20.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n * @param {boolean} [addToScene] - Add this Game Object to the Scene after creating it? If set this argument overrides the `add` property in the config object.\r\n *\r\n * @return {Phaser.GameObjects.Video} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('video', function (config, addToScene)\r\n{\r\n    if (config === undefined) { config = {}; }\r\n\r\n    var key = GetAdvancedValue(config, 'key', null);\r\n\r\n    var video = new Video(this.scene, 0, 0, key);\r\n\r\n    if (addToScene !== undefined)\r\n    {\r\n        config.add = addToScene;\r\n    }\r\n\r\n    BuildGameObject(this.scene, video, config);\r\n\r\n    if (!config.add)\r\n    {\r\n        this.updateList.add(video);\r\n    }\r\n\r\n    return video;\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Video = require('./Video');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Video Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Video Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#video\r\n * @since 3.20.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {string} [key] - Optional key of the Video this Game Object will play, as stored in the Video Cache.\r\n *\r\n * @return {Phaser.GameObjects.Video} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('video', function (x, y, key)\r\n{\r\n    return this.displayList.add(new Video(this.scene, x, y, key));\r\n});\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar renderWebGL = require('../../utils/NOOP');\r\nvar renderCanvas = require('../../utils/NOOP');\r\n\r\nif (typeof WEBGL_RENDERER)\r\n{\r\n    renderWebGL = require('./VideoWebGLRenderer');\r\n}\r\n\r\nif (typeof CANVAS_RENDERER)\r\n{\r\n    renderCanvas = require('./VideoCanvasRenderer');\r\n}\r\n\r\nmodule.exports = {\r\n\r\n    renderWebGL: renderWebGL,\r\n    renderCanvas: renderCanvas\r\n\r\n};\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Renders this Game Object with the WebGL Renderer to the given Camera.\r\n * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.\r\n * This method should not be called directly. It is a utility function of the Render module.\r\n *\r\n * @method Phaser.GameObjects.Video#renderWebGL\r\n * @since 3.20.0\r\n * @private\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.\r\n * @param {Phaser.GameObjects.Video} src - The Game Object being rendered in this call.\r\n * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.\r\n * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested\r\n */\r\nvar VideoWebGLRenderer = function (renderer, src, camera, parentMatrix)\r\n{\r\n    if (src.videoTexture)\r\n    {\r\n        camera.addToRenderList(src);\r\n\r\n        src.pipeline.batchSprite(src, camera, parentMatrix);\r\n    }\r\n};\r\n\r\nmodule.exports = VideoWebGLRenderer;\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar GameObjectCreator = require('../GameObjectCreator');\r\nvar GetAdvancedValue = require('../../utils/object/GetAdvancedValue');\r\nvar Zone = require('./Zone');\r\n\r\n/**\r\n * Creates a new Zone Game Object and returns it.\r\n *\r\n * Note: This method will only be available if the Zone Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#zone\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The configuration object this Game Object will use to create itself.\r\n *\r\n * @return {Phaser.GameObjects.Zone} The Game Object that was created.\r\n */\r\nGameObjectCreator.register('zone', function (config)\r\n{\r\n    var x = GetAdvancedValue(config, 'x', 0);\r\n    var y = GetAdvancedValue(config, 'y', 0);\r\n    var width = GetAdvancedValue(config, 'width', 1);\r\n    var height = GetAdvancedValue(config, 'height', width);\r\n\r\n    return new Zone(this.scene, x, y, width, height);\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n","/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2020 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Zone = require('./Zone');\r\nvar GameObjectFactory = require('../GameObjectFactory');\r\n\r\n/**\r\n * Creates a new Zone Game Object and adds it to the Scene.\r\n *\r\n * Note: This method will only be available if the Zone Game Object has been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#zone\r\n * @since 3.0.0\r\n *\r\n * @param {number} x - The horizontal position of this Game Object in the world.\r\n * @param {number} y - The vertical position of this Game Object in the world.\r\n * @param {number} width - The width of the Game Object.\r\n * @param {number} height - The height of the Game Object.\r\n * \r\n * @return {Phaser.GameObjects.Zone} The Game Object that was created.\r\n */\r\nGameObjectFactory.register('zone', function (x, y, width, height)\r\n{\r\n    return this.displayList.add(new Zone(this.scene, x, y, width, height));\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//  \r\n//  There are several properties available to use:\r\n//  \r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n"],"names":["BlendModes","GetAdvancedValue","module","exports","scene","gameObject","config","x","y","depth","flipX","flipY","scale","setScale","scaleX","scaleY","scrollFactor","setScrollFactor","scrollFactorX","scrollFactorY","rotation","angle","alpha","origin","setOrigin","ox","oy","blendMode","NORMAL","visible","sys","displayList","add","preUpdate","updateList","sprite","animConfig","anims","play","key","undefined","startFrame","delay","repeat","repeatDelay","yoyo","delayedPlay","playConfig","playAfterDelay","load","Class","List","PluginCache","GameObjectEvents","SceneEvents","StableSort","DisplayList","Extends","initialize","call","this","sortChildrenFlag","systems","events","addCallback","addChildCallback","removeCallback","removeChildCallback","once","BOOT","boot","on","START","start","DESTROY","destroy","removeFromDisplayList","queueDepthSort","emit","ADDED_TO_SCENE","REMOVED_FROM_SCENE","SHUTDOWN","shutdown","depthSort","list","sortByDepth","childA","childB","_depth","getChildren","i","length","off","register","ProcessQueue","UpdateList","checkQueue","eventEmitter","PRE_UPDATE","update","UPDATE","sceneUpdate","time","delta","_active","active","_pending","_destroy","_toProcess","removeAllListeners","pipeline","src","char","glyph","offsetX","offsetY","calcMatrix","roundPixels","tintTL","tintTR","tintBL","tintBR","tintEffect","texture","textureUnit","displayOriginX","displayOriginY","xw","w","yh","h","tx0","getXRound","ty0","getYRound","tx1","ty1","tx2","ty2","tx3","ty3","batchQuad","u0","v0","u1","v1","round","updateOrigin","out","local","width","height","global","lines","shortest","longest","lengths","wrappedText","words","characters","str","index","text","textLength","maxWidth","wordWrapCharCode","bx","Number","MAX_VALUE","by","bw","bh","chars","fontData","lineHeight","letterSpacing","xAdvance","yAdvance","charCode","align","_align","fontSize","size","sx","sy","lastGlyph","lastCharCode","lineWidths","shortestLine","longestLine","currentLine","currentLineWidth","current","charCodeAt","glyphKerningOffset","kerning","push","word","cr","concat","xOffset","prev","offset","crs","entry","left","right","substr","charIndex","kerningOffset","gw","gh","charWidth","code","yOffset","t","r","b","line","c","currentChar","ax1","ax2","_displayOriginX","_displayOriginY","Math","ceil","originX","originY","ParseXMLBitmapFont","fontName","textureKey","frameKey","xmlKey","xSpacing","ySpacing","textures","get","frame","xml","cache","data","bitmapFont","fromAtlas","GetValue","cx","floor","cy","letters","getFrame","textureX","cutX","textureY","cutY","textureWidth","source","textureHeight","spacingX","spacingY","lineSpacing","charsPerRow","retroFont","font","centerX","centerY","getValue","node","attribute","parseInt","getAttribute","sourceIndex","info","getElementsByTagName","common","adjustForTrim","trimmed","top","letter","String","fromCharCode","gx","gy","charFrame","setUVs","kernings","kern","first","second","amount","RETRO_FONT_CONST","Extend","RetroFont","Parse","TEXT_SET1","TEXT_SET2","TEXT_SET3","TEXT_SET4","TEXT_SET5","TEXT_SET6","TEXT_SET7","TEXT_SET8","TEXT_SET9","TEXT_SET10","TEXT_SET11","BitmapText","Render","DynamicBitmapText","Mixins","type","scrollX","scrollY","cropWidth","cropHeight","displayCallback","callbackData","parent","color","tint","topLeft","topRight","bottomLeft","bottomRight","setSize","setDisplayCallback","callback","setScrollX","value","setScrollY","SetTransform","renderer","camera","parentMatrix","_text","ctx","currentContext","addToRenderList","textureFrame","frames","_letterSpacing","glyphX","glyphY","glyphW","glyphH","image","baseScale","_fontSize","lineOffsetX","getTextBounds","lineData","_bounds","translate","beginPath","rect","clip","output","save","rotate","drawImage","restore","BuildGameObject","GameObjectCreator","addToScene","bitmapText","renderWebGL","renderCanvas","GetCalcMatrix","TransformMatrix","Utils","tempMatrix","pipelines","set","result","spriteMatrix","calc","fontMatrix","crop","flush","pushScissor","tx","ty","glTexture","tintFill","getTintAppendFloatAlpha","tintTopLeft","_alphaTL","tintTopRight","_alphaTR","tintBottomLeft","_alphaBL","tintBottomRight","_alphaBR","setGameObject","bounds","preBatch","applyITRS","multiply","e","f","d","a","popScissor","postBatch","Clamp","Components","GameObject","GetBitmapTextSize","ParseFromAtlas","Rectangle","Alpha","BlendMode","Depth","Mask","Origin","Pipeline","ScrollFactor","Texture","Tint","Transform","Visible","console","warn","_dirty","_maxWidth","charColors","dropShadowX","dropShadowY","dropShadowColor","dropShadowAlpha","setTexture","setPosition","initPipeline","setText","setLeftAlign","ALIGN_LEFT","setCenterAlign","ALIGN_CENTER","setRightAlign","ALIGN_RIGHT","setFontSize","setLetterSpacing","spacing","Array","isArray","join","toString","updateDisplayOrigin","setDropShadow","setCharacterTint","len","end","setWordTint","count","wordIsNumber","total","lineword","getCharacterAt","point","getLocalPoint","tempRect","setTo","contains","setFont","setMaxWidth","toJSON","ToJSON","preDestroy","BatchChar","cameraAlpha","getTint","dropShadow","srcShadowColor","srcShadowAlpha","shadowTL","shadowTR","shadowBL","shadowBR","charTintEffect","charTintTL","charTintTR","charTintBL","charTintBR","BlitterRender","Bob","Frame","Blitter","Size","children","renderList","dirty","create","bob","addAt","createFromCallback","quantity","bobs","createMultiple","name","_this","forEach","singleFrame","childCanRender","child","getRenderList","filter","clear","removeAll","globalCompositeOperation","blendModes","imageSmoothingEnabled","antialias","scaleMode","cameraScrollX","cameraScrollY","copyToContext","flip","cd","canvasData","dx","dy","fx","fy","bobAlpha","globalAlpha","blitter","copyFrom","matrix","multiplyWithOffset","blitterX","blitterY","prevTextureSourceIndex","getX","getY","_visible","_alpha","setFrame","resetFlip","reset","setFlipX","setFlipY","setFlip","setVisible","setAlpha","setTint","remove","ArrayUtils","Events","Union","Vector2","Container","AlphaSingle","ComputedSize","exclusive","maxSize","position","localTransform","tempTransformMatrix","_sortKey","_sysEvents","clearAlpha","setBlendMode","SKIP_CHECK","setExclusive","getBounds","parentContainer","transformedPosition","getBoundsTransformMatrix","transformPoint","hasSetFirst","setEmpty","addHandler","removeHandler","addToDisplayList","pointToContainer","invert","getWorldTransformMatrix","Add","AddAt","getAt","getIndex","indexOf","sort","property","handler","getByName","GetFirst","getRandom","startIndex","GetRandom","getFirst","endIndex","getAll","GetAll","CountAllMatching","swap","child1","child2","Swap","moveTo","MoveTo","moveAbove","MoveAbove","moveBelow","MoveBelow","destroyChild","removed","Remove","removeAt","RemoveAt","removeBetween","RemoveBetween","bringToTop","BringToTop","sendToBack","SendToBack","moveUp","MoveUp","moveDown","MoveDown","reverse","shuffle","Shuffle","replace","oldChild","newChild","Replace","exists","setAll","SetAll","each","context","args","temp","slice","arguments","apply","iterate","updateChildren","last","next","previous","container","transformMatrix","loadIdentity","containerHasBlendMode","mask","preRenderCanvas","willRender","childAlpha","childScrollFactorX","childScrollFactorY","currentBlendMode","postRenderCanvas","childCount","childAlphaTopLeft","childAlphaTopRight","childAlphaBottomLeft","childAlphaBottomRight","alphaTopLeft","alphaTopRight","alphaBottomLeft","alphaBottomRight","preRenderWebGL","currentType","newType","nextTypeMatch","postRenderWebGL","DOMElementRender","IsPlainObject","RemoveFromDOM","SCENE_EVENTS","Vector4","DOMElement","element","style","innerText","game","domContainer","html","transformOnly","skewX","skewY","rotate3d","rotate3dAngle","pointerEvents","displayWidth","displayHeight","dispatchNativeEvent","bind","setElement","createElement","SLEEP","handleSceneEvent","WAKE","addedToScene","removedFromScene","display","settings","setSkew","setPerspective","perspective","parseFloat","addListener","split","addEventListener","removeListener","removeEventListener","event","tagName","document","target","removeElement","getElementById","nodeType","zIndex","phaser","appendChild","updateSize","createFromCache","createFromHTML","innerHTML","nodeBounds","getBoundingClientRect","clientWidth","clientHeight","getChildByProperty","querySelectorAll","getChildByID","id","getChildByName","setClassName","className","setHTML","CSSBlendModes","tempMatrix1","tempMatrix2","tempMatrix3","RENDER_MASK","renderFlags","cameraFilter","camMatrix","srcMatrix","opacity","mixBlendMode","_blendMode","transform","getCSSMatrix","z","transformOrigin","ExternRender","Extern","Flip","render","extern","rebind","ARC","BEGIN_PATH","CLOSE_PATH","FILL_RECT","LINE_TO","MOVE_TO","LINE_STYLE","FILL_STYLE","FILL_PATH","STROKE_PATH","FILL_TRIANGLE","STROKE_TRIANGLE","SAVE","RESTORE","TRANSLATE","SCALE","ROTATE","GRADIENT_FILL_STYLE","GRADIENT_LINE_STYLE","BaseCamera","Commands","ComponentsAlpha","ComponentsBlendMode","ComponentsDepth","ComponentsMask","ComponentsPipeline","ComponentsScrollFactor","ComponentsTransform","ComponentsVisible","Ellipse","GetFastValue","MATH_CONST","Graphics","options","commandBuffer","defaultFillColor","defaultFillAlpha","defaultStrokeWidth","defaultStrokeColor","defaultStrokeAlpha","_lineWidth","setDefaultStyles","lineStyle","fillStyle","lineWidth","fillGradientStyle","lineGradientStyle","closePath","fillPath","fill","strokePath","stroke","fillCircleShape","circle","fillCircle","radius","strokeCircleShape","strokeCircle","arc","PI2","fillRectShape","fillRect","strokeRectShape","strokeRect","lineWidthHalf","minx","maxx","lineTo","fillRoundedRect","tl","tr","bl","br","TAU","PI","strokeRoundedRect","fillPointShape","fillPoint","fillTriangleShape","triangle","fillTriangle","x1","y1","x2","y2","x3","y3","strokeTriangleShape","strokeTriangle","x0","y0","strokeLineShape","lineBetween","strokePoints","points","closeShape","fillPoints","strokeEllipseShape","ellipse","smoothness","getPoints","strokeEllipse","fillEllipseShape","fillEllipse","startAngle","endAngle","anticlockwise","overshoot","translateCanvas","scaleCanvas","rotateCanvas","radians","generateTexture","TargetCamera","setScene","setViewport","getSourceImage","HTMLCanvasElement","getContext","createCanvas","refresh","renderTargetCtx","allowClip","commandBufferLength","lineAlpha","fillAlpha","lineColor","fillColor","red","green","blue","strokeStyle","LINE_FX_TO","MOVE_FX_TO","graphics","Point","Path","pointsLength","matrixStack","currentMatrix","commands","fillTint","strokeTint","ta","path","pathIndex","pathOpen","lastPath","cmdIndex","batchFillPath","batchStrokePath","strokeTintColor","TL","TR","BL","BR","fillTintColor","alphaTL","alphaTR","alphaBL","alphaBR","gradientLineAlpha","iteration","cos","sin","batchFillRect","batchFillTriangle","batchStrokeTriangle","copyToArray","copyFromArray","pop","Group","Image","GameObjects","GameObjectFactory","BuildGameObjectAnimation","Layer","Particles","PathFollower","RenderTexture","Rope","Sprite","Text","GetTextSize","MeasureText","TextStyle","TileSprite","Zone","Video","Shape","Arc","Curve","Grid","IsoBox","IsoTriangle","Line","Polygon","Star","Triangle","Factories","StaticBitmapText","Creators","Shader","Mesh","PointLight","Light","LightsManager","LightsPlugin","ComponentsToJSON","DataManager","EventEmitter","state","tabIndex","input","body","ignoreDestroy","setActive","setName","setState","setDataEnabled","setData","incData","inc","toggleData","toggle","getData","setInteractive","disableInteractive","removeInteractive","getIndexList","indexes","unshift","resetPostPipeline","layer","layerHasBlendMode","Circle","RGB","g","intensity","setColor","rgb","getFloatsFromUintRGB","setIntensity","setRadius","CircleToRectangle","DistanceBetween","SpliceOne","lights","ambientColor","maxLights","visibleLights","addPointLight","attenuation","enable","disable","getLights","worldView","light","distance","sortByDistance","setAmbientColor","getMaxVisibleLights","getLightCount","addLight","removeLight","isBooted","DegToRad","Face","GenerateVerts","GenerateObjVerts","Matrix4","MeshRender","Vector3","Vertex","vertices","uvs","indicies","containsZ","normals","colors","alphas","faces","debugCallback","debugGraphic","hideCCW","modelPosition","modelScale","modelRotation","dirtyCache","viewPosition","viewMatrix","projectionMatrix","totalRendered","totalFrame","ignoreDirtyCache","addVertices","panX","v","addScale","LEFT","panY","DOWN","panZ","fov","near","far","setOrtho","getAspectRatio","ortho","face","addVerticesFromObj","rotateX","rotateY","rotateZ","zIsUp","obj","faceA","faceB","addVertex","u","vert","addFace","vertex1","vertex2","vertex3","getFaceCount","getVertexCount","getFace","getFaceAt","cameras","main","results","setDebug","graphic","renderDebug","isDirty","px","py","pz","rx","ry","rz","sz","pxCached","pyCached","pzCached","rxCached","ryCached","rzCached","sxCached","syCached","szCached","fCached","identity","setWorldMatrix","transformCoordinatesLocal","mesh","totalFaces","F32","vertexViewF32","U32","vertexViewU32","vertexOffset","vertexCount","currentShader","vertexComponentCount","debugFaces","totalFacesRendered","isInView","shouldFlush","FloatBetween","GetEaseFunction","Wrap","EmitterOp","defaultValue","emitOnly","propertyKey","propertyValue","steps","counter","ease","onEmit","defaultEmit","onUpdate","defaultUpdate","loadConfig","newKey","setMethods","onChange","staticValueEmit","staticValueUpdate","randomStaticValueEmit","hasBoth","isRandom","has","randomRangedValueEmit","steppedEmit","easeType","easeParams","easedValueEmit","easeValueUpdate","min","max","rnd","random","hasEither","object","hasOwnProperty","key1","key2","particle","randomIndex","GravityWell","power","epsilon","gravity","_gravity","_power","_epsilon","dSq","sqrt","factor","velocityX","velocityY","pwr","Particle","emitter","accelerationX","accelerationY","maxVelocityX","maxVelocityY","bounce","life","lifeCurrent","delayCurrent","lifeT","isAlive","resetPosition","fire","emitZone","getPoint","lifespan","speedX","speedY","radial","rad","abs","mx","moveToX","my","moveToY","atan2","speed","acceleration","computeVelocity","step","processors","vx","vy","ax","ay","gravityX","gravityY","checkBounds","collideLeft","collideRight","collideTop","bottom","collideBottom","deathZone","willKill","DeathZone","EdgeZone","HasAny","HasValue","RandomZone","ParticleEmitter","manager","defaultFrame","configFastMap","configOpMap","particleClass","emitCallback","emitCallbackScope","deathCallback","deathCallbackScope","maxParticles","frequency","particleBringToTop","timeScale","follow","followOffset","trackVisible","currentFrame","randomFrame","frameQuantity","dead","alive","_counter","_frameCounter","fromJSON","callbackScope","setEmitZone","setDeathZone","setBounds","setFromObject","reserve","startFollow","stopFollow","_frameLength","pickRandom","setEmitterFrames","frameConfig","isCycle","setRadial","setSpeedX","setSpeedY","setSpeed","setScaleX","setScaleY","setGravityX","setGravityY","setGravity","setEmitterAngle","setAngle","setLifespan","setQuantity","setFrequency","zoneConfig","stepRate","seamless","killOnEnter","particleCount","getAliveParticleCount","getDeadParticleCount","getParticleCount","atLimit","onParticleEmit","onParticleDeath","killAll","forEachAlive","forEachDead","stop","pause","resume","removeEmitter","depthSortCallback","flow","explode","emitParticle","emitParticleAt","followX","followY","getProcessors","particles","rip","splice","ParticleEmitterManager","emitters","frameNames","wells","createEmitter","getFramesFromTextureSource","names","sourceFrame","addEmitter","addGravityWell","well","createGravityWell","tempMatrix4","emitterManager","emittersLength","particleMatrix","managerMatrix","setToContext","halfWidth","halfHeight","Zones","withinZone","_length","_direction","updateSource","oldLength","changeSource","_tempVec","vec","getRandomPoint","pathUpdate","IntegerToColor","PIPELINES_CONST","GetBounds","POINTLIGHT_PIPELINE","_radius","lightX","lightY","batchPointLight","Camera","CanvasPool","CONST","NOOP","PIPELINE_CONST","RenderTarget","UUID","Crop","textureManager","globalTint","canvas","_crop","resetCropObject","_saved","create2D","addCanvas","cutWidth","cutHeight","_eraseMode","renderTarget","WEBGL","drawGameObject","batchGameObjectWebGL","CANVAS","batchGameObjectCanvas","SINGLE_PIPELINE","resize","isRenderTexture","isGLTexture","baseFrame","customHitArea","hitArea","setGlobalTint","setGlobalAlpha","saveTexture","renameTexture","preRender","tw","th","drawFillRect","getTintFromFloats","unbind","setContext","setTransform","clearRect","erase","entries","draw","beginDraw","batchDraw","endDraw","drawFrame","batchDrawFrame","beginCapture","batchList","batchTextureFrame","canvasTarget","endCapture","setUtility","blitFrame","resetScissor","resetViewport","isParent","batchGroup","batchTextureFrameKey","prevX","prevY","renderDirect","ERASE","snapshotArea","encoderOptions","snapshotFramebuffer","framebuffer","snapshotCanvas","snapshot","snapshotPixel","batchSprite","renderTexture","setTexture2D","batchTexture","resetTextures","AnimationState","RopeRender","horizontal","uv","_flipX","_flipY","_perp","setSizeToFrame","ROPE_PIPELINE","resizeArrays","setPoints","updateVertices","prevFrame","updateUVs","ignoreIfPlaying","setDirty","setHorizontal","setVertical","setTintFill","setAlphas","bottomAlpha","currentAlphas","prevAlpha","setColors","currentColors","prevColor","s","frameSegment","segments","currentTotal","currentUVs","partH","partV","uv0","uv1","uv2","uv3","newSize","Float32Array","Uint32Array","perp","nextPoint","lastPoint","frameSize","perpLength","renderDebugVerts","meshLength","verts","px0","py0","px1","py1","rope","meshVerticesLength","colorIndex","debugVerts","SetValue","ShaderRender","textureData","shader","gl","vertexData","ArrayBuffer","BYTES_PER_ELEMENT","vertexBuffer","createVertexBuffer","byteLength","STREAM_DRAW","program","bytes","Uint8Array","_tempMatrix1","_tempMatrix2","_tempMatrix3","uniforms","pointer","_rendererWidth","_rendererHeight","_textureCount","renderToTexture","setShader","setRenderToTexture","createTextureFromSource","createFramebuffer","projOrtho","addGLTexture","deleteProgram","createProgram","vertexSrc","fragmentSrc","uniformMatrix4fv","getUniformLocation","uniform2f","Date","defaultUniforms","resolution","mouse","date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","sampleRate","iChannel0","iChannel1","iChannel2","iChannel3","setSampler2D","initUniforms","setPointer","leftRight","bottomTop","pm","setProgram","map","glFuncMap","uniform","uniformLocation","glMatrix","glValueLength","glFunc","func","setSampler2DBuffer","uniformKey","textureIndex","initSampler2D","setUniform","getUniform","setChannel0","setChannel1","setChannel2","setChannel3","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","magFilter","toUpperCase","minFilter","wrapS","wrapT","format","REPEAT","pixelStorei","UNPACK_FLIP_Y_WEBGL","border","texImage2D","UNSIGNED_BYTE","RGBA","texParameteri","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","uniform1i","syncUniforms","location","textureCount","transpose","matrix2D","vm","useProgram","res","loop","getDuration","toFixed","vertexSize","setFramebuffer","clearColor","COLOR_BUFFER_BIT","bindBuffer","ARRAY_BUFFER","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","vf","bufferSubData","subarray","drawArrays","TRIANGLES","deleteBuffer","deleteFramebuffer","pathData","pathIndexes","p0","p1","p2","batchTri","altColor","altAlpha","strokeColor","strokeAlpha","geom","isFilled","isStroked","_tempLine","setFillStyle","setStrokeStyle","setClosePath","setDisplaySize","pathLength","halfLineWidth","px2","py2","batchLine","ArcRender","Earcut","GeomCircle","_startAngle","_endAngle","_anticlockwise","_iterations","diameter","updateData","iterations","setIterations","setStartAngle","setEndAngle","FillStyleCanvas","LineStyleCanvas","FillPathWebGL","StrokePathWebGL","CurveRender","curve","_smoothness","_curveBounds","setSmoothness","EllipseRender","GeomEllipse","GridRender","cellWidth","cellHeight","outlineFillColor","outlineFillAlpha","showCells","showOutline","showAltCells","altFillColor","altFillAlpha","setOutlineStyle","setAltFillStyle","gridWidth","gridHeight","cellWidthA","cellHeightA","cellWidthB","cellHeightB","cw","ch","IsoBoxRender","fillTop","fillLeft","fillRight","projection","showTop","showLeft","showRight","setProjection","setFaces","sizeA","sizeB","IsoTriangleRender","reversed","isReversed","setReversed","GeomLine","LineRender","_startWidth","_endWidth","setLineWidth","startWidth","endWidth","PolygonRender","GetAABB","GeomPolygon","Smooth","smooth","GeomRectangle","RectangleRender","getLineA","getLineB","getLineC","getLineD","StarRender","innerRadius","outerRadius","_points","_innerRadius","_outerRadius","setInnerRadius","setOuterRadius","rot","GeomTriangle","TriangleRender","tri","maxLineWidth","drawnLines","maxLines","syncFont","strokeThickness","measureText","wordWrap","textStyle","metrics","testString","ascent","actualBoundingBoxAscent","descent","actualBoundingBoxDescent","baselineX","baseline","baselineY","_font","textBaseline","fillText","imagedata","getImageData","j","pixels","numPixels","idx","AddToDOM","GameEvents","TextRender","autoRound","splitRegExp","padding","deleteTexture","initRTL","setPadding","setLineSpacing","CONTEXT_RESTORED","rtl","dir","direction","runWordWrap","wordWrapCallback","wrappedLines","wordWrapCallbackScope","wordWrapWidth","wordWrapUseAdvanced","advancedWordWrap","basicWordWrap","linesCount","wordWithSpace","wordWidth","newWord","Error","secondPart","remainder","lastLineIndex","whiteSpaceWidth","spaceLeft","lastWordIndex","wordWidthWithSpace","getWrappedText","updateText","setStyle","setFontFamily","family","setFontStyle","setFixedSize","setBackgroundColor","setFill","setStroke","thickness","setShadow","blur","shadowStroke","shadowFill","setShadowOffset","setShadowColor","setShadowBlur","setShadowStroke","enabled","setShadowFill","setWordWrapWidth","useAdvancedWrap","setWordWrapCallback","scope","setAlign","setResolution","setMaxLines","outputText","textWidth","textSize","fixedWidth","fixedHeight","linePositionX","linePositionY","backgroundColor","syncStyle","extraSpace","spaceSize","trimmedLine","trim","array","extraSpaceCharacters","syncShadow","strokeText","canvasToTexture","getTextMetrics","content","propertyMap","fontFamily","fontStyle","shadowOffsetX","shadowOffsetY","shadowColor","shadowBlur","setDefaults","lineCap","lineJoin","recalculateMetrics","fontSplit","setTestString","string","GetPowerOfTwo","Smoothing","TileSpriteRender","displayTexture","displayFrame","_tilePosition","_tileScale","potWidth","potHeight","fillCanvas","fillContext","fillPattern","setOriginFromFrame","createTexture2D","LINEAR","newFrame","updateTileTexture","setTilePosition","tilePositionX","tilePositionY","setTileScale","tileScaleX","tileScaleY","fw","fh","createPattern","updateCanvas","positionX","positionY","tile","InputEvents","SoundEvents","VideoRender","TextureCrop","video","videoTexture","videoTextureSource","snapshotTexture","_key","touchLocked","playWhenUnlocked","retryLimit","retry","retryInterval","_retryID","_systemMuted","_codeMuted","_systemPaused","_codePaused","_callbacks","playHandler","error","loadErrorHandler","completeHandler","timeUpdateHandler","seeking","seekingHandler","seeked","seekedHandler","markers","_markerIn","_markerOut","MAX_SAFE_INTEGER","_lastUpdate","_cacheKey","_isSeeking","removeVideoElementOnDestroy","PAUSE","globalPause","RESUME","globalResume","sound","GLOBAL_MUTE","globalMute","markerIn","markerOut","isPlaying","mute","setMute","isNaN","callbacks","playPromise","then","playPromiseSuccessHandler","catch","playPromiseErrorHandler","readyState","window","setTimeout","checkVideoProgress","autoplay","newVideo","paused","muted","videoWidth","videoHeight","VIDEO_CREATED","updateTexture","currentTime","addMarker","playMarker","marker","removeMarker","srcWidth","srcHeight","destWidth","destHeight","snap","saveSnapshotTexture","loadURL","url","loadEvent","noAudio","controls","defaultMuted","setAttribute","loadMediaStream","stream","srcObject","URL","createObjectURL","VIDEO_PLAY","POINTER_DOWN","unlockHandler","VIDEO_ERROR","VIDEO_UNLOCKED","VIDEO_COMPLETE","VIDEO_LOOP","VIDEO_TIMEOUT","textureSource","getVideoKey","seekTo","duration","Infinity","seekTime","setCurrentTime","getCurrentTime","op","num","isSeeking","VIDEO_SEEKING","VIDEO_SEEKED","getProgress","now","isMuted","soundManager","setPaused","getVolume","volume","setVolume","getPlaybackRate","playbackRate","setPlaybackRate","rate","getLoop","setLoop","ended","isPaused","clearTimeout","VIDEO_STOP","removeVideoElement","parentNode","removeChild","hasChildNodes","firstChild","removeAttribute"],"sourceRoot":""}